              ; ****************************************************
              ; * Complete Commodore 8296 Operating System & BASIC *
              ; ****************************************************

              ; Use the Bit Shift Assembler "bsa" for assembly of this source

b000          * = $b000   ; *** b000 ***  Commodore 8296

              .STORE $B000, $1000, "b000.basic"
              .STORE $C000, $1000, "c000.basic"
              .STORE $D000, $1000, "d000.basic"
              .STORE $E000, $1000, "e000.edit"
              .STORE $F000, $1000, "f000.kernal"

0001          BSOS_KBD = 1

              ; revision 1.11 08-Jan-2020
              ; -------------------------
              ; enhance DELETE commnd
              ; implement OLD command

              ; revision 1.10 09-Oct-2015
              ; -------------------------
              ; optimize garbage collection
              ; implement REPLACE command
              ; implement 26 rows mode

              ; revision 1.09 10-Sep-2015
              ; -------------------------
              ; optimize BASIC routines Scan_Linenumber and Basic_LIST
              ; in order to make parts of them callable subroutines
              ; These routines are used in the assembler and power scrolling

              ; revision 1.08 04-Aug-2015
              ; -------------------------
              ; Implement conditional code for original keyboard layout
              ; or BSOS keyboard layout (BSOS_KBD)

              ; revision 1.07 04-Aug-2015
              ; -------------------------
              ; Implement ML Disassembler

              ; revision 1.06 29-Jul-2015
              ; -------------------------
              ; Check disk error after trying to boot from disk

              ; revision 1.05 19-Jan-2015
              ; -------------------------
              ; Detect and activate option ROM's
              ; Detect and run "BSOS BOOT" during boot
              ; Non desctructive RAM test
              ; Optimization of TIM LOAD/SAVE

              ; revision 1.03 29-Dec-2014
              ; -------------------------
              ; Add unit to unit capability to the COPY command

              ; revision 1.02 23-Dec-2014
              ; -------------------------
              ; Fix bug in DSAVE/DOPEN (Save and Replace bug)
              ; Optimize DOS Parameter Parser

              ; revision 1.01 14-Dec-2014
              ; -------------------------
              ; Add support for Nils Eilers' SoftROM
              ; The LOAD and DLOAD routines may be used to load data files
              ; directly into the address range $9000 - $AFFF. This works well
              ; for RAM or SoftROM (which in fact is flashed) installed there.

              ; revision 1.00 30-Nov-2014
              ; -------------------------
              ; First public release

              ; The operating system and BASIC interpreter is stored on two chips:

              ; The editor is stored on a 2332 (4KB) ROM (or 2532 EPROM) for the address
              ; range $E000 - $EFFF. The addresses $E800 - $E8FF are reserved for
              ; I/O and are not accessible

              ; The remaining code is stored on a 23128 (16KB) ROM (or 27128 EPROM):
              ; The address ranges are: $C000 $D000 $B000 $F000

              ; So after assembling you can prepare the EPROM images by using
              ; 1) e000.edit for a 2532 EPROM
              ; 2) cat c000.basic d000.basic b000.basic f000.kernal >os8296.rom
              ;    and use os8296.rom then for a 27128 EPROM

              ; PATCHES APPLIED
              ; ===============

              ; DOS parameter parser accepts 0-9 for drive value (original 0-1)
              ; This allows BASIC4 to work with all 10 possible drives of petSD

              ; The TIM memory display and modifier uses 16 bytes per line

              ; DELETED FEATURES
              ; ================

              ; All tape related code is removed in order to make room for improvements
              ; The entry of diacritic characters is removed (accented letters etc.)

              ; NEW FEATURES
              ; ============

              ; The COPY command accepts different units for source and target
              ; The full syntax is (s = source, t = target):
              ; COPY Ds,"filepattern",Us TO Dt,Ut
              ; The D(rive) parameter defaults to D0 if not specified
              ; The U(nit)  parameter defaults to U8 if not specified
              ; Examples:
              ;
              ; COPY U8 TO U9           copies all files from D0,U8 to D0,U9
              ; COPY D1,U8 TO D2,U10    copies all files from D1,U8 to D2,U10
              ; COPY "*" TO U11         copies all files from D0,U8 to D0,U11
              ; COPY D1,"A*" TO U10     copies all files beginning with A

              ; restrictions:
              ; Currently REL files are not supported.
              ; It is is not possible to give a different name for the target file,
              ; use the RENAME command if necessary

              ; The machine language monitor TIM can now display memory from other banks.
              ; The new command ".b" (set Bank) stores a byte for the bank register.
              ; This affects the memory display for the asddress range $8000 - $ffff.
              ; Common values for the bank register are:

              ; .b 00    : system bank (screen RAM, ROM, I/O)
              ; .b 80    ; RAM bank 0/2 in $8000 - $ffff
              ; .b 8c    ; RAM bank 1/3 in $8000 - $ffff

              ; TIM includes a disassembler:

              ; .d f5c2 f5ef     disassemble the given range
              ; .d f5c2          disassemble 10 statements starting with $f5c2
              ; .d               Disassemble next 10 statements

              ; EDITING
              ; =======

              ; The editor scrolls the BASIC listing upwards or downwards if the cursor
              ; is moved up on the top line or down on the bottom line
              ; The idea (not the code) is taken from Brad Templeton's POWER ROM
              ; The character set is expanded with the missing ASCII characters {|} and ~ 
              ; These can be used by pressing the CONTROL key together with:
              ; CONTROL 7/      |
              ; CONTROL 8(      {
              ; CONTROL 9)      }
              ; CONTROL .Pi     ~ 

              ; LOAD, SAVE and VERIFY use now unit 8 as default device

              ; LOAD "filename",8,0  discards the load address and loads the file to $0401
              ; this enables the loading of C64 and other BASIC programs, which use different
              ; start addresses for BASIC programs.

              ; The Commodore Disk-Wedge is integrated, loosely based on Nils Eilers' code.

              ; @                          read drive status
              ; @command                   send dos command
              ; @$                         directory
              ; $                          directory
              ; $0                         directory of drive 0
              ; $0:pat*                    directory of files starting with "pat"
              ; /prog                      load program prog
              ; ^prog                      load and run program prog
              ; #9                         switch to unit 9
              ; #                          display current unit

              ; New commands added:

              ; DELETE from-to       ; Deletes a line range
              ;   DELETE 500-700 deletes all lines in this range
              ; FIND "text"          ; lists all lines with strings containing <text>
              ; FIND /text/          ; lists all lines with BASIC   containing <text>
              ;                      ; any character may be used as delimiter
              ; MONITOR              ; Calls TIM instead of breaking to it with SYS 1024
              ; RENUMBER new,inc,old ; Renumbers a BASIC program
              ;    The default values for new,inc,old are: 10,10,first line
              ;    RENUMBER 1000,10  renumbers the whole program to linenumbers
              ;       1000,1010,1020 etc.

              ; **********************
              ; BASIC scalar variables
              ; **********************

              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Type     | Exa.|  0  |  1  |  2  |  3  |  4  |  5  |  6
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Float    | AB  |  A  |  B  | EXP | MSB | MAN | MAN | LSB
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Integer  | AB% |  A^ |  B^ | MSB | LSB |  0  |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Function | AB( |  A^ |  B  | LFP | MFP | LBP | MBP | ARG
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; String   | AB$ |  A  |  B^ | LEN | LSP | MSP |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----

              ; ************
              ; BASIC arrays
              ; ************

              ; ---------+-----+-----+-----+---------------+
              ; Type     | Exa.|  0  |  1  |  Element Size |
              ; ---------+-----+-----+-----+---------------+
              ; Float    | AB  |  A  |  B  |       5       |
              ; ---------+-----+-----+-----+---------------+
              ; Integer  | AB% |  A^ |  B^ |       2       |
              ; ---------+-----+-----+-----+---------------+
              ; String   | AB$ |  A  |  B^ |       3       |
              ; ---------+-----+-----+-----+---------------+

              ; The circumflex ^ indicates characters OR'ed with $80

              ; Array header:

              ; Byte  0   : 1st. character of name
              ; Byte  1   : 2nd, character of name
              ; Byte  2-3 : length of array including header in bytes
              ; Byte  4   : dimension count
              ; Byte  5-6 : Hi/Lo elements of 1st. dimension, (e.g. 11 for dim a(10)
              ; Byte  7-8 : Hi/Lo elements of 2nd. dimension if dimension count > 1
              ; Byte  x-x : Two bytes for each dimension

              ; *******
              ; Equates
              ; *******

0001          CTRLA     = $01 ; scroll window down
0002          CTRLB     = $02 ; switch character ROM
0004          CTRLD     = $04 ; toggle display size between 25 or 26 rows
0007          BELL      = $07 ; chime
0009          TAB       = $09
000d          CR        = $0d
000e          CTRLN     = $0e ; switch to text mode
000f          CTRLO     = $0f ; set top left window corner
0011          DOWN      = $11
0012          RVS       = $12
0013          HOME      = $13
0014          DEL       = $14
0015          CTRLU     = $15
0016          CTRLV     = $16
0019          CTRLY     = $19
001b          ESC       = $1b
001d          RIGHT     = $1d
0022          QUOTE     = $22

              ; These locations contain the JMP instruction and target address of the
              ; USR command. They are initialised so that if you try to execute a USR
              ; call without changing them you will receive an ILLEGAL QUANTITY error
              ; message.

0000          Basic_USR = $00               ; initialized to $4c the code for JMP
0001          USRVEC    = $01               ; initialized to $c373 (Illegal_Quantity)

0003          CHARAC    = $03               ; search character
0004          ENDCHR    = $04               ; scan quotes flag
0005          COUNT     = $05               ; line crunch/array access/logic operators

              ; This is used as a flag by the routines that build an array or
              ; reference an existing array. It is used to determine whether a
              ; variable is in an array, whether the array has already been
              ; DIMensioned, and whether a new array should assume default size.

0006          DIMFLG    = $06               ; DIM flag

              ; This flag is used to indicate whether data being operated upon is
              ; string or numeric. A value of $FF in this location indicates string
              ; data while a $00 indicates numeric data.

0007          VALTYP    = $07               ; data type flag, $FF = string, $00 = numeric

              ; If the above flag indicates numeric then a $80 in this location
              ; identifies the number as an integer, and a $00 indicates a floating
              ; point number.

0008          INTFLG    = $08     ; data type flag, $80 = integer, $00 = floating pt.

              ; The garbage collection routine uses this location as a flag to
              ; indicate that garbage collection has already been tried before adding
              ; a new string. If there is still not enough memory, an OUT OF MEMORY
              ; error message will result.

              ; LIST uses this byte as a flag to let it know when it has come to a
              ; character string in quotes. It will then print the string,rather than
              ; search it for BASIC keyword tokens.

              ; This location is also used during the process of converting a line of
              ; text in the BASIC input buffer into a linked program line of BASIC
              ; keyword tokens to flag a DATA line is being processed.

0009          GARBFL    = $09     ; garbage collected/open quote/DATA flag

              ; This flag is set from the routines handling FOR, DEF and FN
              ; statements. Names for loop indices and function names must not be
              ; integer. Only identifiers of type real are allowed.

000a          SUBFLG    = $0a     ; subscript/FNx flag

              ; input mode, $00 = INPUT, $40 = GET, $80 = READ

000b          INPFLG    = $0b     ; input mode, $00 = INPUT, $40 = GET, $98 = READ

              ; This location is used to determine whether the sign of the value
              ; returned by the functions SIN, COS, ATN or TAN is positive or negative
              ; Also the comparison routines use this location to indicate the outcome
              ; of the compare. For A <=> B the value here will be $01 if A > B,
              ; $02 if A = B, and $04 if A < B. If more than one comparison operator
              ; was used to compare the two variables then the value here will be a
              ; combination of the above values.

000c          TANSGN    = $0c     ; ATN sign/comparison evaluation flag

              ; Disk status or temporary string descriptor

000d          DS_Len    = $0d     ; unused
000e          DS_Ptr    = $0e     ; unused

              ; When the default input or output device is used the value here will
              ; be a zero, and the format of prompting and output will be the standard
              ; screen output format. The location $B8 is used to decide what device
              ; actually to put input from or output to.

0010          IOPMPT    = $10     ; current I/O channel

              ; Used whenever a 16 bit integer is used e.g. the target line number for
              ; GOTO, LIST, ON, and GOSUB also the number of a BASIC line that is to
              ; be added or replaced. additionally PEEK, POKE, WAIT, and SYS use this
              ; location as a pointer to the address which is the subject of the
              ; command.

0011          LINNUM = $11        ; line number

              ; This location points to the next available slot in the temporary
              ; string descriptor stack located at TEMPST ($16-$1e).

0013          TEMPPT = $13        ; descriptor stack pointer, next free

              ; This contains information about temporary strings which have not yet
              ; been assigned to a string variable.

0014          LASTPT = $14        ; current descriptor stack item pointer

              ; Stack for temporary string descriptors
              ; String 1: $16-$18
              ; String 2: $19-$1b
              ; String 3: $1c-$1e

0016          TEMPST = $16        ; temporary descriptor stack

              ; miscellaneous pointer / word used in many BASIC routines

001f          INDEXA = $1f        ; miscellaneous pointer

              ; miscellaneous pointer / word used in many BASIC routines

0021          INDEXB = $21

              ; above address shared with RENUMBER as increment value

0021          RENINC = $21        ; RENUMBER increment value

              ; Floating point accumulator #3 (mantissa only)

0023          FAC3M1 = $23        ; mantissa byte 1 MSB
0024          FAC3M2 = $24        ; mantissa byte 2
0025          FAC3M3 = $25        ; mantissa byte 3
0026          FAC3M4 = $26        ; mantissa byte 4 LSB

0027          FAC3M5 = $27        ; unused

              ; FAC3 addresses shared with RENUMBER as start value for new line numbers

0023          RENNEW = $23        ; RENUMBER new line number start

              ; Start of BASIC program - initialized to $0401

0028          TXTTAB = $28        ; Text Table

              ; Two byte pointer to the start of the BASIC variable storage area.

002a          VARTAB = $2a        ; Variable table

              ; Two byte pointer to the start of the BASIC array storage area.

002c          ARYTAB = $2c        ; Array table

              ; Two byte pointer to end of the start of free RAM.

002e          STREND = $2e        ; String end

              ; Two byte pointer to the highest address used by BASIC +1.

0030          FRETOP = $30        ; top of BASIC memory

              ; Two byte pointer to the bottom of the string text storage area.

0032          FRESPC = $32        ; bottom of string space

              ; Two byte pointer to the highest RAM address

0034          MEMSIZ = $34        ; top of RAM

              ; These locations contain the line number of the BASIC statement which
              ; is currently being executed. A value of $FF in location $3A means that
              ; BASIC is in immediate mode.

0036          CURLIN = $36        ; current line number

              ; When program execution ends or stops the last line number executed is
              ; stored here.

0038          OLDLIN = $38        ; break line number

              ; These locations contain the address of the start of the text of the
              ; BASIC statement that is being executed.  The value of the pointer to
              ; the address of the BASIC text character currently being scanned is
              ; stored here each time a new BASIC statement begins execution.

003a          OLDTXT = $3a        ; continue pointer

              ; These locations hold the line number of the current DATA statement
              ; being READ. If an error concerning the DATA occurs this number will
              ; be moved to $39/$3A so that the error message will show the line that
              ; contains the DATA statement rather than in the line that contains the
              ; READ statement.

003c          DATLIN = $3c        ; current DATA line number

              ; These locations point to the address where the next DATA will be READ
              ; from. RESTORE sets this pointer back to the address indicated by the
              ; start of BASIC pointer.

003e          DATPTR = $3e        ; DATA pointer

              ; READ, INPUT and GET all use this as a pointer to the address of the
              ; source of incoming data, such as DATA statements, or the text input
              ; buffer.

0040          INPPTR = $40        ; READ pointer

              ; Two bytes storing the name of a BASIC variable as ASCII values
              ; The combination of the two bits 7 determines the type
              ; ---------------------------------------------
              ; Real    : AB      = $41 $42 = 'A'     'B'
              ; Function: FNAB()  = $c1 $42 = 'A'+$80 'B'
              ; String  : AB$     = $41 $c2 = 'A'     'B'+$80
              ; Integer : AB%     = $c1 $c2 = 'A'+$80 'B'+$80

0042          VARNAM = $42        ; current variable name

              ; These locations point to the value of the current BASIC variable.
              ; Specifically they point to the byte just after the two-character
              ; variable name.

0044          VARPTR = $44        ; current variable address

              ; The address of the BASIC variable which is the subject of a FOR/NEXT
              ; loop is first stored here before being pushed onto the stack.

0046          FORPNT = $46        ; FOR/NEXT variable pointer

              ; The expression evaluation routine creates this to let it know whether
              ; the current comparison operation is a < $01, = $02 or > $04 comparison
              ; or combination.

0048          YSAVE  = $48        ; BASIC execute pointer temporary/precedence flag

              ; used to compare the variable type on both sides of an operator

004a          ACCSYM = $4a        ; comparison evaluation flag

              ; These locations are used as a pointer to the function that is created
              ; during function definition. During function execution it points to
              ; where the evaluation results should be saved.

004b          FUNCPT = $4b        ; FAC temp store/function/variable/garbage pointer

              ; Temporary Pointer to the current string descriptor.

004d          DESCPT = $4d        ; FAC temp store/descriptor pointer

              ; Temporary pointer used in subroutines

004f          INDEXC = $4f

              ; The first byte is the 6502 JMP instruction $4C, followed by the
              ; address of the required function taken from the table at $B000.

0051          JUMPER = $51         ; JMP opcode for functions

              ; Used as jump address for previous opcode
              ; Several uses as temporary storage in BASIC routines

0052          FUNJMP = $52         ; functions jump vector

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary pointer (block pointer, array pointer)

0054          FACTPA = $54         ; FAC temp store ($54 - $58)
0055          TMPPTA = $55         ; temp pointer A
0057          TMPPTB = $57         ; temp pointer B

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary variables

0059          FACTPB = $59         ; FAC temp store ($59 - $5d)
005a          TMPVAR = $5a         ; temporary variable
005c          TMPPTC = $5c         ; temporary pointer

              ; Floating point accumulator 1

005e          FAC1EX = $5e         ; FAC1 exponent
005f          FAC1M1 = $5f         ; FAC1 mantissa 1
0060          FAC1M2 = $60         ; FAC1 mantissa 2
0061          FAC1M3 = $61         ; FAC1 mantissa 3
0062          FAC1M4 = $62         ; FAC1 mantissa 4
0063          FAC1SI = $63         ; FAC1 sign
0064          SGNFLG = $64         ; constant count/negative flag

0065          BITS   = $65         ; unused

              ; Floating point accumulator 2

0066          FAC2EX = $66         ; FAC2 exponent
0067          FAC2M1 = $67         ; FAC2 mantissa 1
0068          FAC2M2 = $68         ; FAC2 mantissa 2
0069          FAC2M3 = $69         ; FAC2 mantissa 3
006a          FAC2M4 = $6a         ; FAC2 mantissa 4
006b          FAC2SI = $6b         ; FAC2 sign

              ; String pointer and FAC sign comparison and FAC rounding

006c          STRPTR = $6c         ; string pointer & FAC variables

              ; this address is sometimes used as high btye for the STRPTR
              ; and as rounding byte (5th. byte of mantissa) for FAC1

006d          FROUND = $6d         ; FAC1 mantissa 5 = rounding byte

              ; Temporary pointer and index used in many BASIC routines

006e          TMPPTD = $6e         ; temp BASIC execute/array pointer low byte/index

              ; Basic CHRGET (with increment) and CHRGOT (no increment) routine
              ; Also ISNUM for check if character is numeric
              ; Copied to this location from CHRGET_ROM at $d399
              ;
              ; 0070 e6 77     CHRGET    INC TXTPTR
              ; 0072 d0 02               BNE CHRGOT
              ; 0074 e6 78               INC TXTPTR+1
              ; 0076 ad 60 ea  CHRGOT    LDA $ffff       ; modified by previous code
              ; 0079 c9 3a               CMP #':'        ; check of end of statement
              ; 007b b0 0a               BCS CHRRET
              ; 007d c9 20     ISNUM     CMP #' '        ; skip blanks
              ; 007f f0 ef               BEQ CHRGET
              ; 0081 38                  SEC
              ; 0082 e9 30               SBC #'0'
              ; 0084 38                  SEC
              ; 0085 e9 d0               SBC #$d0
              ; 0087 60        CHRRET    RTS

0070          CHRGET = $70        ; Get program byte with pointer pre increment
0076          CHRGOT = $76        ; Get program byte
0077          TXTPTR = $77        ; Pointer to current program byte
007d          ISNUM  = $7d        ; Check for numeric digit

              ; Random seed, five bytes ($88 - $8c)

0088          RNDX   = $88        ; Random seed

              ; These three locations form a counter which is updated 60 times a
              ; second, and serves as a software clock which counts the number of
              ; jiffies that have elapsed since the computer was turned on.
              ; European computers running at 50 Hz add an additional count every
              ; 5th. jiffy in order to compensate the lower interrupt frequency.
              ; After 24 hours and one jiffy these locations are set back to $000000.

008d          JIFFY_CLOCK = $8d   ; Count jiffies (1/60 seconds)

              ; Vector, which may be used to redirect the interrupt routine.
              ; It is initialized to IRQ_NORMAL ($e455), which handles updating
              ; the jiffy clock, blinking the cursor and scanning the keyboard
              ; ROM's with tape routines switch this vector during tape activities
              ; to routines handling write to tape or read from tape.

0090          CINV   = $90        ; IRQ vector (IRQ_NORMAL)

              ; Vector, which may be used to redirect the break routine.
              ; The break routine is called after executing the BRK ($00) command
              ; either by intention or accidentally due to an error.
              ; It is initialized to MONITOR_BREAK ($d467), which saves the contents
              ; of all registers and starts TIM, the tiny machine language monitor.

0092          CBINV  = $92        ; BRK vector (MONITOR_BREAK)

              ; Vector, which may be used to redirect the Non Maskable Interrupt.
              ; It is intialized to Basic_Reday ($b3ff).

0094          NMINV  = $94        ; NMI vector (Basic_Reday)

              ; The STATUS byte is used to flag I/O errors or End-Of-Information
              ; A bit set to 1 indicates foloowing conditions:

              ; bit 0 : time out write
              ; bit 1 : time out read
              ; bit 4 : verify error
              ; bit 6 : EOI (End Of Information)
              ; bit 7 : device not present

0096          STATUS = $96        ; Status byte for I/O operations

              ; Key_Index is used in the subroutine EDIT_KEY_SCAN
              ; It holds the index for the character tables or -1 ($ff) for no key

0097          Key_Index = $97     ; Key index for character lookup

              ; The keyflags are used to select the character lookup table for
              ; NORMAL, SHIFTED or CONTROL.
              ; Flags are set by setting the corresponding bit to 0

              ; bit 7:  0 = <shift>
              ; bit 6:  0 = <control>

0098          Key_Flags = $98

              ; The power flag activates power scrolling (continuous scrolling)
              ; when set. It is active in direct mode and inactive in run mode.

0099          Power_Flag = $99    ; $ff power scrolling on, $00 off


              ; The default bank holds the configuration for the bank register $FFF0
              ; If the operating system runs from ROM its value is $00
              ; Loadable BSOS runs for configuration $ec

009a          Default_Bank = $9a  ; $00 = OS running in ROM

              ; The Stop_Flag is set by the keyboard scan routine
              ; $ff = no STOP key pressed, $ef = STOP key pressed

009b          Stop_Flag = $9b     ; $ef = 1110 1111 flags STOP key pressed

              ; Originally used as variable SVXT for tape routines
              ; Mow used by Parse_DOS_Parameter

009c          Source_Unit = $9c   ; Source unit for COPY command

              ; VERCK flags LOAD (0) or VERIFY ($80) mode for the load routines
              ; MERGE uses the value $40

009d          VERCK         = $9d ; LOAD or VERIFY flag

              ; Counter for the number of keys in keyboard buffer

009e          CharsInBuffer = $9e ; number of keys buffered

              ; Flag indicating reverse mode for screen output

009f          ReverseFlag  = $9f  ; 0 = normal   non zero = reverse

              ; IEEE-488 output: deferred character flag

00a0          C3PO         = $a0  ; 0 = no character waiting, $ff = character waiting

00a1          LastInputCol = $a1  ; screen input stops reading at LastInputVol
00a3          InputRow     = $a3  ; store screen input row number (0-24)
00a4          InputCol     = $a4  ; store screen input column (0-79)

              ; The IEEE-488 output routine CIOUT delays the output by one character,
              ; which is stored in BSOUR. CIOUT checks on each call first, if a character
              ; is stored in BSOUR for transmisson, by testing the flag C3PO.
              ; If C3PO is negative, the character in BSOUR is sent and the actual
              ; character is stored in BSOUR. If BSOUR is empty (C3PO == 0), the only
              ; action is storing the actual character in BSOUR and setting C3PO negative.
              ; The delay in sending makes it possible  to send the EOI (End Of Information)
              ; along with the last character to transmit.

00a5          BSOUR  = $a5        ; IEEE-488  output: deferred character (buffer)

              ; The keyscan interrupt routine uses this location to indicate which key
              ; is currently being pressed. The value here is then used as an index
              ; into the appropriate keyboard table to determine which character to
              ; print when a key is struck.
              ; The correspondence between the key pressed and the number stored here
              ; is as follows:

              ; $00          $10   2      $20   4      $30   6       $40   9
              ; $01          $11  [DOWN]  $21   UE     $31   AE      $41
              ; $02   sz     $12          $22   O      $32   L       $42  [HOME]
              ; $03  [DEL]   $13   0      $23   [      $33  [RETURN] $43   7
              ; $04   9      $14   ,      $24   U      $34   J       $44   0
              ; $05   6      $15   N      $25   T      $35   G       $45   7
              ; $06   3      $16   V      $26   E      $36   D       $46   4
              ; $07   <   ]  $17   Y      $27   Q      $37   A       $47   1
              ; $08   1      $18   3      $28   ]      $38   5       $48
              ; $09          $19  [SHIFT] $29   P      $39   OE      $49
              ; $0A          $1A          $2A   I      $3A   K       $4a  [STOP]
              ; $0B  [RIGHT] $1B   .      $2B   +      $3B   #       $4b   8
              ; $0C   M      $1C   .      $2C   Z      $3C   H       $4c   ´
              ; $0D  [SPACE] $1D   B      $2D   R      $3D   F       $4d   9
              ; $0E   X      $1E   C      $2E   W      $3E   S       $4e   6
              ; $0F  [CTRL]  $1F  [SHIFT] $2F  [TAB]   $3F  [ESC]    $4f   3

00a6          SFDX   = $a6         ; which key

              ; When this flag is set to a nonzero value, it indicates to the routine
              ; that normally flashes the cursor not to do so. The cursor blink is
              ; turned off when there are characters in the keyboard buffer, or when
              ; the program is running.

00a7          BLNSW   = $a7        ; cursor enable, $00 = flash cursor

              ; The routine that blinks the cursor uses this location to tell when
              ; it's time for a blink. The number 20 is put here and decremented every
              ; jiffy until it reaches zero. Then the cursor state is changed, the
              ; number 20 is put back here, and the cycle starts all over again.

00a8          BLNCT   = $a8

              ; The cursor is formed by printing the inverse of the character that
              ; occupies the cursor position. If that characters is the letter A, for
              ; example, the flashing cursor merely alternates between printing an A
              ; and a reverse-A. This location keeps track of the normal screen code
              ; of the character that is located at the cursor position, so that it
              ; may be restored when the cursor moves on.

00a9          GDBLN  = $a9         ; character under cursor

              ; This location keeps track of whether, during the current cursor blink,
              ; the character under the cursor was reversed, or was restored to
              ; normal. This location will contain 0 if the character is reversed, and
              ; 1 if the character is not reversed.

00aa          BLNON  = $aa         ; cursor blink phase

              ; The current unit number for wedge commands is held in Wedge_Unit
              ; It is initialized to 8 and can be changed with #<unit>

00ab          Wedge_Unit = $ab     ; current device for DOS wedge commands

              ; input from keyboard or screen, $xx = input is available from the
              ; screen, $00 = input should be obtained from the keyboard

00ac          CRSW   = $ac         ; input from keyboard or screen

00ad          Target_Unit = $ad    ; used by DOS Copy

              ; The number of currently open I/O files is stored here. The maximum
              ; number that can be open at one time is ten. The number stored here is
              ; used as the index to the end of the tables that hold the file numbers,
              ; device numbers, and secondary addresses.

00ae          LDTND  = $ae         ; open file count

              ; The default value of this location is 0.

00af          DFLTN  = $af         ; input device number

              ; The default value of this location is 3.

00b0          DFLTO  = $b0         ; output device number

                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard
                                   ;  1      cassette #1 - disabled in BSOS
                                   ;  2      cassette #2 - disabled in BSOS
                                   ;  3      screen
                                   ;  4-31   IEEE-488 bus

00b1          DOS_FC     = $b1     ; used for DOS_Copy
00b2          DOS_EOF    = $b2     ; used for DOS_Copy
00b3          PC_Adjust  = $b3     ; used in monitor
00b4          SCROLLING  = $b4     ; unused
00b5          MONCNT     = $b5     ; TIM counter variable

              ; Theses variables are used to store the value for the bank switching register
              ; while performing the RENUMBER command.

00b6          R_Bank     = $b6     ; Read  Bank value for bank switching
00b7          W_Bank     = $b7     ; Write Bank value for bank switching
00b8          ZP_b8      = $b8     ; unused
00b9          DOS_RL     = $b9     ; used for DOS_Copy
00ba          Dis_Line   = $ba     ; Disassembler
00bb          DosPtr     = $bb     ; used for DS$
00bd          Mon_Format = $bd     ; Disassembler
00be          Dis_Length = $be     ; Disassembler
00bf          Mon_A      = $bf     ; Disassembler
00c0          Mon_B      = $c0     ; Disassembler
00c1          Mon_Op     = $c1     ; Disassembler
00c2          Mon_Lo     = $c2     ; Disassembler
00c3          Mon_Hi     = $c3     ; Disassembler

              ; The Screen Pointer ScrPtr contains the screen memory address
              ; of the current cursor position

00c4          ScrPtr     = $c4      ; screen pointer ($8000 - $87cf)
00c6          CursorCol  = $c6      ; cursor column (0 - 79)

00c7          SAL        = $c7      ; used for windows scrolling
00c9          EAL        = $c9      ; used for LOAD, SAVE and TIM

00cb          Mon_Tmp    = $cb      ; Monitor temporary
00cc          Mon_ZP     = $cc      ; Monitor ZP flag

              ; A nonzero value in this location indicates that the editor is in quote
              ; mode. Quote mode is toggled every time that you type in a quotation
              ; mark on a given line, the first quote mark turns it on, the second
              ; turns it off, the third turns it on, etc.

              ; If the editor is in this mode when a cursor control character or other
              ; nonprinting character is entered, a printed equivalent will appear on
              ; the screen instead of the cursor movement or other control operation
              ; taking place. Instead, that action is deferred until the string is
              ; sent to the string by a PRINT statement, at which time the cursor
              ; movement or other control operation will take place.

              ; The exception to this rule is the DELETE key, which will function
              ; normally within quote mode. The only way to print a character which is
              ; equivalent to the DELETE key is by entering insert mode. Quote mode
              ; may be exited by printing a closing quote or by hitting the RETURN or
              ; SHIFT-RETURN or ESC keys.

00cd          QTSW   = $cd        ; quote switch non zero:inside quotes

00ce          BITTS  = $ce        ; unused (transmitter byte buffer)
00cf          EOT    = $cf        ; unused (end of tape)
00d0          ZD0    = $d0        ; unused

00d1          FNLEN  = $d1        ; Length of filename - for file open and DOS commands
00d2          LA     = $d2        ; Local     Address
00d3          SA     = $d3        ; Secondary Address
00d4          FA     = $d4        ; First     Address

00d5          RigMargin  = $d5    ; right margin of window (0 - 79)
00d6          TAPE1      = $d6    ; unused
00d8          CursorRow  = $d8    ; current corsor row
00d9          DATAX      = $d9    ; temprary storage
00da          FNADR      = $da    ; file name address
00dc          INSRT      = $dc    ; # of inserts outstanding
00dd          ROPRTY     = $dd    ; unused
00de          FSBLK      = $de    ; unused
00df          ScreenRows = $df    ; current screen rows - 1 (24 or 29)
00e0          TopMargin  = $e0    ; bottom margin of window (0 - screenrows-1)
00e1          BotMargin  = $e1    ; top margin of window
00e2          LefMargin  = $e2    ; left margin of window
00e3          XMAX       = $e3    ; length of keyboard buffer-1 = 9
00e4          LSTX       = $e4    ; last key pressed
00e5          KOUNT      = $e5    ; repeat speed counter
00e6          DELAY      = $e6    ; repeat delay
00e7          CHIME      = $e7    ; chime counter

              ; save the last character processed by Edit_CHROUT in PrevChar
              ; this is used to identify the seuence <HOME><HOME>, which resets
              ; the window to full screen

00e8          PrevChar   = $e8

00e9          SCRIV = $00e9
00eb          SCROV = $00eb
00f8          JIFFY6 = $00f8
00f9          BPTR = $00f9
00fb          STAL = $00fb
00fd          MEMUSS = $00fd
0100          STACK = $0100
0200          BUF = $0200
0251          LAT = $0251
025b          FAT = $025b
0265          SAT = $0265
026f          KEYD = $026f

              ; Commodore BASIC 4 used the area $027a - $0339
              ; as buffer for tape operations (TAPE1 buffer)
              ; BSOS has no TAPE routine and uses it for storing routines
              ; for accessing memory at different banks. These routines must
              ; be located at low RAM, because the ROM area is switched off
              ; while accessing High RAM.
              ; The area is used by the Monitor and RENUMBER command only.

028b          Bank_Store = Bank_Fetch + Bank_Store_Start - Bank_Fetch_Start
027a          Bank_Fetch     = $027a
02a0          Mon_Register   = $02a0
02b0          Dis_Buf_Length = $02b0
02b1          Dis_Buf        = $02b1
02c0          Ass_Buf_Length = $02c0
02c1          Ass_Buf        = $02c1
02d0          Ass_Index      = $02d0
02d1          Ass_Dollar     = $02d1
02d2          Ass_Length     = $02d2

              ; The area $033a - $03c9 was the tape buffer 2 on BASIC 2
              ; BASIC 4 uses this area for variables and buffers related to the
              ; BASIC 4 disk commands, like DOPEN, DCLOSE, DIRECTORY, etc.

033a          DOS_Tmp     = $033a
033b          DOS_Drive_1 = $033b
033c          DOS_Drive_2 = $033c
033d          DOS_Attr    = $033d

              ; DOS_flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

033e          DOS_Flags          = $033e
033f          DOS_Id             = $033f
0341          DOS_Command_Length = $0341
0342          DOS_Filename       = $0342
0353          DOS_Command_Buffer = $0353
03ad          DOS_Status         = $03ad
03ee          TABS_SET           = $03ee
03fa          Reset_Vector       = $03fa
03fc          Ignore_Timeout     = $03fc
8000          SCREEN_RAM         = $8000

              ; *****************************
              ; MCS 6520 Peripheral Adapter 1
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E810 |CASR| EOI|    |    |Select Keyboard Row| PIA1_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E811 |  0 |  0 |  1 |  1 |  1 |  x |  0 |  0 | PIA1_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E812 |          Keyboard Row (8 keys)        | PIA1_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E813 |  0 |  0 |  1 |  1 |  1 |  1 |  0 |  1 | PIA1_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e810          PIA1_Port_A = $e810
e811          PIA1_Cont_A = $e811
e812          PIA1_Port_B = $e812
e813          PIA1_Cont_B = $e813

              ; *****************************
              ; MCS 6520 Peripheral Adapter 2
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E820 |             IEEE-488 DATA IN          | PIA2_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E821 |    |    |    |    |NDAC|    |    |    | PIA2_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E822 |             IEEE-488 DATA OUT         | PIA2_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E823 | SRQ|    |    |    | DAV|    |    |    | PIA2_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e820          PIA2_Port_A = $e820
e821          PIA2_Cont_A = $e821
e822          PIA2_Port_B = $e822
e823          PIA2_Cont_B = $e823

              ; ************************************
              ; MCS 6522 Versatile Interface Adapter
              ; ************************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  0| E840 | DAV|NRFD|    |    |    | ATN|NRFD|NDAC| Port_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  1| E841 |              User-Port                | Port_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  2| E842 |  0 |  0 |  0 |  1 |  1 |  1 |  1 |  0 | DDR_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  3| E843 |       User-Port Data Direction        | DDR_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  4| E844 |    |    |    |    |    |    |    |    | Timer 1 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  5| E845 |    |    |    |    |    |    |    |    | Timer 1 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  6| E846 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  7| E847 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  8| E848 |    |    |    |    |    |    |    |    | Timer 2 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  9| E849 |    |    |    |    |    |    |    |    | Timer 2 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 10| E84A |    Shift Register                     | Shift
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 11| E84B |    Auxiliary Control Register         | ACR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 12| E84C |    |    |    |    |    |    |    |    | PCR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 13| E84D |    Interrupt Flag Register            | IFR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 14| E84E |    Interrupt Enable Register          | IER
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 15| E84F |    No Handshake Register              | no_HS
              ; --+------+----+----+----+----+----+----+----+----+--------------

e840          VIA_Port_B           = $e840
e841          VIA_Port_A           = $e841  ; unused
e842          VIA_DDR_B            = $e842
e843          VIA_DDR_A            = $e843  ; unused
e844          VIA_Timer_1_Lo       = $e844
e845          VIA_Timer_1_Hi       = $e845
e846          VIA_Timer_1_Latch_Lo = $e846  ; unused
e847          VIA_Timer_1_Latch_Hi = $e847  ; unused
e848          VIA_Timer_2_Lo       = $e848
e849          VIA_Timer_2_Hi       = $e849
e84a          VIA_Shift            = $e84a

e84b          VIA_ACR              = $e84b  ; Auxiliary Control Register
              ; bit 7: Timer 1 : Output Enable    1 = continuous 0 = single
              ; bit 6: Timer 1 : Free-Run Enable  1 = PB7 pulse  0 = IRQ
              ; bit 5: Timer 2 : Control          1 = pulse      0 = single

e84c          VIA_PCR              = $e84c

e84d          VIA_IFR              = $e84d  ; Interrupt Flag Register
              ; 7        IRQ
              ;  6       T1
              ;   5      T2
              ;    4     CB1
              ;     3    CB2
              ;      2   SR
              ;       1  CA1
              ;        0 CA2

e84e          VIA_IER              = $e84e  ; Interrupt Enable Register
e84f          VIA_Port_A_no_HS     = $e84f  ; unused




e880          CRT_Address          = $e880
e881          CRT_Value            = $e881

b000          * = $b000   ; *** b000 ***  Commodore 8296


              ; *********************
b000            Basic_Statement_Table
              ; *********************

b000 c7 b7              .WORD Basic_END       - 1
b002 dd b6              .WORD Basic_FOR       - 1
b004 18 bd              .WORD Basic_NEXT      - 1
b006 82 b8              .WORD Basic_DATA      - 1
b008 a3 bb              .WORD Basic_INPUTN    - 1
b00a bd bb              .WORD Basic_INPUT     - 1
b00c 20 c1              .WORD Basic_DIM       - 1
b00e 01 bc              .WORD Basic_READ      - 1
b010 2f b9              .WORD Basic_LET       - 1
b012 2f b8              .WORD Basic_GOTO      - 1
b014 07 b8              .WORD Basic_RUN       - 1
b016 b2 b8              .WORD Basic_IF        - 1
b018 b6 b7              .WORD Basic_RESTORE   - 1
b01a 12 b8              .WORD Basic_GOSUB     - 1
b01c 5c b8              .WORD Basic_RETURN    - 1
b01e c5 b8              .WORD Basic_REM       - 1
b020 c5 b7              .WORD Basic_STOP      - 1
b022 d5 b8              .WORD Basic_ON        - 1
b024 62 c9              .WORD Basic_WAIT      - 1
b026 d4 ff              .WORD Basic_LOAD      - 1
b028 d7 ff              .WORD Basic_SAVE      - 1
b02a da ff              .WORD Basic_VERIFY    - 1
b02c db c4              .WORD Basic_DEF       - 1
b02e 59 c9              .WORD Basic_POKE      - 1
b030 87 ba              .WORD Basic_PRINTN    - 1
b032 a7 ba              .WORD Basic_PRINT     - 1
b034 ed b7              .WORD Basic_CONT      - 1
b036 2f b6              .WORD Basic_LIST      - 1
b038 ed b5              .WORD Basic_CLR       - 1
b03a 8d ba              .WORD Basic_CMD       - 1
b03c dd ff              .WORD Basic_SYS       - 1
b03e bf ff              .WORD OPEN            - 1
b040 c2 ff              .WORD CLOSE           - 1
b042 79 bb              .WORD Basic_GET       - 1
b044 d1 b5              .WORD Basic_NEW       - 1
b046 ab b7              .WORD Basic_GO        - 1
b048 92 ff              .WORD Basic_CONCAT    - 1
b04a 95 ff              .WORD Basic_DOPEN     - 1
b04c 98 ff              .WORD Basic_DCLOSE    - 1
b04e 9b ff              .WORD Basic_RECORD    - 1
b050 9e ff              .WORD Basic_HEADER    - 1
b052 a1 ff              .WORD Basic_COLLECT   - 1
b054 a4 ff              .WORD Basic_BACKUP    - 1
b056 a7 ff              .WORD Basic_COPY      - 1
b058 aa ff              .WORD Basic_APPEND    - 1
b05a ad ff              .WORD Basic_DSAVE     - 1
b05c b0 ff              .WORD Basic_DLOAD     - 1
b05e b3 ff              .WORD Basic_DIRECTORY - 1
b060 b6 ff              .WORD Basic_RENAME    - 1
b062 b9 ff              .WORD Basic_SCRATCH   - 1
b064 b3 ff              .WORD Basic_DIRECTORY - 1

b066                    .SIZE ;  102 [Basic_Statement_Table]

              ; ********************
b066            Basic_Function_Table
              ; ********************

b066 6f cd              .WORD Basic_SGN
b068 02 ce              .WORD Basic_INT
b06a 8e cd              .WORD Basic_ABS
b06c 00 00              .WORD Basic_USR
b06e a8 c4              .WORD Basic_FRE
b070 c9 c4              .WORD Basic_POS
b072 08 d1              .WORD Basic_SQR
b074 29 d2              .WORD Basic_RND
b076 20 cb              .WORD Basic_LOG
b078 84 d1              .WORD Basic_EXP
b07a 82 d2              .WORD Basic_COS
b07c 89 d2              .WORD Basic_SIN
b07e d2 d2              .WORD Basic_TAN
b080 2c d3              .WORD Basic_ATN
b082 43 c9              .WORD Basic_PEEK
b084 b2 c8              .WORD Basic_LEN
b086 8e c5              .WORD Basic_STR
b088 e3 c8              .WORD Basic_VAL
b08a c1 c8              .WORD Basic_ASC
b08c 22 c8              .WORD Basic_CHR
b08e 36 c8              .WORD Basic_LEFT
b090 62 c8              .WORD Basic_RIGHT
b092 6d c8              .WORD Basic_MID

b094                    .SIZE ;   46 [Basic_Function_Table]

              ; ********************
b094            Basic_Operator_Table
              ; ********************

b094 79 9f c9           .BYTE $79, Op_PLUS     - 1
b097 79 88 c9           .BYTE $79, Op_MINUS    - 1
b09a 7b 60 cb           .BYTE $7b, Op_MULTIPLY - 1
b09d 7b 47 cc           .BYTE $7b, Op_DIVIDE   - 1
b0a0 7f 11 d1           .BYTE $7f, Op_POWER    - 1
b0a3 50 87 c0           .BYTE $50, Op_AND      - 1
b0a6 46 85 c0           .BYTE $46, Op_OR       - 1
b0a9 7d 4a d1           .BYTE $7d, Op_NEGATE   - 1
b0ac 5a cb be           .BYTE $5a, Op_NOT      - 1
b0af 64 b5 c0           .BYTE $64, Op_COMPARE  - 1

b0b2                    .SIZE ;   30 [Basic_Operator_Table]

              ; *******************
b0b2            Basic_Keyword_Table
              ; *******************

b0b2 45 4e c4           .BYTE "END"^        ; 80
b0b5 46 4f d2           .BYTE "FOR"^        ; 81
b0b8 4e 45 58           .BYTE "NEXT"^       ; 82
b0bc 44 41 54           .BYTE "DATA"^       ; 83
b0c0 49 4e 50           .BYTE "INPUT#"^     ; 84
b0c6 49 4e 50           .BYTE "INPUT"^      ; 85
b0cb 44 49 cd           .BYTE "DIM"^        ; 86
b0ce 52 45 41           .BYTE "READ"^       ; 87
b0d2 4c 45 d4           .BYTE "LET"^        ; 88
b0d5 47 4f 54           .BYTE "GOTO"^       ; 89
b0d9 52 55 ce           .BYTE "RUN"^        ; 8a
b0dc 49 c6              .BYTE "IF"^         ; 8b
b0de 52 45 53           .BYTE "RESTORE"^    ; 8c
b0e5 47 4f 53           .BYTE "GOSUB"^      ; 8d
b0ea 52 45 54           .BYTE "RETURN"^     ; 8e
b0f0 52 45 cd           .BYTE "REM"^        ; 8f
b0f3 53 54 4f           .BYTE "STOP"^       ; 90
b0f7 4f ce              .BYTE "ON"^         ; 91
b0f9 57 41 49           .BYTE "WAIT"^       ; 92
b0fd 4c 4f 41           .BYTE "LOAD"^       ; 93
b101 53 41 56           .BYTE "SAVE"^       ; 94
b105 56 45 52           .BYTE "VERIFY"^     ; 95
b10b 44 45 c6           .BYTE "DEF"^        ; 96
b10e 50 4f 4b           .BYTE "POKE"^       ; 97
b112 50 52 49           .BYTE "PRINT#"^     ; 98
b118 50 52 49           .BYTE "PRINT"^      ; 99
b11d 43 4f 4e           .BYTE "CONT"^       ; 9a
b121 4c 49 53           .BYTE "LIST"^       ; 9b
b125 43 4c d2           .BYTE "CLR"^        ; 9c
b128 43 4d c4           .BYTE "CMD"^        ; 9d
b12b 53 59 d3           .BYTE "SYS"^        ; 9e
b12e 4f 50 45           .BYTE "OPEN"^       ; 9f
b132 43 4c 4f           .BYTE "CLOSE"^      ; a0
b137 47 45 d4           .BYTE "GET"^        ; a1
b13a 4e 45 d7           .BYTE "NEW"^        ; a2
b13d 54 41 42           .BYTE "TAB("^       ; a3
b141 54 cf              .BYTE "TO"^         ; a4
b143 46 ce              .BYTE "FN"^         ; a5
b145 53 50 43           .BYTE "SPC("^       ; a6
b149 54 48 45           .BYTE "THEN"^       ; a7
b14d 4e 4f d4           .BYTE "NOT"^        ; a8
b150 53 54 45           .BYTE "STEP"^       ; a9
b154 ab                 .BYTE "+"^          ; aa
b155 ad                 .BYTE "-"^          ; ab
b156 aa                 .BYTE "*"^          ; ac
b157 af                 .BYTE "/"^          ; ad
b158 de                 .BYTE "^"^          ; ae
b159 41 4e c4           .BYTE "AND"^        ; af
b15c 4f d2              .BYTE "OR"^         ; b0
b15e be                 .BYTE ">"^          ; b1
b15f bd                 .BYTE "="^          ; b2
b160 bc                 .BYTE "<"^          ; b3
b161 53 47 ce           .BYTE "SGN"^        ; b4
b164 49 4e d4           .BYTE "INT"^        ; b5
b167 41 42 d3           .BYTE "ABS"^        ; b6
b16a 55 53 d2           .BYTE "USR"^        ; b7
b16d 46 52 c5           .BYTE "FRE"^        ; b8
b170 50 4f d3           .BYTE "POS"^        ; b9
b173 53 51 d2           .BYTE "SQR"^        ; ba
b176 52 4e c4           .BYTE "RND"^        ; bb
b179 4c 4f c7           .BYTE "LOG"^        ; bc
b17c 45 58 d0           .BYTE "EXP"^        ; bd
b17f 43 4f d3           .BYTE "COS"^        ; be
b182 53 49 ce           .BYTE "SIN"^        ; bf
b185 54 41 ce           .BYTE "TAN"^        ; c0
b188 41 54 ce           .BYTE "ATN"^        ; c1
b18b 50 45 45           .BYTE "PEEK"^       ; c2
b18f 4c 45 ce           .BYTE "LEN"^        ; c3
b192 53 54 52           .BYTE "STR$"^       ; c4
b196 56 41 cc           .BYTE "VAL"^        ; c5
b199 41 53 c3           .BYTE "ASC"^        ; c6
b19c 43 48 52           .BYTE "CHR$"^       ; c7
b1a0 4c 45 46           .BYTE "LEFT$"^      ; c8
b1a5 52 49 47           .BYTE "RIGHT$"^     ; c9
b1ab 4d 49 44           .BYTE "MID$"^       ; ca
b1af 47 cf              .BYTE "GO"^         ; cb
b1b1 43 4f 4e           .BYTE "CONCAT"^     ; cc
b1b7 44 4f 50           .BYTE "DOPEN"^      ; cd
b1bc 44 43 4c           .BYTE "DCLOSE"^     ; ce
b1c2 52 45 43           .BYTE "RECORD"^     ; cf
b1c8 48 45 41           .BYTE "HEADER"^     ; d0
b1ce 43 4f 4c           .BYTE "COLLECT"^    ; d1
b1d5 42 41 43           .BYTE "BACKUP"^     ; d2
b1db 43 4f 50           .BYTE "COPY"^       ; d3
b1df 41 50 50           .BYTE "APPEND"^     ; d4
b1e5 44 53 41           .BYTE "DSAVE"^      ; d5
b1ea 44 4c 4f           .BYTE "DLOAD"^      ; d6
b1ef 43 41 54           .BYTE "CATALOG"^    ; d7
b1f6 52 45 4e           .BYTE "RENAME"^     ; d8
b1fc 53 43 52           .BYTE "SCRATCH"^    ; d9
b203 44 49 52           .BYTE "DIRECTORY"^  ; da
b20c 00                 .BYTE $00           ; db

b20d                    .SIZE ;  347 [Basic_Keyword_Table]

              ; *********
b20d            Msg_Start
              ; *********

b20d 4e 45 58           .BYTE "NEXT WITHOUT FOR"^
b21d 53 59 4e Msg_SYNTA .BYTE "SYNTAX"^
b223 52 45 54 Msg_GOSUB .BYTE "RETURN WITHOUT GOSUB"^
b237 4f 55 54           .BYTE "OUT OF DATA"^
b242 49 4c 4c Msg_QUANT .BYTE "ILLEGAL QUANTITY"^
b252 4f 56 45 Msg_FLOW  .BYTE "OVERFLOW"^
b25a 4f 55 54 Msg_OOM   .BYTE "OUT OF MEMORY"^
b267 55 4e 44 Msg_UNDEF .BYTE "UNDEF'D STATEMENT"^
b278 42 41 44 Msg_SUBSC .BYTE "BAD SUBSCRIPT"^
b285 52 45 44 Msg_REDIM .BYTE "REDIM'D ARRAY"^
b292 44 49 56 Msg_DIV   .BYTE "DIVISION BY ZERO"^
b2a2 49 4c 4c Msg_DIREC .BYTE "ILLEGAL DIRECT"^
b2b0 54 59 50 Msg_TYPE  .BYTE "TYPE MISMATCH"^
b2bd 53 54 52 Msg_LONG  .BYTE "STRING TOO LONG"^
b2cc 46 49 4c Msg_DATA  .BYTE "FILE DATA"^
b2d5 46 4f 52 Msg_COMPL .BYTE "FORMULA TOO COMPLEX"^
b2e8 43 41 4e           .BYTE "CAN'T CONTINUE"^
b2f6 55 4e 44 Msg_FUNC  .BYTE "UNDEF'D FUNCTION"^
b306 20 45 52 Msg_ERR   .BYTE " ERROR",0
b30d 20 49 4e Msg_IN    .BYTE " IN ",0

b312                    .SIZE ;  261 [Msg_Start]

              ; *********
b312            Msg_READY
              ; *********

b312 0d 52 45           .BYTE "\rREADY.\r",0

              ; *********
b31b            Msg_BREAK
              ; *********

b31b 0d 42 52           .BYTE "\rBREAK",0


              ; FOR TO STEP NEXT data structure on stack
              ; ========================================

              ; 00 : TXTPTR
              ; 01 : TXTPTR+1  address of loop body

              ; 02 : CURLIN+1
              ; 03 : CURLIN    line #  of loop body

              ; 04 : FAC M4
              ; 05 : FAC M3
              ; 06 : FAC M2    value after TO
              ; 07 : FAC M1
              ; 08 : FAC EX

              ; 09 : sign
              ; 0a : FAC M4
              ; 0b : FAC M3
              ; 0c : FAC M2    value after STEP
              ; 0d : FAC M1
              ; 0e : FAC EX

              ; 0f : FORPNT+1
              ; 10 : FORPNT    address of index variable

              ; 11 : 81        loop marker

              ; ***********************
b322            Find_Active_FOR ; $b322
              ; ***********************

              ; Output: X = stackpointer to loop structure
              ;         Z = found flag
              ;         FORPNT = address of index variable

b322 ba                 TSX                 ; X = stack pointer
b323 e8                 INX
b324 e8                 INX                 ; skip return address of current subroutine
b325 e8                 INX
b326 e8                 INX                 ; skip return address of calling subroutine
b327 bd 01 01 FAF_10    LDA STACK+1,X
b32a c9 81              CMP #$81            ; loop marker ?
b32c d0 21              BNE FAF_Ret
b32e a5 47              LDA FORPNT+1        ; index variable given ?
b330 d0 0a              BNE FAF_20
b332 bd 02 01           LDA STACK+2,X       ; index variable low
b335 85 46              STA FORPNT
b337 bd 03 01           LDA STACK+3,X       ; index variable high
b33a 85 47              STA FORPNT+1
b33c dd 03 01 FAF_20    CMP STACK+3,X       ; index address high match ?
b33f d0 07              BNE FAF_30
b341 a5 46              LDA FORPNT
b343 dd 02 01           CMP STACK+2,X       ; index address low  match ?
b346 f0 07              BEQ FAF_Ret         ; OK found correct data structure
b348 8a       FAF_30    TXA
b349 18                 CLC
b34a 69 12              ADC #$12            ; try outer loop
b34c aa                 TAX
b34d d0 d8              BNE FAF_10
b34f 60       FAF_Ret   RTS ;Size   46 [Find_Active_FOR]

              ; *********************
b350            Open_Up_Space ; $b350
              ; *********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ;         TMPPTA = target pointer (upper boundary)
              ;         TMPPTB = source pointer (upper boundary)
              ;         TMPPTC = source pointer (lower boundary)

b350 20 a0 b3           JSR Check_Mem_Avail ; may trigger a garbage collection
b353 85 2e              STA STREND
b355 84 2f              STY STREND+1        ; save new top of variables
b357 38                 SEC
b358 a5 57              LDA TMPPTB
b35a e5 5c              SBC TMPPTC
b35c 85 1f              STA INDEXA
b35e a8                 TAY
b35f a5 58              LDA TMPPTB+1
b361 e5 5d              SBC TMPPTC+1
b363 aa                 TAX                 ; Y/X = bytes to move
b364 e8                 INX                 ; pages + 1
b365 98                 TYA
b366 f0 23              BEQ OUS_40          ; no partial page
b368 a5 57              LDA TMPPTB
b36a 38                 SEC
b36b e5 1f              SBC INDEXA
b36d 85 57              STA TMPPTB
b36f b0 03              BCS OUS_10
b371 c6 58              DEC TMPPTB+1        ; TMPPTB = source ptr
b373 38                 SEC
b374 a5 55    OUS_10    LDA TMPPTA
b376 e5 1f              SBC INDEXA
b378 85 55              STA TMPPTA
b37a b0 08              BCS OUS_30
b37c c6 56              DEC TMPPTA+1        ; TMPPTA = target ptr
b37e 90 04              BCC OUS_30          ; branch always
b380 b1 57    OUS_20    LDA (TMPPTB),Y
b382 91 55              STA (TMPPTA),Y
b384 88       OUS_30    DEY
b385 d0 f9              BNE OUS_20
b387 b1 57              LDA (TMPPTB),Y
b389 91 55              STA (TMPPTA),Y
b38b c6 58    OUS_40    DEC TMPPTB+1
b38d c6 56              DEC TMPPTA+1
b38f ca                 DEX
b390 d0 f2              BNE OUS_30
b392 60                 RTS ;Size   67 [Open_Up_Space]

              ; *************************
b393            Check_Stack_Avail ; $b393
              ; *************************

b393 ba                 TSX
b394 e0 20              CPX #$20
b396 90 35              BCC Error_Out_Of_Memory
b398 60                 RTS ;Size    6 [Check_Stack_Avail]

              ; **************
b399            BSOS_Bank_Init
              ; **************

b399 00                 .BYTE 0             ; changed by BSOS loader

b39a 00 00 00           .FILL $b3a0-* (0) ; 6 bytes

              ; ***********************
b3a0            Check_Mem_Avail ; $b3a0
              ; ***********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ; Return if OK
              ; Jump to OOM error if not

b3a0 c4 31              CPY FRETOP+1
b3a2 90 19              BCC CMA_Ret
b3a4 d0 04              BNE CMA_10
b3a6 c5 30              CMP FRETOP
b3a8 90 13              BCC CMA_Ret
b3aa 48       CMA_10    PHA                 ; not enough space
b3ab 98                 TYA                 ; call garbage collectiom
b3ac 48                 PHA
b3ad 20 6a c6           JSR Garbage_Collection
b3b0 68                 PLA
b3b1 a8                 TAY                 ; restore new top high
b3b2 68                 PLA                 ; restore new to low
b3b3 c4 31              CPY FRETOP+1        ; compare again
b3b5 90 06              BCC CMA_Ret
b3b7 d0 14              BNE Error_Out_Of_Memory
b3b9 c5 30              CMP FRETOP
b3bb b0 10              BCS Error_Out_Of_Memory
b3bd 60       CMA_Ret   RTS ;Size   30 [Check_Mem_Avail]

b3be 00 00 00           .FILL $b3cd-* (0) ; 15 bytes

              ; ***************************
b3cd            Error_Out_Of_Memory ; $b3cd
              ; ***************************

b3cd a2 4d              LDX #[Msg_OOM - Msg_Start] ; $4d

              ; *******************
b3cf            Basic_Error ; $b3cf
              ; *******************

              ; Input:  X = Offset from Msg_Start for message

b3cf a5 10              LDA IOPMPT
b3d1 f0 07              BEQ Berr_10
b3d3 20 cc ff           JSR CLRCHN          ; close open channels
b3d6 a9 00              LDA #0
b3d8 85 10              STA IOPMPT
b3da 20 df ba Berr_10   JSR Print_CR
b3dd 20 44 bb           JSR Print_Question_Mark
b3e0 bd 0d b2 Berr_20   LDA Msg_Start,X
b3e3 48                 PHA
b3e4 29 7f              AND #$7f
b3e6 20 d2 ff           JSR CHROUT
b3e9 e8                 INX
b3ea 68                 PLA
b3eb 10 f3              BPL Berr_20
b3ed 20 0e b6 Berr_30   JSR Flush_BASIC_Stack
b3f0 a9 06              LDA #<Msg_ERR
b3f2 a0 b3              LDY #>Msg_ERR
b3f4 20 1d bb Berr_40   JSR Print_String
b3f7 a4 37              LDY CURLIN+1
b3f9 c8                 INY
b3fa f0 03              BEQ Basic_Ready
b3fc 20 78 cf           JSR Print_IN

              ; ********************
b3ff            Basic_Ready ; $ b3ff
              ; ********************

b3ff a9 12              LDA #<Msg_READY
b401 a0 b3              LDY #>Msg_READY
b403 20 1d bb           JSR Print_String

              ; ***************************
b406            Get_Basic_Statement ; $b406
              ; ***************************

b406 20 f2 e9           JSR Read_Power_String
b409 86 77              STX TXTPTR
b40b 84 78              STY TXTPTR+1
b40d 20 70 00           JSR CHRGET
b410 aa                 TAX
b411 f0 f3              BEQ Get_Basic_Statement; empty line
b413 a2 ff              LDX #$ff
b415 86 37              STX CURLIN+1        ; invalidate CURLIN
b417 90 06              BCC New_Basic_Line  ; started with a line number
              ;         JSR Tokenize_Line   ; else direct mode (HOOK FOR WEDGE)
b419 4c 42 f8           JMP Wedge_Parser
b41c 4c 7c b7           JMP Start_Program   ; execute direct mode

              ; **********************
b41f            New_Basic_Line ; $b41f
              ; **********************

              ; This routine uses the addresses $01fc-$01ff for constructing
              ; the link and line number for the line stored in the buffer at $0200
              ; So these bytes are not available for stack operations.
              ; That's why the Flush_Stack routine initializes the stack pointer to $fa.

b41f 20 f6 b8           JSR Scan_Linenumber ; Line number
b422 20 fb b4           JSR Tokenize_Line   ; Crunch line
b425 84 05              STY COUNT           ; new line length (incl. link & number)
b427 20 a3 b5           JSR Find_BASIC_Line ; does this line exist?
b42a 90 44              BCC NBL_30          ; if not -> create a new line
b42c a0 01              LDY #1              ; Y = 1
b42e b1 5c              LDA (TMPPTC),Y      ; link high
b430 85 20              STA INDEXA+1        ; source pointer INDEXA high
b432 a5 2a              LDA VARTAB
b434 85 1f              STA INDEXA          ; source pointer INDEXA low
b436 a5 5d              LDA TMPPTC+1
b438 85 22              STA INDEXB+1        ; target pointer INDEXB high
b43a a5 5c              LDA TMPPTC
b43c 88                 DEY                 ; Y = 0
b43d f1 5c              SBC (TMPPTC),Y      ; negative length of line
b43f 18                 CLC
b440 65 2a              ADC VARTAB          ; subtract line length from VARTAB
b442 85 2a              STA VARTAB          ; by adding the negative length to VARTAB
b444 85 21              STA INDEXB          ; move target pointer INDEXB low
b446 a5 2b              LDA VARTAB+1
b448 69 ff              ADC #$ff
b44a 85 2b              STA VARTAB+1        ; VARTAB -= length of current line
b44c e5 5d              SBC TMPPTC+1
b44e aa                 TAX                 ; pages to move
b44f 38                 SEC
b450 a5 5c              LDA TMPPTC
b452 e5 2a              SBC VARTAB          ; bytes to move
b454 a8                 TAY
b455 b0 03              BCS NBL_10
b457 e8                 INX                 ; increment pages to move
b458 c6 22              DEC INDEXB+1
b45a 18       NBL_10    CLC
b45b 65 1f              ADC INDEXA
b45d 90 03              BCC NBL_20
b45f c6 20              DEC INDEXA+1
b461 18                 CLC
b462 b1 1f    NBL_20    LDA (INDEXA),Y      ; move program code above deleted line
b464 91 21              STA (INDEXB),Y      ; downwards
b466 c8                 INY
b467 d0 f9              BNE NBL_20          ; inner loop moves 1 page
b469 e6 20              INC INDEXA+1
b46b e6 22              INC INDEXB+1
b46d ca                 DEX                 ; pages to move
b46e d0 f2              BNE NBL_20
b470 20 e9 b5 NBL_30    JSR Reset_BASIC_Execution
b473 20 b6 b4           JSR Rechain
b476 ad 00 02           LDA BUF
b479 f0 8b              BEQ Get_Basic_Statement
b47b 18                 CLC
b47c a5 2a              LDA VARTAB
b47e 85 57              STA TMPPTB
b480 65 05              ADC COUNT
b482 85 55              STA TMPPTA
b484 a4 2b              LDY VARTAB+1
b486 84 58              STY TMPPTB+1
b488 90 01              BCC NBL_40
b48a c8                 INY
b48b 84 56    NBL_40    STY TMPPTA+1
b48d 20 50 b3           JSR Open_Up_Space
b490 a5 11              LDA LINNUM
b492 a4 12              LDY LINNUM+1
b494 8d fe 01           STA BUF-2
b497 8c ff 01           STY BUF-1
b49a a5 2e              LDA STREND
b49c a4 2f              LDY STREND+1
b49e 85 2a              STA VARTAB
b4a0 84 2b              STY VARTAB+1
b4a2 a4 05              LDY COUNT
b4a4 88                 DEY
b4a5 b9 fc 01 NBL_50    LDA BUF-4,Y         ; copy buffer to program
b4a8 91 5c              STA (TMPPTC),Y
b4aa 88                 DEY
b4ab 10 f8              BPL NBL_50

              ; *************************
b4ad            Reset_And_Rechain ; $b4ad
              ; *************************

b4ad 20 e9 b5           JSR Reset_BASIC_Execution
b4b0 20 b6 b4           JSR Rechain
b4b3 4c 06 b4           JMP Get_Basic_Statement

              ; ***************
b4b6            Rechain ; $b4b6
              ; ***************

b4b6 a6 28              LDX TXTTAB
b4b8 a5 29              LDA TXTTAB+1
b4ba a0 01              LDY #1
b4bc d0 16              BNE Rech_30
b4be a0 04    Rech_10   LDY #4
b4c0 c8       Rech_20   INY
b4c1 b1 1f              LDA (INDEXA),Y
b4c3 d0 fb              BNE Rech_20         ; scan for 0
b4c5 98                 TYA
b4c6 38                 SEC                 ; + 1
b4c7 65 1f              ADC INDEXA
b4c9 aa                 TAX                 ; X = new address low
b4ca a0 00              LDY #0
b4cc 91 1f              STA (INDEXA),Y      ; store link low
b4ce 98                 TYA                 ; A = 0
b4cf 65 20              ADC INDEXA+1        ; A = new address high
b4d1 c8                 INY                 ; Y = 1
b4d2 91 1f              STA (INDEXA),Y      ; store link high
b4d4 86 1f    Rech_30   STX INDEXA
b4d6 85 20              STA INDEXA+1
b4d8 b1 1f              LDA (INDEXA),Y      ; link high
b4da d0 e2              BNE Rech_10         ; more lines
b4dc 60                 RTS ;Size   39 [Rechain]

b4dd 00 00 00           .FILL $b4e2-* (0) ; 5 bytes

              ; *******************
b4e2            Read_String ; $b4e2
              ; *******************

b4e2 a2 00              LDX #0
b4e4 20 cf ff ReaS_10   JSR CHRIN
b4e7 c9 0d              CMP #CR
b4e9 f0 0d              BEQ ReaS_20
b4eb 9d 00 02           STA BUF,X
b4ee e8                 INX
b4ef e0 51              CPX #81
b4f1 90 f1              BCC ReaS_10
b4f3 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
b4f5 4c cf b3           JMP Basic_Error
b4f8 4c d2 ba ReaS_20   JMP Terminate_BUF

              ; *********************
b4fb            Tokenize_Line ; $b4fb
              ; *********************

b4fb a6 77              LDX TXTPTR
b4fd a0 04              LDY #4
b4ff 84 09              STY GARBFL          ; clear bits 7-4
b501 bd 00 02 ToLi_01   LDA BUF,X           ; get next char
b504 10 07              BPL ToLi_02         ; normal char
b506 c9 ff              CMP #$ff            ; Pi ?
b508 f0 4a              BEQ ToLi_08         ; treat Pi as normal char
b50a e8                 INX                 ; no action on this char
b50b d0 f4              BNE ToLi_01         ; next one
b50d c9 20    ToLi_02   CMP #' '            ; no action on blank
b50f f0 43              BEQ ToLi_08
b511 85 04              STA ENDCHR          ; save char
b513 c9 22              CMP #$22            ; quote ?
b515 f0 62              BEQ ToLi_12         ; handle string
b517 24 09              BIT GARBFL
b519 70 39              BVS ToLi_08
b51b c9 3f              CMP #'?'            ; short for print
b51d d0 04              BNE ToLi_03
b51f a9 99              LDA #$99            ; PRINT token
b521 d0 31              BNE ToLi_08
b523 c9 30    ToLi_03   CMP #'0'
b525 90 04              BCC ToLi_04         ; is symbol
b527 c9 3c              CMP #$3c            ; '<'
b529 90 29              BCC ToLi_08
b52b 84 6e    ToLi_04   STY TMPPTD          ; save Y
b52d a0 00              LDY #0
b52f 84 05              STY COUNT           ; keyword count
b531 86 77              STX TXTPTR          ; update pointer
b533 a9 b0              LDA #>Basic_Keyword_Table
b535 85 20              STA INDEXA+1
b537 a9 b2              LDA #<Basic_Keyword_Table
b539 85 1f              STA INDEXA
b53b d0 07              BNE ToLi_06         ; branch always
b53d e8       ToLi_05   INX                 ; inc buffer  pointer X
b53e e6 1f              INC INDEXA          ; inc keyword pointer INDEXA
b540 d0 02              BNE ToLi_06
b542 e6 20              INC INDEXA+1
b544 bd 00 02 ToLi_06   LDA BUF,X           ; char - keyword char
b547 38                 SEC
b548 f1 1f              SBC (INDEXA),Y
b54a f0 f1              BEQ ToLi_05         ; match, continue with next char
b54c c9 80              CMP #$80            ; match with difference $80 -> found
b54e d0 30              BNE ToLi_13
b550 05 05              ORA COUNT           ; token = $80 | count
b552 a4 6e    ToLi_07   LDY TMPPTD          ; restore Y (started with 4)
b554 e8       ToLi_08   INX                 ; point to char after parsed word
b555 c8                 INY                 ; point to token insert position - 5
b556 99 fb 01           STA BUF-5,Y         ; insert token at start of word
b559 b9 fb 01           LDA BUF-5,Y         ; reload to set flags
b55c f0 3b              BEQ ToLi_16         ; zero -> end of line
b55e 38                 SEC
b55f e9 3a              SBC #':'            ; colon ?
b561 f0 04              BEQ ToLi_09         ; branch on colon
b563 c9 49              CMP #$49            ; DATA token ? ($83 = $3a + $49)
b565 d0 02              BNE ToLi_10
b567 85 09    ToLi_09   STA GARBFL          ; store colon or $49 for DATA
b569 38       ToLi_10   SEC
b56a e9 55              SBC #$55            ; REM token ? ($8f = $3a + $55)
b56c d0 93              BNE ToLi_01         ; no special tokens -> continue parse
b56e 85 04              STA ENDCHR          ; store REM marker in ENDCHR
b570 bd 00 02 ToLi_11   LDA BUF,X
b573 f0 df              BEQ ToLi_08         ; end of parsed text
b575 c5 04              CMP ENDCHR
b577 f0 db              BEQ ToLi_08         ; end of copied text
b579 c8       ToLi_12   INY                 ; copy text in quotes or after REM or DATA
b57a 99 fb 01           STA BUF-5,Y
b57d e8                 INX
b57e d0 f0              BNE ToLi_11         ; continue copy
b580 a6 77    ToLi_13   LDX TXTPTR          ; found keyword match
b582 e6 05              INC COUNT           ; set count to next token
b584 b1 1f    ToLi_14   LDA (INDEXA),Y      ;
b586 08                 PHP                 ; save flags
b587 e6 1f              INC INDEXA          ; let INDEXA point to next token
b589 d0 02              BNE ToLi_15
b58b e6 20              INC INDEXA+1
b58d 28       ToLi_15   PLP                 ; restore flags
b58e 10 f4              BPL ToLi_14         ; true if not single character keyword
b590 b1 1f              LDA (INDEXA),Y      ; load 1st. char of next token keyword
b592 d0 b0              BNE ToLi_06         ; jump if not at end of table
b594 bd 00 02           LDA BUF,X           ; reread parse char
b597 10 b9              BPL ToLi_07         ; start searching from start of table
b599 99 fd 01 ToLi_16   STA BUF-3,Y         ; end of parse, store zeroes at end of line
b59c c6 78              DEC TXTPTR+1        ; set TXTPTR to BUF-1
b59e a9 ff              LDA #$ff
b5a0 85 77              STA TXTPTR
b5a2 60                 RTS ;Size  168 [Tokenize_Line]

              ; ***********************
b5a3            Find_BASIC_Line ; $b5a3
              ; ***********************

b5a3 a5 28              LDA TXTTAB
b5a5 a6 29              LDX TXTTAB+1

              ; **************************
b5a7            Find_BASIC_Line_AX ; $b5a7
              ; **************************

b5a7 a0 01              LDY #1
b5a9 85 5c              STA TMPPTC
b5ab 86 5d              STX TMPPTC+1
b5ad b1 5c              LDA (TMPPTC),Y      ; link high
b5af f0 1a              BEQ FBL_30          ; branch on EOP
b5b1 aa                 TAX                 ; X = link high
b5b2 a0 03              LDY #3
b5b4 a5 12              LDA LINNUM+1
b5b6 d1 5c              CMP (TMPPTC),Y
b5b8 90 12              BCC FBL_Ret         ; branch if beyond
b5ba d0 09              BNE FBL_10
b5bc 88                 DEY                 ; Y = 2
b5bd a5 11              LDA LINNUM
b5bf d1 5c              CMP (TMPPTC),Y
b5c1 f0 09              BEQ FBL_Ret         ; (C=1) found
b5c3 90 07              BCC FBL_Ret         ; (C=0) not found
b5c5 a0 00    FBL_10    LDY #0
b5c7 b1 5c              LDA (TMPPTC),Y      ; Link low
b5c9 b0 dc              BCS Find_BASIC_Line_AX  ; branch always
b5cb 18       FBL_30    CLC                 ; Carry clear = not found
b5cc 60       FBL_Ret   RTS ;Size   38 [Find_BASIC_Line_AX]

b5cd 00 00 00           .FILL $b5d2-* (0) ; 5 bytes

              ; *****************
b5d2            Basic_NEW ; $b5d2
              ; *****************

b5d2 d0 f8              BNE FBL_Ret         ; return if NEW is not a single statement

              ; ***********
b5d4            Perform_NEW
              ; ***********

b5d4 a9 00              LDA #0
b5d6 a8                 TAY
b5d7 91 28              STA (TXTTAB),Y      ; zero link
b5d9 c8                 INY
b5da 91 28              STA (TXTTAB),Y
b5dc a5 28              LDA TXTTAB
b5de 18                 CLC
b5df 69 02              ADC #2
b5e1 85 2a              STA VARTAB          ; VARTAB = TXTTAB + 2
b5e3 a5 29              LDA TXTTAB+1
b5e5 69 00              ADC #0
b5e7 85 2b              STA VARTAB+1

              ; *********************
b5e9            Reset_BASIC_Execution
              ; *********************

b5e9 20 22 b6           JSR Reset_BASIC_Exec_Pointer
b5ec a9 00              LDA #0              ; set for next condition

              ; *********
b5ee            Basic_CLR
              ; *********

b5ee d0 31              BNE FBS_Ret         ; return if not single statement

              ; **********************
b5f0            Reset_Variable_Pointer
              ; **********************

b5f0 a5 34              LDA MEMSIZ
b5f2 a4 35              LDY MEMSIZ+1
b5f4 85 30              STA FRETOP
b5f6 84 31              STY FRETOP+1
b5f8 ea                 NOP
b5f9 ea                 NOP
b5fa ea                 NOP
b5fb ea                 NOP
b5fc 20 e7 ff           JSR CLALL
b5ff a5 2a              LDA VARTAB
b601 a4 2b              LDY VARTAB+1
b603 85 2c              STA ARYTAB
b605 84 2d              STY ARYTAB+1
b607 85 2e              STA STREND
b609 84 2f              STY STREND+1
b60b 20 b7 b7 RVP_10    JSR Basic_RESTORE

              ; *************************
b60e            Flush_BASIC_Stack ; $b60e
              ; *************************

b60e a2 16              LDX #TEMPST         ; clear string descriptor stack
b610 86 13              STX TEMPPT
b612 68                 PLA
b613 a8                 TAY
b614 68                 PLA
b615 a2 fa              LDX #$fa            ; reset stackpointer
b617 9a                 TXS
b618 48                 PHA
b619 98                 TYA
b61a 48                 PHA
b61b a9 00              LDA #0
b61d 85 3b              STA OLDTXT+1
b61f 85 0a              STA SUBFLG
b621 60       FBS_Ret   RTS ;Size   20 [Flush_BASIC_Stack]

              ; ************************
b622            Reset_BASIC_Exec_Pointer
              ; ************************

b622 18                 CLC                 ; TXTPTR = TXTTAB - 1
b623 a5 28              LDA TXTTAB
b625 69 ff              ADC #$ff
b627 85 77              STA TXTPTR
b629 a5 29              LDA TXTTAB+1
b62b 69 ff              ADC #$ff
b62d 85 78              STA TXTPTR+1
b62f 60       RBEP_Ret  RTS ;Size   14 [Reset_BASIC_Exec_Pointer]

              ; **********
b630            Basic_LIST
              ; **********

b630 90 06              BCC LIST_10         ; C=0 : number after LIST
b632 f0 04              BEQ LIST_10         ; Z=1 : end of statement
b634 c9 ab              CMP #$ab            ; '-' token
b636 d0 f7              BNE RBEP_Ret        ; -> RTS
b638 20 f6 b8 LIST_10   JSR Scan_Linenumber ; starting line or 0 for non numeric
b63b 20 a3 b5           JSR Find_BASIC_Line ; setup TMPPTC
b63e 20 76 00           JSR CHRGOT          ; last character read
b641 f0 0c              BEQ LIST_15         ; no end line
b643 c9 ab              CMP #$ab            ; '-' token
b645 d0 e8              BNE RBEP_Ret        ; -> RTS
b647 20 70 00           JSR CHRGET
b64a 20 f6 b8           JSR Scan_Linenumber ; read end line
b64d d0 e0              BNE RBEP_Ret        ; more chars after end line -> RTS
b64f 68       LIST_15   PLA                 ; remove return address
b650 68                 PLA
b651 a5 11              LDA LINNUM
b653 05 12              ORA LINNUM+1
b655 d0 02              BNE LIST_20         ; end line != 0 ?
b657 c6 12              DEC LINNUM+1        ; end line  = $ff00 = 65280

              ; loop for line listing

b659 a0 01    LIST_20   LDY #1

              ; check for EOP and STOP

b65b b1 5c              LDA (TMPPTC),Y      ; link address high
b65d f0 27              BEQ LIST_50         ; -> end of program
b65f 20 e1 ff           JSR STOP            ; check STOP key
b662 20 df ba           JSR Print_CR        ; start listing with newline

              ; get line #

b665 c8                 INY                 ; Y=2
b666 b1 5c              LDA (TMPPTC),Y      ; line # lo
b668 aa                 TAX
b669 c8                 INY                 ; Y=3
b66a b1 5c              LDA (TMPPTC),Y      ; line # hi

              ; check for last line to list

b66c c5 12              CMP LINNUM+1        ; compare with end line hi
b66e d0 04              BNE LIST_25         ; not equal
b670 e4 11              CPX LINNUM          ; compare with end line lo
b672 f0 02              BEQ LIST_30         ; match -> print it
b674 b0 10    LIST_25   BCS LIST_50         ; line # > end line


              ; loop for printing characters

b676 20 89 b6 LIST_30   JSR List_Line

              ; follow link

b679 a8       LIST_60   TAY                 ; Y=0
b67a b1 5c              LDA (TMPPTC),Y      ; link low
b67c aa                 TAX
b67d c8                 INY
b67e b1 5c              LDA (TMPPTC),Y      ; link high
b680 86 5c              STX TMPPTC          ; TMPPTC = link
b682 85 5d              STA TMPPTC+1
b684 d0 d3              BNE LIST_20         ; continue with next line

              ; next line if not EOP

b686 4c ff b3 LIST_50   JMP Basic_Ready     ; LIST finished

b689                    .SIZE ;   89 [Basic_LIST]

              ; *********
b689            List_Line
              ; *********

b689 20 83 cf           JSR Print_Integer_XA; print line #
b68c a9 20              LDA #' '            ; print blank after line #
b68e a0 03              LDY #3              ; before basic text

b690 20 46 bb LiLi_08   JSR Print_Char
b693 c9 22              CMP #QUOTE
b695 d0 0c              BNE LiLi_20

              ; print quoted string

b697 c8       LiLi_10   INY
b698 b1 5c              LDA (TMPPTC),Y
b69a f0 3e              BEQ LiLi_Ret
b69c 20 46 bb           JSR Print_Char      ; print it
b69f c9 22              CMP #QUOTE
b6a1 d0 f4              BNE LiLi_10

              ; get next char

b6a3 c8       LiLi_20   INY                 ; Y++
b6a4 b1 5c              LDA (TMPPTC),Y      ; next character
b6a6 f0 32              BEQ LiLi_Ret
b6a8 10 e6              BPL LiLi_08         ; continue printing if not a token
b6aa c9 ff              CMP #$ff            ; is it the special char PI ?
b6ac f0 e2              BEQ LiLi_08         ; yes, print it

              ; print keyword from token

b6ae aa                 TAX
b6af 98                 TYA
b6b0 48                 PHA                 ; save Y
b6b1 a0 b0              LDY #>[Basic_Keyword_Table-1]
b6b3 84 20              STY INDEXA+1
b6b5 a0 b1              LDY #<[Basic_Keyword_Table-1]
b6b7 84 1f              STY INDEXA
b6b9 a0 00              LDY #0
b6bb ca       LiLi_30   DEX                 ; token--
b6bc 10 0c              BPL LiLi_60         ; count down finished
b6be e6 1f    LiLi_40   INC INDEXA          ; increment address to keyword table
b6c0 d0 02              BNE LiLi_50
b6c2 e6 20              INC INDEXA+1
b6c4 b1 1f    LiLi_50   LDA (INDEXA),Y      ; load next keyword char
b6c6 10 f6              BPL LiLi_40         ; -> inside keyword
b6c8 30 f1              BMI LiLi_30         ; -> end of keyword
b6ca c8       LiLi_60   INY
b6cb b1 1f              LDA (INDEXA),Y      ; next char from keyword table
b6cd 48                 PHA
b6ce 29 7f              AND #$7f
b6d0 20 46 bb           JSR Print_Char      ; print it
b6d3 68                 PLA
b6d4 10 f4              BPL LiLi_60
b6d6 68                 PLA
b6d7 a8                 TAY
b6d8 d0 c9              BNE LiLi_20
b6da 60       LiLi_Ret  RTS ;Size   82 [List_Line]

b6db 00 00 00           .FILL $b6de-* (0) ; 3 bytes

              ; *****************
b6de            Basic_FOR ; $b6de
              ; *****************

b6de a9 80              LDA #$80
b6e0 85 0a              STA SUBFLG          ; Inhibit integer index
b6e2 20 30 b9           JSR Basic_LET       ; define index variable
b6e5 20 22 b3           JSR Find_Active_FOR
b6e8 d0 05              BNE FOR_10          ; branch if none
b6ea 8a                 TXA
b6eb 69 0f              ADC #15             ; add 16 (C=1 from Find_Active_FOR)
b6ed aa                 TAX
b6ee 9a                 TXS
b6ef 68       FOR_10    PLA                 ; remove return address
b6f0 68                 PLA                 ; now there is space for 18 bytes
b6f1 20 93 b3           JSR Check_Stack_Avail
b6f4 20 91 b8           JSR Next_Statement  ; search start of loop body
b6f7 18                 CLC
b6f8 98                 TYA                 ; Y = position of delimiter (0 or ':')
b6f9 65 77              ADC TXTPTR          ; loop body low
b6fb 48                 PHA
b6fc a5 78              LDA TXTPTR+1        ; loop body high
b6fe 69 00              ADC #0
b700 48                 PHA
b701 a5 37              LDA CURLIN+1        ; line # high for body
b703 48                 PHA
b704 a5 36              LDA CURLIN          ; line # low  for body
b706 48                 PHA
b707 a9 a4              LDA #$a4            ; TO token
b709 20 f7 be           JSR Need_A
b70c 20 84 bd           JSR Eval_Numeric    ; read end value
b70f a5 63              LDA FAC1SI
b711 09 7f              ORA #$7f
b713 25 5f              AND FAC1M1
b715 85 5f              STA FAC1M1
b717 18                 CLC                 ; push without sign
b718 20 2e be           JSR Push_FAC1       ; push TO value
b71b a9 f2              LDA #<REAL_1
b71d a0 ca              LDY #>REAL_1
b71f 20 d8 cc           JSR Load_FAC1_AY    ; default 1.0 for STEP value
b722 20 76 00           JSR CHRGOT
b725 c9 a9              CMP #$a9            ; STEP token
b727 d0 06              BNE FOR_30
b729 20 70 00           JSR CHRGET
b72c 20 84 bd           JSR Eval_Numeric
b72f 20 61 cd FOR_30    JSR Get_FAC1_Sign
b732 85 63              STA FAC1SI
b734 38                 SEC                 ; push with sign
b735 20 2e be           JSR Push_FAC1       ; push STEP value
b738 a5 47              LDA FORPNT+1
b73a 48                 PHA
b73b a5 46              LDA FORPNT
b73d 48                 PHA
b73e a9 81              LDA #$81
b740 48                 PHA
b741 d0 07              BNE Execute         ; always

b743 00 00 00           .FILL $b74a-* (0) ; 7 bytes

              ; ***************
b74a            Execute ; $b74a
              ; ***************

b74a 20 43 f3           JSR Kernal_STOP
b74d a4 78              LDY TXTPTR+1
b74f c0 02              CPY #2
b751 f0 06              BEQ Exec_10
b753 a5 77              LDA TXTPTR
b755 85 3a              STA OLDTXT          ; save pointer if not direct
b757 84 3b              STY OLDTXT+1
b759 a0 00    Exec_10   LDY #0
b75b b1 77              LDA (TXTPTR),Y
b75d d0 46              BNE Inpr_40         ; branch if not at line end
b75f a0 02              LDY #2
b761 b1 77              LDA (TXTPTR),Y      ; link high
b763 18                 CLC                 ; C=0 : normal end
b764 f0 7c              BEQ END_40          ; end of program -> READY.
b766 c8                 INY                 ; Y = 3
b767 b1 77              LDA (TXTPTR),Y      ; new line # to CURLIN
b769 85 36              STA CURLIN
b76b c8                 INY
b76c b1 77              LDA (TXTPTR),Y
b76e 85 37              STA CURLIN+1
b770 98                 TYA
b771 65 77              ADC TXTPTR          ; TXTPTR = next statement
b773 85 77              STA TXTPTR
b775 90 05              BCC Start_Program
b777 e6 78              INC TXTPTR+1

b779 ea                 NOP
b77a ea                 NOP
b77b ea                 NOP

              ; *********************
b77c            Start_Program ; $b77c
              ; *********************

b77c 20 0f bf           JSR Any_Except_Pi   ; Pi must not start a statement
b77f 20 85 b7           JSR Interpret
b782 4c 4a b7           JMP Execute

              ; *****************
b785            Interpret ; $b785
              ; *****************

              ; Input:  A = first character of new statement
              ;         Flags set from GETCHR

b785 f0 3e              BEQ REST_Ret        ; branch on empty statement
b787 e9 80    Inpr_10   SBC #$80            ; token -> number
b789 90 17              BCC Inpr_30         ; branch to LET if not token
b78b c9 23              CMP #$23            ; $80-$a2 may start a statement
b78d 90 06              BCC Inpr_20         ; use jump table
b78f c9 4b              CMP #$4b            ; $a3-$cb are functions or operators
b791 90 16              BCC Inpr_50
b793 e9 28              SBC #$28            ; BASIC-4 token
b795 0a       Inpr_20   ASL A
b796 a8                 TAY
b797 b9 01 b0           LDA Basic_Statement_Table+1,Y
b79a 48                 PHA
b79b b9 00 b0           LDA Basic_Statement_Table,Y
b79e 48                 PHA
b79f 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
b7a2 4c 30 b9 Inpr_30   JMP Basic_LET       ; start with variable name
b7a5 c9 3a    Inpr_40   CMP #':'
b7a7 f0 d3              BEQ Start_Program
b7a9 4c 00 bf Inpr_50   JMP Syntax_Error

              ; ****************
b7ac            Basic_GO ; $b7ac
              ; ****************

b7ac 20 76 00           JSR CHRGOT          ; execute GO TO command
b7af a9 a4              LDA #$a4            ; TO token
b7b1 20 f7 be           JSR Need_A
b7b4 4c 30 b8           JMP Basic_GOTO

              ; *********************
b7b7            Basic_RESTORE ; $b7b7
              ; *********************

b7b7 38                 SEC                 ; DATPTR = TXTTAB - 1
b7b8 a5 28              LDA TXTTAB
b7ba e9 01              SBC #1
b7bc a4 29              LDY TXTTAB+1
b7be b0 01              BCS REST_10
b7c0 88                 DEY
b7c1 85 3e    REST_10   STA DATPTR
b7c3 84 3f              STY DATPTR+1
b7c5 60       REST_Ret  RTS ;Size   15 [Basic_RESTORE]

              ; ******************
b7c6            Basic_STOP ; $b7c6
              ; ******************

b7c6 b0 01              BCS END_10          ; C=1 : BREAK

              ; ****************
b7c8            Basic_END ; b7c8
              ; ****************

b7c8 18                 CLC                 ; C=0 : READY
b7c9 d0 3c    END_10    BNE CONT_Ret
b7cb a5 77              LDA TXTPTR
b7cd a4 78              LDY TXTPTR+1
b7cf a6 37              LDX CURLIN+1
b7d1 e8                 INX                 ; CURLIN+1 = $ff : undefined
b7d2 f0 0c              BEQ END_30
b7d4 85 3a              STA OLDTXT
b7d6 84 3b              STY OLDTXT+1
b7d8 a5 36    END_20    LDA CURLIN
b7da a4 37              LDY CURLIN+1
b7dc 85 38              STA OLDLIN
b7de 84 39              STY OLDLIN+1
b7e0 68       END_30    PLA
b7e1 68                 PLA
b7e2 a9 1b    END_40    LDA #<Msg_BREAK     ; $b31b
b7e4 a0 b3              LDY #>Msg_BREAK
b7e6 90 03              BCC END_50
b7e8 4c f4 b3           JMP Berr_40
b7eb 4c ff b3 END_50    JMP Basic_Ready

              ; ******************
b7ee            Basic_CONT ; $b7ee
              ; ******************

b7ee d0 17              BNE CONT_Ret
b7f0 a2 db              LDX #$db
b7f2 a4 3b              LDY OLDTXT+1
b7f4 d0 03              BNE CONT_10
b7f6 4c cf b3           JMP Basic_Error
b7f9 a5 3a    CONT_10   LDA OLDTXT
b7fb 85 77              STA TXTPTR
b7fd 84 78              STY TXTPTR+1
b7ff a5 38              LDA OLDLIN
b801 a4 39              LDY OLDLIN+1
b803 85 36              STA CURLIN
b805 84 37              STY CURLIN+1
b807 60       CONT_Ret  RTS ;Size   26 [Basic_CONT]

              ; *****************
b808            Basic_RUN ; $b808
              ; *****************

b808 d0 03              BNE RUN_20          ; branch onheck_Stack_Avail
b80a 4c e9 b5 RUN_10    JMP Reset_BASIC_Execution
b80d 20 f0 b5 RUN_20    JSR Reset_Variable_Pointer
b810 4c 25 b8           JMP GOSUB_10

              ; *******************
b813            Basic_GOSUB ; $b813
              ; *******************

b813 20 93 b3           JSR Check_Stack_Avail
b816 a5 78              LDA TXTPTR+1
b818 48                 PHA
b819 a5 77              LDA TXTPTR
b81b 48                 PHA
b81c a5 37              LDA CURLIN+1
b81e 48                 PHA
b81f a5 36              LDA CURLIN
b821 48                 PHA
b822 a9 8d              LDA #$8d            ; GOSUB token marker
b824 48                 PHA
b825 20 76 00 GOSUB_10  JSR CHRGOT
b828 20 30 b8           JSR Basic_GOTO
b82b 4c 4a b7           JMP Execute

b82e 00 00              .FILL $b830-* (0) ; 2 bytes

              ; ******************
b830            Basic_GOTO ; $b830
              ; ******************

b830 20 f6 b8           JSR Scan_Linenumber ; read LINNUM
b833 20 94 b8           JSR End_Of_Line     ; skip to end of line
b836 a5 37              LDA CURLIN+1
b838 c5 12              CMP LINNUM+1        ; CURLIN >= LINNUM ?
b83a b0 0b              BCS GOTO_10         ; search from start
b83c 98                 TYA                 ; EOL index
b83d 38                 SEC
b83e 65 77              ADC TXTPTR          ; (A/X) = TXTPTR + length + 1 (carry)
b840 a6 78              LDX TXTPTR+1
b842 90 07              BCC GOTO_20
b844 e8                 INX
b845 b0 04              BCS GOTO_20         ; start search from current link
b847 a5 28    GOTO_10   LDA TXTTAB
b849 a6 29              LDX TXTTAB+1
b84b 20 a7 b5 GOTO_20   JSR Find_BASIC_Line_AX
b84e 90 1e              BCC RET_10          ; undefined statement
b850 a5 5c              LDA TMPPTC
b852 e9 01              SBC #1
b854 85 77              STA TXTPTR          ; TXTPTR = TMPPTC - 1
b856 a5 5d              LDA TMPPTC+1
b858 e9 00              SBC #0
b85a 85 78              STA TXTPTR+1
b85c 60       GOTO_Ret  RTS ;Size   45 [Basic_GOTO]

              ; ********************
b85d            Basic_RETURN ; $b85d
              ; ********************

b85d d0 fd              BNE GOTO_Ret        ; no raguments allowed
b85f a9 ff              LDA #$ff
b861 85 47              STA FORPNT+1        ; invalidate FORPNT
b863 20 22 b3           JSR Find_Active_FOR ; remove open loops
b866 9a                 TXS
b867 c9 8d              CMP #$8d            ; GOSUB token marker ?
b869 f0 0b              BEQ RET_30           ; yes -> perform return
b86b a2 16              LDX #[Msg_GOSUB - Msg_Start] ; $16
b86d 2c                 .BYTE $2c           ; skip next instruction
b86e a2 5a    RET_10    LDX #[Msg_UNDEF - Msg_Start] ; $5a
b870 4c cf b3           JMP Basic_Error
b873 4c 00 bf RET_20    JMP Syntax_Error
b876 68       RET_30    PLA                 ; marker
b877 68                 PLA
b878 85 36              STA CURLIN
b87a 68                 PLA
b87b 85 37              STA CURLIN+1
b87d 68                 PLA
b87e 85 77              STA TXTPTR
b880 68                 PLA
b881 85 78              STA TXTPTR+1

              ; ******************
b883            Basic_DATA ; $b883
              ; ******************

b883 20 91 b8           JSR Next_Statement

              ; **********************************
b886            Add_Y_To_Execution_Pointer ; $b886
              ; **********************************

b886 98                 TYA
b887 18                 CLC
b888 65 77              ADC TXTPTR
b88a 85 77              STA TXTPTR
b88c 90 02              BCC AYEP_Ret
b88e e6 78              INC TXTPTR+1
b890 60       AYEP_Ret  RTS ;Size   11 [Add_Y_To_Execution_Pointer]

              ; **********************
b891            Next_Statement ; $b891
              ; **********************

b891 a2 3a              LDX #':'
b893 2c                 .BYTE $2c

              ; *******************
b894            End_Of_Line ; $b894
              ; *******************

b894 a2 00              LDX #0
b896 86 03              STX CHARAC
b898 a0 00              LDY #0
b89a 84 04              STY ENDCHR
b89c a5 04    NeSt_10   LDA ENDCHR
b89e a6 03              LDX CHARAC
b8a0 85 03              STA CHARAC
b8a2 86 04              STX ENDCHR
b8a4 b1 77    NeSt_20   LDA (TXTPTR),Y
b8a6 f0 e8              BEQ AYEP_Ret
b8a8 c5 04              CMP ENDCHR
b8aa f0 e4              BEQ AYEP_Ret
b8ac c8                 INY
b8ad c9 22              CMP #QUOTE          ; Gaensefuesschen oben
b8af d0 f3              BNE NeSt_20
b8b1 f0 e9              BEQ NeSt_10

              ; ****************
b8b3            Basic_IF ; $b8b3
              ; ****************

b8b3 20 98 bd           JSR Eval_Expression
b8b6 20 76 00           JSR CHRGOT
b8b9 c9 89              CMP #$89            ; GOTO token
b8bb f0 05              BEQ IF_10
b8bd a9 a7              LDA #$a7            ; THEN token
b8bf 20 f7 be           JSR Need_A
b8c2 a5 5e    IF_10     LDA FAC1EX          ; IF clause != 0 (true) or 0 (false)
b8c4 d0 05              BNE REM_10          ; branch if true

              ; *****************
b8c6            Basic_REM ; $b8c6
              ; *****************

b8c6 20 94 b8           JSR End_Of_Line
b8c9 f0 bb              BEQ Add_Y_To_Execution_Pointer
b8cb 20 76 00 REM_10    JSR CHRGOT
b8ce b0 03              BCS REM_20
b8d0 4c 30 b8           JMP Basic_GOTO
b8d3 4c 85 b7 REM_20    JMP Interpret

              ; ********
b8d6            Basic_ON
              ; ********

b8d6 20 d4 c8           JSR Get_Byte_Value
b8d9 48                 PHA
b8da c9 8d              CMP #$8d            ; GOSUB token
b8dc f0 04              BEQ ON_20
b8de c9 89    ON_10     CMP #$89            ; GOTO token
b8e0 d0 91              BNE RET_20          ; -> syntax error
b8e2 c6 62    ON_20     DEC FAC1M4          ; ON - counter
b8e4 d0 04              BNE ON_30
b8e6 68                 PLA
b8e7 4c 87 b7           JMP Inpr_10
b8ea 20 70 00 ON_30     JSR CHRGET
b8ed 20 f6 b8           JSR Scan_Linenumber
b8f0 c9 2c              CMP #','
b8f2 f0 ee              BEQ ON_20
b8f4 68                 PLA
b8f5 60                 RTS ;Size   32 [Basic_ON]

              ; ***************
b8f6            Scan_Linenumber
              ; ***************

              ; Input:  A = 1st. character
              ; Output: LINNUM decoded (0-63999) valid range
              ;         LINNUM = 0 if (A) is not numeric (C=1)

b8f6 a2 00              LDX #0
b8f8 86 11              STX LINNUM
b8fa 86 12              STX LINNUM+1
b8fc b0 0e              BCS ScLi_Ret        ; return if (A) is not numeric
b8fe a6 12    ScLi_10   LDX LINNUM+1
b900 e0 19              CPX #25             ; $fa00 after multiplication
b902 b0 da              BCS ON_10           ; value >= 64000 -> Syntax Error
b904 20 0d b9           JSR Dec_Char
b907 20 70 00           JSR CHRGET
b90a 90 f2              BCC ScLi_10         ; next char if numeric
b90c 60       ScLi_Ret  RTS ;Size   23 [Scan_Linenumber]

              ; ********
b90d            Dec_Char
              ; ********

              ; Input:  LINNUM = 16 bit unsigned integer
              ;         A      = new value to add
              ;         X      = LINNUM+1
              ; Output: LINNUM = LINNUM * 10 + (A)

              ; check on integer overflow is done on calling routine

b90d 29 0f              AND #15             ; char -> bin
b90f 48                 PHA                 ; save value to add
b910 a5 11              LDA LINNUM
b912 0a                 ASL A               ; * 2
b913 26 12              ROL LINNUM+1
b915 0a                 ASL A               ; * 4
b916 26 12              ROL LINNUM+1
b918 65 11              ADC LINNUM          ; * 5
b91a 85 11              STA LINNUM
b91c 8a                 TXA                 ; old high byte of LINNUM
b91d 65 12              ADC LINNUM+1
b91f 85 12              STA LINNUM+1
b921 06 11              ASL LINNUM          ; * 10
b923 26 12              ROL LINNUM+1
b925 68                 PLA                 ; value to add
b926 65 11              ADC LINNUM
b928 85 11              STA LINNUM
b92a 90 02              BCC LIM_10
b92c e6 12              INC LINNUM+1
b92e 60       LIM_10    RTS ;Size   34 [Dec_Char]

b92f 00                 .FILL $b930-* (0) ; 1 bytes

              ; *****************
b930            Basic_LET ; $b930
              ; *****************

b930 20 2b c1           JSR Parse_Name
b933 85 46              STA FORPNT
b935 84 47              STY FORPNT+1
b937 a9 b2              LDA #$b2            ; '=' token
b939 20 f7 be           JSR Need_A
b93c a5 08              LDA INTFLG          ; save attributes
b93e 48                 PHA                 ; of variable
b93f a5 07              LDA VALTYP
b941 48                 PHA
b942 20 98 bd           JSR Eval_Expression ; FAC1 = value or pointer
b945 68                 PLA                 ; VALTYP
b946 2a                 ROL A               ; C=1 : string   C=0 : numeric
b947 20 8a bd           JSR Check_Var_Type
b94a d0 18              BNE LET_20          ; branch for string
b94c 68                 PLA                 ; INTFLG

              ; ***********************
b94d            Assign_Numeric_variable
              ; ***********************

b94d 10 12              BPL LET_10          ; branch for real
b94f 20 51 cd           JSR Round_FAC1
b952 20 ea c2           JSR Real_To_Integer
b955 a0 00              LDY #0
b957 a5 61              LDA FAC1M3
b959 91 46              STA (FORPNT),Y      ; integer high byte
b95b c8                 INY
b95c a5 62              LDA FAC1M4
b95e 91 46              STA (FORPNT),Y      ; integer low  byte
b960 60                 RTS ;Size   20 [Assign_Numeric_variable]
b961 4c 06 cd LET_10    JMP FAC1_To_FORPNT

b964 68       LET_20    PLA                 ; INTFLG

              ; ******************************
b965            Assign_String_Variable ; $b965
              ; ******************************

b965 a4 47              LDY FORPNT+1
b967 c0 d0              CPY #>[Float_0_5 + 2]; void string descriptor for TI$
b969 d0 4f              BNE Assign_Normal_String
b96b 20 b8 c7           JSR Free_String_FAC1
b96e c9 06              CMP #6              ; setting TI$ requires 6 digits
b970 d0 40              BNE ATSD_10
b972 a0 00              LDY #0              ; FAC1 = 0.0
b974 84 5e              STY FAC1EX
b976 84 63              STY FAC1SI
b978 84 6e    CLOCK_10  STY TMPPTD
b97a 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b97d 20 18 cc           JSR Multiply_FAC1_BY_10
b980 e6 6e              INC TMPPTD
b982 a4 6e              LDY TMPPTD
b984 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b987 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
b98a aa                 TAX                 ; number is zero ?
b98b f0 05              BEQ CLOCK_20
b98d e8                 INX
b98e 8a                 TXA                 ; FAC2 *= 2
b98f 20 23 cc           JSR Add_And_Double  ; FAC1 = (FAC1 + FAC2) * 2
b992 a4 6e    CLOCK_20  LDY TMPPTD
b994 c8                 INY
b995 c0 06              CPY #6
b997 d0 df              BNE CLOCK_10
b999 20 18 cc           JSR Multiply_FAC1_BY_10
b99c 20 d1 cd           JSR FAC1_LSR
b99f a2 02              LDX #2
b9a1 78                 SEI                 ; set jiffy clock
b9a2 b5 60    CLOCK_30  LDA FAC1M2,X
b9a4 95 8d              STA JIFFY_CLOCK,X
b9a6 ca                 DEX
b9a7 10 f9              BPL CLOCK_30
b9a9 58                 CLI
b9aa 60                 RTS ;Size   70 [Assign_String_Variable]

              ; ***************************
b9ab            Add_TI_String_Digit_To_FAC1
              ; ***************************

b9ab b1 1f              LDA (INDEXA),Y
b9ad 20 7d 00           JSR ISNUM
b9b0 90 03              BCC ATSD_20
b9b2 4c 73 c3 ATSD_10   JMP Jump_To_Illegal_Quantity
b9b5 e9 2f    ATSD_20   SBC #$2f            ; '0'-1
b9b7 4c b4 ce           JMP Add_A_To_FAC1

              ; ****************************
b9ba            Assign_Normal_String ; $b9ba
              ; ****************************

              ; 100 a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to static string in code
              ;     STRPTR = $0409
              ;     -> ANS_60 branch

              ; a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to dynamic string
              ;     STRPTR = $7ffa
              ;     -> ANS_60 branch

              ; a$ = ds$ (disk status)
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 12, pointer to dynamic string
              ;     STRPTR = $7fd6
              ;     -> ANS_50 branch

b9ba a0 01              LDY #1
b9bc b1 61              LDA (FAC1M3),Y
b9be 85 6c              STA STRPTR          ; STRPTR = string pointer
b9c0 c8                 INY
b9c1 b1 61              LDA (FAC1M3),Y
b9c3 85 6d              STA STRPTR+1        ; STRPTR = DS$ (Disk Status) ?
b9c5 c9 04              CMP #4
b9c7 90 23              BCC ANS_50          ; string is in system area (DS$)

b9c9 a5 6d    ANS_10    LDA STRPTR+1        ; STRPTR < FRETOP ?
b9cb c5 31    ANS_20    CMP FRETOP+1
b9cd 90 16              BCC ANS_40          ; branch if static
b9cf d0 06              BNE ANS_30          ; branch if higher
b9d1 a5 6c              LDA STRPTR
b9d3 c5 30              CMP FRETOP
b9d5 90 0e              BCC ANS_40          ; branch if static
b9d7 a4 62    ANS_30    LDY FAC1M4
b9d9 c4 2b              CPY VARTAB+1
b9db 90 08              BCC ANS_40          ; branch if not variable
b9dd d0 0d              BNE ANS_50
b9df a5 61              LDA FAC1M3
b9e1 c5 2a              CMP VARTAB
b9e3 b0 07              BCS ANS_50
b9e5 a5 61    ANS_40    LDA FAC1M3          ; static string
b9e7 a4 62              LDY FAC1M4
b9e9 4c 05 ba           JMP ANS_60

              ; assign string from string variable

b9ec a0 00    ANS_50    LDY #0              ; allocate & copy string
b9ee b1 61              LDA (FAC1M3),Y      ; length
b9f0 20 a6 c5           JSR Allocate_String_A
b9f3 a6 6c              LDX STRPTR
b9f5 a4 6d              LDY STRPTR+1
b9f7 20 9a c7           JSR Store_String_XY
b9fa a5 61              LDA FAC1M3
b9fc a4 62              LDY FAC1M4
b9fe 20 11 c8           JSR Pop_Descriptor_Stack
ba01 a9 5e              LDA #<FAC1EX        ; allocated descriptor
ba03 a0 00              LDY #>FAC1EX

              ; assign static string and create back reference

ba05 85 4d    ANS_60    STA DESCPT
ba07 84 4e              STY DESCPT+1
ba09 85 1f              STA INDEXA
ba0b 84 20              STY INDEXA+1
ba0d 20 11 c8           JSR Pop_Descriptor_Stack
ba10 20 3d ba           JSR Back_Reference_Position   ; from INDEXA
ba13 90 09              BCC ANS_70          ; -> no back reference
ba15 a5 47              LDA FORPNT+1
ba17 91 4f              STA (INDEXC),Y      ; Y = 1
ba19 88                 DEY
ba1a a5 46              LDA FORPNT          ; store back reference
ba1c 91 4f              STA (INDEXC),Y      ; for garbage collection

              ; invalidate old string

ba1e a5 46    ANS_70    LDA FORPNT
ba20 85 1f              STA INDEXA
ba22 a5 47              LDA FORPNT+1
ba24 85 20              STA INDEXA+1
ba26 20 3d ba           JSR Back_Reference_Position
ba29 90 08              BCC ANS_80
ba2b a9 ff              LDA #$ff            ; mark old string as obsolete
ba2d 91 4f              STA (INDEXC),Y      ; Y = 1
ba2f 88                 DEY                 ; Y = 0
ba30 8a                 TXA                 ; length
ba31 91 4f              STA (INDEXC),Y

              ; copy new value to variable

ba33 a0 02    ANS_80    LDY #2
ba35 b1 4d    ANS_90    LDA (DESCPT),Y
ba37 91 46              STA (FORPNT),Y
ba39 88                 DEY
ba3a 10 f9              BPL ANS_90
ba3c 60                 RTS ;Size  131 [Assign_Normal_String]

              ; ***********************
ba3d            Back_Reference_Position
              ; ***********************

              ; Input:  INDEXA = pointer to string descriptor
              ; Output: INDEXA = points to start of string
              ;         INDEXC = points to the end of string + 1
              ;         X = length of string
              ;         Y = 1
              ;         C = 1 : INDEXA and INDEXC set
              ;         C = 0 : nothing changed

ba3d a0 00              LDY #0
ba3f b1 1f              LDA (INDEXA),Y      ; A = length
ba41 48                 PHA                 ; push length
ba42 f0 28              BEQ BRP_no
ba44 c8                 INY
ba45 b1 1f              LDA (INDEXA),Y
ba47 aa                 TAX                 ; X = pointer low
ba48 c8                 INY
ba49 b1 1f              LDA (INDEXA),Y      ; A = pointer high
ba4b 30 1f              BMI BRP_no          ; return if not in lower RAM
ba4d c5 31              CMP FRETOP+1
ba4f 90 1b              BCC BRP_no          ; return if not dynamic string
ba51 d0 04              BNE BRP_10
ba53 e4 30              CPX FRETOP
ba55 90 15              BCC BRP_no          ; return if not dynamic string
ba57 86 1f    BRP_10    STX INDEXA          ; INDEXA = string pointer
ba59 85 20              STA INDEXA+1
ba5b 68                 PLA                 ; length
ba5c aa                 TAX                 ; return length in X
ba5d 18                 CLC
ba5e 65 1f              ADC INDEXA
ba60 85 4f              STA INDEXC
ba62 a5 20              LDA INDEXA+1
ba64 69 00              ADC #0
ba66 85 50              STA INDEXC+1        ; INDEXC = INDEXA + length
ba68 a0 01              LDY #1              ; expected by callers
ba6a 38                 SEC
ba6b 60                 RTS ;Size   47 [Back_Reference_Position]
ba6c 68       BRP_no    PLA
ba6d 18                 CLC
ba6e 60                 RTS ;Size   50 [Back_Reference_Position]

              ; This subroutines converts a real value to a 16 bit integer.
              ; There is no sign or range check in this routine. So it may
              ; be used for signed integers (-32768 to 32767) or unsigned
              ; integers (0 to 65535).

              ; ********
ba6f            FAC1_INT
              ; ********

ba6f 20 d1 cd           JSR FAC1_LSR
ba72 24 63              BIT FAC1SI
ba74 10 0b              BPL FACI_Ret
ba76 38                 SEC
ba77 98                 TYA
ba78 e5 62              SBC FAC1M4
ba7a 85 62              STA FAC1M4
ba7c 98                 TYA
ba7d e5 61              SBC FAC1M3
ba7f 85 61              STA FAC1M3
ba81 60       FACI_Ret  RTS ;Size   19 [FAC1_INT]

ba82 00 00 00           .FILL $ba88-* (0) ; 6 bytes

              ; ********************
ba88            Basic_PRINTN ; $ba88
              ; ********************

ba88 20 8e ba           JSR Basic_CMD
ba8b 4c b2 bb           JMP Set_Default_Channels

              ; *********
ba8e            Basic_CMD
              ; *********

ba8e 20 d4 c8           JSR Get_Byte_Value  ; X = value
ba91 f0 05              BEQ CMD_10          ; -> no more parameter
ba93 a9 2c              LDA #','
ba95 20 f7 be           JSR Need_A
ba98 08       CMD_10    PHP
ba99 20 c9 ff           JSR CHKOUT          ; set channel
ba9c 86 10              STX IOPMPT          ; mark output redirected
ba9e 28                 PLP
ba9f 4c a8 ba           JMP Basic_PRINT     ; do the printing


baa2 20 20 bb PRINT_10  JSR Print_String_From_Descriptor
baa5 20 76 00 PRINT_20  JSR CHRGOT

              ; ***********
baa8            Basic_PRINT
              ; ***********

baa8 f0 35              BEQ Print_CR
baaa f0 38    PRINT_30  BEQ PRINT_Ret
baac c9 a3              CMP #$a3            ; TAB(   token
baae f0 4d              BEQ Tab_Spc
bab0 c9 a6              CMP #$a6            ; SPC(   token
bab2 18                 CLC
bab3 f0 48              BEQ Tab_Spc
bab5 c9 2c              CMP #','
bab7 f0 37              BEQ Comma_Tab
bab9 c9 3b              CMP #';'
babb f0 5a              BEQ TaSp_50
babd 20 98 bd           JSR Eval_Expression
bac0 24 07              BIT VALTYP
bac2 30 de              BMI PRINT_10
bac4 20 93 cf           JSR Format_FAC1
bac7 20 b0 c5           JSR Create_String_Descriptor
baca 20 20 bb           JSR Print_String_From_Descriptor
bacd 20 3a bb           JSR Cursor_Right_Or_Space
bad0 d0 d3              BNE PRINT_20           ; always

              ; *************
bad2            Terminate_BUF
              ; *************

bad2 a9 00              LDA #0
bad4 9d 00 02           STA BUF,X
bad7 a2 ff              LDX #<[BUF-1]
bad9 a0 01              LDY #>[BUF-1]
badb a5 10              LDA IOPMPT
badd d0 05              BNE PRINT_Ret

              ; ****************
badf            Print_CR ; $badf
              ; ****************

badf a9 0d              LDA #CR
bae1 4c d2 ff           JMP CHROUT
bae4 60       PRINT_Ret RTS ;Size    6 [Print_CR]

bae5 00 00 00           .FILL $baf0-* (0) ; 11 bytes

              ; *****************
baf0            Comma_Tab ; $baf0
              ; *****************

baf0 a5 c6              LDA CursorCol
baf2 38                 SEC
baf3 e9 0a    CoTa_10   SBC #10
baf5 b0 fc              BCS CoTa_10
baf7 49 ff              EOR #$ff
baf9 69 01              ADC #1
bafb d0 10              BNE TaSp_10           ; always

              ; *******
bafd            Tab_Spc
              ; *******

bafd 08                 PHP                 ; C=1 TAB, C=0 SPC
bafe 20 d1 c8           JSR Get_Next_Byte_Value
bb01 c9 29              CMP #')'
bb03 d0 59              BNE SynErr
bb05 28                 PLP
bb06 90 06              BCC TaSp_20         ; SPC -> use X
bb08 8a                 TXA
bb09 e5 c6              SBC CursorCol       ; TAB -> use X - Col
bb0b 90 0a              BCC TaSp_50         ; branch if TAB < Col
bb0d aa       TaSp_10   TAX
bb0e e8       TaSp_20   INX
bb0f d0 03              BNE TaSp_40         ; always
bb11 20 3a bb TaSp_30   JSR Cursor_Right_Or_Space
bb14 ca       TaSp_40   DEX
bb15 d0 fa              BNE TaSp_30
bb17 20 70 00 TaSp_50   JSR CHRGET
bb1a 4c aa ba           JMP PRINT_30

              ; ********************
bb1d            Print_String ; $bb1d
              ; ********************

bb1d 20 b0 c5           JSR Create_String_Descriptor

              ; ************************************
bb20            Print_String_From_Descriptor ; $bb20
              ; ************************************

bb20 20 b8 c7           JSR Free_String_FAC1
bb23 aa                 TAX
bb24 f0 0b              BEQ PSFD_Ret        ; zero length ?
bb26 a0 00              LDY #0
bb28 b1 1f    PSFD_10   LDA (INDEXA),Y
bb2a 20 d2 ff           JSR CHROUT
bb2d c8                 INY
bb2e ca                 DEX
bb2f d0 f7              BNE PSFD_10
bb31 60       PSFD_Ret  RTS ;Size   18 [Print_String_From_Descriptor]

bb32 00 00 00           .FILL $bb3a-* (0) ; 8 bytes

              ; *****************************
bb3a            Cursor_Right_Or_Space ; $bb3a
              ; *****************************

bb3a a5 10              LDA IOPMPT
bb3c f0 03              BEQ CROS_10
bb3e a9 20              LDA #' '
bb40 2c                 .BYTE $2c
bb41 a9 1d    CROS_10   LDA #RIGHT
bb43 2c                 .BYTE $2c

              ; *******************
bb44            Print_Question_Mark
              ; *******************

bb44 a9 3f              LDA #'?'

              ; **********
bb46            Print_Char
              ; **********

bb46 4c d2 ff           JMP CHROUT

bb49 00 00 00           .FILL $bb4c-* (0) ; 3 bytes

              ; *****************
bb4c            Bad_Input ; $bb4c
              ; *****************

bb4c a5 0b              LDA INPFLG
bb4e f0 11              BEQ BaIn_30
bb50 30 04              BMI BaIn_10
bb52 a0 ff              LDY #$ff            ; invalidate CURLIN
bb54 d0 04              BNE BaIn_20
bb56 a5 3c    BaIn_10   LDA DATLIN
bb58 a4 3d              LDY DATLIN+1
bb5a 85 36    BaIn_20   STA CURLIN
bb5c 84 37              STY CURLIN+1
bb5e 4c 00 bf SynErr    JMP Syntax_Error
bb61 a5 10    BaIn_30   LDA IOPMPT
bb63 f0 05              BEQ BaIn_40
bb65 a2 bf              LDX #[Msg_DATA - Msg_Start] ; $bf
bb67 4c cf b3           JMP Basic_Error
bb6a a9 07    BaIn_40   LDA #<Msg_Redo_From_Start
bb6c a0 bd              LDY #>Msg_Redo_From_Start
bb6e 20 1d bb           JSR Print_String
bb71 a5 3a              LDA OLDTXT
bb73 a4 3b              LDY OLDTXT+1
bb75 85 77              STA TXTPTR
bb77 84 78              STY TXTPTR+1
bb79 60                 RTS ;Size   46 [Bad_Input]

              ; *****************
bb7a            Basic_GET ; $bb7a
              ; *****************

bb7a 20 cf c4           JSR Assert_Non_Direct
bb7d c9 23              CMP #'#'
bb7f d0 0e              BNE GET_10
bb81 20 70 00           JSR CHRGET
bb84 20 d4 c8           JSR Get_Byte_Value  ; channel #
bb87 20 f5 be           JSR Need_Comma
bb8a 20 c6 ff           JSR CHKIN
bb8d 86 10              STX IOPMPT
bb8f a2 01    GET_10    LDX #<[BUF+1]
bb91 a0 02              LDY #>[BUF+1]
bb93 a9 00              LDA #0
bb95 8d 01 02           STA BUF+1
bb98 a9 40              LDA #$40            ; no prompt
bb9a 20 0b bc           JSR Read_Get
bb9d a6 10              LDX IOPMPT
bb9f d0 13              BNE SDC_10
bba1 60                 RTS ;Size   40 [Basic_GET]

bba2 00 00              .FILL $bba4-* (0) ; 2 bytes

              ; ********************
bba4            Basic_INPUTN ; $bba4
              ; ********************

bba4 20 d4 c8           JSR Get_Byte_Value
bba7 20 f5 be           JSR Need_Comma
bbaa 20 c6 ff           JSR CHKIN
bbad 86 10              STX IOPMPT
bbaf 20 cd bb           JSR Input_String

              ; ********************
bbb2            Set_Default_Channels
              ; ********************

bbb2 a5 10              LDA IOPMPT
bbb4 20 cc ff SDC_10    JSR CLRCHN
bbb7 a2 00              LDX #0
bbb9 86 10              STX IOPMPT
bbbb 60                 RTS ;Size   10 [Set_Default_Channels]

bbbc 00 00              .FILL $bbbe-* (0) ; 2 bytes

              ; *******************
bbbe            Basic_INPUT ; $bbbe
              ; *******************

bbbe c9 22              CMP #QUOTE
bbc0 d0 0b              BNE Input_String
bbc2 20 b5 be           JSR Make_String_Descriptor_From_Code
bbc5 a9 3b              LDA #';'
bbc7 20 f7 be           JSR Need_A          ; prompt delimiter
bbca 20 20 bb           JSR Print_String_From_Descriptor

              ; ************
bbcd            Input_String
              ; ************

bbcd 20 cf c4           JSR Assert_Non_Direct
bbd0 a9 2c              LDA #','
bbd2 8d ff 01           STA BUF-1
bbd5 20 f5 bb InSt_10   JSR Prompt_And_Input
bbd8 a5 10              LDA IOPMPT
bbda f0 0c              BEQ InSt_20
bbdc a5 96              LDA STATUS
bbde 29 03              AND #3              ; check time out bits
bbe0 f0 06              BEQ InSt_20
bbe2 20 b2 bb           JSR Set_Default_Channels
bbe5 4c 83 b8           JMP Basic_DATA
bbe8 ad 00 02 InSt_20   LDA BUF
bbeb d0 1c              BNE READ_10
bbed 4c 19 bf           JMP Input_String_Patch
bbf0 18       InSt_30   CLC
bbf1 4c d8 b7           JMP END_20

bbf4 00                 .FILL $bbf5-* (0) ; 1 bytes

              ; ************************
bbf5            Prompt_And_Input ; $bbf5
              ; ************************

bbf5 a5 10              LDA IOPMPT
bbf7 d0 06              BNE PAI_10
bbf9 20 44 bb           JSR Print_Question_Mark
bbfc 20 3a bb           JSR Cursor_Right_Or_Space
bbff 4c e2 b4 PAI_10    JMP Read_String

              ; ******************
bc02            Basic_READ ; $bc02
              ; ******************

bc02 a6 3e              LDX DATPTR
bc04 a4 3f              LDY DATPTR+1
bc06 a9 98              LDA #$98            ; flag for READ
bc08 2c                 .BYTE $2c
bc09 a9 00    READ_10    LDA #0

              ; ********
bc0b            Read_Get
              ; ********

bc0b 85 0b              STA INPFLG
bc0d 86 40              STX INPPTR
bc0f 84 41              STY INPPTR+1

              ; loop reading variables

bc11 20 2b c1 READ_15   JSR Parse_Name      ; address of variable
bc14 85 46              STA FORPNT
bc16 84 47              STY FORPNT+1        ; FORPNT = variable pointer
bc18 a5 77              LDA TXTPTR
bc1a a4 78              LDY TXTPTR+1        ; save TXTPTR
bc1c 85 48              STA YSAVE
bc1e 84 49              STY YSAVE+1
bc20 a6 40              LDX INPPTR          ; TXTPTR = INPPTR
bc22 a4 41              LDY INPPTR+1
bc24 86 77              STX TXTPTR
bc26 84 78              STY TXTPTR+1
bc28 20 76 00           JSR CHRGOT
bc2b d0 20              BNE READ_35
bc2d 24 0b              BIT INPFLG
bc2f 50 0c              BVC READ_20         ; bit 6 set: GETIN
bc31 20 e4 ff           JSR GETIN
bc34 8d 00 02           STA BUF
bc37 a2 ff              LDX #<[BUF-1]
bc39 a0 01              LDY #>[BUF-1]
bc3b d0 0c              BNE READ_30         ; always

bc3d 30 75    READ_20   BMI READ_75         ; bit 7 set: READ
bc3f a5 10              LDA IOPMPT          ; else: INPUT
bc41 d0 03              BNE READ_25
bc43 20 44 bb           JSR Print_Question_Mark
bc46 20 f5 bb READ_25   JSR Prompt_And_Input
bc49 86 77    READ_30   STX TXTPTR
bc4b 84 78              STY TXTPTR+1

              ; loop reading character

bc4d 20 70 00 READ_35   JSR CHRGET
bc50 24 07              BIT VALTYP
bc52 10 31              BPL READ_60         ; -> numeric
bc54 24 0b              BIT INPFLG
bc56 50 09              BVC READ_40         ; -> not GET
bc58 e8                 INX
bc59 86 77              STX TXTPTR          ; GET A$
bc5b a9 00              LDA #0
bc5d 85 03              STA CHARAC
bc5f f0 0c              BEQ READ_45         ; always

              ; input or read string

bc61 85 03    READ_40   STA CHARAC
bc63 c9 22              CMP #QUOTE
bc65 f0 07              BEQ READ_50
bc67 a9 3a              LDA #':'
bc69 85 03              STA CHARAC
bc6b a9 2c              LDA #','
bc6d 18       READ_45   CLC
bc6e 85 04    READ_50   STA ENDCHR
bc70 a5 77              LDA TXTPTR
bc72 a4 78              LDY TXTPTR+1
bc74 69 00              ADC #0
bc76 90 01              BCC READ_55
bc78 c8                 INY
bc79 20 b6 c5 READ_55   JSR Create_String_Descriptor_AY
bc7c 20 18 c9           JSR Restore_Execution_Pointer
bc7f 20 65 b9           JSR Assign_String_Variable
bc82 4c 8d bc           JMP READ_65

              ; input or read number

bc85 20 29 ce READ_60   JSR Read_Real_To_FAC1
bc88 a5 08              LDA INTFLG
bc8a 20 4d b9           JSR Assign_Numeric_variable

              ; more to read ?

bc8d 20 76 00 READ_65   JSR CHRGOT
bc90 f0 07              BEQ READ_70         ; -> nothing left
bc92 c9 2c              CMP #','
bc94 f0 03              BEQ READ_70         ; comma or error
bc96 4c 4c bb           JMP Bad_Input

bc99 a5 77    READ_70   LDA TXTPTR
bc9b a4 78              LDY TXTPTR+1
bc9d 85 40              STA INPPTR          ; advance input pointer
bc9f 84 41              STY INPPTR+1
bca1 a5 48              LDA YSAVE
bca3 a4 49              LDY YSAVE+1
bca5 85 77              STA TXTPTR          ; restore text pointer
bca7 84 78              STY TXTPTR+1
bca9 20 76 00           JSR CHRGOT
bcac f0 2c              BEQ READ_85         ; -> goto loop end
bcae 20 f5 be           JSR Need_Comma
bcb1 4c 11 bc           JMP READ_15         ; -> next item

              ; READ from DATA statements

bcb4 20 91 b8 READ_75   JSR Next_Statement
bcb7 c8                 INY
bcb8 aa                 TAX
bcb9 d0 12              BNE READ_80
bcbb a2 2a              LDX #$2a
bcbd c8                 INY
bcbe b1 77              LDA (TXTPTR),Y
bcc0 f0 6b              BEQ NEXT_30
bcc2 c8                 INY
bcc3 b1 77              LDA (TXTPTR),Y
bcc5 85 3c              STA DATLIN
bcc7 c8                 INY
bcc8 b1 77              LDA (TXTPTR),Y
bcca c8                 INY
bccb 85 3d              STA DATLIN+1
bccd b1 77    READ_80   LDA (TXTPTR),Y
bccf aa                 TAX
bcd0 20 86 b8           JSR Add_Y_To_Execution_Pointer
bcd3 e0 83              CPX #$83            ; DATA token
bcd5 d0 dd              BNE READ_75
bcd7 4c 4d bc           JMP READ_35
              ;

bcda a5 40    READ_85   LDA INPPTR
bcdc a4 41              LDY INPPTR+1
bcde a6 0b              LDX INPFLG
bce0 10 03              BPL READ_90
bce2 4c c1 b7           JMP REST_10
bce5 a0 00    READ_90   LDY #0
bce7 b1 40              LDA (INPPTR),Y
bce9 f0 0b              BEQ READ_Ret
bceb a5 10              LDA IOPMPT
bced d0 07              BNE READ_Ret
bcef a9 f7              LDA #<Msg_Extra_Ignored
bcf1 a0 bc              LDY #>Msg_Extra_Ignored
bcf3 4c 1d bb           JMP Print_String
bcf6 60       READ_Ret  RTS ;Size  236 [Read_Get]

bcf7                    .FILL $bcf7-* (0) ; 0 bytes

              ; *************************
bcf7            Msg_Extra_Ignored ; $bcf7
              ; *************************

bcf7 3f 45 58           .BYTE "?EXTRA IGNORED\r",0

              ; *******************
bd07            Msg_Redo_From_Start
              ; *******************

bd07 3f 52 45           .BYTE "?REDO FROM START\r",0

              ; ******************
bd19            Basic_NEXT ; $bd19
              ; ******************

bd19 d0 04              BNE NEXT_10         ; branch if index after NEXT
bd1b a0 00              LDY #0
bd1d f0 05              BEQ NEXT_20
bd1f 20 2b c1 NEXT_10   JSR Parse_Name      ; address of index
bd22 85 46              STA FORPNT
bd24 84 47    NEXT_20   STY FORPNT+1        ; address or zero if no index
bd26 20 22 b3           JSR Find_Active_FOR
bd29 f0 04              BEQ NEXT_40         ; branch if found
bd2b a2 00              LDX #0              ; index for next without for error
bd2d f0 66    NEXT_30   BEQ CVT_40           ; -> basic error
bd2f 9a       NEXT_40   TXS                 ; set stack pointer
bd30 8a                 TXA                 ; A = SP
bd31 18                 CLC
bd32 69 04              ADC #4              ; A = SP + 4 (STEP value)
bd34 48                 PHA
bd35 69 06              ADC #6
bd37 85 21              STA INDEXB          ; address TO   value low
bd39 68                 PLA                 ; address STEP value low
bd3a a0 01              LDY #>[STACK]       ; address STEP value high
bd3c 20 d8 cc           JSR Load_FAC1_AY
bd3f ba                 TSX                 ; X = SP    <-- DELETE obsolete
bd40 bd 09 01           LDA STACK+9,X       ; sign of STEP
bd43 85 63              STA FAC1SI
bd45 a5 46              LDA FORPNT
bd47 a4 47              LDY FORPNT+1           ; address of index
bd49 20 9d c9           JSR Add_Var_AY_To_FAC1 ; FAC1 = index + STEP
bd4c 20 06 cd           JSR FAC1_To_FORPNT
bd4f a0 01              LDY #>[STACK]          ; address TO value high
bd51 20 93 cd           JSR Compare_FAC1_INDEXB_Y
bd54 ba                 TSX
bd55 38                 SEC
bd56 fd 09 01           SBC STACK+9,X          ; STEP sign
bd59 f0 17              BEQ NEXT_60            ; loop finished
bd5b bd 0f 01           LDA STACK+15,X
bd5e 85 36              STA CURLIN
bd60 bd 10 01           LDA STACK+16,X
bd63 85 37              STA CURLIN+1           ; line # of loop body
bd65 bd 12 01           LDA STACK+18,X
bd68 85 77              STA TXTPTR
bd6a bd 11 01           LDA STACK+17,X
bd6d 85 78              STA TXTPTR+1           ; address of loop body
bd6f 4c 4a b7 NEXT_50   JMP Execute            ; next iteration
bd72 8a       NEXT_60   TXA
bd73 69 11              ADC #$11               ; carry was set
bd75 aa                 TAX
bd76 9a                 TXS                    ; remove loop structure from stack
bd77 20 76 00           JSR CHRGOT             ; character after NEXT
bd7a c9 2c              CMP #','               ; comma ?
bd7c d0 f1              BNE NEXT_50            ; continue with follow up statement
bd7e 20 70 00           JSR CHRGET             ; get another index
bd81 20 1f bd           JSR NEXT_10            ; perform NEXT again

              ; ********************
bd84            Eval_Numeric ; $bd84
              ; ********************

bd84 20 98 bd           JSR Eval_Expression

              ; ******************
bd87            Is_Numeric ; $bd87
              ; ******************

bd87 18                 CLC
bd88 24                 .BYTE $24

              ; *****************
bd89            Is_String ; $bd89
              ; *****************

bd89 38                 SEC

              ; **********************
bd8a            Check_Var_Type ; $bd8a
              ; **********************

bd8a 24 07              BIT VALTYP          ; $FF = string   $00 = numeric
bd8c 30 03              BMI CVT_20          ; branch on string type
bd8e b0 03              BCS CVT_30          ; string assert -> TYPE MISMATCH
bd90 60       CVT_10    RTS ;Size    7 [Check_Var_Type]
bd91 b0 fd    CVT_20    BCS CVT_10          ; looking for string, found string
bd93 a2 a3    CVT_30    LDX #[Msg_TYPE - Msg_Start] ; $a3
bd95 4c cf b3 CVT_40    JMP Basic_Error     ; want string got numeric or vice versa

              ; called from $b947 Basic_LET
              ;             $c06b Op_COMPARE

              ; ***********************
bd98            Eval_Expression ; $bd98
              ; ***********************

bd98 a6 77              LDX TXTPTR          ; TXTPTR--
bd9a d0 02              BNE EvEx_05
bd9c c6 78              DEC TXTPTR+1
bd9e c6 77    EvEx_05   DEC TXTPTR
bda0 a2 00              LDX #0
bda2 24                 .BYTE $24           ; skip next PHA
bda3 48       EvEx_10   PHA                 ; push ACCSYM (comparison op + type)
bda4 8a                 TXA
bda5 48                 PHA                 ; push X
bda6 20 93 b3           JSR Check_Stack_Avail
bda9 20 81 be           JSR Evaluate
bdac a9 00              LDA #0
bdae 85 4a              STA ACCSYM          ;clear type comparison flag
bdb0 20 76 00 EvEx_15   JSR CHRGOT
bdb3 38       EvEx_20   SEC
bdb4 e9 b1              SBC #$b1            ; > token ( start of comparison ops)
bdb6 90 16              BCC EvEx_25         ; -> binary operators
bdb8 c9 03              CMP #3              ; ( 3 comparison operators > = < )
bdba b0 12              BCS EvEx_25         ; -> function
bdbc c9 02              CMP #2              ; '>'  A = 1
bdbe 69 01              ADC #1              ; '='  A = 2
bdc0 45 4a              EOR ACCSYM          ; '<'  A = 4
bdc2 c5 4a              CMP ACCSYM
bdc4 90 61              BCC SynErr1           ; -> syntax error
bdc6 85 4a              STA ACCSYM          ; rememer comparison operator
bdc8 20 70 00           JSR CHRGET
bdcb 4c b3 bd           JMP EvEx_20         ; loop (maybe <= or >= or <>)

bdce a6 4a    EvEx_25   LDX ACCSYM
bdd0 d0 2c              BNE EvEx_50
bdd2 b0 7e              BCS Pop_FAC2        ; function ( SGN INT ... MID$ )
bdd4 69 07              ADC #7
bdd6 90 7a              BCC Pop_FAC2        ; ->
bdd8 65 07              ADC VALTYP          ; C=1               0 1 2 3 4  5  6
bdda d0 03              BNE EvEx_30         ; binary operator ( + - * / ^ AND OR )
bddc 4c 4f c7           JMP Concatenate     ; '+' with strings

bddf 69 ff    EvEx_30   ADC #$ff
bde1 85 1f              STA INDEXA          ; op code (0-9 for '+' to '<')
bde3 0a                 ASL A               ; op code * 2
bde4 65 1f              ADC INDEXA          ; op code * 3
bde6 a8                 TAY                 ; Y = index
bde7 68       EvEx_35   PLA                 ; precedence
bde8 d9 94 b0           CMP Basic_Operator_Table,Y
bdeb b0 6a              BCS PoFA_20         ; previous op has higher precedence
bded 20 87 bd           JSR Is_Numeric
bdf0 48       EvEx_40   PHA                 ; save precedence
bdf1 20 17 be EvEx_45   JSR Use_Operator
bdf4 68                 PLA                 ; restore precedence
bdf5 a4 48              LDY YSAVE           ; restore index
bdf7 10 17              BPL EvEx_60
bdf9 aa                 TAX
bdfa f0 59              BEQ PoFA_10
bdfc d0 62              BNE PoFA_40         ; always

bdfe 46 07    EvEx_50   LSR VALTYP          ; clear type
be00 8a                 TXA                 ; comparison operator
be01 2a                 ROL A               ; com op * 2
be02 a6 77              LDX TXTPTR          ; TXTPTR--
be04 d0 02              BNE EvEx_55
be06 c6 78              DEC TXTPTR+1
be08 c6 77    EvEx_55   DEC TXTPTR
be0a a0 1b              LDY #27             ; index to Op_COMPARE
be0c 85 4a              STA ACCSYM          ; com op * 2
be0e d0 d7              BNE EvEx_35
be10 d9 94 b0 EvEx_60   CMP Basic_Operator_Table,Y
be13 b0 4b              BCS PoFA_40         ; higher precedence
be15 90 d9              BCC EvEx_40         ; lower  precedence

              ; ************
be17            Use_Operator
              ; ************

be17 b9 96 b0           LDA Basic_Operator_Table+2,Y
be1a 48                 PHA
be1b b9 95 b0           LDA Basic_Operator_Table+1,Y
be1e 48                 PHA
be1f 20 2a be           JSR Push_Operand
be22 a5 4a              LDA ACCSYM
be24 4c a3 bd           JMP EvEx_10

be27 4c 00 bf SynErr1   JMP Syntax_Error

              ; ************
be2a            Push_Operand
              ; ************

be2a be 94 b0           LDX Basic_Operator_Table,Y ; operator priority
be2d 38                 SEC                        ; push with sign

              ; *********
be2e            Push_FAC1
              ; *********

be2e 68                 PLA                 ; return address-1 low
be2f 85 1f              STA INDEXA
be31 68                 PLA                 ; return address-1 high
be32 85 20              STA INDEXA+1
be34 90 03              BCC PuFA_10
be36 a5 63              LDA FAC1SI          ; sign of operand
be38 48                 PHA
be39 20 51 cd PuFA_10   JSR Round_FAC1
be3c a5 62              LDA FAC1M4
be3e 48                 PHA
be3f a5 61              LDA FAC1M3
be41 48                 PHA
be42 a5 60              LDA FAC1M2
be44 48                 PHA
be45 a5 5f              LDA FAC1M1
be47 48                 PHA
be48 a5 5e              LDA FAC1EX
be4a 48                 PHA
be4b a5 20              LDA INDEXA+1
be4d 48                 PHA
be4e a5 1f              LDA INDEXA
be50 48                 PHA
be51 60                 RTS ;Size   36 [Push_FAC1]

              ; ********
be52            Pop_FAC2
              ; ********

be52 a0 ff              LDY #$ff
be54 68                 PLA
be55 f0 23    PoFA_10   BEQ PoFA_50
be57 c9 64    PoFA_20   CMP #$64            ; precedence of Op_COMPARE
be59 f0 03              BEQ PoFA_30         ; strings may be comapred too
be5b 20 87 bd           JSR Is_Numeric
be5e 84 48    PoFA_30   STY YSAVE
be60 68       PoFA_40   PLA
be61 4a                 LSR A               ; C = VALTYPE
be62 85 0c              STA TANSGN          ; comparison operator
be64 68                 PLA
be65 85 66              STA FAC2EX
be67 68                 PLA
be68 85 67              STA FAC2M1
be6a 68                 PLA
be6b 85 68              STA FAC2M2
be6d 68                 PLA
be6e 85 69              STA FAC2M3
be70 68                 PLA
be71 85 6a              STA FAC2M4
be73 68                 PLA
be74 85 6b              STA FAC2SI
be76 45 63              EOR FAC1SI
be78 85 6c              STA STRPTR
be7a a5 5e    PoFA_50   LDA FAC1EX
be7c 60                 RTS                 ; -> use operator ;Size   43 [Pop_FAC2]

be7d 00 00 00           .FILL $be81-* (0) ; 4 bytes

              ; ****************
be81            Evaluate ; $be81
              ; ****************

be81 a9 00              LDA #0
be83 85 07              STA VALTYP          ; default numeric
be85 20 70 00 Eva_10    JSR CHRGET
be88 b0 03              BCS Eva_30          ; branch if not numeric
be8a 4c 29 ce Eva_20    JMP Read_Real_To_FAC1
be8d 20 b6 c1 Eva_30    JSR Is_Alpha
be90 b0 7a              BCS JMP_Get_Var     ; branch to Get_Var
be92 c9 ff              CMP #$ff            ; Pi token
be94 d0 0f              BNE Eva_40
be96 a9 a0              LDA #<Float_PI
be98 a0 be              LDY #>Float_PI
be9a 20 d8 cc           JSR Load_FAC1_AY
be9d 4c 70 00           JMP CHRGET
bea0 82 49 0f Float_PI  .REAL $82490fdaa1   ; 3.14159265254
bea5 c9 2e    Eva_40    CMP # '.'
bea7 f0 e1              BEQ Eva_20          ; real number starting with '.'
bea9 c9 ab              CMP #$ab            ; '-' token sign
beab f0 58              BEQ Negate
bead c9 aa              CMP #$aa            ; '+' token sign
beaf f0 d4              BEQ Eva_10
beb1 c9 22              CMP #QUOTE
beb3 d0 0f              BNE Eva_50

              ; ********************************
beb5            Make_String_Descriptor_From_Code
              ; ********************************

beb5 a5 77              LDA TXTPTR
beb7 a4 78              LDY TXTPTR+1
beb9 69 00              ADC #0              ; INC (A,Y)
bebb 90 01              BCC MSDF_10
bebd c8                 INY
bebe 20 b0 c5 MSDF_10   JSR Create_String_Descriptor
bec1 4c 18 c9           JMP Restore_Execution_Pointer

bec4 c9 a8    Eva_50    CMP #$a8            ; NOT token
bec6 d0 13              BNE Eva_60
bec8 a0 18              LDY #24             ; NOT index to Op Table
beca d0 3b              BNE Nega_10         ; always

              ; ******
becc            Op_NOT
              ; ******

              ; convert real in FAC1 to integer
              ; do a bitwise EOR (negate)
              ; convert result back to FAC1
              ; 0 : false, <> 0 : true

becc 20 ea c2           JSR Real_To_Integer
becf a5 62              LDA FAC1M4
bed1 49 ff              EOR #$ff
bed3 a8                 TAY
bed4 a5 61              LDA FAC1M3
bed6 49 ff              EOR #$ff
bed8 4c bc c4           JMP AY_To_Real

bedb c9 a5    Eva_60    CMP #$a5            ; FN(  token
bedd d0 03              BNE Eva_70
bedf 4c 1d c5           JMP Eval_FNX
bee2 c9 b4    Eva_70    CMP #$b4            ; SGN( token
bee4 90 03              BCC Eval_In_Parenthesis
bee6 4c 47 c0           JMP Function_Call

              ; *******************
bee9            Eval_In_Parenthesis
              ; *******************

bee9 20 f2 be           JSR Need_Left_Parenthesis
beec 20 98 bd           JSR Eval_Expression

              ; **********************
beef            Need_Right_Parenthesis
              ; **********************

beef a9 29              LDA #')'
bef1 2c                 .BYTE $2c

              ; *********************
bef2            Need_Left_Parenthesis
              ; *********************

bef2 a9 28              LDA #'('
bef4 2c                 .BYTE $2c

              ; **********
bef5            Need_Comma
              ; **********

bef5 a9 2c              LDA #','

              ; ******
bef7            Need_A
              ; ******

bef7 a0 00              LDY #0
bef9 d1 77              CMP (TXTPTR),Y
befb d0 03              BNE Syntax_Error
befd 4c 70 00           JMP CHRGET

              ; ************
bf00            Syntax_Error
              ; ************

bf00 a2 10              LDX #[Msg_SYNTA - Msg_Start]
bf02 4c cf b3           JMP Basic_Error

              ; ******
bf05            Negate
              ; ******

bf05 a0 15              LDY #21             ; index to Op_NEGATE
bf07 68       Nega_10   PLA
bf08 68                 PLA
bf09 4c f1 bd           JMP EvEx_45

              ; ***********
bf0c            JMP_Get_Var
              ; ***********

bf0c 4c 8c bf           JMP Get_Var

              ; *************
bf0f            Any_Except_Pi
              ; *************

bf0f 20 70 00           JSR CHRGET
bf12 c9 ff              CMP #$ff            ; Pi token
bf14 f0 ea              BEQ Syntax_Error
bf16 4c 76 00           JMP CHRGOT

              ; ******************
bf19            Input_String_Patch
              ; ******************

bf19 a5 10              LDA IOPMPT
bf1b d0 03              BNE InSt_40
bf1d 4c f0 bb           JMP InSt_30
bf20 a5 96    InSt_40   LDA STATUS
bf22 29 40              AND #$40            ; check EOF
bf24 d0 03              BNE InSt_50
bf26 4c d5 bb           JMP InSt_10
bf29 4c 09 bc InSt_50   JMP READ_10

              ; ************************
bf2c            Extended_Statement_Table
              ; ************************

bf2c b0 de              .WORD Renumber         - 1
bf2e 41 d4              .WORD Monitor          - 1
bf30 7c e4              .WORD Delete           - 1
bf32 77 ed              .WORD Find_Text        - 1
bf34 59 fe              .WORD Replace          - 1
bf36 e5 f3              .WORD Merge            - 1
bf38 00 e7              .WORD OLD              - 1

              ; **********************
bf3a            Extended_Keyword_Table
              ; **********************

bf3a 52 45 4e           .BYTE "RENUMBER"^
bf42 4d 4f 4e           .BYTE "MONITOR"^
bf49 44 45 4c           .BYTE "DELETE"^
bf4f 46 49 4e           .BYTE "FIND"^
bf53 52 45 50           .BYTE "REPLACE"^
bf5a 4d 45 52           .BYTE "MERGE"^
bf5f 4f 4c c4           .BYTE "OLD"^
bf62 00                 .BYTE 0

bf63 00 00 00           .FILL $bf8c-* (0) ; 41 bytes

              ; *******
bf8c            Get_Var
              ; *******

              ; Parse_Name checks, whether the caller is Get_Var
              ; It does not create a so far unknown variable in this case

              ; Output: FAC1 a) integer value converted to real
              ;              b) real value
              ;              c) address of string (FAC1M3)

bf8c 20 2b c1           JSR Parse_Name      ; call address checked in Create_Var !
bf8f 85 61              STA FAC1M3          ; A = VARPTR
bf91 84 62              STY FAC1M4          ; Y = VARPTR+1
bf93 a5 42              LDA VARNAM
bf95 a4 43              LDY VARNAM+1
bf97 a6 07              LDX VALTYP
bf99 f0 33              BEQ Get_Numeric_Value
bf9b a6 62              LDX FAC1M4          ; VARPTR+1
bf9d 10 2e              BPL GeVa_Ret        ; is assigned: no special variables
bf9f c9 54              CMP #'T'            ; TI$ - 1st. char
bfa1 d0 18              BNE GeVa_10
bfa3 c0 c9              CPY #'I'+$80        ; TI$ - 2nd. char
bfa5 d0 14              BNE GeVa_10
bfa7 20 03 c0           JSR Load_Jiffyclock
bfaa 84 5b              STY TMPVAR+1        ; TMPVAR+1 = 0
bfac 88                 DEY
bfad 84 6e              STY TMPPTD          ; TMPPTD = $ff
bfaf a0 06              LDY #6
bfb1 84 5a              STY TMPVAR          ; # of digits
bfb3 a0 24              LDY #$24            ; index to Decimal_Conversion_Table
bfb5 20 1a d0           JSR Format_Jiffyclock
bfb8 4c 98 c5           JMP STR_10           ; create string and descriptor

bfbb c9 44    GeVa_10   CMP #'D'            ; DS$ - 1st. char
bfbd d0 0e              BNE GeVa_Ret
bfbf c0 d3              CPY #'S'+$80        ; DS$ - 2nd. char
bfc1 d0 0a              BNE GeVa_Ret
bfc3 20 91 d9           JSR Kernal_Read_DS
bfc6 a9 ad              LDA #<DOS_Status
bfc8 a0 03              LDY #>DOS_Status
bfca 4c b0 c5           JMP Create_String_Descriptor
bfcd 60       GeVa_Ret  RTS ;Size   66 [Get_Var]

              ; *****************
bfce            Get_Numeric_Value
              ; *****************

bfce a6 08              LDX INTFLG
bfd0 10 0d              BPL Load_Float
bfd2 a0 00              LDY #0
bfd4 b1 61              LDA (FAC1M3),Y
bfd6 aa                 TAX
bfd7 c8                 INY
bfd8 b1 61              LDA (FAC1M3),Y
bfda a8                 TAY
bfdb 8a                 TXA
bfdc 4c bc c4           JMP AY_To_Real

              ; **********
bfdf            Load_Float
              ; **********

bfdf a6 62              LDX FAC1M4
bfe1 10 5d              BPL Load_Float_Var
bfe3 c9 54              CMP #'T'            ; TI - 1st. char
bfe5 d0 28              BNE Check_ST_Var
bfe7 c0 49              CPY #'I'            ; TI - 2nd. char
bfe9 d0 55              BNE Load_Float_Var
bfeb 20 03 c0           JSR Load_Jiffyclock
bfee 98                 TYA                 ; FROUND := $00  FAC1SI := $00
bfef a2 a0              LDX #$a0            ; FAC1EX := $a0
bff1 4c 85 cd           JMP CITR_10           ; normalize FAC1

bff4 00 00 00           .FILL $c003-* (0) ; 15 bytes

              ; ***********************
c003            Load_Jiffyclock ; $c003
              ; ***********************

c003 a9 8b              LDA #<[JIFFY_CLOCK-2] ; load mixture of random seed
c005 a0 00              LDY #>[JIFFY_CLOCK-2] ; and jiffy clock
c007 78                 SEI
c008 20 d8 cc           JSR Load_FAC1_AY      ; FAC1M2/3/4 = Jiffy Clock
c00b 58                 CLI
c00c 84 5f              STY FAC1M1            ; FAC1M1 = 0
c00e 60                 RTS ;Size   12 [Load_Jiffyclock]

              ; ************
c00f            Check_ST_Var
              ; ************

c00f c9 53              CMP #'S'
c011 d0 09              BNE Check_DS_Var
c013 c0 54              CPY #'T'
c015 d0 05              BNE Check_DS_Var
c017 a5 96              LDA STATUS
c019 4c 72 cd           JMP A_To_FAC1

              ; ************
c01c            Check_DS_Var
              ; ************

c01c c9 44              CMP #'D'
c01e d0 20              BNE Load_Float_Var
c020 c0 53              CPY #'S'
c022 d0 1c              BNE Load_Float_Var
c024 20 91 d9           JSR Kernal_Read_DS
c027 29 0f              AND #15
c029 0a                 ASL A
c02a 85 09              STA GARBFL
c02c 0a                 ASL A
c02d 0a                 ASL A
c02e 65 09              ADC GARBFL
c030 85 09              STA GARBFL
c032 ad ae 03           LDA DOS_Status+1
c035 29 0f              AND #15
c037 65 09              ADC GARBFL
c039 4c 72 cd           JMP A_To_FAC1

c03c 00 00 00           .FILL $c040-* (0) ; 4 bytes

              ; **********************
c040            Load_Float_Var ; $c040
              ; **********************

c040 a5 61              LDA FAC1M3
c042 a4 62              LDY FAC1M4
c044 4c d8 cc           JMP Load_FAC1_AY

              ; *************
c047            Function_Call
              ; *************

              ; called from Evaluate
              ; Input:  A = function token
              ;         token  range = $b4 SGN - $ca MID$
              ;         scaled range = $68 SGN - $92 MID$

c047 0a                 ASL A               ; A = token * 2
c048 48                 PHA                 ; save
c049 aa                 TAX                 ; X = token * 2
c04a 20 70 00           JSR CHRGET
c04d e0 8f              CPX #$8f            ; limit of single numeric argument
c04f 90 20              BCC FuCa_10         ; branch if not LEFT$, RIGHT$, MID$
c051 20 f2 be           JSR Need_Left_Parenthesis
c054 20 98 bd           JSR Eval_Expression
c057 20 f5 be           JSR Need_Comma
c05a 20 89 bd           JSR Is_String       ; 1st. arg must be string
c05d 68                 PLA                 ; scaled token
c05e aa                 TAX                 ; X = $90 LEFT$, $92 RIGHT$, $94 MID$
c05f a5 62              LDA FAC1M4
c061 48                 PHA
c062 a5 61              LDA FAC1M3          ; push pointer to 1st. argUment
c064 48                 PHA
c065 8a                 TXA
c066 48                 PHA                 ; save scaled token
c067 20 d4 c8           JSR Get_Byte_Value  ; get 2nd. argument (byte value)
c06a 68                 PLA
c06b a8                 TAY                 ; Y = scaled token
c06c 8a                 TXA
c06d 48                 PHA                 ; push 2nd. argument
c06e 4c 76 c0           JMP FuCa_20
c071 20 e9 be FuCa_10   JSR Eval_In_Parenthesis
c074 68                 PLA                 ; scaled token
c075 a8                 TAY                 ; Y = index
c076 b9 fe af FuCa_20   LDA Basic_Function_Table-$68,Y
c079 85 52              STA FUNJMP
c07b b9 ff af           LDA Basic_Function_Table-$67,Y
c07e 85 53              STA FUNJMP+1
c080 20 51 00           JSR JUMPER
c083 4c 87 bd           JMP Is_Numeric

              ; *****
c086            Op_OR
              ; *****

c086 38                 SEC
c087 24                 .BYTE $24

              ; ******
c088            Op_AND
              ; ******

c088 18                 CLC
c089 66 03              ROR CHARAC          ; bit7=1:OR bit7=0:AND
c08b 20 ea c2           JSR Real_To_Integer
c08e a5 61              LDA FAC1M3
c090 48                 PHA
c091 a5 62              LDA FAC1M4
c093 48                 PHA
c094 20 32 cd           JSR FAC2_To_FAC1
c097 20 ea c2           JSR Real_To_Integer
c09a 68                 PLA
c09b 24 03              BIT CHARAC
c09d 10 09              BPL ANDOR_10
c09f 05 62              ORA FAC1M4
c0a1 a8                 TAY
c0a2 68                 PLA
c0a3 05 61              ORA FAC1M3
c0a5 4c bc c4           JMP AY_To_Real
c0a8 25 62    ANDOR_10  AND FAC1M4
c0aa a8                 TAY
c0ab 68                 PLA
c0ac 25 61              AND FAC1M3
c0ae 4c bc c4           JMP AY_To_Real

              ; ************
              ; Float_M32768
              ; ************

              ;         .REAL $9080000000   ; -32768

c0b1 00 00 00           .FILL $c0b6-* (0) ; 5 bytes

              ; ******************
c0b6            Op_COMPARE ; $c0b6
              ; ******************

              ; Input:  C = VALTYPE
              ;         TANSGN = comparison mask
              ;         FAC1 = right operand
              ;         FAC2 = left  operand

c0b6 20 8a bd           JSR Check_Var_Type
c0b9 b0 13              BCS OpCO_10         ; -> compare strings
c0bb a5 6b              LDA FAC2SI          ; transfer sign to FAC2M1
c0bd 09 7f              ORA #$7f
c0bf 25 67              AND FAC2M1
c0c1 85 67              STA FAC2M1
c0c3 a9 66              LDA #<FAC2EX
c0c5 a0 00              LDY #>FAC2EX
c0c7 20 91 cd           JSR Compare_FAC1_AY ; -1: FAC1 > FAC2  +1: FAC1 < FAC2
c0ca aa                 TAX                 ; set flags
c0cb 4c 01 c1           JMP OpCO_40
c0ce a9 00    OpCO_10   LDA #0
c0d0 85 07              STA VALTYP          ; result = numeric (-1:true, 0:false)
c0d2 c6 4a              DEC ACCSYM          ; OBSOLETE
c0d4 20 b8 c7           JSR Free_String_FAC1
c0d7 85 5e              STA FAC1EX
c0d9 86 5f              STX FAC1M1          ; 1st. string
c0db 84 60              STY FAC1M2
c0dd a5 69              LDA FAC2M3
c0df a4 6a              LDY FAC2M4
c0e1 20 bc c7           JSR Free_String_AY
c0e4 86 69              STX FAC2M3          ; 2nd. string
c0e6 84 6a              STY FAC2M4
c0e8 aa                 TAX                 ; X = length2
c0e9 38                 SEC
c0ea e5 5e              SBC FAC1EX          ; length difference
c0ec f0 08              BEQ OpCO_20         ; -> equal length
c0ee a9 01              LDA #1
c0f0 90 04              BCC OpCO_20
c0f2 a6 5e              LDX FAC1EX          ; X = length1 (shorter one)
c0f4 a9 ff              LDA #-1
c0f6 85 63    OpCO_20   STA FAC1SI          ; store length1 <=> length2 (-1,0,1)
c0f8 a0 ff              LDY #-1
c0fa e8                 INX
c0fb c8       OpCO_30   INY
c0fc ca                 DEX
c0fd d0 07              BNE OpCO_50
c0ff a6 63              LDX FAC1SI          ; equal so far
c101 30 0f    OpCO_40   BMI OpCO_60         ; left > right
c103 18                 CLC
c104 90 0c              BCC OpCO_60
c106 b1 69    OpCO_50   LDA (FAC2M3),Y
c108 d1 5f              CMP (FAC1M1),Y
c10a f0 ef              BEQ OpCO_30
c10c a2 ff              LDX #-1
c10e b0 02              BCS OpCO_60
c110 a2 01              LDX #1
c112 e8       OpCO_60   INX                 ; C=1 : string2 >= string1
c113 8a                 TXA                 ; C=0 : string2 <  string1
c114 2a                 ROL A
c115 25 0c              AND TANSGN          ; ACCSYM comparison mask
c117 f0 02              BEQ OpCO_70         ; > 1   = 2   < 4
c119 a9 ff              LDA #-1             ; true
c11b 4c 72 cd OpCO_70   JMP A_To_FAC1


c11e 20 f5 be DIM_10    JSR Need_Comma

              ; *********
c121            Basic_DIM
              ; *********

c121 aa                 TAX
c122 20 30 c1           JSR Get_Array_Address
c125 20 76 00           JSR CHRGOT
c128 d0 f4              BNE DIM_10
c12a 60                 RTS ;Size   10 [Basic_DIM]

              ; **********
c12b            Parse_Name
              ; **********

c12b a2 00              LDX #0
c12d 20 76 00           JSR CHRGOT

              ; *****************
c130            Get_Array_Address
              ; *****************

c130 86 06              STX DIMFLG

              ; **************
c132            Get_FN_Address
              ; **************

c132 85 42              STA VARNAM
c134 20 76 00           JSR CHRGOT
c137 20 b6 c1           JSR Is_Alpha
c13a b0 03              BCS Get_Address
c13c 4c 00 bf GFA_Err   JMP Syntax_Error

              ; *******************
c13f            Get_Address ; $c13f
              ; *******************

c13f a2 00              LDX #0              ; set defaults
c141 86 07              STX VALTYP          ; numeric
c143 86 08              STX INTFLG          ; real
c145 20 70 00           JSR CHRGET          ; 2nd. char of name
c148 90 05              BCC GeAd_05         ; -> branch if numeric
c14a 20 b6 c1           JSR Is_Alpha
c14d 90 0b              BCC GeAd_15         ; -> branch if not alpha
c14f aa       GeAd_05   TAX                 ; X = 2nd. char of name
c150 20 70 00 GeAd_10   JSR CHRGET          ; skip all alphanumeric characters
c153 90 fb              BCC GeAd_10         ; after the 2nd. one
c155 20 b6 c1           JSR Is_Alpha
c158 b0 f6              BCS GeAd_10
c15a c9 24    GeAd_15   CMP #'$'            ; string ?
c15c d0 06              BNE GeAd_20
c15e a9 ff              LDA #$ff            ; set string flag
c160 85 07              STA VALTYP          ; $ff = string  $00 = numeric
c162 d0 10              BNE GeAd_25         ; branch always
c164 c9 25    GeAd_20   CMP #'%'            ; integer ?
c166 d0 13              BNE GeAd_30
c168 a5 0a              LDA SUBFLG          ; integer allowed ?
c16a d0 d0              BNE GFA_Err         ; -> not in this context
c16c a9 80              LDA #$80
c16e 85 08              STA INTFLG          ; integer flag
c170 05 42              ORA VARNAM
c172 85 42              STA VARNAM          ; mark variable as integer
c174 8a       GeAd_25   TXA                 ; A = 2nd. char
c175 09 80              ORA #$80            ; set string/integer bit
c177 aa                 TAX                 ; X = 2nd. char OR $80
c178 20 70 00           JSR CHRGET          ; next char after '$' or '%'
c17b 86 43    GeAd_30   STX VARNAM+1        ; store 2nd. char of name
c17d 38                 SEC
c17e 05 0a              ORA SUBFLG          ; Or with FOR, FN flag
c180 e9 28              SBC #'('            ; array ?
c182 d0 03              BNE GeAd_35         ; -> no
c184 4c fc c2           JMP Find_Array      ; read subscripts
c187 a0 00    GeAd_35   LDY #0
c189 84 0a              STY SUBFLG          ; clear integer disable flag
c18b a5 2a              LDA VARTAB
c18d a6 2b              LDX VARTAB+1        ; (A/X) = VARTAB
c18f 86 5d    GeAd_40   STX TMPPTC+1        ; find variable in (VARTAB..ARYTAB)
c191 85 5c    GeAd_45   STA TMPPTC          ; TMPPTC = (A/X)
c193 e4 2d              CPX ARYTAB+1
c195 d0 04              BNE GeAd_50
c197 c5 2c              CMP ARYTAB
c199 f0 25              BEQ Create_Var      ; (A/X) == ARYTAB -> not found
c19b a5 42    GeAd_50   LDA VARNAM
c19d d1 5c              CMP (TMPPTC),Y      ; compare 1st. char
c19f d0 0b              BNE GeAd_60
c1a1 a5 43              LDA VARNAM+1
c1a3 c8                 INY                 ; Y = 1
c1a4 d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c1a6 d0 03              BNE GeAd_55
c1a8 4c b4 c2           JMP CrVa_80           ; -> found
c1ab 88       GeAd_55   DEY                 ; Y = 0
c1ac 18       GeAd_60   CLC
c1ad a5 5c              LDA TMPPTC
c1af 69 07              ADC #7              ; TMPPTC += 7
c1b1 90 de              BCC GeAd_45
c1b3 e8                 INX
c1b4 d0 d9              BNE GeAd_40         ; branch always

              ; ********
c1b6            Is_Alpha
              ; ********

c1b6 c9 41              CMP #'A'
c1b8 90 05              BCC IsAl_Ret
c1ba e9 5b              SBC #'Z'+1
c1bc 38                 SEC
c1bd e9 a5              SBC #$a5            ; restore original content
c1bf 60       IsAl_Ret  RTS                 ; C=1 if (A..Z) ;Size   10 [Is_Alpha]

              ; ******************
c1c0            Create_Var ; $c1c0
              ; ******************

c1c0 68                 PLA
c1c1 48                 PHA                 ; return address low
c1c2 c9 8e              CMP #<[Get_Var+2]   ; $8e called from Get_Var ?
c1c4 d0 05              BNE CrVa_10
c1c6 a9 c9    CrVa_05   LDA #<[Float_0_5 + 2]; void descriptor (0,0,0)
c1c8 a0 d0              LDY #>[Float_0_5 + 2]; or value in ROM
c1ca 60                 RTS ;Size   11 [Create_Var]
c1cb a5 42    CrVa_10   LDA VARNAM
c1cd a4 43              LDY VARNAM+1
c1cf c9 54              CMP #'T'            ; check reserved names
c1d1 d0 0b              BNE CrVa_20
c1d3 c0 c9              CPY #'I'+$80        ; TI$ = "hhmmss"  sets jiffy clock
c1d5 f0 ef              BEQ CrVa_05         ; create void descriptor
c1d7 c0 49              CPY #'I'            ; TI  (read only variable)
c1d9 d0 03              BNE CrVa_20
c1db 4c 00 bf CrVa_15   JMP Syntax_Error    ; tried to use reserved name
c1de c9 53    CrVa_20   CMP #'S'
c1e0 d0 04              BNE CrVa_25
c1e2 c0 54              CPY #'T'            ; ST  (read only variable)
c1e4 f0 f5              BEQ CrVa_15
c1e6 c9 44    CrVa_25   CMP #'D'
c1e8 d0 08              BNE CrVa_30
c1ea c0 53              CPY #'S'            ; DS  (read only variable)
c1ec f0 ed              BEQ CrVa_15
c1ee c0 d3              CPY #'S'+$80        ; DS$ (read only variable)
c1f0 f0 e9              BEQ CrVa_15
c1f2 a5 2c    CrVa_30   LDA ARYTAB
c1f4 a4 2d              LDY ARYTAB+1        ; (A/Y)  = ARYTAB
c1f6 85 5c              STA TMPPTC
c1f8 84 5d              STY TMPPTC+1        ; TMPPTC = ARYTAB
c1fa a5 2e              LDA STREND
c1fc a4 2f              LDY STREND+1        ; (A/Y)  = STREND
c1fe 85 57              STA TMPPTB
c200 84 58              STY TMPPTB+1        ; TMPPTB = STREND
c202 18                 CLC
c203 69 07              ADC #7              ; 7 bytes for a new variable
c205 90 01              BCC CrVa_35
c207 c8                 INY
c208 85 55    CrVa_35   STA TMPPTA
c20a 84 56              STY TMPPTA+1        ; TMPPTA = TMPPTB + 7
c20c 20 50 b3           JSR Open_Up_Space   ; move array space 7 bytes up
c20f a5 55              LDA TMPPTA
c211 a4 56              LDY TMPPTA+1
c213 c8                 INY
c214 85 2c              STA ARYTAB
c216 84 2d              STY ARYTAB+1        ; ARYTAB += 7
c218 85 55              STA TMPPTA
c21a 84 56              STY TMPPTA+1        ; TMPPTA = ARYTAB

              ; scan through array area and adjust all dynamic string
              ; back references to the new descriptor position

c21c a5 55    CrVa_40   LDA TMPPTA
c21e a6 56              LDX TMPPTA+1
c220 e4 2f    CrVa_45   CPX STREND+1        ; TMPPTA == STREND ?
c222 d0 04              BNE CrVa_50
c224 c5 2e              CMP STREND
c226 f0 70              BEQ CrVa_75         ; -> initialize variable
c228 85 1f    CrVa_50   STA INDEXA
c22a 86 20              STX INDEXA+1        ; INDEXA = TMPPTA
c22c a0 00              LDY #0
c22e b1 1f              LDA (INDEXA),Y
c230 aa                 TAX                 ; X = 1st. char
c231 c8                 INY                 ; Y = 1
c232 b1 1f              LDA (INDEXA),Y
c234 08                 PHP                 ; push flags of 2nd. char
c235 c8                 INY                 ; Y = 2
c236 b1 1f              LDA (INDEXA),Y      ; A = array length low
c238 65 55              ADC TMPPTA
c23a 85 55              STA TMPPTA
c23c c8                 INY                 ; Y = 3
c23d b1 1f              LDA (INDEXA),Y      ; A = array length high
c23f 65 56              ADC TMPPTA+1
c241 85 56              STA TMPPTA+1        ; TMPPTA += array length
c243 28                 PLP                 ; flags of 2nd. char
c244 10 d6              BPL CrVa_40         ; -> branch for real array
c246 8a                 TXA                 ; flags for 1st. char
c247 30 d3              BMI CrVa_40         ;-> branch for integer
c249 c8                 INY                 ; Y = 4
c24a b1 1f              LDA (INDEXA),Y      ; A = # of dimensions
c24c a0 00              LDY #0
c24e 0a                 ASL A               ; dimensions * 2
c24f 69 05              ADC #5              ; plus 5 bytes for header
c251 65 1f              ADC INDEXA
c253 85 1f              STA INDEXA
c255 90 02              BCC CrVa_55
c257 e6 20              INC INDEXA+1        ; INDEXA += header size
c259 a6 20    CrVa_55   LDX INDEXA+1
c25b e4 56              CPX TMPPTA+1        ; INDEXA == TMPPTA (end of array) ?
c25d d0 04              BNE CrVa_60
c25f c5 55              CMP TMPPTA
c261 f0 bd              BEQ CrVa_45         ; -> branch on end of array
c263 a0 00    CrVa_60   LDY #0
c265 b1 1f              LDA (INDEXA),Y      ; length
c267 f0 22              BEQ CrVa_70         ; -> next item
c269 c8                 INY                 ; Y = 1
c26a 18                 CLC
c26b 71 1f              ADC (INDEXA),Y      ; A = length + address low
c26d 85 57              STA TMPPTB
c26f aa                 TAX
c270 c8                 INY                 ; Y = 2
c271 b1 1f              LDA (INDEXA),Y      ; address high
c273 69 00              ADC #0
c275 85 58              STA TMPPTB+1        ; TMPPTB = back reference
c277 c5 31              CMP FRETOP+1
c279 90 10              BCC CrVa_70         ; -> branch if not in string area
c27b d0 04              BNE CrVa_65
c27d e4 30              CPX FRETOP
c27f 90 0a              BCC CrVa_70         ; -> branch if not in string area
c281 88       CrVa_65   DEY                 ; Y = 1
c282 a5 20              LDA INDEXA+1        ; back reference high
c284 91 57              STA (TMPPTB),Y      ; store
c286 88                 DEY                 ; Y = 0
c287 a5 1f              LDA INDEXA          ; back reference low
c289 91 57              STA (TMPPTB),Y      ; store
c28b a9 03    CrVa_70   LDA #3
c28d 18                 CLC
c28e 65 1f              ADC INDEXA
c290 85 1f              STA INDEXA
c292 90 c5              BCC CrVa_55
c294 e6 20              INC INDEXA+1        ; INDEXA += 3 (next descriptor)
c296 d0 c1              BNE CrVa_55         ; branch always

c298 a0 00    CrVa_75   LDY #0
c29a a5 42              LDA VARNAM
c29c 91 5c              STA (TMPPTC),Y      ; byte 0: 1st. char
c29e c8                 INY
c29f a5 43              LDA VARNAM+1
c2a1 91 5c              STA (TMPPTC),Y      ; byte 1: 2nd. char
c2a3 a9 00              LDA #0
c2a5 c8                 INY
c2a6 91 5c              STA (TMPPTC),Y      ; byte 2-6: 0
c2a8 c8                 INY
c2a9 91 5c              STA (TMPPTC),Y
c2ab c8                 INY
c2ac 91 5c              STA (TMPPTC),Y
c2ae c8                 INY
c2af 91 5c              STA (TMPPTC),Y
c2b1 c8                 INY
c2b2 91 5c              STA (TMPPTC),Y
c2b4 a5 5c    CrVa_80   LDA TMPPTC
c2b6 18                 CLC
c2b7 69 02              ADC #2
c2b9 a4 5d              LDY TMPPTC+1
c2bb 90 01              BCC CrVa_85
c2bd c8                 INY
c2be 85 44    CrVa_85   STA VARPTR          ; VARPTR = TMPPTC + 2
c2c0 84 45              STY VARPTR+1
c2c2 60                 RTS ;Size  259 [Create_Var]

c2c3 00 00 00           .FILL $c2c8-* (0) ; 5 bytes

              ; ******************************
c2c8            Array_Pointer_To_First ; $c2c8
              ; ******************************

c2c8 a5 05              LDA COUNT           ; # of dimensions
c2ca 0a                 ASL A               ; in bytes
c2cb 69 05              ADC #5              ; plus header size
c2cd 65 5c              ADC TMPPTC          ; plus start of array
c2cf a4 5d              LDY TMPPTC+1
c2d1 90 01              BCC APTF_10
c2d3 c8                 INY
c2d4 85 55    APTF_10   STA TMPPTA          ; pointer to first elemnt
c2d6 84 56              STY TMPPTA+1
c2d8 60                 RTS ;Size   17 [Array_Pointer_To_First]

              ; ************
c2d9            Float_M32768
              ; ************

c2d9 90 80 00           .QUAD $90800000  -1870659584

c2dd                    .FILL $c2dd-* (0) ; 0 bytes

              ; *****************************
c2dd            Eval_Positive_Integer ; $c2dd
              ; *****************************

c2dd 20 70 00           JSR CHRGET
c2e0 20 98 bd           JSR Eval_Expression

              ; ***************************
c2e3            Eval_Positive_Integer_Check
              ; ***************************

c2e3 20 87 bd           JSR Is_Numeric
c2e6 a5 63              LDA FAC1SI
c2e8 30 0d              BMI RIT_10

              ; ***********************
c2ea            Real_To_Integer ; $c2ea
              ; ***********************

c2ea a5 5e              LDA FAC1EX
c2ec c9 90              CMP #$90            ; check if -32767 >= value >= 32767
c2ee 90 09              BCC RIT_20
c2f0 a9 d9              LDA #<Float_M32768  ; check if value = -32768
c2f2 a0 c2              LDY #>Float_M32768
c2f4 20 91 cd           JSR Compare_FAC1_AY
c2f7 d0 7a    RIT_10    BNE Jump_To_Illegal_Quantity
c2f9 4c 6f ba RIT_20    JMP FAC1_INT

              ; ******************
c2fc            Find_Array ; $c2fc
              ; ******************

              ; This routine is jumped at from the Parse_Name routine
              ; after parsing the name of the array (VARNAM) and the
              ; left parenthesis '('

c2fc a5 06              LDA DIMFLG
c2fe 05 08              ORA INTFLG          ; push INTFLG (bit 7) and DIMFLG (6-0)
c300 48                 PHA
c301 a5 07              LDA VALTYP          ; push VALTYP
c303 48                 PHA
c304 a0 00              LDY #0
c306 98       FiAr_05   TYA                 ; start loop evaluating subscripts
c307 48                 PHA                 ; push Y
c308 a5 43              LDA VARNAM+1
c30a 48                 PHA
c30b a5 42              LDA VARNAM          ; push VARNAM
c30d 48                 PHA
c30e 20 dd c2           JSR Eval_Positive_Integer
c311 68                 PLA
c312 85 42              STA VARNAM
c314 68                 PLA
c315 85 43              STA VARNAM+1        ; pull VARNAM
c317 68                 PLA
c318 a8                 TAY                 ; pull Y
c319 ba                 TSX                 ; X = stack pointer
c31a bd 02 01           LDA STACK+2,X
c31d 48                 PHA                 ; push DIMFLG/INTFLG again
c31e bd 01 01           LDA STACK+1,X
c321 48                 PHA                 ; push VALTYP again
c322 a5 61              LDA FAC1M3
c324 9d 02 01           STA STACK+2,X
c327 a5 62              LDA FAC1M4          ; replace value above these flags
c329 9d 01 01           STA STACK+1,X       ; by the subscript pointer
c32c c8                 INY                 ; check next index
c32d 20 76 00           JSR CHRGOT
c330 c9 2c              CMP #','
c332 f0 d2              BEQ FiAr_05         ; evaluate next subscript
c334 84 05              STY COUNT           ; # of subscripts
c336 20 ef be           JSR Need_Right_Parenthesis
c339 68                 PLA
c33a 85 07              STA VALTYP
c33c 68                 PLA
c33d 85 08              STA INTFLG
c33f 29 7f              AND #$7f
c341 85 06              STA DIMFLG          ; restore array flags
c343 a6 2c              LDX ARYTAB
c345 a5 2d              LDA ARYTAB+1        ; start of search
c347 86 5c    FiAr_10   STX TMPPTC
c349 85 5d              STA TMPPTC+1
c34b c5 2f              CMP STREND+1
c34d d0 04              BNE FiAr_15
c34f e4 2e              CPX STREND
c351 f0 39              BEQ FiAr_30           ; not found -> create default size array
c353 a0 00    FiAr_15   LDY #0
c355 b1 5c              LDA (TMPPTC),Y
c357 c8                 INY                 ; Y = 1
c358 c5 42              CMP VARNAM          ; compare 1st. char
c35a d0 06              BNE FiAr_20
c35c a5 43              LDA VARNAM+1
c35e d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c360 f0 16              BEQ FiAr_25
c362 c8       FiAr_20   INY                 ; Y = 2
c363 b1 5c              LDA (TMPPTC),Y      ; length of header
c365 18                 CLC
c366 65 5c              ADC TMPPTC
c368 aa                 TAX
c369 c8                 INY
c36a b1 5c              LDA (TMPPTC),Y
c36c 65 5d              ADC TMPPTC+1        ; advance TMPPTC to next array
c36e 90 d7              BCC FiAr_10         ; branch always

              ; -------------
c370            Bad_Subscript
              ; -------------

c370 a2 6b              LDX #[Msg_SUBSC - Msg_Start] ; $6b
c372 2c                 .BYTE $2c

              ; ------------------------
c373            Jump_To_Illegal_Quantity
              ; ------------------------

c373 a2 35              LDX #[Msg_QUANT - Msg_Start] ; $35
c375 4c cf b3 FiAr_Err  JMP Basic_Error

              ; array already declared and dimensioned

c378 a2 78    FiAr_25   LDX #[Msg_REDIM - Msg_Start] ; $78
c37a a5 06              LDA DIMFLG          ; dimension statement ?
c37c d0 f7              BNE FiAr_Err        ; array already created
c37e 20 c8 c2           JSR Array_Pointer_To_First
c381 a5 05              LDA COUNT           ; # of subscripts
c383 a0 04              LDY #4
c385 d1 5c              CMP (TMPPTC),Y      ; compare with # of declared dimensions
c387 d0 e7              BNE Bad_Subscript   ; error if no match
c389 4c 15 c4           JMP FiAr_70

              ; create array

c38c 20 c8 c2 FiAr_30   JSR Array_Pointer_To_First
c38f 20 a0 b3           JSR Check_Mem_Avail
c392 a0 00              LDY #0
c394 84 6f              STY TMPPTD+1
c396 a2 05              LDX #5              ; # of bytes per element (default REAL)
c398 a5 42              LDA VARNAM
c39a 91 5c              STA (TMPPTC),Y      ; store 1st. char
c39c 10 01              BPL FiAr_35         ; branch if REAL or STRING
c39e ca                 DEX                 ; # of bytes = 4
c39f c8       FiAr_35   INY                 ; Y = 1
c3a0 a5 43              LDA VARNAM+1
c3a2 91 5c              STA (TMPPTC),Y      ; store 2nd. char
c3a4 10 02              BPL FiAr_40         ; branch if REAL
c3a6 ca                 DEX
c3a7 ca                 DEX                 ; # of bytes (2 INTEGER, 3 STRING)
c3a8 86 6e    FiAr_40   STX TMPPTD          ; store size of elemnts
c3aa a5 05              LDA COUNT           ; # of subscripts
c3ac c8                 INY                 ; Y = 2
c3ad c8                 INY                 ; Y = 3
c3ae c8                 INY                 ; Y = 4
c3af 91 5c              STA (TMPPTC),Y      ; store # of dimensions
c3b1 a2 0b    FiAr_45   LDX #11             ; default dimension (0..10)
c3b3 a9 00              LDA #0              ; high value
c3b5 24 06              BIT DIMFLG
c3b7 50 08              BVC FiAr_50         ; -> branch for default dimension
c3b9 68                 PLA
c3ba 18                 CLC
c3bb 69 01              ADC #1              ; add 1 because indices start at 0
c3bd aa                 TAX
c3be 68                 PLA
c3bf 69 00              ADC #0              ; (X/A) = (subscript + 1)
c3c1 c8       FiAr_50   INY                 ; Y = 5,7,...
c3c2 91 5c              STA (TMPPTC),Y      ; store dimension high
c3c4 c8                 INY                 ; Y = 6,8,...
c3c5 8a                 TXA
c3c6 91 5c              STA (TMPPTC),Y      ; store dimension low
c3c8 20 77 c4           JSR Mult_16x16
c3cb 86 6e              STX TMPPTD          ; size low
c3cd 85 6f              STA TMPPTD+1        ; size high
c3cf a4 1f              LDY INDEXA
c3d1 c6 05              DEC COUNT           ; decrement dimension counter
c3d3 d0 dc              BNE FiAr_45         ; loop for next dimension
c3d5 65 56              ADC TMPPTA+1
c3d7 b0 5d              BCS FiAr_76           ; -> out of memory
c3d9 85 56              STA TMPPTA+1
c3db a8                 TAY
c3dc 8a                 TXA
c3dd 65 55              ADC TMPPTA
c3df 90 03              BCC FiAr_55
c3e1 c8                 INY
c3e2 f0 52              BEQ FiAr_76           ; -> out of memory
c3e4 20 a0 b3 FiAr_55   JSR Check_Mem_Avail
c3e7 85 2e              STA STREND
c3e9 84 2f              STY STREND+1        ; new top of array area
c3eb a9 00              LDA #0              ; zero array content
c3ed e6 6f              INC TMPPTD+1        ; size high
c3ef a4 6e              LDY TMPPTD          ; Y = size low
c3f1 f0 05              BEQ FiAr_65
c3f3 88       FiAr_60   DEY
c3f4 91 55              STA (TMPPTA),Y      ; clear array
c3f6 d0 fb              BNE FiAr_60
c3f8 c6 56    FiAr_65   DEC TMPPTA+1
c3fa c6 6f              DEC TMPPTD+1
c3fc d0 f5              BNE FiAr_60
c3fe e6 56              INC TMPPTA+1
c400 38                 SEC
c401 a5 2e              LDA STREND
c403 e5 5c              SBC TMPPTC
c405 a0 02              LDY #2
c407 91 5c              STA (TMPPTC),Y      ; store array size low
c409 a5 2f              LDA STREND+1
c40b c8                 INY                 ; Y = 3
c40c e5 5d              SBC TMPPTC+1
c40e 91 5c              STA (TMPPTC),Y      ; store array size high
c410 a5 06              LDA DIMFLG
c412 d0 62              BNE FiAr_Ret
c414 c8                 INY                 ; Y = 4
c415 b1 5c    FiAr_70   LDA (TMPPTC),Y      ; # of dimensions
c417 85 05              STA COUNT
c419 a9 00              LDA #0
c41b 85 6e              STA TMPPTD          ; TMPPTD = 0
c41d 85 6f    FiAr_72   STA TMPPTD+1
c41f c8                 INY                 ; Y = 5,7,...
c420 68                 PLA
c421 aa                 TAX
c422 85 61              STA FAC1M3
c424 68                 PLA
c425 85 62              STA FAC1M4          ; FAC1M3/4 = subscript
c427 d1 5c              CMP (TMPPTC),Y      ; compare with dimension high
c429 90 0e              BCC FiAr_78         ; -> lower
c42b d0 06              BNE FiAr_74         ; greater -> out of range
c42d c8                 INY                 ; Y = 6,8,...
c42e 8a                 TXA
c42f d1 5c              CMP (TMPPTC),Y      ; compare with dimension low
c431 90 07              BCC FiAr_80         ; -> lower
c433 4c 70 c3 FiAr_74   JMP Bad_Subscript
c436 4c cd b3 FiAr_76   JMP Error_Out_Of_Memory
c439 c8       FiAr_78   INY                 ; Y = 6,8,...
c43a a5 6f    FiAr_80   LDA TMPPTD+1
c43c 05 6e              ORA TMPPTD
c43e 18                 CLC
c43f f0 0a              BEQ FiAr_82         ; TMPPTD == 0 ?
c441 20 77 c4           JSR Mult_16x16
c444 8a                 TXA
c445 65 61              ADC FAC1M3
c447 aa                 TAX
c448 98                 TYA
c449 a4 1f              LDY INDEXA
c44b 65 62    FiAr_82   ADC FAC1M4
c44d 86 6e              STX TMPPTD
c44f c6 05              DEC COUNT
c451 d0 ca              BNE FiAr_72         ; next subscript
c453 85 6f              STA TMPPTD+1
c455 a2 05              LDX #5              ; standard item size (REAL)
c457 a5 42              LDA VARNAM
c459 10 01              BPL FiAr_84         ; -> REAL or STRING
c45b ca                 DEX                 ; X = 4
c45c a5 43    FiAr_84   LDA VARNAM+1
c45e 10 02              BPL FiAr_86         ; -> REAL
c460 ca                 DEX
c461 ca                 DEX                 ; X = 2
c462 86 25    FiAr_86   STX FAC3M3          ; item size (I=2, S=3, R=5)
c464 a9 00              LDA #0
c466 20 80 c4           JSR Mult_16x16_A    ; # of items * item size
c469 8a                 TXA
c46a 65 55              ADC TMPPTA
c46c 85 44              STA VARPTR
c46e 98                 TYA
c46f 65 56              ADC TMPPTA+1
c471 85 45              STA VARPTR+1        ; VARPTR = array element
c473 a8                 TAY
c474 a5 44              LDA VARPTR          ; (A/Y) = VARPTR
c476 60       FiAr_Ret  RTS ;Size  379 [Find_Array]

c477                    .FILL $c477-* (0) ; 0 bytes

              ; ******************
c477            Mult_16x16 ; $c477
              ; ******************

c477 84 1f              STY INDEXA
c479 b1 5c              LDA (TMPPTC),Y
c47b 85 25              STA FAC3M3
c47d 88                 DEY
c47e b1 5c              LDA (TMPPTC),Y

              ; ************
c480            Mult_16x16_A
              ; ************

c480 85 26              STA FAC3M4          ; FAC3M3/3 = Dimension
c482 a9 10              LDA #16
c484 85 5a              STA TMPVAR          ; 16 bit multiplication
c486 a2 00              LDX #0
c488 a0 00              LDY #0
c48a 8a       Mu16_10   TXA                 ; (X/Y) = FAC3M3 * TMPPTD
c48b 0a                 ASL A
c48c aa                 TAX
c48d 98                 TYA
c48e 2a                 ROL A
c48f a8                 TAY
c490 b0 a4              BCS FiAr_76
c492 06 6e              ASL TMPPTD
c494 26 6f              ROL TMPPTD+1
c496 90 0b              BCC Mu16_20
c498 18                 CLC
c499 8a                 TXA
c49a 65 25              ADC FAC3M3
c49c aa                 TAX
c49d 98                 TYA
c49e 65 26              ADC FAC3M4
c4a0 a8                 TAY
c4a1 b0 93              BCS FiAr_76
c4a3 c6 5a    Mu16_20   DEC TMPVAR          ; next bit
c4a5 d0 e3              BNE Mu16_10
c4a7 60                 RTS ;Size   40 [Mult_16x16_A]

              ; *****************
c4a8            Basic_FRE ; $c4a8
              ; *****************

c4a8 a5 07              LDA VALTYP
c4aa f0 03              BEQ FRE_10          ; -> numeric argument
c4ac 20 b8 c7           JSR Free_String_FAC1
c4af 20 6a c6 FRE_10    JSR Garbage_Collection
c4b2 38                 SEC
c4b3 a5 30              LDA FRETOP
c4b5 e5 2e              SBC STREND
c4b7 a8                 TAY
c4b8 a5 31              LDA FRETOP+1
c4ba e5 2f              SBC STREND+1

              ; **********
c4bc            AY_To_Real
              ; **********

c4bc a2 00              LDX #0
c4be 86 07              STX VALTYP          ; numeric result
c4c0 85 5f              STA FAC1M1
c4c2 84 60              STY FAC1M2
c4c4 a2 90              LDX #$90            ; exponent
c4c6 4c 7a cd           JMP ATOF_10

              ; *****************
c4c9            Basic_POS ; $c4c9
              ; *****************

c4c9 a4 c6              LDY CursorCol

              ; **********
c4cb            Y_To_Float
              ; **********

c4cb a9 00              LDA #0
c4cd f0 ed              BEQ AY_To_Real      ; always

              ; *****************
c4cf            Assert_Non_Direct
              ; *****************

c4cf a6 37              LDX CURLIN+1
c4d1 e8                 INX
c4d2 d0 a2              BNE FiAr_Ret
c4d4 a2 95              LDX #[Msg_DIREC - Msg_Start] ; $95
c4d6 2c                 .BYTE $2c

              ; ******************
c4d7            Undefined_Function
              ; ******************

c4d7 a2 e9              LDX #[Msg_FUNC - Msg_Start] ; $e9
c4d9 4c cf b3           JMP Basic_Error

              ; *****************
c4dc            Basic_DEF ; $c4dc
              ; *****************

c4dc 20 0a c5           JSR Get_FN          ; read function name
c4df 20 cf c4           JSR Assert_Non_Direct
c4e2 20 f2 be           JSR Need_Left_Parenthesis
c4e5 a9 80              LDA #$80
c4e7 85 0a              STA SUBFLG          ; no integer function
c4e9 20 2b c1           JSR Parse_Name
c4ec 20 87 bd           JSR Is_Numeric      ; only numeric arguments
c4ef 20 ef be           JSR Need_Right_Parenthesis
c4f2 a9 b2              LDA #$b2            ; '=' token
c4f4 20 f7 be           JSR Need_A
c4f7 48                 PHA
c4f8 a5 45              LDA VARPTR+1
c4fa 48                 PHA
c4fb a5 44              LDA VARPTR          ; push function argument address
c4fd 48                 PHA
c4fe a5 78              LDA TXTPTR+1
c500 48                 PHA
c501 a5 77              LDA TXTPTR          ; push function address
c503 48                 PHA
c504 20 83 b8           JSR Basic_DATA      ; skip to next statement
c507 4c 75 c5           JMP FNX_30           ; pull and store attributes

              ; ******
c50a            Get_FN
              ; ******

c50a a9 a5              LDA #$a5            ; FN token
c50c 20 f7 be           JSR Need_A
c50f 09 80              ORA #$80
c511 85 0a              STA SUBFLG          ; no integer function
c513 20 32 c1           JSR Get_FN_Address
c516 85 4b              STA FUNCPT
c518 84 4c              STY FUNCPT+1
c51a 4c 87 bd           JMP Is_Numeric

              ; ********
c51d            Eval_FNX
              ; ********

c51d 20 0a c5           JSR Get_FN          ; address of function descriptor
c520 48                 PHA                 ; push FUNCPT
c521 98                 TYA
c522 48                 PHA                 ; push FUNCPT+1
c523 20 e9 be           JSR Eval_In_Parenthesis
c526 20 87 bd           JSR Is_Numeric      ; force numeric argument
c529 68                 PLA
c52a 85 4c              STA FUNCPT+1
c52c 68                 PLA
c52d 85 4b              STA FUNCPT          ; restore function descriptor
c52f a0 02              LDY #2
c531 b1 4b              LDA (FUNCPT),Y
c533 85 44              STA VARPTR
c535 aa                 TAX
c536 c8                 INY                 ; Y = 3
c537 b1 4b              LDA (FUNCPT),Y
c539 f0 9c              BEQ Undefined_Function
c53b 85 45              STA VARPTR+1        ; VARPTR = address of argument variable
c53d c8                 INY                 ; Y = 4
c53e b1 44    FNX_10    LDA (VARPTR),Y      ; push value of variable (5 bytes)
c540 48                 PHA
c541 88                 DEY
c542 10 fa              BPL FNX_10
c544 a4 45              LDY VARPTR+1
c546 20 0a cd           JSR FAC1_To_XY      ; (X/Y) = VARPTR - Y=0 on return
c549 a5 78              LDA TXTPTR+1
c54b 48                 PHA
c54c a5 77              LDA TXTPTR
c54e 48                 PHA                 ; push TXTPTR
c54f b1 4b              LDA (FUNCPT),Y
c551 85 77              STA TXTPTR
c553 c8                 INY                 ; Y = 1
c554 b1 4b              LDA (FUNCPT),Y
c556 85 78              STA TXTPTR+1        ; TXTPTR = function body
c558 a5 45              LDA VARPTR+1
c55a 48                 PHA
c55b a5 44              LDA VARPTR
c55d 48                 PHA                 ; push VARPTR
c55e 20 84 bd           JSR Eval_Numeric    ; execute function body
c561 68                 PLA
c562 85 4b              STA FUNCPT
c564 68                 PLA
c565 85 4c              STA FUNCPT+1        ; FUNCPT = VARPTR
c567 20 76 00           JSR CHRGOT
c56a f0 03              BEQ FNX_20
c56c 4c 00 bf           JMP Syntax_Error     ; function did not end properly
c56f 68       FNX_20    PLA
c570 85 77              STA TXTPTR
c572 68                 PLA
c573 85 78              STA TXTPTR+1         ; restore execution pointer
c575 a0 00    FNX_30    LDY #0               ; restore value of argument variable
c577 68                 PLA
c578 91 4b              STA (FUNCPT),Y
c57a 68                 PLA
c57b c8                 INY
c57c 91 4b              STA (FUNCPT),Y
c57e 68                 PLA
c57f c8                 INY
c580 91 4b              STA (FUNCPT),Y
c582 68                 PLA
c583 c8                 INY
c584 91 4b              STA (FUNCPT),Y
c586 68                 PLA
c587 c8                 INY
c588 91 4b              STA (FUNCPT),Y
c58a 60                 RTS ;Size  110 [Eval_FNX]

c58b 00 00 00           .FILL $c58e-* (0) ; 3 bytes

              ; *****************
c58e            Basic_STR ; $c58e
              ; *****************

c58e 20 87 bd           JSR Is_Numeric
c591 a0 00              LDY #0
c593 20 95 cf           JSR Format_FAC1_Y
c596 68                 PLA
c597 68                 PLA
c598 a9 ff    STR_10    LDA #<STACK-1
c59a a0 00              LDY #>STACK-1
c59c f0 12              BEQ Create_String_Descriptor

              ; ********************
c59e            Allocate_String_FAC1
              ; ********************

c59e a6 61              LDX FAC1M3
c5a0 a4 62              LDY FAC1M4
c5a2 86 4d              STX DESCPT
c5a4 84 4e              STY DESCPT+1

              ; *****************
c5a6            Allocate_String_A
              ; *****************

c5a6 20 1d c6           JSR Allocate_String_Space
c5a9 86 5f              STX FAC1M1          ; addres low
c5ab 84 60              STY FAC1M2          ; address high
c5ad 85 5e              STA FAC1EX          ; length
c5af 60                 RTS ;Size   10 [Allocate_String_A]

              ; ************************
c5b0            Create_String_Descriptor
              ; ************************

c5b0 a2 22              LDX #QUOTE          ; quote is the only valid delimiter
c5b2 86 03              STX CHARAC
c5b4 86 04              STX ENDCHR

              ; ***************************
c5b6            Create_String_Descriptor_AY
              ; ***************************

c5b6 85 6c              STA STRPTR
c5b8 84 6d              STY STRPTR+1        ; set STRPTR from (A/Y)
c5ba 85 5f              STA FAC1M1
c5bc 84 60              STY FAC1M2          ; set FAC1M1 from (A/Y)
c5be a0 ff              LDY #-1             ; start loop with 0
c5c0 c8       CSD_10    INY
c5c1 b1 6c              LDA (STRPTR),Y
c5c3 f0 0c              BEQ CSD_30          ; end of string
c5c5 c5 03              CMP CHARAC          ; closing delimiter
c5c7 f0 04              BEQ CSD_20
c5c9 c5 04              CMP ENDCHR
c5cb d0 f3              BNE CSD_10          ; loop
c5cd c9 22    CSD_20    CMP #QUOTE
c5cf f0 01              BEQ CSD_40
c5d1 18       CSD_30    CLC
c5d2 84 5e    CSD_40    STY FAC1EX          ; string length
c5d4 98                 TYA
c5d5 65 6c              ADC STRPTR          ; TMPPTD = STRPTR + strlen
c5d7 85 6e              STA TMPPTD
c5d9 a6 6d              LDX STRPTR+1
c5db 90 01              BCC CSD_50
c5dd e8                 INX
c5de 86 6f    CSD_50    STX TMPPTD+1
c5e0 a5 6d              LDA STRPTR+1
c5e2 f0 04              BEQ CSD_60          ; -> allocate if on ZP
c5e4 c9 02              CMP #2              ; -> allocate if in buffer
c5e6 d0 0b              BNE Push_String_Descriptor
c5e8 98       CSD_60    TYA                 ; A = length
c5e9 20 9e c5           JSR Allocate_String_FAC1
c5ec a6 6c              LDX STRPTR
c5ee a4 6d              LDY STRPTR+1
c5f0 20 9a c7           JSR Store_String_XY ; Copy string from (X/Y) to (FRESPC)

              ; **********************
c5f3            Push_String_Descriptor
              ; **********************

c5f3 a6 13              LDX TEMPPT
c5f5 e0 1f              CPX #TEMPST+9       ; top of temp string descriptors
c5f7 d0 05              BNE PuSD_10
c5f9 a2 c8              LDX #Msg_COMPL-Msg_Start ; $c8 FORMULA TOO COMPLEX
c5fb 4c cf b3 PuSD_Err  JMP Basic_Error
c5fe a5 5e    PuSD_10   LDA FAC1EX          ; push FAC1 descriptor
c600 95 00              STA 0,X
c602 a5 5f              LDA FAC1M1
c604 95 01              STA 1,X
c606 a5 60              LDA FAC1M2
c608 95 02              STA 2,X
c60a a0 00              LDY #0
c60c 86 61              STX FAC1M3          ; mark stack position
c60e 84 62              STY FAC1M4
c610 84 6d              STY FROUND
c612 88                 DEY                 ; Y = $ff
c613 84 07              STY VALTYP          ; type = string
c615 86 14              STX LASTPT          ; remember last used position
c617 e8                 INX
c618 e8                 INX
c619 e8                 INX
c61a 86 13              STX TEMPPT          ; increase string stack pointer
c61c 60                 RTS ;Size   42 [Push_String_Descriptor]

              ; *****************************
c61d            Allocate_String_Space ; $c61d
              ; *****************************

              ; Input:  A = length of string

              ; Output: A = length of string
              ;         X = address low
              ;         Y = address high

c61d 46 09              LSR GARBFL          ; clear bit 7 of GARBFL
c61f aa       ASS_10    TAX                 ; string length
c620 f0 38              BEQ ASS_50          ; 0 : nothing to do
c622 48                 PHA                 ; save length
c623 38                 SEC
c624 a5 30              LDA FRETOP
c626 e9 02              SBC #2
c628 85 1f              STA INDEXA
c62a a5 31              LDA FRETOP+1
c62c e9 00              SBC #0
c62e 85 20              STA INDEXA+1        ; INDEXA = FRETOP - 2
c630 a8                 TAY                 ; Y = INDEXA+1
c631 8a                 TXA                 ; A = length
c632 49 ff              EOR #$ff
c634 38                 SEC                 ; add -length
c635 65 1f              ADC INDEXA          ; (A/Y) = INDEXA - length
c637 b0 01              BCS ASS_30
c639 88                 DEY
c63a c4 2f    ASS_30    CPY STREND+1
c63c 90 1d              BCC ASS_60          ; OOM: try garbage collection
c63e d0 04              BNE ASS_40
c640 c5 2e              CMP STREND
c642 90 17              BCC ASS_60          ; OOM: try garbage collection
c644 85 32    ASS_40    STA FRESPC
c646 84 33              STY FRESPC+1        ; FRESPC = INDEXA - length
c648 a0 01              LDY #1
c64a a9 ff              LDA #$ff
c64c 91 1f              STA (INDEXA),Y      ; mark as unassigned
c64e 88                 DEY                 ; Y = 0
c64f 68                 PLA
c650 91 1f              STA (INDEXA),Y      ; store length
c652 a6 32              LDX FRESPC
c654 a4 33              LDY FRESPC+1
c656 86 30              STX FRETOP
c658 84 31              STY FRETOP+1        ; FRETOP = FRESPC
c65a 60       ASS_50    RTS ;Size   62 [Allocate_String_Space]
c65b a2 4d    ASS_60    LDX #[Msg_OOM - Msg_Start] ; $4d
c65d a5 09              LDA GARBFL
c65f 30 9a              BMI PuSD_Err           ; -> Out Of Memory
c661 20 6a c6           JSR Garbage_Collection
c664 38                 SEC
c665 66 09              ROR GARBFL          ; mark: collection done
c667 68                 PLA                 ; length
c668 d0 b5              BNE ASS_10          ; always

c66a                    .FILL $c66a-* (0) ; 0 bytes

              ; **************************
c66a            Garbage_Collection ; $c66a
              ; **************************

c66a a5 34              LDA MEMSIZ
c66c 85 32              STA FRESPC          ; new location of string
c66e 85 4b              STA FUNCPT          ; old location of string
c670 a5 35              LDA MEMSIZ+1
c672 85 33              STA FRESPC+1
c674 85 4c              STA FUNCPT+1

c676 a5 30    GaCo_05   LDA FRETOP          ; if (FRETOP >= FUNCPT)
c678 c5 4b              CMP FUNCPT
c67a a5 31              LDA FRETOP+1
c67c e5 4c              SBC FUNCPT+1
c67e b0 6b              BCS GaCo_45         ; finish

c680 a5 4b              LDA FUNCPT
c682 e9 01              SBC #1              ; subtract 2 (C=0)
c684 85 4b              STA FUNCPT
c686 b0 02              BCS GaCo_10
c688 c6 4c              DEC FUNCPT+1        ; FUNCPT -= 2

c68a a0 01    GaCo_10   LDY #1
c68c b1 4b              LDA (FUNCPT),Y      ; reference high
c68e 88                 DEY                 ; Y = 0
c68f c9 ff              CMP #$ff            ; obsolete flag
c691 d0 0c              BNE GaCo_15         ; branch to string copy
c693 a5 4b              LDA FUNCPT          ; C = 1 from CMP #$ff
c695 f1 4b              SBC (FUNCPT),Y      ; subtract length
c697 85 4b              STA FUNCPT
c699 b0 db              BCS GaCo_05         ; loop
c69b c6 4c              DEC FUNCPT+1
c69d d0 d7              BNE GaCo_05         ; loop always

c69f 85 20    GaCo_15   STA INDEXA+1        ; reference high
c6a1 b1 4b              LDA (FUNCPT),Y
c6a3 85 1f              STA INDEXA          ; reference low
c6a5 38                 SEC
c6a6 a5 4b              LDA FUNCPT
c6a8 f1 1f              SBC (INDEXA),Y      ; subtract length
c6aa 85 4b              STA FUNCPT
c6ac b0 02              BCS GaCo_20
c6ae c6 4c              DEC FUNCPT+1        ; FUNCPT -= length

c6b0 a5 32    GaCo_20   LDA FRESPC
c6b2 d0 02              BNE GaCo_25
c6b4 c6 33              DEC FRESPC+1
c6b6 c6 32    GaCo_25   DEC FRESPC          ; FRESPC--

c6b8 a5 20              LDA INDEXA+1        ; reference high
c6ba 91 32              STA (FRESPC),Y
c6bc 18                 CLC
c6bd a5 32              LDA FRESPC
c6bf f1 1f              SBC (INDEXA),Y      ; subtract length + borrow
c6c1 85 32              STA FRESPC
c6c3 b0 02              BCS GaCo_30
c6c5 c6 33              DEC FRESPC+1        ; FRESPC -= (length+1)

c6c7 c5 4b    GaCo_30   CMP FUNCPT          ; if (FRESPC == FUNCPT)
c6c9 d0 06              BNE GaCo_35         ; copy
c6cb a5 33              LDA FRESPC+1
c6cd c5 4c              CMP FUNCPT+1
c6cf f0 a5              BEQ GaCo_05         ; loop

c6d1 b1 1f    GaCo_35   LDA (INDEXA),Y      ; length
c6d3 a8                 TAY
c6d4 b1 4b    GaCo_40   LDA (FUNCPT),Y      ; copy string & low reference
c6d6 91 32              STA (FRESPC),Y
c6d8 88                 DEY
c6d9 d0 f9              BNE GaCo_40
c6db b1 4b              LDA (FUNCPT),Y
c6dd 91 32              STA (FRESPC),Y
c6df c8                 INY                 ; Y = 1
c6e0 a5 32              LDA FRESPC          ; store new reference
c6e2 91 1f              STA (INDEXA),Y
c6e4 c8                 INY
c6e5 a5 33              LDA FRESPC+1
c6e7 91 1f              STA (INDEXA),Y
c6e9 d0 8b              BNE GaCo_05         ; loop always
c6eb a5 32    GaCo_45   LDA FRESPC
c6ed 85 30              STA FRETOP
c6ef a5 33              LDA FRESPC+1
c6f1 85 31              STA FRETOP+1
c6f3 60                 RTS ;Size  138 [Garbage_Collection]

              ; ********
c6f4            FAC1_LSB
              ; ********

c6f4 a2 5e              LDX #FAC1EX
c6f6 a0 00    FACX_LSB  LDY #0
c6f8 84 65              STY BITS
c6fa c9 f9    FACB_10   CMP #-7
c6fc b0 1e              BCS FACB_Ret
c6fe a8                 TAY
c6ff b5 04              LDA 4,X
c701 85 6d              STA FROUND
c703 05 65              ORA BITS
c705 85 65              STA BITS
c707 b5 03              LDA 3,X
c709 95 04              STA 4,X
c70b b5 02              LDA 2,X
c70d 95 03              STA 3,X
c70f b5 01              LDA 1,X
c711 95 02              STA 2,X
c713 a9 00              LDA #0
c715 95 01              STA 1,X
c717 98                 TYA
c718 69 08              ADC #8
c71a d0 de              BNE FACB_10
c71c a8       FACB_Ret  TAY
c71d 60                 RTS ;Size   42 [FAC1_LSB]

c71e 00 00 00           .FILL $c74f-* (0) ; 49 bytes

              ; *******************
c74f            Concatenate ; $c74f
              ; *******************

c74f a5 62              LDA FAC1M4
c751 48                 PHA
c752 a5 61              LDA FAC1M3
c754 48                 PHA
c755 20 81 be           JSR Evaluate
c758 20 89 bd           JSR Is_String
c75b 68                 PLA
c75c 85 6c              STA STRPTR
c75e 68                 PLA
c75f 85 6d              STA STRPTR+1
c761 a0 00              LDY #0
c763 b1 6c              LDA (STRPTR),Y
c765 18                 CLC
c766 71 61              ADC (FAC1M3),Y
c768 90 05              BCC Conc_10
c76a a2 b0              LDX #Msg_LONG-Msg_Start ; $b0 STRING TOO LONG
c76c 4c cf b3           JMP Basic_Error
c76f 20 9e c5 Conc_10   JSR Allocate_String_FAC1
c772 20 8c c7           JSR Store_String_STRPTR ; store first part
c775 a5 4d              LDA DESCPT
c777 a4 4e              LDY DESCPT+1
c779 20 bc c7           JSR Free_String_AY
c77c 20 9e c7           JSR Store_String_INDEXA ; store second part
c77f a5 6c              LDA STRPTR
c781 a4 6d              LDY STRPTR+1
c783 20 bc c7           JSR Free_String_AY
c786 20 f3 c5           JSR Push_String_Descriptor
c789 4c b0 bd           JMP EvEx_15

              ; *******************
c78c            Store_String_STRPTR
              ; *******************

c78c a0 00              LDY #0
c78e b1 6c              LDA (STRPTR),Y      ; A = length
c790 48                 PHA
c791 c8                 INY
c792 b1 6c              LDA (STRPTR),Y      ; X = address low
c794 aa                 TAX
c795 c8                 INY
c796 b1 6c              LDA (STRPTR),Y      ; Y = address high
c798 a8                 TAY
c799 68                 PLA

              ; ***************
c79a            Store_String_XY
              ; ***************

c79a 86 1f              STX INDEXA
c79c 84 20              STY INDEXA+1

              ; ***************************
c79e            Store_String_INDEXA ; $c79e
              ; ***************************

c79e a8                 TAY
c79f f0 13              BEQ SSI_Ret
c7a1 48                 PHA
c7a2 88       SSI_10    DEY
c7a3 b1 1f              LDA (INDEXA),Y
c7a5 91 32              STA (FRESPC),Y
c7a7 98                 TYA
c7a8 d0 f8              BNE SSI_10
c7aa 68                 PLA
c7ab 18                 CLC
c7ac 65 32              ADC FRESPC          ; FRESPC += length
c7ae 85 32              STA FRESPC          ; (used by Concatenate)
c7b0 90 02              BCC SSI_Ret
c7b2 e6 33              INC FRESPC+1
c7b4 60       SSI_Ret   RTS ;Size   23 [Store_String_INDEXA]

              ; ****************************
c7b5            Eval_And_Free_String ; $c7b5
              ; ****************************

c7b5 20 89 bd           JSR Is_String

              ; ****************
c7b8            Free_String_FAC1
              ; ****************

c7b8 a5 61              LDA FAC1M3
c7ba a4 62              LDY FAC1M4

              ; **********************
c7bc            Free_String_AY ; $c7bc
              ; **********************

              ; Input:  (A/Y) = pointer to descriptor
              ; Output: (X/Y) = INDEXA = pointer to string
              ;         A     = length

c7bc 85 1f              STA INDEXA
c7be 84 20              STY INDEXA+1        ; INDEXA = pointer to descriptor
c7c0 20 11 c8           JSR Pop_Descriptor_Stack
c7c3 d0 28              BNE GSD_40          ; -> load if not temporary
c7c5 20 3d ba           JSR Back_Reference_Position
c7c8 90 23              BCC GSD_40          ; -> branch if not dynamic string
c7ca a9 ff              LDA #$ff
c7cc 91 4f              STA (INDEXC),Y      ; invalidate string
c7ce 88                 DEY                 ; Y = 0
c7cf 8a                 TXA
c7d0 91 4f              STA (INDEXC),Y      ; store length
c7d2 a6 1f              LDX INDEXA
c7d4 a4 20              LDY INDEXA+1
c7d6 c4 31              CPY FRETOP+1
c7d8 d0 25              BNE GSD_Ret
c7da e4 30              CPX FRETOP
c7dc d0 21              BNE GSD_Ret         ; return if INDEXA != FRETOP
c7de 48                 PHA                 ; push length
c7df a5 4f              LDA INDEXC
c7e1 69 01              ADC #1              ; add 2 (1 + carry)
c7e3 85 30              STA FRETOP
c7e5 a5 50              LDA INDEXC+1
c7e7 69 00              ADC #0
c7e9 85 31              STA FRETOP+1
c7eb 68                 PLA
c7ec 60                 RTS ;Size   49 [Free_String_AY]
c7ed a0 00    GSD_40    LDY #0              ; load descriptor from pointer
c7ef b1 1f              LDA (INDEXA),Y
c7f1 48                 PHA
c7f2 c8                 INY
c7f3 b1 1f              LDA (INDEXA),Y
c7f5 aa                 TAX
c7f6 c8                 INY
c7f7 b1 1f              LDA (INDEXA),Y
c7f9 a8                 TAY
c7fa 86 1f              STX INDEXA
c7fc 84 20              STY INDEXA+1
c7fe 68                 PLA
c7ff 60       GSD_Ret   RTS ;Size   68 [Free_String_AY]

c800 00 00 00           .FILL $c811-* (0) ; 17 bytes

              ; ****************************
c811            Pop_Descriptor_Stack ; $c811
              ; ****************************

c811 c4 15              CPY LASTPT+1
c813 d0 0c              BNE PDS_Ret
c815 c5 14              CMP LASTPT
c817 d0 08              BNE PDS_Ret
c819 85 13              STA TEMPPT
c81b e9 03              SBC #3
c81d 85 14              STA LASTPT
c81f a0 00              LDY #0
c821 60       PDS_Ret   RTS ;Size   17 [Pop_Descriptor_Stack]

              ; *********
c822            Basic_CHR
              ; *********

c822 20 d7 c8           JSR Eval_Byte       ; get byte in X
c825 8a                 TXA
c826 48                 PHA
c827 a9 01              LDA #1
c829 20 a6 c5           JSR Allocate_String_A
c82c 68                 PLA
c82d a0 00              LDY #0
c82f 91 5f              STA (FAC1M1),Y
c831 68                 PLA
c832 68                 PLA
c833 4c f3 c5           JMP Push_String_Descriptor

              ; **********
c836            Basic_LEFT
              ; **********

c836 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c839 d1 4d              CMP (DESCPT),Y      ; compare argument with length
c83b 98                 TYA                 ; A = 0
c83c 90 04    LEFT_10   BCC LEFT_20         ; branch if arg < length
c83e b1 4d              LDA (DESCPT),Y      ; get total length
c840 aa                 TAX                 ; string length
c841 98                 TYA                 ; A = 0
c842 48       LEFT_20   PHA                 ; push start index (0 for LEFT$)
c843 8a       LEFT_30   TXA                 ; A  = new length
c844 48       LEFT_40   PHA                 ; push new length
c845 20 a6 c5           JSR Allocate_String_A
c848 a5 4d              LDA DESCPT
c84a a4 4e              LDY DESCPT+1
c84c 20 bc c7           JSR Free_String_AY  ; free string argument
c84f 68                 PLA
c850 a8                 TAY                 ; Y = length
c851 68                 PLA                 ; A = start index
c852 18                 CLC
c853 65 1f              ADC INDEXA
c855 85 1f              STA INDEXA
c857 90 02              BCC LEFT_50
c859 e6 20              INC INDEXA+1        ; INDEX += start index
c85b 98       LEFT_50   TYA                 ; new length
c85c 20 9e c7           JSR Store_String_INDEXA
c85f 4c f3 c5           JMP Push_String_Descriptor

              ; ***********
c862            Basic_RIGHT
              ; ***********

c862 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c865 18                 CLC
c866 f1 4d              SBC (DESCPT),Y      ; argument - length
c868 49 ff              EOR #$ff            ; length - argument
c86a 4c 3c c8           JMP LEFT_10         ; share code with LEFT$

              ; *********
c86d            Basic_MID
              ; *********

c86d a9 ff              LDA #255            ; default value for 3rd. argument
c86f 85 62              STA FAC1M4
c871 20 76 00           JSR CHRGOT
c874 c9 29              CMP #')'
c876 f0 06              BEQ MID_10
c878 20 f5 be           JSR Need_Comma
c87b 20 d4 c8           JSR Get_Byte_Value  ; 3rd. argument to FAC1M4
c87e 20 97 c8 MID_10    JSR Pop_DESCPT      ; get string address and 2nd. argument
c881 f0 4b              BEQ ASC_Err         ; null string -> error
c883 ca                 DEX                 ; start index to offset
c884 8a                 TXA
c885 48                 PHA                 ; push offset
c886 18                 CLC
c887 a2 00              LDX #0
c889 f1 4d              SBC (DESCPT),Y      ; offset - length
c88b b0 b6              BCS LEFT_30
c88d 49 ff              EOR #$ff            ; length - offset
c88f c5 62              CMP FAC1M4
c891 90 b1              BCC LEFT_40         ; new length = rest of string
c893 a5 62              LDA FAC1M4          ; new length
c895 b0 ad              BCS LEFT_40         ; branch always

              ; **********
c897            Pop_DESCPT
              ; **********

c897 20 ef be           JSR Need_Right_Parenthesis
c89a 68                 PLA
c89b a8                 TAY                 ; return address low
c89c 68                 PLA
c89d 85 52              STA FUNJMP          ; return address high
c89f 68                 PLA
c8a0 68                 PLA
c8a1 68                 PLA
c8a2 aa                 TAX                 ; X = length
c8a3 68                 PLA
c8a4 85 4d              STA DESCPT
c8a6 68                 PLA
c8a7 85 4e              STA DESCPT+1        ; DESCPT = string address
c8a9 a5 52              LDA FUNJMP
c8ab 48                 PHA                 ; return address high
c8ac 98                 TYA
c8ad 48                 PHA                 ; return address low
c8ae a0 00              LDY #0
c8b0 8a                 TXA                 ; A = length
c8b1 60                 RTS ;Size   27 [Pop_DESCPT]

              ; *********
c8b2            Basic_LEN
              ; *********

c8b2 20 b8 c8           JSR Eval_String_Desc
c8b5 4c cb c4           JMP Y_To_Float

              ; ****************
c8b8            Eval_String_Desc
              ; ****************

c8b8 20 b5 c7           JSR Eval_And_Free_String
c8bb a2 00              LDX #0
c8bd 86 07              STX VALTYP
c8bf a8                 TAY
c8c0 60                 RTS ;Size    9 [Eval_String_Desc]

              ; *********
c8c1            Basic_ASC
              ; *********

c8c1 20 b8 c8           JSR Eval_String_Desc
c8c4 f0 05              BEQ ASC_10          ; ASC(""") was a syntax error in BASIC 4
c8c6 a0 00              LDY #0              ; here we return 0
c8c8 b1 1f              LDA (INDEXA),Y
c8ca a8                 TAY
c8cb 4c cb c4 ASC_10    JMP Y_To_Float
c8ce 4c 73 c3 ASC_Err   JMP Jump_To_Illegal_Quantity

c8d1                    .FILL $c8d1-* (0) ; 0 bytes

              ; ***************************
c8d1            Get_Next_Byte_Value ; $c8d1
              ; ***************************

c8d1 20 70 00           JSR CHRGET

              ; **************
c8d4            Get_Byte_Value
              ; **************

c8d4 20 84 bd           JSR Eval_Numeric

              ; *********
c8d7            Eval_Byte
              ; *********

c8d7 20 e3 c2           JSR Eval_Positive_Integer_Check
c8da a6 61              LDX FAC1M3
c8dc d0 f0              BNE ASC_Err
c8de a6 62              LDX FAC1M4
c8e0 4c 76 00           JMP CHRGOT

              ; *****************
c8e3            Basic_VAL ; $c8e3
              ; *****************

c8e3 20 b8 c8           JSR Eval_String_Desc
c8e6 d0 03              BNE VAL_10
c8e8 4c 2d ca           JMP Clear_FAC1
c8eb a6 77    VAL_10    LDX TXTPTR
c8ed a4 78              LDY TXTPTR+1
c8ef 86 6e              STX TMPPTD
c8f1 84 6f              STY TMPPTD+1        ; TMPPTD = TXTPTR
c8f3 a6 1f              LDX INDEXA
c8f5 86 77              STX TXTPTR
c8f7 18                 CLC
c8f8 65 1f              ADC INDEXA
c8fa 85 21              STA INDEXB
c8fc a6 20              LDX INDEXA+1
c8fe 86 78              STX TXTPTR+1        ; TXTPTR = INDEXA
c900 90 01              BCC VAL_20          ; INDEXB = INDEXA + length
c902 e8                 INX
c903 86 22    VAL_20    STX INDEXB+1
c905 a0 00              LDY #0
c907 b1 21              LDA (INDEXB),Y      ; back reference low
c909 48                 PHA
c90a 98                 TYA
c90b 91 21              STA (INDEXB),Y      ; add zero delimiter for CHRGET
c90d 20 76 00           JSR CHRGOT
c910 20 29 ce           JSR Read_Real_To_FAC1
c913 68                 PLA
c914 a0 00              LDY #0
c916 91 21              STA (INDEXB),Y      ; restore back reference low

              ; *************************
c918            Restore_Execution_Pointer
              ; *************************

c918 a6 6e              LDX TMPPTD
c91a a4 6f              LDY TMPPTD+1
c91c 86 77              STX TXTPTR
c91e 84 78              STY TXTPTR+1
c920 60                 RTS ;Size    9 [Restore_Execution_Pointer]

c921                    .FILL $c921-* (0) ; 0 bytes

              ; *************************
c921            Get_Word_And_Byte ; $c921
              ; *************************

c921 20 84 bd           JSR Eval_Numeric
c924 20 2d c9           JSR FAC1_To_LINNUM

              ; *******************
c927            Need_Comma_Get_Byte
              ; *******************

c927 20 f5 be           JSR Need_Comma
c92a 4c d4 c8           JMP Get_Byte_Value

              ; **************
c92d            FAC1_To_LINNUM
              ; **************

c92d a5 63              LDA FAC1SI
c92f 30 9d              BMI ASC_Err         ; only positive numbers
c931 a5 5e              LDA FAC1EX
c933 c9 91              CMP #$91
c935 b0 97              BCS ASC_Err         ; -> greater 65536
c937 20 d1 cd           JSR FAC1_LSR
c93a a5 61              LDA FAC1M3
c93c a4 62              LDY FAC1M4
c93e 84 11              STY LINNUM
c940 85 12              STA LINNUM+1
c942 60                 RTS ;Size   22 [FAC1_To_LINNUM]

              ; **********
c943            Basic_PEEK
              ; **********

c943 a5 12              LDA LINNUM+1
c945 48                 PHA
c946 a5 11              LDA LINNUM
c948 48                 PHA
c949 20 2d c9           JSR FAC1_To_LINNUM
c94c a0 00              LDY #0
c94e b1 11              LDA (LINNUM),Y
c950 a8                 TAY
c951 68                 PLA
c952 85 11              STA LINNUM
c954 68                 PLA
c955 85 12              STA LINNUM+1
c957 4c cb c4           JMP Y_To_Float

              ; **********
c95a            Basic_POKE
              ; **********

c95a 20 21 c9           JSR Get_Word_And_Byte
c95d 8a                 TXA
c95e a0 00              LDY #0
c960 91 11              STA (LINNUM),Y
c962 60                 RTS ;Size    9 [Basic_POKE]

              ; **********
c963            Basic_WAIT
              ; **********

c963 20 21 c9           JSR Get_Word_And_Byte
c966 86 46              STX FORPNT
c968 a2 00              LDX #0
c96a 20 76 00           JSR CHRGOT
c96d f0 03              BEQ WAIT_10
c96f 20 27 c9           JSR Need_Comma_Get_Byte
c972 86 47    WAIT_10   STX FORPNT+1
c974 a0 00              LDY #0
c976 b1 11    WAIT_20   LDA (LINNUM),Y
c978 45 47              EOR FORPNT+1
c97a 25 46              AND FORPNT
c97c f0 f8              BEQ WAIT_20
c97e 60       WAIT_Ret  RTS ;Size   28 [Basic_WAIT]

              ; ***************
c97f            Add_0_5_To_FAC1
              ; ***************

c97f a9 c7              LDA #<Float_0_5
c981 a0 d0              LDY #>Float_0_5
c983 4c 9d c9           JMP Add_Var_AY_To_FAC1

              ; *************
c986            AY_Minus_FAC1
              ; *************

c986 20 c2 cb           JSR Load_FAC2_From_AY

              ; ********
c989            Op_MINUS
              ; ********

c989 a5 63              LDA FAC1SI
c98b 49 ff              EOR #$ff
c98d 85 63              STA FAC1SI
c98f 45 6b              EOR FAC2SI
c991 85 6c              STA STRPTR          ; pos = ADD, neg = SUB
c993 a5 5e              LDA FAC1EX
c995 4c a0 c9           JMP Op_PLUS

c998 00 00 00           .FILL $c99d-* (0) ; 5 bytes

              ; ******************
c99d            Add_Var_AY_To_FAC1
              ; ******************

c99d 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***************
c9a0            Op_PLUS ; $c9a0
              ; ***************

c9a0 d0 03              BNE PLUS_10         ; -> branch if FAC1 is not 0
c9a2 4c 32 cd           JMP FAC2_To_FAC1    ; FAC1 = FAC2
c9a5 a6 6d    PLUS_10   LDX FROUND
c9a7 86 53              STX FUNJMP+1        ; copy rounding byte
c9a9 a2 66              LDX #FAC2EX         ; X points to FAC2
c9ab a5 66              LDA FAC2EX

              ; ***************************
c9ad            AddSub_FAC2_To_FAC1 ; $c9ad
              ; ***************************

              ; The mantissa of the FAC with the lower exponent is shifted
              ; right until both exponents become equal.

              ; Input:  A = exponent of FAC2
              ;         X = address  of FAC2
              ;         STRPTR ($00:Add, $80:Subtract)

              ; Output: FAC1 = FAC1 + FAC2 (for STRPTR == $00)
              ;         FAC1 = FAC1 - FAC2 (for STRPTR == $80)

c9ad a8                 TAY                 ; Y = exp 2
c9ae f0 ce              BEQ WAIT_Ret        ; return if FAC2 is zero
c9b0 38                 SEC
c9b1 e5 5e              SBC FAC1EX          ; A = exp 2 - exp 1
c9b3 f0 1b              BEQ AFTF_30         ; -> exponents are equal
c9b5 90 12              BCC AFTF_10         ; -> exp 2 < exp 1
c9b7 84 5e              STY FAC1EX          ; exp 1 = exp 2
c9b9 a4 6b              LDY FAC2SI
c9bb 84 63              STY FAC1SI          ; sign 1 = sign 2
c9bd 49 ff              EOR #$ff
c9bf 69 00              ADC #0              ; A = exp 1 - exp 2
c9c1 a0 00              LDY #0
c9c3 84 53              STY FUNJMP+1        ; clear FAC2 rounding byte
c9c5 a2 5e              LDX #FAC1EX         ; X points to FAC1
c9c7 d0 04              BNE AFTF_20         ; always
c9c9 a0 00    AFTF_10   LDY #0
c9cb 84 6d              STY FROUND          ; clear FAC1 rounding byte
c9cd 20 cf ca AFTF_20   JSR Shift_FACX_A
c9d0 24 6c    AFTF_30   BIT STRPTR          ; add or subtract ?
c9d2 10 60              BPL AFTF_60         ; -> add mantissa of FAC2 to FAC1
c9d4 a0 5e              LDY #FAC1EX
c9d6 e0 66              CPX #FAC2EX         ; if (X == FAC2) Y = FAC1
c9d8 f0 02              BEQ AFTF_40
c9da a0 66              LDY #FAC2EX         ; else           Y = FAC2
c9dc 38       AFTF_40   SEC
c9dd 49 ff              EOR #$ff            ; negate rounding byte
c9df 65 53              ADC FUNJMP+1
c9e1 85 6d              STA FROUND
c9e3 b9 04 00           LDA 4,Y
c9e6 f5 04              SBC 4,X
c9e8 85 62              STA FAC1M4
c9ea b9 03 00           LDA 3,Y
c9ed f5 03              SBC 3,X
c9ef 85 61              STA FAC1M3
c9f1 b9 02 00           LDA 2,Y
c9f4 f5 02              SBC 2,X
c9f6 85 60              STA FAC1M2
c9f8 b9 01 00           LDA 1,Y
c9fb f5 01              SBC 1,X
c9fd 85 5f              STA FAC1M1
c9ff b0 0c    AFTF_50   BCS Normalise_FAC1
ca01 20 7d ca           JSR Negate_FAC1
ca04 4c 0d ca           JMP Normalise_FAC1

ca07 00 00 00           .FILL $ca0d-* (0) ; 6 bytes

              ; **************
ca0d            Normalise_FAC1
              ; **************

ca0d a0 00              LDY #0              ; Y = 0
ca0f 98                 TYA                 ; A = 0
ca10 18                 CLC
ca11 a6 5f    NF1_10    LDX FAC1M1          ; MSB of mantissa
ca13 d0 4a              BNE AFTF_70         ; -> shift bitwise
ca15 a6 60              LDX FAC1M2          ; shift bytes
ca17 86 5f              STX FAC1M1
ca19 a6 61              LDX FAC1M3
ca1b 86 60              STX FAC1M2
ca1d a6 62              LDX FAC1M4
ca1f 86 61              STX FAC1M3
ca21 a6 6d              LDX FROUND
ca23 86 62              STX FAC1M4
ca25 84 6d              STY FROUND          ; = 0
ca27 69 08              ADC #8              ; A = shift count
ca29 c9 20              CMP #32             ; maximum shift = 32 bit
ca2b d0 e4              BNE NF1_10          ; loop

              ; **********
ca2d            Clear_FAC1
              ; **********

ca2d a9 00              LDA #0
ca2f 85 5e    CF1_10    STA FAC1EX
ca31 85 63              STA FAC1SI
ca33 60                 RTS ;Size    7 [Clear_FAC1]

ca34 65 53    AFTF_60   ADC FUNJMP+1        ; FAC1 rounding byte
ca36 85 6d              STA FROUND
ca38 a5 62              LDA FAC1M4          ; add FAC2 mantissa to FAC1
ca3a 65 6a              ADC FAC2M4
ca3c 85 62              STA FAC1M4
ca3e a5 61              LDA FAC1M3
ca40 65 69              ADC FAC2M3
ca42 85 61              STA FAC1M3
ca44 a5 60              LDA FAC1M2
ca46 65 68              ADC FAC2M2
ca48 85 60              STA FAC1M2
ca4a a5 5f              LDA FAC1M1
ca4c 65 67              ADC FAC2M1
ca4e 85 5f              STA FAC1M1
ca50 4c 6c ca           JMP Mantissa_Overflow

ca53 69 01    AFTF_65   ADC #1
ca55 06 6d              ASL FROUND
ca57 26 62              ROL FAC1M4
ca59 26 61              ROL FAC1M3
ca5b 26 60              ROL FAC1M2
ca5d 26 5f              ROL FAC1M1
ca5f 10 f2    AFTF_70   BPL AFTF_65
ca61 38                 SEC
ca62 e5 5e              SBC FAC1EX
ca64 b0 c7              BCS Clear_FAC1
ca66 49 ff              EOR #$ff
ca68 69 01              ADC #1
ca6a 85 5e              STA FAC1EX

              ; *****************
ca6c            Mantissa_Overflow
              ; *****************

ca6c 90 0e              BCC AFTF_Ret
ca6e e6 5e    AFTF_80   INC FAC1EX
ca70 f0 42              BEQ Overflow_Error
ca72 66 5f              ROR FAC1M1
ca74 66 60              ROR FAC1M2
ca76 66 61              ROR FAC1M3
ca78 66 62              ROR FAC1M4
ca7a 66 6d              ROR FROUND
ca7c 60       AFTF_Ret  RTS ;Size   17 [Mantissa_Overflow]

              ; ***********
ca7d            Negate_FAC1
              ; ***********

ca7d a5 63              LDA FAC1SI
ca7f 49 ff              EOR #$ff
ca81 85 63              STA FAC1SI

              ; ********************
ca83            Negate_FAC1_Mantissa
              ; ********************

ca83 a5 5f              LDA FAC1M1
ca85 49 ff              EOR #$ff
ca87 85 5f              STA FAC1M1
ca89 a5 60              LDA FAC1M2
ca8b 49 ff              EOR #$ff
ca8d 85 60              STA FAC1M2
ca8f a5 61              LDA FAC1M3
ca91 49 ff              EOR #$ff
ca93 85 61              STA FAC1M3
ca95 a5 62              LDA FAC1M4
ca97 49 ff              EOR #$ff
ca99 85 62              STA FAC1M4
ca9b a5 6d              LDA FROUND
ca9d 49 ff              EOR #$ff
ca9f 85 6d              STA FROUND
caa1 e6 6d              INC FROUND
caa3 d0 0e              BNE IFM_Ret

              ; *****************
caa5            Inc_FAC1_Mantissa
              ; *****************

caa5 e6 62              INC FAC1M4
caa7 d0 0a              BNE IFM_Ret
caa9 e6 61              INC FAC1M3
caab d0 06              BNE IFM_Ret
caad e6 60              INC FAC1M2
caaf d0 02              BNE IFM_Ret
cab1 e6 5f              INC FAC1M1
cab3 60       IFM_Ret   RTS ;Size   15 [Inc_FAC1_Mantissa]

              ; **************
cab4            Overflow_Error
              ; **************

cab4 a2 45              LDX #Msg_FLOW-Msg_Start ; $45 OVERFLOW
cab6 4c cf b3           JMP Basic_Error

              ; **********
cab9            Shift_FAC3
              ; **********

cab9 a5 26              LDA FAC3M4
cabb 85 6d              STA FROUND
cabd a5 25              LDA FAC3M3
cabf 85 26              STA FAC3M4
cac1 a5 24              LDA FAC3M2
cac3 85 25              STA FAC3M3
cac5 a5 23              LDA FAC3M1
cac7 85 24              STA FAC3M2
cac9 a9 00              LDA #0
cacb 85 23              STA FAC3M1
cacd 60                 RTS ;Size   21 [Shift_FAC3]

cace 00                 .FILL $cacf-* (0) ; 1 bytes

              ; perform a byte shift right on FAC X
              ; the LSB byte goes to FROUND

              ; ************
cacf            Shift_FACX_A
              ; ************

cacf 20 f6 c6           JSR FACX_LSB
cad2 a5 6d              LDA FROUND          ; byte shifted off
cad4 c0 00              CPY #0
cad6 10 0c              BPL SFA_40          ; return if done
cad8 56 01    SFA_10    LSR 1,X
cada 76 02              ROR 2,X
cadc 76 03              ROR 3,X
cade 76 04              ROR 4,X
cae0 6a                 ROR A               ; A gets bits shifted out
cae1 c8                 INY
cae2 d0 f4              BNE SFA_10
cae4 18       SFA_40    CLC
cae5 60                 RTS ;Size   23 [Shift_FACX_A]

cae6 00 00 00           .FILL $caf2-* (0) ; 12 bytes

              ; **************
caf2            REAL_1 ; $caf2
              ; **************

caf2 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000
caf7 03       VLOG_A    .BYTE $03
caf8 7f 5e 56 cb 79     .REAL $7f5e56cb79   ;    0.43425594189
cafd 80 13 9b 0b 64     .REAL $80139b0b64   ;    0.57658454124
cb02 80 76 38 93 16     .REAL $8076389316   ;    0.96180075919
cb07 82 38 aa 3b 20     .REAL $8238aa3b20   ;    2.88539007306

              ; ***********
cb0c            HALF_SQRT_2
              ; ***********

cb0c 80 35 04 f3 34     .REAL $803504f334   ;    0.70710678119
cb11 81 35 04 SQRT_2    .REAL $813504f334   ;    1.41421356238

              ; *********
cb16            MINUS_0_5
              ; *********

cb16 80 80 00 00 00     .REAL $8080000000   ;   -0.50000000000
cb1b 80 31 72 LN_2      .REAL $80317217f8   ;    0.69314718060

              ; *********
cb20            Basic_LOG
              ; *********

cb20 20 61 cd           JSR Get_FAC1_Sign
cb23 f0 02              BEQ LOG_10
cb25 10 03              BPL LOG_20
cb27 4c 73 c3 LOG_10    JMP Jump_To_Illegal_Quantity
cb2a a5 5e    LOG_20    LDA FAC1EX
cb2c e9 7f              SBC #$7f
cb2e 48                 PHA
cb2f a9 80              LDA #$80
cb31 85 5e              STA FAC1EX
cb33 a9 0c              LDA #<HALF_SQRT_2
cb35 a0 cb              LDY #>HALF_SQRT_2
cb37 20 9d c9           JSR Add_Var_AY_To_FAC1
cb3a a9 11              LDA #<SQRT_2
cb3c a0 cb              LDY #>SQRT_2
cb3e 20 45 cc           JSR AY_Divided_By_FAC1
cb41 a9 f2              LDA #<REAL_1
cb43 a0 ca              LDY #>REAL_1
cb45 20 86 c9           JSR AY_Minus_FAC1
cb48 a9 f7              LDA #<VLOG_A
cb4a a0 ca              LDY #>VLOG_A
cb4c 20 d7 d1           JSR Square_And_Series_Eval
cb4f a9 16              LDA #<MINUS_0_5
cb51 a0 cb              LDY #>MINUS_0_5
cb53 20 9d c9           JSR Add_Var_AY_To_FAC1
cb56 68                 PLA
cb57 20 b4 ce           JSR Add_A_To_FAC1
cb5a a9 1b              LDA #<LN_2
cb5c a0 cb              LDY #>LN_2

              ; *********************
cb5e            Multiply_FAC1_With_AY
              ; *********************

cb5e 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***********
cb61            Op_MULTIPLY
              ; ***********

cb61 f0 5b              BEQ MULT_Ret
cb63 20 ed cb           JSR Check_FAC
cb66 a9 00              LDA #0
cb68 85 23              STA FAC3M1
cb6a 85 24              STA FAC3M2
cb6c 85 25              STA FAC3M3
cb6e 85 26              STA FAC3M4
cb70 a5 6d              LDA FROUND
cb72 20 8c cb           JSR Mult_SubA
cb75 a5 62              LDA FAC1M4
cb77 20 8c cb           JSR Mult_SubA
cb7a a5 61              LDA FAC1M3
cb7c 20 8c cb           JSR Mult_SubA
cb7f a5 60              LDA FAC1M2
cb81 20 8c cb           JSR Mult_SubA
cb84 a5 5f              LDA FAC1M1
cb86 20 91 cb           JSR Mult_SubB
cb89 4c c5 cc           JMP FAC3_To_FAC1

              ; *********
cb8c            Mult_SubA
              ; *********

cb8c d0 03              BNE Mult_SubB       ; do multiply if A is not zero
cb8e 4c b9 ca           JMP Shift_FAC3      ; else shift FAC3 right 8 bits

              ; *********
cb91            Mult_SubB
              ; *********

cb91 4a                 LSR A
cb92 09 80              ORA #$80            ; make sure, that A remains not zero
cb94 a8       MULT_20   TAY                 ; until 8 shifts are done
cb95 90 19              BCC MULT_30
cb97 18                 CLC
cb98 a5 26              LDA FAC3M4
cb9a 65 6a              ADC FAC2M4
cb9c 85 26              STA FAC3M4
cb9e a5 25              LDA FAC3M3
cba0 65 69              ADC FAC2M3
cba2 85 25              STA FAC3M3
cba4 a5 24              LDA FAC3M2
cba6 65 68              ADC FAC2M2
cba8 85 24              STA FAC3M2
cbaa a5 23              LDA FAC3M1
cbac 65 67              ADC FAC2M1
cbae 85 23              STA FAC3M1
cbb0 66 23    MULT_30   ROR FAC3M1
cbb2 66 24              ROR FAC3M2
cbb4 66 25              ROR FAC3M3
cbb6 66 26              ROR FAC3M4
cbb8 66 6d              ROR FROUND
cbba 98                 TYA
cbbb 4a                 LSR A
cbbc d0 d6              BNE MULT_20
cbbe 60       MULT_Ret  RTS ;Size   46 [Mult_SubB]

cbbf 00 00 00           .FILL $cbc2-* (0) ; 3 bytes

              ; *************************
cbc2            Load_FAC2_From_AY ; $cbc2
              ; *************************

              ; Input:  (A/Y) = address of packed floating point value
              ; Output: FAC2  = read floating point value
              ;         A     = exponent of FAC1
              ;         Y     = 0

cbc2 85 1f              STA INDEXA
cbc4 84 20              STY INDEXA+1
cbc6 a0 04              LDY #4
cbc8 b1 1f              LDA (INDEXA),Y
cbca 85 6a              STA FAC2M4
cbcc 88                 DEY
cbcd b1 1f              LDA (INDEXA),Y
cbcf 85 69              STA FAC2M3
cbd1 88                 DEY
cbd2 b1 1f              LDA (INDEXA),Y
cbd4 85 68              STA FAC2M2
cbd6 88                 DEY
cbd7 b1 1f              LDA (INDEXA),Y      ; bit7 = sign
cbd9 85 6b              STA FAC2SI          ; transfer sign to FAC2SI bit7
cbdb 45 63              EOR FAC1SI          ; EOR with sign of FAC1
cbdd 85 6c              STA STRPTR          ; flag sign comparison
cbdf a5 6b              LDA FAC2SI          ; load sign/byte 1 of mantissa
cbe1 09 80              ORA #$80            ; replace sign with 1 (normalize)
cbe3 85 67              STA FAC2M1          ; M1 is now in unpacked mode
cbe5 88                 DEY
cbe6 b1 1f              LDA (INDEXA),Y      ; exponent
cbe8 85 66              STA FAC2EX
cbea a5 5e              LDA FAC1EX          ; return with FAC1 exp in A
cbec 60                 RTS ;Size   43 [Load_FAC2_From_AY]

              ; *********
cbed            Check_FAC
              ; *********

cbed a5 66              LDA FAC2EX
cbef f0 1c    ChFA_10   BEQ ChFA_50         ; -> set FAC1 = 0.0
cbf1 18                 CLC
cbf2 65 5e              ADC FAC1EX          ; (exp 1 + exp 2)
cbf4 90 04              BCC ChFA_20         ; -> no overflow
cbf6 30 1a              BMI ChFA_Err        ; -> overflow
cbf8 18                 CLC
cbf9 2c                 .BYTE $2c
cbfa 10 11    ChFA_20   BPL ChFA_50         ; -> underflow
cbfc 69 80              ADC #$80            ; correct bias
cbfe 85 5e              STA FAC1EX          ; exp 1 += exp 2
cc00 f0 02              BEQ ChFA_30
cc02 a5 6c              LDA STRPTR
cc04 85 63    ChFA_30   STA FAC1SI
cc06 60                 RTS ;Size   26 [Check_FAC]
cc07 a5 63    ChFA_40   LDA FAC1SI
cc09 49 ff              EOR #$ff
cc0b 30 05              BMI ChFA_Err
cc0d 68       ChFA_50   PLA
cc0e 68                 PLA
cc0f 4c 2d ca           JMP Clear_FAC1      ; underflow -> set FAC1 = 0.0
cc12 4c b4 ca ChFA_Err  JMP Overflow_Error  ; overflow  -> error

cc15 00 00 00           .FILL $cc18-* (0) ; 3 bytes

              ; ***************************
cc18            Multiply_FAC1_BY_10 ; $cc18
              ; ***************************

cc18 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2   ; FAC2 = FAC1
cc1b aa                 TAX                               ; A = Exponent
cc1c f0 10              BEQ Mul10_Ret
cc1e 18                 CLC
cc1f 69 02              ADC #2                            ; FAC2 *= 4
cc21 b0 ef              BCS ChFA_Err

              ; **************
cc23            Add_And_Double
              ; **************

cc23 a2 00              LDX #0
cc25 86 6c              STX STRPTR                        ; choose ADD
cc27 20 ad c9           JSR AddSub_FAC2_To_FAC1           ; FAC1 += FAC2   (*  5)
cc2a e6 5e              INC FAC1EX                        ; FAC1 *= 2      (* 10)
cc2c f0 e4              BEQ ChFA_Err
cc2e 60       Mul10_Ret RTS ;Size   12 [Add_And_Double]

              ; ********
cc2f            Float_10
              ; ********

cc2f 84 20 00 00 00     .REAL $8420000000   ;   10.00000000000

              ; *****************
cc34            Divide_FAC1_By_10
              ; *****************

cc34 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
cc37 a9 2f              LDA #<Float_10
cc39 a0 cc              LDY #>Float_10
cc3b a2 00              LDX #0

              ; *****************
cc3d            Divide_FAC2_By_AY
              ; *****************

cc3d 86 6c              STX STRPTR
cc3f 20 d8 cc           JSR Load_FAC1_AY
cc42 4c 48 cc           JMP Op_DIVIDE

              ; ******************
cc45            AY_Divided_By_FAC1
              ; ******************

cc45 20 c2 cb           JSR Load_FAC2_From_AY

              ; *********
cc48            Op_DIVIDE
              ; *********

cc48 f0 76              BEQ Divide_By_Zero
cc4a 20 51 cd           JSR Round_FAC1
cc4d a9 00              LDA #0
cc4f 38                 SEC
cc50 e5 5e              SBC FAC1EX
cc52 85 5e              STA FAC1EX
cc54 20 ed cb           JSR Check_FAC
cc57 e6 5e              INC FAC1EX
cc59 f0 b7              BEQ ChFA_Err
cc5b a2 fc              LDX #$fc            ; wrap around index
cc5d a9 01              LDA #1
cc5f a4 67    DIV_10    LDY FAC2M1
cc61 c4 5f              CPY FAC1M1
cc63 d0 10              BNE DIV_20
cc65 a4 68              LDY FAC2M2
cc67 c4 60              CPY FAC1M2
cc69 d0 0a              BNE DIV_20
cc6b a4 69              LDY FAC2M3
cc6d c4 61              CPY FAC1M3
cc6f d0 04              BNE DIV_20
cc71 a4 6a              LDY FAC2M4
cc73 c4 62              CPY FAC1M4
cc75 08       DIV_20    PHP
cc76 2a                 ROL A
cc77 90 09              BCC DIV_30
cc79 e8                 INX
cc7a 95 26              STA FAC3M4,X
cc7c f0 32              BEQ DIV_60
cc7e 10 34              BPL DIV_70
cc80 a9 01              LDA #1
cc82 28       DIV_30    PLP
cc83 b0 0e              BCS DIV_50
cc85 06 6a    DIV_40    ASL FAC2M4
cc87 26 69              ROL FAC2M3
cc89 26 68              ROL FAC2M2
cc8b 26 67              ROL FAC2M1
cc8d b0 e6              BCS DIV_20
cc8f 30 ce              BMI DIV_10
cc91 10 e2              BPL DIV_20
cc93 a8       DIV_50    TAY
cc94 a5 6a              LDA FAC2M4
cc96 e5 62              SBC FAC1M4
cc98 85 6a              STA FAC2M4
cc9a a5 69              LDA FAC2M3
cc9c e5 61              SBC FAC1M3
cc9e 85 69              STA FAC2M3
cca0 a5 68              LDA FAC2M2
cca2 e5 60              SBC FAC1M2
cca4 85 68              STA FAC2M2
cca6 a5 67              LDA FAC2M1
cca8 e5 5f              SBC FAC1M1
ccaa 85 67              STA FAC2M1
ccac 98                 TYA
ccad 4c 85 cc           JMP DIV_40
ccb0 a9 40    DIV_60    LDA #$40
ccb2 d0 ce              BNE DIV_30
ccb4 0a       DIV_70    ASL A
ccb5 0a                 ASL A
ccb6 0a                 ASL A
ccb7 0a                 ASL A
ccb8 0a                 ASL A
ccb9 0a                 ASL A
ccba 85 6d              STA FROUND
ccbc 28                 PLP
ccbd 4c c5 cc           JMP FAC3_To_FAC1

              ; **************
ccc0            Divide_By_Zero
              ; **************

ccc0 a2 85              LDX #Msg_DIV-Msg_Start ; $85
ccc2 4c cf b3           JMP Basic_Error

              ; ************
ccc5            FAC3_To_FAC1
              ; ************

ccc5 a5 23              LDA FAC3M1
ccc7 85 5f              STA FAC1M1
ccc9 a5 24              LDA FAC3M2
cccb 85 60              STA FAC1M2
cccd a5 25              LDA FAC3M3
cccf 85 61              STA FAC1M3
ccd1 a5 26              LDA FAC3M4
ccd3 85 62              STA FAC1M4
ccd5 4c 0d ca           JMP Normalise_FAC1

              ; ********************
ccd8            Load_FAC1_AY ; $ccd8
              ; ********************

ccd8 85 1f              STA INDEXA
ccda 84 20              STY INDEXA+1
ccdc a0 04              LDY #4
ccde b1 1f    LFAY_10   LDA (INDEXA),Y
cce0 99 5e 00           STA FAC1EX,Y
cce3 88                 DEY
cce4 10 f8              BPL LFAY_10
cce6 c8                 INY                 ; Y = 0
cce7 84 6d              STY FROUND          ; rounding byte
cce9 a5 5f              LDA FAC1M1
cceb 85 63              STA FAC1SI
cced 09 80              ORA #$80
ccef 85 5f              STA FAC1M1
ccf1 a5 5e              LDA FAC1EX
ccf3 60                 RTS ;Size   28 [Load_FAC1_AY]

              ; ********
ccf4            Set_FAC1
              ; ********

ccf4 85 5f              STA FAC1M1
ccf6 85 60              STA FAC1M2
ccf8 85 61              STA FAC1M3
ccfa 85 62              STA FAC1M4
ccfc 60                 RTS ;Size    9 [Set_FAC1]

ccfd                    .FILL $ccfd-* (0) ; 0 bytes

              ; **********************
ccfd            FAC1_To_FACTPB ; $ccfd
              ; **********************

ccfd a2 59              LDX #FACTPB ; $59
ccff 2c                 .BYTE $2c

              ; **************
cd00            FAC1_To_FACTPA
              ; **************

cd00 a2 54              LDX #<FACTPA
cd02 a0 00              LDY #>FACTPA
cd04 f0 04              BEQ FAC1_To_XY      ; always

              ; **************
cd06            FAC1_To_FORPNT
              ; **************

cd06 a6 46              LDX FORPNT
cd08 a4 47              LDY FORPNT+1

              ; **********
cd0a            FAC1_To_XY
              ; **********

cd0a 20 51 cd           JSR Round_FAC1
cd0d 86 1f              STX INDEXA
cd0f 84 20              STY INDEXA+1
cd11 a0 04              LDY #4
cd13 a5 62              LDA FAC1M4
cd15 91 1f              STA (INDEXA),Y
cd17 88                 DEY
cd18 a5 61              LDA FAC1M3
cd1a 91 1f              STA (INDEXA),Y
cd1c 88                 DEY
cd1d a5 60              LDA FAC1M2
cd1f 91 1f              STA (INDEXA),Y
cd21 88                 DEY
cd22 a5 63              LDA FAC1SI
cd24 09 7f              ORA #$7f
cd26 25 5f              AND FAC1M1
cd28 91 1f              STA (INDEXA),Y
cd2a 88                 DEY
cd2b a5 5e              LDA FAC1EX
cd2d 91 1f              STA (INDEXA),Y
cd2f 84 6d              STY FROUND
cd31 60                 RTS ;Size   40 [FAC1_To_XY]

              ; ************
cd32            FAC2_To_FAC1
              ; ************

cd32 a5 6b              LDA FAC2SI

              ; *********************
cd34            Copy_ABS_FAC2_To_FAC1
              ; *********************

cd34 85 63              STA FAC1SI
cd36 a2 05              LDX #5
cd38 b5 65    F1F2_10   LDA FAC2EX-1,X
cd3a 95 5d              STA FAC1EX-1,X
cd3c ca                 DEX
cd3d d0 f9              BNE F1F2_10
cd3f 86 6d              STX FROUND ; 0
cd41 60                 RTS ;Size   14 [Copy_ABS_FAC2_To_FAC1]

              ; ***************************
cd42            FAC1_Round_And_Copy_To_FAC2
              ; ***************************

cd42 20 51 cd           JSR Round_FAC1

              ; ************
cd45            FAC1_To_FAC2
              ; ************

cd45 a2 06              LDX #6
cd47 b5 5d    FA12_10   LDA FAC1EX-1,X
cd49 95 65              STA FAC2EX-1,X
cd4b ca                 DEX
cd4c d0 f9              BNE FA12_10
cd4e 86 6d              STX FROUND ; 0
cd50 60       FA12_Ret  RTS ;Size   12 [FAC1_To_FAC2]

              ; **********
cd51            Round_FAC1
              ; **********

cd51 a5 5e              LDA FAC1EX
cd53 f0 fb              BEQ FA12_Ret
cd55 06 6d              ASL FROUND
cd57 90 f7              BCC FA12_Ret

              ; ********
cd59            Inc_FAC1
              ; ********

cd59 20 a5 ca           JSR Inc_FAC1_Mantissa
cd5c d0 f2              BNE FA12_Ret
cd5e 4c 6e ca           JMP AFTF_80

              ; *************
cd61            Get_FAC1_Sign
              ; *************

cd61 a5 5e              LDA FAC1EX
cd63 f0 09              BEQ GFS_Ret
cd65 a5 63    GFS_10    LDA FAC1SI
cd67 2a       GFS_20    ROL A
cd68 a9 ff              LDA #$ff
cd6a b0 02              BCS GFS_Ret
cd6c a9 01              LDA #1
cd6e 60       GFS_Ret   RTS ;Size   14 [Get_FAC1_Sign]

              ; *********
cd6f            Basic_SGN
              ; *********

cd6f 20 61 cd           JSR Get_FAC1_Sign

              ; *********
cd72            A_To_FAC1
              ; *********

cd72 85 5f              STA FAC1M1
cd74 a9 00              LDA #0
cd76 85 60              STA FAC1M2
cd78 a2 88              LDX #$88
cd7a a5 5f    ATOF_10   LDA FAC1M1
cd7c 49 ff              EOR #$ff
cd7e 2a                 ROL A               ; clear carry for negative numbers

              ; ***********************
cd7f            Convert_Integer_To_Real
              ; ***********************

cd7f a9 00              LDA #0
cd81 85 62              STA FAC1M4
cd83 85 61              STA FAC1M3
cd85 86 5e    CITR_10   STX FAC1EX
cd87 85 6d              STA FROUND
cd89 85 63              STA FAC1SI
cd8b 4c ff c9           JMP AFTF_50

              ; *********
cd8e            Basic_ABS
              ; *********

cd8e 46 63              LSR FAC1SI          ; clear bit 7 (sign)
cd90 60                 RTS ;Size    3 [Basic_ABS]

              ; ***************
cd91            Compare_FAC1_AY
              ; ***************

cd91 85 21              STA INDEXB

              ; *********************
cd93            Compare_FAC1_INDEXB_Y
              ; *********************

cd93 84 22              STY INDEXB+1        ; (INDEXB) = operand 2
cd95 a0 00              LDY #0
cd97 b1 21              LDA (INDEXB),Y      ; exp 2
cd99 c8                 INY                 ; Y = 1
cd9a aa                 TAX
cd9b f0 c4              BEQ Get_FAC1_Sign   ; branch if operand 2 is zero
cd9d b1 21              LDA (INDEXB),Y      ; M1
cd9f 45 63              EOR FAC1SI          ; EOR both sign bits
cda1 30 c2              BMI GFS_10          ; branch on different signs
cda3 e4 5e              CPX FAC1EX          ; compare exponents
cda5 d0 21              BNE CFAY_10         ; branch if not equal
cda7 b1 21              LDA (INDEXB),Y      ; M1
cda9 09 80              ORA #$80            ; remove sign
cdab c5 5f              CMP FAC1M1          ; compare M1's
cdad d0 19              BNE CFAY_10
cdaf c8                 INY                 ; Y = 2
cdb0 b1 21              LDA (INDEXB),Y
cdb2 c5 60              CMP FAC1M2          ; compare M2's
cdb4 d0 12              BNE CFAY_10
cdb6 c8                 INY                 ; Y = 3
cdb7 b1 21              LDA (INDEXB),Y
cdb9 c5 61              CMP FAC1M3          ; compare M3's
cdbb d0 0b              BNE CFAY_10
cdbd c8                 INY                 ; Y = 4
cdbe a9 7f              LDA #$7f
cdc0 c5 6d              CMP FROUND          ; $7f >= FROUND ?
cdc2 b1 21              LDA (INDEXB),Y
cdc4 e5 62              SBC FAC1M4          ; compare M4's and FROUND
cdc6 f0 39              BEQ FLSR_Ret
cdc8 a5 63    CFAY_10   LDA FAC1SI
cdca 90 02              BCC CFAY_20
cdcc 49 ff              EOR #$ff
cdce 4c 67 cd CFAY_20   JMP GFS_20

              ; ********
cdd1            FAC1_LSR
              ; ********

              ; Shift FAC1 right until the exponent is at $a0.
              ; This is the value for which the four mantissa bytes
              ; represent a 32 bit integer value.

cdd1 a5 5e              LDA FAC1EX
cdd3 d0 03              BNE FLSR_20
cdd5 4c f4 cc FLSR_10   JMP Set_FAC1        ; clear mantissa for zero exp
cdd8 38       FLSR_20   SEC
cdd9 e9 a0              SBC #$a0
cddb 20 f4 c6           JSR FAC1_LSB        ; shift bytes
cdde f0 1f              BEQ FLSR_40         ; -> done
cde0 a5 65              LDA BITS            ; check integer status
cde2 f0 02              BEQ FLSR_30         ; branch on integer
cde4 a9 80              LDA #$80            ; real
cde6 46 5f    FLSR_30   LSR FAC1M1          ; do a bit shift
cde8 66 60              ROR FAC1M2
cdea 66 61              ROR FAC1M3
cdec 66 62              ROR FAC1M4
cdee 66 6d              ROR FROUND
cdf0 05 6d              ORA FROUND          ; remember bits shifted off
cdf2 c8                 INY
cdf3 d0 f1              BNE FLSR_30
cdf5 24 63              BIT FAC1SI
cdf7 10 06              BPL FLSR_40         ; positive: finished
cdf9 0a                 ASL A               ; any 1 bits shifted off ?
cdfa 90 03              BCC FLSR_40         ; -> number was exact integer
cdfc 20 a5 ca           JSR Inc_FAC1_Mantissa ; subtract 1 from negative number
cdff 84 6d    FLSR_40   STY FROUND          ; FROUND = 0
ce01 60       FLSR_Ret  RTS ;Size   49 [FAC1_LSR]

ce02                    .FILL $ce02-* (0) ; 0 bytes

              ; *****************
ce02            Basic_INT ; $ce02
              ; *****************

              ; The BASIC int function is not restricted to the 16 bit
              ; range of integer variables. Its range is 32 bit.
              ; INT does not round, it looks for the integer lower or
              ; equal to the given value. E.g: int(-1.1) results in -2.

ce02 a5 5e              LDA FAC1EX
ce04 c9 a0              CMP #$a0
ce06 b0 f9              BCS FLSR_Ret        ; -> no bits after decimal point
ce08 20 d1 cd           JSR FAC1_LSR        ; normalise to integer
ce0b a9 a0              LDA #$a0
ce0d 85 5e              STA FAC1EX          ; set exponent for integer mantissa
ce0f a5 62              LDA FAC1M4
ce11 24 63              BIT FAC1SI
ce13 10 05              BPL INT_10
ce15 38                 SEC
ce16 a9 00              LDA #0
ce18 e5 62              SBC FAC1M4
ce1a 85 03    INT_10    STA CHARAC          ; needed from Basic_EXP
ce1c 4c 0d ca           JMP Normalise_FAC1  ; normalise back to real

ce1f 00 00 00           .FILL $ce29-* (0) ; 10 bytes

              ; *************************
ce29            Read_Real_To_FAC1 ; $ce29
              ; *************************

              ; This subroutine parses a string via CHRGET and
              ; converts it into a floating point value in FAC1.

              ;         TMPVAR   = digits after decimal point
              ;         TMPVAR+1 = exponent
              ;         TMPPTC   = bit 7 : flag for '.' decimal point
              ;         TMPPTC+1 = bit 7 : flag for '-' sign

ce29 a0 00              LDY #0
ce2b a2 0a              LDX #10
ce2d 94 5a    RRTF_02   STY TMPVAR,X        ; clear TMPVAR, TMPPTC and FAC1
ce2f ca                 DEX
ce30 10 fb              BPL RRTF_02         ; X = $ff at end
ce32 90 68              BCC RRTF_34         ; -> numeric
ce34 c9 2b              CMP #'+'            ; positive sign ?
ce36 f0 06              BEQ RRTF_04         ; -> get next
ce38 c9 2d              CMP #'-'            ; negative sign ?
ce3a d0 07              BNE RRTF_06
ce3c 86 64              STX SGNFLG          ; sign flag = $ff
ce3e 20 70 00 RRTF_04   JSR CHRGET          ; next character after sign
ce41 90 59              BCC RRTF_34         ; -> numeric
ce43 c9 2e    RRTF_06   CMP #'.'            ; decimal point ?
ce45 f0 2c              BEQ RRTF_20         ; -> now the fractional part
ce47 c9 45              CMP #'E'            ; exponent ?
ce49 d0 2e              BNE RRTF_22
ce4b 20 70 00           JSR CHRGET          ; read character of exponent
ce4e 90 77              BCC RRTF_40         ; -> numeric
ce50 c9 aa              CMP #$aa            ; '+' token
ce52 f0 0e              BEQ RRTF_10
ce54 c9 2b              CMP #'+'            ; '+' sign of exponent
ce56 f0 0a              BEQ RRTF_10
ce58 c9 ab              CMP #$ab            ; '-' token
ce5a f0 04              BEQ RRTF_08
ce5c c9 2d              CMP #'-'            ; '-' sign of exponent
ce5e d0 07              BNE RRTF_12
ce60 66 5d    RRTF_08   ROR TMPPTC+1        ; flag negative sign
ce62 20 70 00 RRTF_10   JSR CHRGET          ; read character of exponent
ce65 90 60              BCC RRTF_40         ; -> numeric
ce67 24 5d    RRTF_12   BIT TMPPTC+1
ce69 10 0e              BPL RRTF_22         ; -> positive exponent
ce6b a9 00              LDA #0
ce6d 38                 SEC
ce6e e5 5b              SBC TMPVAR+1        ; -> negative exponent
ce70 4c 7b ce           JMP RRTF_24

ce73 66 5c    RRTF_20   ROR TMPPTC          ; bit 7 = flag for '.'
ce75 24 5c              BIT TMPPTC
ce77 50 c5              BVC RRTF_04         ; break if 2nd. dot read

ce79 a5 5b    RRTF_22   LDA TMPVAR+1        ; exponent read
ce7b 38       RRTF_24   SEC
ce7c e5 5a              SBC TMPVAR          ; minus # of digits after '.'
ce7e 85 5b              STA TMPVAR+1        ; effective exponent
ce80 f0 12              BEQ RRTF_30         ; -> zero exponent
ce82 10 09              BPL RRTF_28         ; -> pos. exponent

ce84 20 34 cc RRTF_26   JSR Divide_FAC1_By_10 ; neg. exponent
ce87 e6 5b              INC TMPVAR+1
ce89 d0 f9              BNE RRTF_26
ce8b f0 07              BEQ RRTF_30

ce8d 20 18 cc RRTF_28   JSR Multiply_FAC1_BY_10 ; apply positive exponent
ce90 c6 5b              DEC TMPVAR+1
ce92 d0 f9              BNE RRTF_28

ce94 a5 64    RRTF_30   LDA SGNFLG
ce96 30 01              BMI RRTF_32         ; -> negate result
ce98 60                 RTS ;Size  112 [Read_Real_To_FAC1]

ce99 4c 4b d1 RRTF_32   JMP Op_NEGATE

ce9c 48       RRTF_34   PHA                 ; result = result * 10 + digit
ce9d 24 5c              BIT TMPPTC
ce9f 10 02              BPL RRTF_36
cea1 e6 5a              INC TMPVAR          ; count digits after decimal point
cea3 20 18 cc RRTF_36   JSR Multiply_FAC1_BY_10
cea6 68                 PLA
cea7 29 0f              AND #15             ; PETSCII -> binary
cea9 20 b4 ce           JSR Add_A_To_FAC1
ceac 4c 3e ce           JMP RRTF_04

ceaf 00 00 00           .FILL $ceb4-* (0) ; 5 bytes

              ; *********************
ceb4            Add_A_To_FAC1 ; $ceb4
              ; *********************

ceb4 48                 PHA
ceb5 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
ceb8 68                 PLA
ceb9 20 72 cd           JSR A_To_FAC1
cebc a5 6b              LDA FAC2SI
cebe 45 63              EOR FAC1SI
cec0 85 6c              STA STRPTR
cec2 a6 5e              LDX FAC1EX
cec4 4c a0 c9           JMP Op_PLUS

              ; read digits for exponent

cec7 a5 5b    RRTF_40   LDA TMPVAR+1        ; exponent so far
cec9 c9 0a              CMP #10             ; alreay two digits ?
cecb 90 09              BCC RRTF_42         ; -> OK if less than 10
cecd a9 64              LDA #100            ; exponent = 100
cecf 24 5d              BIT TMPPTC+1
ced1 30 11              BMI RRTF_44         ; -> negative exponent
ced3 4c b4 ca           JMP Overflow_Error  ; max value = 37
ced6 0a       RRTF_42   ASL A               ; * 2
ced7 0a                 ASL A               ; * 4
ced8 18                 CLC
ced9 65 5b              ADC TMPVAR+1        ; * 5
cedb 0a                 ASL A               ; * 10
cedc 18                 CLC
cedd a0 00              LDY #0
cedf 71 77              ADC (TXTPTR),Y
cee1 38                 SEC
cee2 e9 30              SBC #'0'
cee4 85 5b    RRTF_44   STA TMPVAR+1        ; new value for exponent
cee6 4c 62 ce           JMP RRTF_10

              ; *********
cee9            REAL_1e8
              ; *********

cee9 9b 3e bc 20 00     .REAL $9b3ebc2000   ; 1e8

              ; *********
ceee            REAL_9x9
              ; *********

ceee 9e 6e 6b 27 fe     .REAL $9e6e6b27fe   ;  999999999.5

              ; *********
cef3            REAL_1e9
              ; *********

cef3 9e 6e 6b 28 00     .REAL $9e6e6b2800   ; 1e9

cef8 42 53 4f BSOS_TEXT .BYTE "BSOS BOOT"

              ; **********
cf01            Option_ROM
              ; **********

cf01 a2 03              LDX #3
cf03 bd 00 90 OpRO_10   LDA $9000,X         ; check $9000 ROM
cf06 dd f8 ce           CMP BSOS_TEXT,X
cf09 d0 06              BNE OpRO_20
cf0b ca                 DEX
cf0c 10 f5              BPL OpRO_10
cf0e 20 04 90           JSR $9004
cf11 a2 03    OpRO_20   LDX #3
cf13 bd 00 a0 OpRO_30   LDA $a000,X         ; check $a000 ROM
cf16 dd f8 ce           CMP BSOS_TEXT,X
cf19 d0 06              BNE OpRO_40
cf1b ca                 DEX
cf1c 10 f5              BPL OpRO_30
cf1e 4c 04 a0           JMP $a004
cf21 60       OpRO_40   RTS ;Size   33 [Option_ROM]

              ; *********
cf22            BOOT_File
              ; *********

cf22 24 98              BIT Key_Flags
cf24 10 fb              BPL OpRO_40         ; skip if SHIFT pressed
cf26 a9 f8              LDA #<BSOS_TEXT     ; look for boot file
cf28 85 da              STA FNADR
cf2a a9 ce              LDA #>BSOS_TEXT
cf2c 85 db              STA FNADR+1
cf2e a9 09              LDA #?BSOS_TEXT
cf30 85 d1              STA FNLEN
cf32 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
cf35 a9 00              LDA #0
cf37 85 d3              STA SA              ; enforce load to $0401
cf39 a5 28              LDA TXTTAB
cf3b a6 29              LDX TXTTAB+1
cf3d 85 c9              STA EAL             ; TXTTAB (normally $0401)
cf3f 86 ca              STX EAL+1
cf41 20 d0 f3           JSR Open_Load_File
cf44 a5 96              LDA STATUS
cf46 f0 06              BEQ BOFi_10
cf48 20 ae f1           JSR UNTLK           ; not there
cf4b 4c 91 d9           JMP Kernal_Read_DS  ; clear status and return
cf4e 20 8e f3 BOFi_10   JSR LoFi_30         ; load boot file
cf51 a5 c9              LDA EAL
cf53 85 2a              STA VARTAB
cf55 a5 ca              LDA EAL+1
cf57 85 2b              STA VARTAB+1
cf59 20 e9 b5           JSR Reset_BASIC_Execution
cf5c 20 b6 b4           JSR Rechain
cf5f 4c 4a b7           JMP Execute

cf62 00 00 00           .FILL $cf78-* (0) ; 22 bytes

              ; ********
cf78            Print_IN
              ; ********

cf78 a9 0d              LDA #<Msg_IN
cf7a a0 b3              LDY #>Msg_IN
cf7c 20 90 cf           JSR To_Print_String
cf7f a5 37              LDA CURLIN+1
cf81 a6 36              LDX CURLIN

              ; ****************
cf83            Print_Integer_XA
              ; ****************

cf83 85 5f              STA FAC1M1
cf85 86 60              STX FAC1M2
cf87 a2 90              LDX #$90
cf89 38                 SEC
cf8a 20 7f cd           JSR Convert_Integer_To_Real
cf8d 20 93 cf           JSR Format_FAC1

              ; ***************
cf90            To_Print_String
              ; ***************

cf90 4c 1d bb           JMP Print_String

              ; *******************
cf93            Format_FAC1 ; $cf93
              ; *******************

cf93 a0 01              LDY #1              ; start of string storage

              ; =====================
cf95            Format_FAC1_Y ; $cf95
              ; =====================

              ; Format floating point number in FAC1
              ; The string is stored starting at $ff for Y=0
              ; and extending into the bottom of the stack

cf95 a9 00              LDA #0
cf97 85 5a              STA TMPVAR          ; 10's exponent

              ; the first character is blank for positive or '-'
              ; for negative numbers

cf99 a9 20              LDA #' '
cf9b 24 63              BIT FAC1SI
cf9d 10 02              BPL FoFA_02
cf9f a9 2d              LDA #'-'
cfa1 99 ff 00 FoFA_02   STA STACK-1,Y       ; 1.st char ' ' or '-'
cfa4 85 63              STA FAC1SI          ; delete sign info from FAC1
cfa6 84 6e              STY TMPPTD          ; save Y
cfa8 c8                 INY                 ; next string position
cfa9 a9 30              LDA #'0'            ; default for value zero

              ; if the value is zero, store '0' and finish

cfab a6 5e              LDX FAC1EX
cfad d0 03              BNE FoFA_04         ; -> non zero
cfaf 4c b6 d0           JMP FoFA_94         ; store '0' and finish

              ; if the value is less than 1.0, scale it with 1.0e+9
              ; and store the scaled 10's exponent (-9) in TMPVAR
              ; this saves 9 iterations in loop FoFA_08

cfb2 a9 00    FoFA_04   LDA #0
cfb4 e0 81              CPX #$81            ; exponent for >= 1.0
cfb6 b0 09              BCS FoFA_06
cfb8 a9 f3              LDA #<REAL_1e9
cfba a0 ce              LDY #>REAL_1e9
cfbc 20 5e cb           JSR Multiply_FAC1_With_AY
cfbf a9 f7              LDA #-9
cfc1 85 5a    FoFA_06   STA TMPVAR          ; current 10's exponent

              ; scale FAC1 up until the number has more than 8 digits

cfc3 a9 e9    FoFA_08   LDA #<REAL_1e8
cfc5 a0 ce              LDY #>REAL_1e8
cfc7 20 91 cd           JSR Compare_FAC1_AY
cfca 10 0c              BPL FoFA_12         ; FAC1 >= REAL_1e8 ->
cfcc 20 18 cc           JSR Multiply_FAC1_BY_10
cfcf c6 5a              DEC TMPVAR          ; decrement 10's exponent
cfd1 d0 f0              BNE FoFA_08         ; always

              ; scale FAC1 down until the number has less than 10 digits

cfd3 20 34 cc FoFA_10   JSR Divide_FAC1_By_10
cfd6 e6 5a              INC TMPVAR          ; increment 10's exponent
cfd8 a9 ee    FoFA_12   LDA #<REAL_9x9
cfda a0 ce              LDY #>REAL_9x9      ; 999999999.5
cfdc 20 91 cd           JSR Compare_FAC1_AY
cfdf 10 f2              BPL FoFA_10         ; FAC1 > REAL_9x9 -> continue scaling

              ; scaling is done - now convert the digits before the decimal
              ; point into a 32 bit integer

cfe1 20 7f c9           JSR Add_0_5_To_FAC1 ; add 0.5 for rounding
cfe4 20 d1 cd           JSR FAC1_LSR        ; convert to integer

              ; choose fixed point format if -2 < exp < 10
              ; else format in exponential format

cfe7 a2 01              LDX #1
cfe9 a5 5a              LDA TMPVAR          ; current 10's exponent
cfeb 18                 CLC
cfec 69 0a              ADC #10             ; exp difference
cfee 30 09              BMI FoFA_14         ; value < 1.0
cff0 c9 0b              CMP #11
cff2 b0 06              BCS FoFA_16         ; value >= 1e9
cff4 69 ff              ADC #$ff
cff6 aa                 TAX                 ; X = exp + 9
cff7 a9 02              LDA #2              ; fixed point
cff9 38       FoFA_14   SEC
cffa e9 02    FoFA_16   SBC #2
cffc 85 5b              STA TMPVAR+1        ; exp print = 0 or exp+8
cffe 86 5a              STX TMPVAR          ; digits before decimal point
d000 8a                 TXA
d001 f0 02              BEQ FoFA_18         ; -> if no digits before point
d003 10 13              BPL FoFA_22
d005 a4 6e    FoFA_18   LDY TMPPTD
d007 a9 2e              LDA #'.'
d009 c8                 INY
d00a 99 ff 00           STA STACK-1,Y       ; insert decimal point
d00d 8a                 TXA
d00e f0 06              BEQ FoFA_20
d010 a9 30              LDA #'0'
d012 c8                 INY
d013 99 ff 00           STA STACK-1,Y       ; insert '0'
d016 84 6e    FoFA_20   STY TMPPTD
d018 a0 00    FoFA_22   LDY #0

              ; =================
d01a            Format_Jiffyclock
              ; =================

d01a a2 80              LDX #$80
d01c 18       FoFA_78   CLC
d01d a5 62              LDA FAC1M4
d01f 79 cf d0           ADC Decimal_Conversion_Table+3,Y
d022 85 62              STA FAC1M4
d024 a5 61              LDA FAC1M3
d026 79 ce d0           ADC Decimal_Conversion_Table+2,Y
d029 85 61              STA FAC1M3
d02b a5 60              LDA FAC1M2
d02d 79 cd d0           ADC Decimal_Conversion_Table+1,Y
d030 85 60              STA FAC1M2
d032 a5 5f              LDA FAC1M1
d034 79 cc d0           ADC Decimal_Conversion_Table,Y
d037 85 5f              STA FAC1M1
d039 e8                 INX
d03a b0 04              BCS FoFA_80
d03c 10 de              BPL FoFA_78
d03e 30 02              BMI FoFA_82

d040 30 da    FoFA_80   BMI FoFA_78
d042 8a       FoFA_82   TXA
d043 90 04              BCC FoFA_84
d045 49 ff              EOR #$ff
d047 69 0a              ADC #10
d049 69 2f    FoFA_84   ADC #'0'-1
d04b c8                 INY
d04c c8                 INY
d04d c8                 INY
d04e c8                 INY                 ; Y += 4
d04f 84 44              STY VARPTR          ; save index to table
d051 a4 6e              LDY TMPPTD          ; get index to string
d053 c8                 INY
d054 aa                 TAX
d055 29 7f              AND #$7f
d057 99 ff 00           STA STACK-1,Y       ; store digit
d05a c6 5a              DEC TMPVAR          ; # of digits
d05c d0 06              BNE FoFA_86         ; -> if not zero
d05e a9 2e              LDA #'.'
d060 c8                 INY
d061 99 ff 00           STA STACK-1,Y       ; store decimal point
d064 84 6e    FoFA_86   STY TMPPTD          ; save string index
d066 a4 44              LDY VARPTR          ; get table index
d068 8a                 TXA
d069 49 ff              EOR #$ff
d06b 29 80              AND #$80
d06d aa                 TAX
d06e c0 24              CPY #$24            ; end of decimal table ?
d070 f0 04              BEQ FoFA_88
d072 c0 3c              CPY #$3c            ; end of jiffy table ?
d074 d0 a6              BNE FoFA_78

              ; remove trailing zeroes

d076 a4 6e    FoFA_88   LDY TMPPTD          ; get string index
d078 b9 ff 00 FoFA_90   LDA STACK-1,Y
d07b 88                 DEY
d07c c9 30              CMP #'0'
d07e f0 f8              BEQ FoFA_90
d080 c9 2e              CMP #'.'
d082 f0 01              BEQ FoFA_91
d084 c8                 INY
d085 a9 2b    FoFA_91   LDA #'+'            ; default sign for exponent
d087 a6 5b              LDX TMPVAR+1
d089 f0 2e              BEQ FoFA_95         ; -> no exponent
d08b 10 08              BPL FoFA_92         ; -> positive exponent
d08d a9 00              LDA #0
d08f 38                 SEC
d090 e5 5b              SBC TMPVAR+1        ; negate exponent
d092 aa                 TAX
d093 a9 2d              LDA #'-'            ; negative sign for exponent
d095 99 01 01 FoFA_92   STA STACK+1,Y
d098 a9 45              LDA #'E'
d09a 99 00 01           STA STACK,Y
d09d 8a                 TXA
d09e a2 2f              LDX #'0'-1
d0a0 38                 SEC
d0a1 e8       FoFA_93   INX
d0a2 e9 0a              SBC #10
d0a4 b0 fb              BCS FoFA_93
d0a6 69 3a              ADC #'0'+10
d0a8 99 03 01           STA STACK+3,Y
d0ab 8a                 TXA
d0ac 99 02 01           STA STACK+2,Y
d0af a9 00              LDA #0
d0b1 99 04 01           STA STACK+4,Y
d0b4 f0 08              BEQ FoFA_96         ; always

d0b6 99 ff 00 FoFA_94   STA STACK-1,Y
d0b9 a9 00    FoFA_95   LDA #0
d0bb 99 00 01           STA STACK,Y
d0be a9 00    FoFA_96   LDA #0
d0c0 a0 01              LDY #1
d0c2 60                 RTS ;Size  304 [Format_FAC1]

d0c3 00 00 00           .FILL $d0c7-* (0) ; 4 bytes

              ; *****************
d0c7            Float_0_5 ; $d0c7
              ; *****************

d0c7 80 00 00 00 00     .REAL $8000000000   ;    0.50000000000

              ; ************************
d0cc            Decimal_Conversion_Table
              ; ************************

d0cc fa 0a 1f           .QUAD $fa0a1f00     ; -100000000
d0d0 00 98 96           .QUAD $00989680     ;   10000000
d0d4 ff f0 bd           .QUAD $fff0bdc0     ;   -1000000
d0d8 00 01 86           .QUAD $000186a0     ;     100000
d0dc ff ff d8           .QUAD $ffffd8f0     ;     -10000
d0e0 00 00 03           .QUAD $000003e8     ;       1000
d0e4 ff ff ff           .QUAD $ffffff9c     ;       -100
d0e8 00 00 00           .QUAD $0000000a     ;         10
d0ec ff ff ff           .QUAD $ffffffff     ;         -1

              ; **********************
d0f0            Jiffy_Conversion_Table
              ; **********************

d0f0 ff df 0a           .QUAD $ffdf0a80     ;   -2160000
d0f4 00 03 4b           .QUAD $00034bc0     ;     216000
d0f8 ff ff 73           .QUAD $ffff7360     ;     -36000
d0fc 00 00 0e           .QUAD $00000e10     ;       3600
d100 ff ff fd           .QUAD $fffffda8     ;       -600
d104 00 00 00           .QUAD $0000003c     ;         60

              ; *****************
d108            Basic_SQR ; $d108
              ; *****************

d108 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d10b a9 c7              LDA #<Float_0_5
d10d a0 d0              LDY #>Float_0_5
d10f 20 d8 cc           JSR Load_FAC1_AY    ; perform (arg)^0.5

              ; ********
d112            Op_POWER
              ; ********

d112 f0 70              BEQ Basic_EXP       ; -> FAC1 == 0
d114 a5 66              LDA FAC2EX
d116 d0 03              BNE PWR_10
d118 4c 2f ca           JMP CF1_10
d11b a2 4b    PWR_10    LDX #<FUNCPT
d11d a0 00              LDY #>FUNCPT
d11f 20 0a cd           JSR FAC1_To_XY
d122 a5 6b              LDA FAC2SI
d124 10 0f              BPL PWR_20
d126 20 02 ce           JSR Basic_INT
d129 a9 4b              LDA #<FUNCPT
d12b a0 00              LDY #>FUNCPT
d12d 20 91 cd           JSR Compare_FAC1_AY
d130 d0 03              BNE PWR_20
d132 98                 TYA
d133 a4 03              LDY CHARAC
d135 20 34 cd PWR_20    JSR Copy_ABS_FAC2_To_FAC1
d138 98                 TYA
d139 48                 PHA
d13a 20 20 cb           JSR Basic_LOG
d13d a9 4b              LDA #<FUNCPT
d13f a0 00              LDY #>FUNCPT
d141 20 5e cb           JSR Multiply_FAC1_With_AY
d144 20 84 d1           JSR Basic_EXP
d147 68                 PLA
d148 4a                 LSR A
d149 90 0a              BCC NEGA_Ret

              ; *********
d14b            Op_NEGATE
              ; *********

d14b a5 5e              LDA FAC1EX
d14d f0 06              BEQ NEGA_Ret
d14f a5 63              LDA FAC1SI
d151 49 ff              EOR #$ff            ; change sign
d153 85 63              STA FAC1SI
d155 60       NEGA_Ret  RTS ;Size   11 [Op_NEGATE]

              ; *********
d156            REV_LOG_2
              ; *********

d156 81 38 aa 3b 29     .REAL $8138aa3b29   ;    1.44269504072
d15b 07       VAR_EXP   .BYTE $07
d15c 71 34 58 3e 56     .REAL $7134583e56   ;    0.00002149876
d161 74 16 7e b3 1b     .REAL $74167eb31b   ;    0.00014352314
d166 77 2f ee e3 85     .REAL $772feee385   ;    0.00134226348
d16b 7a 1d 84 1c 2a     .REAL $7a1d841c2a   ;    0.00961401701
d170 7c 63 59 58 0a     .REAL $7c6359580a   ;    0.05550512686
d175 7e 75 fd e7 c6     .REAL $7e75fde7c6   ;    0.24022638460
d17a 80 31 72 18 10     .REAL $8031721810   ;    0.69314718619
d17f 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; *********
d184            Basic_EXP
              ; *********

d184 a9 56              LDA #<REV_LOG_2
d186 a0 d1              LDY #>REV_LOG_2
d188 20 5e cb           JSR Multiply_FAC1_With_AY
d18b a5 6d              LDA FROUND
d18d 69 50              ADC #$50
d18f 90 03              BCC EXP_10
d191 20 59 cd           JSR Inc_FAC1
d194 85 53    EXP_10    STA FUNJMP+1        ; FROUND + $50
d196 20 45 cd           JSR FAC1_To_FAC2
d199 a5 5e              LDA FAC1EX
d19b c9 88              CMP #$88
d19d 90 03              BCC EXP_30          ; -> value < 128
d19f 20 07 cc EXP_20    JSR ChFA_40         ; Floating Point Exception
d1a2 20 02 ce EXP_30    JSR Basic_INT       ; convert to integer
d1a5 a5 03              LDA CHARAC
d1a7 49 80              EOR #$80
d1a9 48                 PHA
d1aa a2 05              LDX #5
d1ac b5 66    EXP_40    LDA FAC2EX,X
d1ae b4 5e              LDY FAC1EX,X
d1b0 95 5e              STA FAC1EX,X
d1b2 94 66              STY FAC2EX,X
d1b4 ca                 DEX
d1b5 10 f5              BPL EXP_40
d1b7 a5 53              LDA FUNJMP+1
d1b9 85 6d              STA FROUND
d1bb 20 89 c9           JSR Op_MINUS
d1be 20 4b d1           JSR Op_NEGATE
d1c1 a9 5b              LDA #<VAR_EXP
d1c3 a0 d1              LDY #>VAR_EXP
d1c5 20 ed d1           JSR Eval_Series_AY
d1c8 a9 00              LDA #0
d1ca 85 6c              STA STRPTR
d1cc 68                 PLA
d1cd 20 ef cb           JSR ChFA_10
d1d0 60                 RTS ;Size   77 [Basic_EXP]

d1d1 00 00 00           .FILL $d1d7-* (0) ; 6 bytes

              ; ******************************
d1d7            Square_And_Series_Eval ; $d1d7
              ; ******************************

d1d7 85 6e              STA TMPPTD
d1d9 84 6f              STY TMPPTD+1
d1db 20 00 cd           JSR FAC1_To_FACTPA
d1de a9 54              LDA #<FACTPA        ; Y = 0
d1e0 20 5e cb           JSR Multiply_FAC1_With_AY
d1e3 20 f1 d1           JSR Eval_Series
d1e6 a9 54              LDA #<FACTPA
d1e8 a0 00              LDY #>FACTPA
d1ea 4c 5e cb           JMP Multiply_FAC1_With_AY

              ; **************
d1ed            Eval_Series_AY
              ; **************

d1ed 85 6e              STA TMPPTD
d1ef 84 6f              STY TMPPTD+1

              ; ***********
d1f1            Eval_Series
              ; ***********

d1f1 20 fd cc           JSR FAC1_To_FACTPB
d1f4 b1 6e              LDA (TMPPTD),Y
d1f6 85 64              STA SGNFLG          ; # of terms
d1f8 a4 6e              LDY TMPPTD
d1fa c8                 INY
d1fb 98                 TYA
d1fc d0 02              BNE EvSe_10
d1fe e6 6f              INC TMPPTD+1
d200 85 6e    EvSe_10   STA TMPPTD
d202 a4 6f              LDY TMPPTD+1
d204 20 5e cb EvSe_20   JSR Multiply_FAC1_With_AY
d207 a5 6e              LDA TMPPTD
d209 a4 6f              LDY TMPPTD+1
d20b 18                 CLC
d20c 69 05              ADC #5              ; advance polynomial pointer
d20e 90 01              BCC EvSe_30
d210 c8                 INY
d211 85 6e    EvSe_30   STA TMPPTD
d213 84 6f              STY TMPPTD+1
d215 20 9d c9           JSR Add_Var_AY_To_FAC1
d218 a9 59              LDA #<FACTPB
d21a a0 00              LDY #>FACTPB
d21c c6 64              DEC SGNFLG
d21e d0 e4              BNE EvSe_20         ; -> next polynomial
d220 60                 RTS ;Size   48 [Eval_Series]

d221 98 35 44 RND_VA    .QUAD $9835447a     ; -1741339526
d225 68 28 b1 RND_VB    .QUAD $6828b146     ;  1747497286

              ; *********
d229            Basic_RND
              ; *********

              ; The random factor argument from RND(arg) is interpreted:
              ; arg < 0 : use argument as random seed
              ; arg = 0 : use timer 1 and 2 for random seed
              ; arg > 0 : start with fixed random seed from ROM

d229 20 61 cd           JSR Get_FAC1_Sign
d22c 30 2e              BMI RND_20
d22e d0 17              BNE RND_10
d230 ad 44 e8           LDA VIA_Timer_1_Lo  ; timer seed
d233 85 5f              STA FAC1M1
d235 ad 48 e8           LDA VIA_Timer_2_Lo
d238 85 60              STA FAC1M2
d23a ad 45 e8           LDA VIA_Timer_1_Hi
d23d 85 61              STA FAC1M3
d23f ad 49 e8           LDA VIA_Timer_2_Hi
d242 85 62              STA FAC1M4
d244 4c 6c d2           JMP RND_30
d247 a9 88    RND_10    LDA #<RNDX          ; fixed seed
d249 a0 00              LDY #>RNDX
d24b 20 d8 cc           JSR Load_FAC1_AY
d24e a9 21              LDA #<RND_VA
d250 a0 d2              LDY #>RND_VA
d252 20 5e cb           JSR Multiply_FAC1_With_AY
d255 a9 25              LDA #<RND_VB
d257 a0 d2              LDY #>RND_VB
d259 20 9d c9           JSR Add_Var_AY_To_FAC1
d25c a6 62    RND_20    LDX FAC1M4          ; argument seed
d25e a5 5f              LDA FAC1M1
d260 85 62              STA FAC1M4
d262 86 5f              STX FAC1M1
d264 a6 60              LDX FAC1M2
d266 a5 61              LDA FAC1M3
d268 85 60              STA FAC1M2
d26a 86 61              STX FAC1M3
d26c a9 00    RND_30    LDA #0
d26e 85 63              STA FAC1SI
d270 a5 5e              LDA FAC1EX
d272 85 6d              STA FROUND
d274 a9 80              LDA #$80
d276 85 5e              STA FAC1EX
d278 20 0d ca           JSR Normalise_FAC1
d27b a2 88              LDX #<RNDX
d27d a0 00              LDY #>RNDX
d27f 4c 0a cd           JMP FAC1_To_XY

              ; *********
d282            Basic_COS
              ; *********

d282 a9 fe              LDA #<PI_Half
d284 a0 d2              LDY #>PI_Half
d286 20 9d c9           JSR Add_Var_AY_To_FAC1

              ; *****************
d289            Basic_SIN ; $d289
              ; *****************

d289 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d28c a9 03              LDA #<Two_PI
d28e a0 d3              LDY #>Two_PI
d290 a6 6b              LDX FAC2SI
d292 20 3d cc           JSR Divide_FAC2_By_AY ; arg / (2 pi)
d295 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d298 20 02 ce           JSR Basic_INT
d29b a9 00              LDA #0
d29d 85 6c              STA STRPTR
d29f 20 89 c9           JSR Op_MINUS
d2a2 a9 08              LDA #<Float_0_25
d2a4 a0 d3              LDY #>Float_0_25
d2a6 20 86 c9           JSR AY_Minus_FAC1
d2a9 a5 63              LDA FAC1SI
d2ab 48                 PHA
d2ac 10 0d              BPL SIN_10
d2ae 20 7f c9           JSR Add_0_5_To_FAC1
d2b1 a5 63              LDA FAC1SI
d2b3 30 09              BMI SIN_20
d2b5 a5 0c              LDA TANSGN
d2b7 49 ff              EOR #$ff
d2b9 85 0c              STA TANSGN
d2bb 20 4b d1 SIN_10    JSR Op_NEGATE
d2be a9 08    SIN_20    LDA #<Float_0_25
d2c0 a0 d3              LDY #>Float_0_25
d2c2 20 9d c9           JSR Add_Var_AY_To_FAC1
d2c5 68                 PLA
d2c6 10 03              BPL SIN_30
d2c8 20 4b d1           JSR Op_NEGATE
d2cb a9 0d    SIN_30    LDA #<VAR_SIN
d2cd a0 d3              LDY #>VAR_SIN
d2cf 4c d7 d1           JMP Square_And_Series_Eval

              ; *********
d2d2            Basic_TAN
              ; *********

d2d2 20 00 cd           JSR FAC1_To_FACTPA
d2d5 a9 00              LDA #0
d2d7 85 0c              STA TANSGN
d2d9 20 89 d2           JSR Basic_SIN
d2dc a2 4b              LDX #<FUNCPT
d2de a0 00              LDY #>FUNCPT
d2e0 20 0a cd           JSR FAC1_To_XY
d2e3 a9 54              LDA #<FACTPA
d2e5 a0 00              LDY #>FACTPA
d2e7 20 d8 cc           JSR Load_FAC1_AY
d2ea a9 00              LDA #0
d2ec 85 63              STA FAC1SI
d2ee a5 0c              LDA TANSGN
d2f0 20 fa d2           JSR TAN_10
d2f3 a9 4b              LDA #<FUNCPT
d2f5 a0 00              LDY #>FUNCPT
d2f7 4c 45 cc           JMP AY_Divided_By_FAC1

              ; ******
d2fa            TAN_10
              ; ******

d2fa 48                 PHA
d2fb 4c bb d2           JMP SIN_10
d2fe 81 49 0f PI_Half   .REAL $81490fdaa2   ;    1.57079632673
d303 83 49 0f Two_PI    .REAL $83490fdaa2   ;    6.28318530694

              ; **********
d308            Float_0_25
              ; **********

d308 7f 00 00 00 00     .REAL $7f00000000   ;    0.25000000000
d30d 05       VAR_SIN   .BYTE $05
d30e 84 e6 1a 2d 1b     .REAL $84e61a2d1b   ;  -14.38139067218
d313 86 28 07 fb f8     .REAL $862807fbf8   ;   42.00779712200
d318 87 99 68 89 01     .REAL $8799688901   ;  -76.70417025685
d31d 87 23 35 df e1     .REAL $872335dfe1   ;   81.60522368550
d322 86 a5 5d e7 28     .REAL $86a55de728   ;  -41.34170210361
d327 83 49 0f da a2     .REAL $83490fdaa2   ;    6.28318530694

              ; *****************
d32c            Basic_ATN ; $d32c
              ; *****************

d32c a5 63              LDA FAC1SI
d32e 48                 PHA                 ; save sign
d32f a9 00              LDA #0
d331 85 63              STA FAC1SI          ; use symmetry of arctangent
d333 a5 5e              LDA FAC1EX
d335 c9 81              CMP #$81
d337 08                 PHP                 ; save flags
d338 90 07              BCC ATN_20          ; -> arg < 1.0
d33a a9 f2              LDA #<REAL_1
d33c a0 ca              LDY #>REAL_1
d33e 20 45 cc           JSR AY_Divided_By_FAC1
d341 a9 5c    ATN_20    LDA #<VAR_ATN
d343 a0 d3              LDY #>VAR_ATN
d345 20 d7 d1           JSR Square_And_Series_Eval
d348 28                 PLP                 ; restore comparison flags
d349 90 07              BCC ATN_30          ; -> arg < 1.0
d34b a9 fe              LDA #<PI_Half
d34d a0 d2              LDY #>PI_Half
d34f 20 86 c9           JSR AY_Minus_FAC1
d352 68       ATN_30    PLA
d353 85 63              STA FAC1SI          ; use same sign as arguemnt
d355 60                 RTS ;Size   42 [Basic_ATN]

d356 00 00 00           .FILL $d35c-* (0) ; 6 bytes

              ; ***************
d35c            VAR_ATN ; $d35c
              ; ***************

d35c 0b                 .BYTE $0b
d35d 76 b3 83 bd d3     .REAL $76b383bdd3   ;   -0.00068479391
d362 79 1e f4 a6 f5     .REAL $791ef4a6f5   ;    0.00485094216
d367 7b 83 fc b0 10     .REAL $7b83fcb010   ;   -0.01611170184
d36c 7c 0c 1f 67 ca     .REAL $7c0c1f67ca   ;    0.03420963805
d371 7c de 53 cb c1     .REAL $7cde53cbc1   ;   -0.05427913276
d376 7d 14 64 70 4c     .REAL $7d1464704c   ;    0.07245719654
d37b 7d b7 ea 51 7a     .REAL $7db7ea517a   ;   -0.08980239538
d380 7d 63 30 88 7e     .REAL $7d6330887e   ;    0.11093241343
d385 7e 92 44 99 3a     .REAL $7e9244993a   ;   -0.14283980767
d38a 7e 4c cc 91 c7     .REAL $7e4ccc91c7   ;    0.19999912049
d38f 7f aa aa aa 13     .REAL $7faaaaaa13   ;   -0.33333331568
d394 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; **********
d399            CHRGET_ROM
              ; **********

d399 e6 77              INC TXTPTR
d39b d0 02              BNE CHRG_10
d39d e6 78              INC TXTPTR+1
d39f ad 60 ea CHRG_10   LDA $ea60           ; dummy address
d3a2 c9 3a              CMP #':'
d3a4 b0 0a              BCS CHRG_20
d3a6 c9 20              CMP #' '
d3a8 f0 ef              BEQ CHRGET_ROM
d3aa 38                 SEC
d3ab e9 30              SBC #'0'
d3ad 38                 SEC
d3ae e9 d0              SBC #$d0
d3b0 60       CHRG_20   RTS ;Size   24 [CHRGET_ROM]

d3b1 80 4f c7 52 58     .REAL $804fc75258   ;    0.81163515709

              ; **********************
d3b6            Init_BASIC_RAM_Vectors
              ; **********************

d3b6 20 0e b6           JSR Flush_BASIC_Stack
d3b9 a9 4c              LDA #$4c            ; JMP code
d3bb 85 51              STA JUMPER
d3bd 85 00              STA Basic_USR
d3bf a9 73              LDA #<Jump_To_Illegal_Quantity
d3c1 a0 c3              LDY #>Jump_To_Illegal_Quantity
d3c3 85 01              STA USRVEC
d3c5 84 02              STY USRVEC+1
d3c7 a2 1c              LDX #$1c
d3c9 bd 98 d3 IBRV_10   LDA CHRGET_ROM-1,X
d3cc 95 6f              STA CHRGET-1,X
d3ce ca                 DEX
d3cf d0 f8              BNE IBRV_10         ; X=0 on exit
d3d1 86 10              STX IOPMPT          ; 0
d3d3 86 15              STX LASTPT+1        ; 0
d3d5 8e 00 04           STX $0400           ; BASIC start
d3d8 a0 04              LDY #4              ; X=0  Y=4
d3da 84 29              STY TXTTAB+1        ; >$0401
d3dc 86 11              STX LINNUM
d3de 84 12              STY LINNUM+1        ; $0400
d3e0 a9 08              LDA #8
d3e2 85 ab              STA Wedge_Unit
d3e4 a0 01              LDY #1              ; start RAM test at $0401
d3e6 84 28              STY TXTTAB          ; (TXTTAB) = $0401
d3e8 b1 11    IBRV_20   LDA (LINNUM),Y
d3ea aa                 TAX                 ; save content
d3eb a9 55              LDA #$55            ; test pattern
d3ed 91 11              STA (LINNUM),Y
d3ef d1 11              CMP (LINNUM),Y
d3f1 d0 11              BNE IBRV_30         ; failed
d3f3 0a                 ASL A               ; shift pattern
d3f4 91 11              STA (LINNUM),Y
d3f6 d1 11              CMP (LINNUM),Y
d3f8 d0 0a              BNE IBRV_30         ; failed
d3fa 8a                 TXA                 ; restore content
d3fb 91 11              STA (LINNUM),Y
d3fd c8                 INY                 ; next address
d3fe d0 e8              BNE IBRV_20         ; loop
d400 e6 12              INC LINNUM+1
d402 10 e4              BPL IBRV_20         ; loop for LINNUM < $8000
d404 a5 12    IBRV_30   LDA LINNUM+1
d406 84 34              STY MEMSIZ
d408 85 35              STA MEMSIZ+1        ; top of RAM + 1
d40a 84 30              STY FRETOP
d40c 85 31              STA FRETOP+1
d40e a9 9d              LDA #<Start_Message
d410 a0 de              LDY #>Start_Message
d412 20 1d bb           JSR Print_String
d415 a5 34              LDA MEMSIZ
d417 38                 SEC
d418 e5 28              SBC TXTTAB
d41a aa                 TAX
d41b a5 35              LDA MEMSIZ+1
d41d e5 29              SBC TXTTAB+1
d41f 20 83 cf           JSR Print_Integer_XA
d422 a9 35              LDA #<Bytes_Free_Message
d424 a0 d4              LDY #>Bytes_Free_Message
d426 20 1d bb           JSR Print_String
d429 20 d4 b5           JSR Perform_NEW
d42c 20 01 cf           JSR Option_ROM
d42f 20 22 cf           JSR BOOT_File
d432 4c ff b3           JMP Basic_Ready

              ; ******************
d435            Bytes_Free_Message
              ; ******************

d435 20 42 59           .BYTE " BYTES FREE\r",0

              ; *******
d442            Monitor
              ; *******
d442 a9 b4              LDA #>[Basic_Ready+1]
d444 48                 PHA
d445 a9 00              LDA #<[Basic_Ready+1]
d447 48                 PHA
d448 a9 00              LDA #0              ; clear if not already 0
d44a 48                 PHA                 ; Y
d44b 48                 PHA                 ; X
d44c 48                 PHA                 ; A
d44d 48                 PHA                 ; SR

              ; *************
d44e            MONITOR_BREAK
              ; *************

d44e d8                 CLD
d44f a2 01              LDX #1              ; 1 for BRK
d451 c9 20              CMP #$20            ; T2 single step IRQ
d453 d0 01              BNE MOBR_05
d455 ca                 DEX                 ; 0 for STEP IRQ
d456 86 b3    MOBR_05   STX PC_Adjust
d458 20 a6 f2           JSR Kernal_CLRCHN
d45b 68                 PLA
d45c 8d a7 02           STA Mon_Register+7  ; Y
d45f 68                 PLA
d460 8d a6 02           STA Mon_Register+6  ; X
d463 68                 PLA
d464 8d a5 02           STA Mon_Register+5  ; A
d467 68                 PLA
d468 8d a4 02           STA Mon_Register+4  ; SR
d46b 20 43 ec           JSR Install_Bank_Access ; Carry = 1
d46e 68                 PLA
d46f e5 b3              SBC PC_Adjust
d471 8d a1 02           STA Mon_Register+1  ; PC lo
d474 68                 PLA
d475 e9 00              SBC #0
d477 8d a0 02           STA Mon_Register    ; PC hi
d47a a5 90              LDA CINV
d47c 8d a3 02           STA Mon_Register+3  ; IRQ lo
d47f a5 91              LDA CINV+1
d481 8d a2 02           STA Mon_Register+2  ; IRQ hi
d484 ba                 TSX
d485 8e a8 02           STX Mon_Register+8  ; SP
d488 a5 b6              LDA R_Bank
d48a 8d a9 02           STA Mon_Register+9  ; RB
d48d a5 b7              LDA W_Bank
d48f 8d aa 02           STA Mon_Register+10 ; WB
d492 58                 CLI
d493 a6 b3              LDX PC_Adjust
d495 f0 0e              BEQ MOBR_20         ; no greetings on single step mode
d497 a0 ff              LDY #-1
d499 c8       MOBR_10   INY
d49a b9 23 d5           LDA Mon_Start,Y
d49d f0 06              BEQ MOBR_20
d49f 20 02 e2           JSR EDIT_CHROUT
d4a2 4c 99 d4           JMP MOBR_10
d4a5 a9 52    MOBR_20   LDA #'R'
d4a7 d0 11              BNE Mon_20          ; always

              ; *********
d4a9            Mon_Error
              ; *********

d4a9 a9 3f              LDA #'?'
d4ab 20 02 e2           JSR EDIT_CHROUT

              ; ********
d4ae            Mon_Main
              ; ********

d4ae 20 1e d5           JSR Mon_Print_CR
d4b1 20 f4 d8 Mon_10    JSR Mon_CHRIN
d4b4 f0 f8              BEQ Mon_Main
d4b6 c9 20              CMP #' '
d4b8 f0 f7              BEQ Mon_10
d4ba a2 18    Mon_20    LDX #24
d4bc ca       Mon_30    DEX
d4bd 30 ea              BMI Mon_Error
d4bf dd 2e d5           CMP Mon_Commands,X
d4c2 d0 f8              BNE Mon_30
d4c4 bd 46 d5           LDA Mon_Sub_Hi,X
d4c7 48                 PHA
d4c8 bd 5d d5           LDA Mon_Sub_Lo,X
d4cb 48                 PHA
d4cc 60                 RTS ;Size   31 [Mon_Main]

              ; **********************
d4cd            Mon_Print_A_Hex_Values
              ; **********************

d4cd 85 b5              STA MONCNT
d4cf a0 00              LDY #0
d4d1 20 1b d5 MPAH_10   JSR Mon_Print_Blank
d4d4 20 7a 02           JSR Bank_Fetch
d4d7 20 54 d7           JSR Print_Hex_Byte
d4da c8                 INY
d4db c0 08              CPY #8
d4dd d0 03              BNE MPAH_12
d4df 20 1b d5           JSR Mon_Print_Blank
d4e2 c4 b5    MPAH_12   CPY MONCNT
d4e4 90 eb              BCC MPAH_10
d4e6 20 1b d5           JSR Mon_Print_Blank
d4e9 a5 b5              LDA MONCNT
d4eb c9 10              CMP #16
d4ed d0 20              BNE MPAH_Ret
d4ef a0 00              LDY #0
d4f1 20 7a 02 MPAH_20   JSR Bank_Fetch
d4f4 29 7f              AND #$7f
d4f6 c9 20              CMP #$20
d4f8 90 04              BCC MPAH_30
d4fa c9 60              CMP #$60
d4fc 90 02              BCC MPAH_40
d4fe a9 2e    MPAH_30   LDA #'.'
d500 20 02 e2 MPAH_40   JSR EDIT_CHROUT
d503 c8                 INY
d504 c0 08              CPY #8
d506 d0 03              BNE MPAH_42
d508 20 1b d5           JSR Mon_Print_Blank
d50b c4 b5    MPAH_42   CPY MONCNT
d50d 90 e2              BCC MPAH_20
d50f 60       MPAH_Ret  RTS ;Size   67 [Mon_Print_A_Hex_Values]

              ; *****************
d510            Mon_STAL_Register
              ; *****************

d510 a9 a4              LDA #<[Mon_Register+4]
d512 85 fb              STA STAL
d514 a9 02              LDA #>[Mon_Register+4]
d516 85 fc              STA STAL+1
d518 a9 07              LDA #7              ; 7 bytes to display
d51a 60                 RTS ;Size   11 [Mon_STAL_Register]

              ; ***************
d51b            Mon_Print_Blank
              ; ***************

d51b a9 20              LDA #$20            ; ' '
d51d 2c                 .BYTE $2c

              ; ************
d51e            Mon_Print_CR
              ; ************

d51e a9 0d              LDA #CR
d520 4c 02 e2           JMP EDIT_CHROUT


d523 42 53 20   Mon_Start .BYTE "BS MONITOR "

              ; ************
d52e            Mon_Commands
              ; ************

d52e 23 24 2e           .BYTE "#$./:;@ABCDFGHLMNRSTUWX",0

              ; **********
d546            Mon_Sub_Hi
              ; **********

d546 fd                 .BYTE >[Mon_Unit-1]           ; #
d547 fb                 .BYTE >[Mon_Dir-1]            ; $
d548 fa                 .BYTE >[Assemble-1]           ; .
d549 d6                 .BYTE >[Mon_Load-1]           ; /
d54a d6                 .BYTE >[Modify_Memory-1]      ; :
d54b d6                 .BYTE >[Modify_Register-1]    ; ;
d54c fb                 .BYTE >[Mon_Wedge-1]          ; @
d54d fa                 .BYTE >[Assemble-1]           ; A
d54e d8                 .BYTE >[Mon_Set_Bank-1]       ; B
d54f fb                 .BYTE >[Mon_Compare-1]        ; C
d550 f5                 .BYTE >[Disassemble-1]        ; D
d551 e5                 .BYTE >[Mon_Fill-1]           ; F
d552 d6                 .BYTE >[Mon_Go-1]             ; G
d553 fc                 .BYTE >[Mon_Hunt-1]           ; H
d554 d6                 .BYTE >[Mon_Load-1]           ; L
d555 d5                 .BYTE >[Display_Memory-1]     ; M
d556 fd                 .BYTE >[Mon_Next]             ; N
d557 d5                 .BYTE >[Display_Register-1]   ; R
d558 d6                 .BYTE >[Mon_Save-1]           ; S
d559 fc                 .BYTE >[Mon_Transfer-1]       ; T
d55a e5                 .BYTE >[Mon_Disk-1]           ; U
d55b d8                 .BYTE >[Mon_Write_Bank-1]     ; W
d55c d6                 .BYTE >[Mon_Exit-1]           ; X

              ; **********
d55d            Mon_Sub_Lo
              ; **********

d55d 50                 .BYTE <[Mon_Unit-1]           ; #
d55e 5e                 .BYTE <[Mon_Dir-1]            ; $
d55f 41                 .BYTE <[Assemble-1]           ; .
d560 cd                 .BYTE <[Mon_Load-1]           ; /
d561 58                 .BYTE <[Modify_Memory-1]      ; :
d562 3e                 .BYTE <[Modify_Register-1]    ; ;
d563 3d                 .BYTE <[Mon_Wedge-1]          ; @
d564 41                 .BYTE <[Assemble-1]           ; A
d565 e3                 .BYTE <[Mon_Set_Bank-1]       ; B
d566 e3                 .BYTE <[Mon_Compare-1]        ; C
d567 c1                 .BYTE <[Disassemble-1]        ; D
d568 3e                 .BYTE <[Mon_Fill-1]           ; F
d569 83                 .BYTE <[Mon_Go-1]             ; G
d56a 7f                 .BYTE <[Mon_Hunt-1]           ; H
d56b cd                 .BYTE <[Mon_Load-1]           ; L
d56c f3                 .BYTE <[Display_Memory-1]     ; M
d56d 6e                 .BYTE <[Mon_Next]             ; N
d56e 7b                 .BYTE <[Display_Register-1]   ; R
d56f d0                 .BYTE <[Mon_Save-1]           ; S
d570 15                 .BYTE <[Mon_Transfer-1]       ; T
d571 a6                 .BYTE <[Mon_Disk-1]           ; U
d572 eb                 .BYTE <[Mon_Write_Bank-1]     ; W
d573 bd                 .BYTE <[Mon_Exit-1]           ; X

              ; **********
d574            Mon_Prompt
              ; **********

d574 48                 PHA
d575 20 1e d5           JSR Mon_Print_CR
d578 68                 PLA
d579 4c 02 e2           JMP EDIT_CHROUT

              ; ****************
d57c            Display_Register
              ; ****************

d57c a2 00              LDX #0
d57e bd fb e4 DiRe_10   LDA Mon_Message,X
d581 20 02 e2           JSR EDIT_CHROUT
d584 e8                 INX
d585 e0 2a              CPX #42
d587 d0 f5              BNE DiRe_10
d589 a5 b6              LDA R_Bank
d58b 8d a9 02           STA Mon_Register+9
d58e a5 b7              LDA W_Bank
d590 8d aa 02           STA Mon_Register+10
d593 a9 3b              LDA #';'
d595 20 74 d5           JSR Mon_Prompt
d598 20 1b d5           JSR Mon_Print_Blank
d59b ad a0 02           LDA Mon_Register    ; display PC
d59e 20 54 d7           JSR Print_Hex_Byte
d5a1 ad a1 02           LDA Mon_Register+1
d5a4 20 54 d7           JSR Print_Hex_Byte
d5a7 20 1b d5           JSR Mon_Print_Blank
d5aa ad a2 02           LDA Mon_Register+2  ; display IRQ vector
d5ad 20 54 d7           JSR Print_Hex_Byte
d5b0 ad a3 02           LDA Mon_Register+3
d5b3 20 54 d7           JSR Print_Hex_Byte
d5b6 20 10 d5           JSR Mon_STAL_Register
d5b9 20 cd d4           JSR Mon_Print_A_Hex_Values
d5bc ad a4 02           LDA Mon_Register+4  ; SR
d5bf 85 b5              STA MONCNT
d5c1 a2 08              LDX #8
d5c3 a9 30    DiRe_20   LDA #'0'
d5c5 06 b5              ASL MONCNT
d5c7 69 00              ADC #0
d5c9 20 02 e2           JSR EDIT_CHROUT
d5cc ca                 DEX
d5cd d0 f4              BNE DiRe_20
d5cf a5 b3              LDA PC_Adjust
d5d1 d0 42              BNE To_Mon_Main     ; branch if not stepping
d5d3 ad a1 02           LDA Mon_Register+1
d5d6 85 fb              STA STAL
d5d8 ad a0 02           LDA Mon_Register
d5db 85 fc              STA STAL+1
d5dd 4c cf f5           JMP Disa_15


              ; ************
d5e0            Mon_Cmp_Addr
              ; ************

d5e0 a5 ba              LDA Dis_Line        ; negative: compare addresses
d5e2 30 07              BMI Cmp_STAL_MEMUSS
d5e4 e6 ba              INC Dis_Line
d5e6 a9 10              LDA #16
d5e8 c5 ba              CMP Dis_Line        ; line count > 16 ?
d5ea 60                 RTS ;Size   11 [Mon_Cmp_Addr]

              ; ***************
d5eb            Cmp_STAL_MEMUSS
              ; ***************

d5eb a5 fd              LDA MEMUSS          ; end addr >= start addr ?
d5ed c5 fb              CMP STAL
d5ef a5 fe              LDA MEMUSS+1
d5f1 e5 fc              SBC STAL+1
d5f3 60                 RTS ;Size    9 [Cmp_STAL_MEMUSS]

              ; **************
d5f4            Display_Memory
              ; **************

d5f4 20 18 d6           JSR Mon_Get_Addr
d5f7 20 35 f3 DiMe_10   JSR Check_STOP_Key  ; STOP key pressed?
d5fa f0 19              BEQ To_Mon_Main
d5fc 20 e0 d5           JSR Mon_Cmp_Addr
d5ff 90 14              BCC To_Mon_Main     ; STAL > MEMUSS ?
d601 a9 3a              LDA #':'
d603 20 74 d5           JSR Mon_Prompt
d606 20 4d d7           JSR Mon_Print_STAL
d609 a9 10              LDA #16             ; dump 16 bytes per line
d60b 20 cd d4           JSR Mon_Print_A_Hex_Values
d60e a9 10              LDA #16
d610 20 1b fb           JSR Add_STAL
d613 d0 e2              BNE DiMe_10
d615          To_Mon_Main
d615 4c ae d4           JMP Mon_Main

              ; ************
d618            Mon_Get_Addr
              ; ************

d618 a0 00              LDY #0              ; reset line count
d61a 84 ba              STY Dis_Line
d61c 88                 DEY                 ; Y = $ff
d61d 84 fd              STY MEMUSS
d61f 84 fe              STY MEMUSS+1        ; default end address = $ffff
d621 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d624 f0 13              BEQ MGA_Ret         ; use last value for STAL
d626 20 6a d7           JSR Hex_To_STAL     ; read start address to STAL
d629 90 0f              BCC MGA_Err
d62b 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d62e f0 09              BEQ MGA_Ret
d630 a2 fd              LDX #MEMUSS
d632 20 6c d7           JSR Read_Hex_Word  ; read end address
d635 90 03              BCC MGA_Err
d637 c6 ba              DEC Dis_Line        ; disable line count
d639 60       MGA_Ret   RTS ;Size   34 [Mon_Get_Addr]
d63a 68       MGA_Err   PLA
d63b 68                 PLA
d63c          To_Mon_Err
d63c 4c a9 d4           JMP Mon_Error

              ; ***************
d63f            Modify_Register
              ; ***************

d63f a2 00              LDX #0
d641 20 79 d7 MoRe_10   JSR Read_Hex
d644 9d a0 02           STA Mon_Register,X
d647 e8                 INX
d648 e0 0b              CPX #11
d64a 90 f5              BCC MoRe_10
d64c ad a9 02           LDA Mon_Register+9
d64f 85 b6              STA R_Bank
d651 ad aa 02           LDA Mon_Register+10
d654 85 b7              STA W_Bank
d656 4c ae d4           JMP Mon_Main

              ; *************
d659            Modify_Memory
              ; *************

d659 20 6a d7           JSR Hex_To_STAL
d65c 90 de              BCC To_Mon_Err
d65e a9 10              LDA #16
d660 85 b5    MoMe_10   STA MONCNT
d662 a5 fb              LDA STAL
d664 85 f9              STA BPTR
d666 a5 fc              LDA STAL+1
d668 85 fa              STA BPTR+1
d66a a0 00              LDY #0
d66c 20 79 d7 MoMe_20   JSR Read_Hex
d66f 90 cb              BCC To_Mon_Err
d671 85 cb              STA Mon_Tmp
d673 20 8b 02           JSR Bank_Store
d676 20 7a 02           JSR Bank_Fetch
d679 c5 cb              CMP Mon_Tmp
d67b d0 bf              BNE To_Mon_Err      ; not RAM
d67d c8       MoMe_30   INY
d67e c4 b5              CPY MONCNT
d680 90 ea              BCC MoMe_20
d682 b0 91              BCS To_Mon_Main

              ; ******
d684            Mon_Go
              ; ******

d684 20 f4 d8           JSR Mon_CHRIN
d687 f0 10              BEQ MoGo_10
d689 c9 20              CMP #' '
d68b d0 af              BNE To_Mon_Err
d68d 20 79 d7           JSR Read_Hex
d690 8d a0 02           STA Mon_Register
d693 20 79 d7           JSR Read_Hex
d696 8d a1 02           STA Mon_Register+1
d699 78       MoGo_10   SEI
d69a ad a2 02           LDA Mon_Register+2  ; IRQ
d69d 85 91              STA CINV+1
d69f ad a3 02           LDA Mon_Register+3
d6a2 85 90              STA CINV

              ; ********
d6a4            Mon_Step
              ; ********

d6a4 ae a8 02           LDX Mon_Register+8  ; SP
d6a7 9a                 TXS
d6a8 ad a0 02           LDA Mon_Register    ; PC high
d6ab 48                 PHA
d6ac ad a1 02           LDA Mon_Register+1  ; PC low
d6af 48                 PHA
d6b0 ad a4 02           LDA Mon_Register+4  ; SR
d6b3 48                 PHA
d6b4 ad a5 02           LDA Mon_Register+5
d6b7 ae a6 02           LDX Mon_Register+6
d6ba ac a7 02           LDY Mon_Register+7
d6bd 40                 RTI

              ; ********
d6be            Mon_Exit
              ; ********

d6be ae a8 02           LDX Mon_Register+8  ; SP
d6c1 9a                 TXS
d6c2 4c ff b3           JMP Basic_Ready

              ; *************
d6c5            Set_DOS_FNADR
              ; *************

d6c5 a9 42              LDA #<DOS_Filename
d6c7 85 da              STA FNADR
d6c9 a9 03              LDA #>DOS_Filename
d6cb 85 db              STA FNADR+1
d6cd 60                 RTS ;Size    9 [Set_DOS_FNADR]

              ; ********
d6ce            Mon_Load
              ; ********

d6ce a9 00              LDA #0              ; load flag
d6d0 2c                 .BYTE $2c           ; skip 2 bytes

              ; ********
d6d1            Mon_Save
              ; ********

d6d1 a9 80              LDA #$80            ; save flag
d6d3 85 9d              STA VERCK           ; (0) LOAD, ($80) SAVE
d6d5 a0 01              LDY #1
d6d7 84 d3              STY SA              ; use file load address
d6d9 88                 DEY                 ; Y = 0
d6da 20 c5 d6           JSR Set_DOS_FNADR
d6dd 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
d6e0 20 f4 d8 MLS_10    JSR Mon_CHRIN
d6e3 f0 14              BEQ MLS_Err         ; filename required
d6e5 c9 22              CMP #QUOTE          ; filename must be quoted
d6e7 d0 f7              BNE MLS_10          ; skip until leading quote
d6e9 20 f4 d8 MLS_20    JSR Mon_CHRIN       ; next char in string
d6ec f0 0b              BEQ MLS_Err         ; no ending quote
d6ee c9 22              CMP #QUOTE          ; ending quote?
d6f0 f0 14              BEQ MLS_50
d6f2 91 da              STA (FNADR),Y       ; append to filename
d6f4 c8                 INY                 ; next
d6f5 c0 10              CPY #16
d6f7 90 f0              BCC MLS_20          ; loop
d6f9 4c a9 d4 MLS_Err   JMP Mon_Error

d6fc 24 9d    MLS_30    BIT VERCK           ; LOAD or SAVE ?
d6fe 30 f9    MLS_35    BMI MLS_Err         ; SAVE needs range
d700 20 56 f3           JSR Load_File
d703 4c ae d4           JMP Mon_Main        ; OK - done

d706 84 d1    MLS_50    STY FNLEN
d708 20 f4 d8           JSR Mon_CHRIN       ; parameter after filename
d70b f0 ef              BEQ MLS_30
d70d c9 2c              CMP #','            ; comma needed
d70f d0 f5              BNE MLS_50
d711 20 79 d7           JSR Read_Hex        ; read device
d714 85 d4              STA FA
d716 20 f4 d8           JSR Mon_CHRIN
d719 f0 e1              BEQ MLS_30          ; no range -> LOAD
d71b c9 2c              CMP #','            ; comma needed
d71d d0 da              BNE MLS_Err
d71f 20 6a d7           JSR Hex_To_STAL     ; STAL = start address
d722 a9 00              LDA #0
d724 85 d3              STA SA              ; relocate to EAL
d726 20 f4 d8           JSR Mon_CHRIN
d729 c9 2c              CMP #','
d72b d0 cc              BNE MLS_Err
d72d a2 c9              LDX #EAL
d72f 20 6c d7           JSR Read_Hex_Word   ; EAL  = end address
d732 90 c5              BCC MLS_Err
d734 24 9d              BIT VERCK           ; (0) LOAD or ($80) SAVE
d736 10 c1              BPL MLS_Err
d738 20 e3 f6           JSR Save_File
d73b 4c ae d4           JMP Mon_Main

              ; *************
d73e            Make_Hex_Byte
              ; *************

d73e 48                 PHA
d73f 4a                 LSR A
d740 4a                 LSR A
d741 4a                 LSR A
d742 4a                 LSR A
d743 20 60 d7           JSR Nibble_To_Hex
d746 aa                 TAX
d747 68                 PLA
d748 29 0f              AND #15
d74a 4c 60 d7           JMP Nibble_To_Hex

              ; **************
d74d            Mon_Print_STAL
              ; **************

d74d a5 fc              LDA STAL+1
d74f 20 54 d7           JSR Print_Hex_Byte
d752 a5 fb              LDA STAL

              ; **************
d754            Print_Hex_Byte
              ; **************

d754 20 3e d7           JSR Make_Hex_Byte

              ; ************
d757            Mon_Print_XA
              ; ************

d757 48                 PHA
d758 8a                 TXA
d759 20 02 e2           JSR EDIT_CHROUT
d75c 68                 PLA
d75d 4c 02 e2           JMP EDIT_CHROUT

              ; *************
d760            Nibble_To_Hex
              ; *************

d760 18                 CLC
d761 69 f6              ADC #$f6
d763 90 02              BCC NTH_10
d765 69 06              ADC #6
d767 69 3a    NTH_10    ADC #$3a
d769 60                 RTS ;Size   10 [Nibble_To_Hex]

              ; ***********
d76a            Hex_To_STAL
              ; ***********

d76a a2 fb              LDX #STAL

              ; *************
d76c            Read_Hex_Word
              ; *************

d76c 20 79 d7           JSR Read_Hex        ; X points to word address
d76f 90 07              BCC RHW_Ret
d771 95 01              STA 1,X             ; high byte
d773 20 79 d7           JSR Read_Hex
d776 95 00              STA 0,X             ; low  byte
d778 60       RHW_Ret   RTS ;Size   13 [Read_Hex_Word]

              ; ********
d779            Read_Hex
              ; ********

              ; read a two digit hex number, allow leading blanks

d779 20 f4 d8           JSR Mon_CHRIN
d77c c9 20              CMP #' '
d77e f0 f9              BEQ Read_Hex
d780          Read_Hex_A
d780 20 11 d9           JSR Is_Hex
d783 90 17              BCC ReHe_Ret         ; error
d785 20 fa d8           JSR Hex_To_Bin
d788 0a                 ASL A
d789 0a                 ASL A
d78a 0a                 ASL A
d78b 0a                 ASL A
d78c 85 cb              STA Mon_Tmp
d78e 20 f4 d8           JSR Mon_CHRIN
d791 20 11 d9           JSR Is_Hex
d794 90 06              BCC ReHe_Ret         ; error
d796 20 fa d8           JSR Hex_To_Bin
d799 05 cb              ORA Mon_Tmp
d79b 38                 SEC
d79c 60       ReHe_Ret  RTS ;Size   36 [Read_Hex]


d79d 00 00 00           .FILL $d7af - * (0) ; 18 bytes

              ; *************
d7af            Kernal_RECORD
              ; *************

d7af a9 01              LDA #1
d7b1 8d 3a 03           STA DOS_Tmp         ; default for position
d7b4 20 76 00           JSR CHRGOT
d7b7 a9 23              LDA #'#'
d7b9 20 f7 be           JSR Need_A
d7bc 20 8a de           JSR DOS_Get_Byte    ; get lfn
d7bf e0 00              CPX #0
d7c1 f0 3e              BEQ RECO_40
d7c3 86 d2              STX LA
d7c5 20 f5 be           JSR Need_Comma
d7c8 f0 3e              BEQ DOS_JMP_Syntax_Error
d7ca 90 0f              BCC RECO_10         ; -> numeric
d7cc 20 f2 be           JSR Need_Left_Parenthesis
d7cf 20 98 bd           JSR Eval_Expression
d7d2 20 2d c9           JSR FAC1_To_LINNUM
d7d5 20 ef be           JSR Need_Right_Parenthesis
d7d8 4c e1 d7           JMP RECO_20
d7db 20 98 bd RECO_10   JSR Eval_Expression ; get record #
d7de 20 2d c9           JSR FAC1_To_LINNUM
d7e1 20 76 00 RECO_20   JSR CHRGOT
d7e4 f0 18              BEQ RECO_30
d7e6 20 f5 be           JSR Need_Comma
d7e9 f0 1d              BEQ DOS_JMP_Syntax_Error
d7eb 20 8a de           JSR DOS_Get_Byte    ; get position
d7ee e0 00              CPX #0
d7f0 f0 0f              BEQ RECO_40
d7f2 e0 ff              CPX #$ff
d7f4 f0 0b              BEQ RECO_40
d7f6 8e 3a 03           STX DOS_Tmp
d7f9 20 76 00           JSR CHRGOT
d7fc d0 0a              BNE DOS_JMP_Syntax_Error
d7fe 4c 31 da RECO_30   JMP Build_Record_Command
d801 4c 27 de RECO_40   JMP DOS_JMP_Illegal_Quantity

              ; *************************
d804            Allow_Drive_Unit_Filename
              ; *************************

d804 29 e6              AND #$e6
d806 f0 03              BEQ Check_Filename_Given

              ; ********************
d808            DOS_JMP_Syntax_Error
              ; ********************

d808 4c 00 bf           JMP Syntax_Error

              ; ********************
d80b            Check_Filename_Given
              ; ********************

d80b ad 3e 03           LDA DOS_Flags
d80e 29 01              AND #1
d810 c9 01              CMP #1
d812 d0 f4              BNE DOS_JMP_Syntax_Error
d814 ad 3e 03           LDA DOS_Flags
d817 60                 RTS ;Size   13 [Check_Filename_Given]

              ; ********************
d818            Allow_Drive_And_Unit
              ; ********************

d818 29 e7              AND #$e7
d81a d0 ec              BNE DOS_JMP_Syntax_Error
d81c 60                 RTS ;Size    5 [Allow_Drive_And_Unit]

              ; ************
d81d            No_WL_Record
              ; ************

d81d 29 c4              AND #$c4
d81f d0 e7              BNE DOS_JMP_Syntax_Error
d821 ad 3e 03           LDA DOS_Flags

              ; *********************
d824            Check_Filename_Syntax
              ; *********************

d824 29 03              AND #3
d826 c9 03              CMP #3
d828 d0 de              BNE DOS_JMP_Syntax_Error
d82a ad 3e 03           LDA DOS_Flags
d82d 60                 RTS ;Size   10 [Check_Filename_Syntax]

              ; *******************
d82e            Check_Record_Syntax
              ; *******************

d82e 29 05              AND #5
d830 c9 05              CMP #5
d832 d0 d4              BNE DOS_JMP_Syntax_Error
d834 ad 3e 03           LDA DOS_Flags
d837 60                 RTS ;Size   10 [Check_Record_Syntax]

              ; ***************
d838            DOS_Build_Table
              ; ***************

d838 ff                 .BYTE $ff
                        ;-------------------- directory $00
d839 24                 .BYTE "$"
d83a d1                 .BYTE $d1           ; drive 1

                        ;-------------------- dopen     $02
d83b d1                 .BYTE $d1           ; drive 1
d83c 3a                 .BYTE ":"
d83d f1                 .BYTE $f1           ; file 1
d83e 2c                 .BYTE ","
d83f e1                 .BYTE $e1           ; L,S,W
d840 2c                 .BYTE ","
d841 e0                 .BYTE $e0           ; Record length

                        ;-------------------- append    $09
d842 d1                 .BYTE $d1           ; drive 1
d843 3a                 .BYTE ":"
d844 f1                 .BYTE $f1           ; file 1
d845 2c 41              .BYTE ",A"

                        ;-------------------- header    $0e
d847 4e                 .BYTE "N"
d848 d1                 .BYTE $d1           ; drive 1
d849 3a                 .BYTE ":"
d84a f1                 .BYTE $f1           ; file 1
d84b 2c                 .BYTE ","
d84c d0                 .BYTE $d0           ; ID

                        ;-------------------- collect   $14
d84d 56                 .BYTE "V"
d84e d1                 .BYTE $d1           ; drive 1

                        ;-------------------- backup    $16
d84f 44                 .BYTE "D"
d850 d2                 .BYTE $d2           ; drive 2
d851 3d                 .BYTE "="
d852 d1                 .BYTE $d1           ; drive 1

                        ;-------------------- copy      $1a
d853 43                 .BYTE "C"
d854 d2                 .BYTE $d2           ; drive 2
d855 3a                 .BYTE ":"
d856 f2                 .BYTE $f2           ; file 2
d857 3d                 .BYTE "="
d858 d1                 .BYTE $d1           ; drive 1
d859 3a                 .BYTE ":"
d85a f1                 .BYTE $f1           ; file 1

                        ;-------------------- concat    $22
d85b 43                 .BYTE "C"
d85c d2                 .BYTE $d2           ; drive 2
d85d 3a                 .BYTE ":"
d85e f2                 .BYTE $f2           ; file 2
d85f 3d                 .BYTE "="
d860 d2                 .BYTE $d2           ; drive 2
d861 3a                 .BYTE ":"
d862 f2                 .BYTE $f2           ; file 2
d863 2c                 .BYTE ","
d864 d1                 .BYTE $d1           ; drive 1
d865 3a                 .BYTE ":"
d866 f1                 .BYTE $f1           ; file 1

                        ;-------------------- rename    $2e
d867 52                 .BYTE "R"
d868 d1                 .BYTE $d1           ; drive 1
d869 3a                 .BYTE ":"
d86a f2                 .BYTE $f2           ; file 2
d86b 3d                 .BYTE "="
d86c d1                 .BYTE $d1           ; drive 1
d86d 3a                 .BYTE ":"
d86e f1                 .BYTE $f1           ; file 1

                        ;-------------------- scratch   $36
d86f 53                 .BYTE "S"
d870 d1                 .BYTE $d1           ; drive 1
d871 3a                 .BYTE ":"
d872 f1                 .BYTE $f1           ; file 1

              ; ****************
d873            Kernal_DIRECTORY
              ; ****************

d873 20 68 dc           JSR Parse_DOS_Parameter
d876 20 18 d8           JSR Allow_Drive_And_Unit
d879 a0 00              LDY #0
d87b a2 01              LDX #1
d87d ad 3e 03           LDA DOS_Flags
d880 29 10              AND #16
d882 f0 01              BEQ DIRE_10
d884 e8                 INX                 ; drive given
d885 8a       DIRE_10   TXA
d886 20 fa db           JSR Build_DOS_Command

              ; **************
d889            Wedge_Call_Dir
              ; **************

d889 a9 60              LDA #$60            ; secondary address 0 for LOAD
d88b 85 d3              STA SA
d88d a9 0e              LDA #14             ; logical address used for loading directory
d88f 85 d2              STA LA
d891 20 b9 f1           JSR UNLSN
d894 20 65 f5           JSR Open_File
d897 a2 0e              LDX #14
d899 20 af f7           JSR Kernal_CHKIN    ; input from floppy
d89c a0 03              LDY #3              ; 1st time: skip load address + next line link
d89e 20 c0 f1 WCD_10    JSR ACPTR           ; read until length in blocks read
d8a1 aa                 TAX                 ; file size low in X
d8a2 a5 96              LDA STATUS
d8a4 d0 36              BNE WCD_80          ; abort if status bad
d8a6 20 c0 f1           JSR ACPTR           ; file size high in A
d8a9 88                 DEY
d8aa d0 f2              BNE WCD_10          ; if not done
d8ac 20 83 cf           JSR Print_Integer_XA; output number of blocks
d8af a9 20              LDA #' '            ; output separator space
d8b1 20 02 e2           JSR EDIT_CHROUT
d8b4 20 c0 f1 WCD_20    JSR ACPTR           ; get char
d8b7 f0 1a              BEQ WCD_40          ; branch if end of line
d8b9 a6 96              LDX STATUS          ; get status
d8bb d0 1f              BNE WCD_80          ; abort if bad status
d8bd 20 02 e2           JSR EDIT_CHROUT
d8c0 20 35 f3           JSR Check_STOP_Key  ; abort if STOP key pressed
d8c3 f0 17              BEQ WCD_80
d8c5 20 0d f2           JSR GETIN_10        ; read keyboard
d8c8 c9 20              CMP #' '
d8ca d0 e8              BNE WCD_20          ; continue if not SPACE pressed
d8cc 20 0d f2 WCD_30    JSR GETIN_10        ; read keyboard
d8cf f0 fb              BEQ WCD_30          ; loop until any key pressed
d8d1 d0 e1              BNE WCD_20          ; branch always: continue reading dir characters

d8d3 a9 0d    WCD_40    LDA #CR             ; end of line: output CR
d8d5 20 02 e2           JSR EDIT_CHROUT
d8d8 a0 02              LDY #2              ; further passes: skip line link only
d8da d0 c2              BNE WCD_10          ; branch always

d8dc 20 a6 f2 WCD_80    JSR Kernal_CLRCHN   ; exit: clear channel
d8df a9 0e              LDA #14             ; close directory
d8e1 4c e2 f2           JMP Close_LA_in_A

              ; ************
d8e4            Mon_Set_Bank
              ; ************

d8e4 20 79 d7           JSR Read_Hex
d8e7 85 b6              STA R_Bank
d8e9 4c ae d4           JMP Mon_Main

              ; **************
d8ec            Mon_Write_Bank
              ; **************

d8ec 20 79 d7           JSR Read_Hex
d8ef 85 b7              STA W_Bank
d8f1 4c ae d4           JMP Mon_Main

              ; *********
d8f4            Mon_CHRIN
              ; *********

d8f4 20 15 f2           JSR Kernal_CHRIN
d8f7 c9 0d              CMP #CR
d8f9 60                 RTS ;Size    6 [Mon_CHRIN]

              ; **********
d8fa            Hex_To_Bin
              ; **********

d8fa c9 3a              CMP #$3a
d8fc 08                 PHP
d8fd 29 0f              AND #15
d8ff 28                 PLP
d900 90 02              BCC HTB_Ret
d902 69 08              ADC #8
d904 60       HTB_Ret   RTS ;Size   11 [Hex_To_Bin]

              ; ******
d905            Is_Int
              ; ******

d905 c9 24              CMP #'$'
d907 f0 18              BEQ IH_True
d909 c9 2b              CMP #'+'
d90b f0 14              BEQ IH_True
d90d c9 2d              CMP #'-'
d90f f0 10              BEQ IH_True

              ; ******
d911            Is_Hex
              ; ******

d911 c9 47              CMP #'F'+1
d913 b0 0e              BCS IH_False
d915 c9 41              CMP #'A'
d917 b0 08              BCS IH_True

              ; ******
d919            Is_Dec
              ; ******

d919 c9 30              CMP #'0'
d91b 90 06              BCC IH_False
d91d c9 3a              CMP #'9'+1
d91f b0 02              BCS IH_False
d921 38       IH_True   SEC
d922 60                 RTS                 ; carry 1 : true ;Size   10 [Is_Dec]
d923 18       IH_False  CLC
d924 60                 RTS                 ; carry 0 : false ;Size   12 [Is_Dec]

d925 00 00 00           .FILL $d92f - * (0) ; 10 bytes

              ; **************
d92f            Select_Free_SA
              ; **************

d92f a0 61              LDY #$61            ; start with SA = $62
d931 c8       SFSA_10   INY
d932 98                 TYA
d933 a6 ae              LDX LDTND           ; # of open files
d935 ca       SFSA_20   DEX
d936 30 07              BMI SFSA_30         ; -> not in use : take this SA
d938 dd 65 02           CMP SAT,X
d93b f0 f4              BEQ SFSA_10         ; -> in use: try next
d93d d0 f6              BNE SFSA_20
d93f 84 d3    SFSA_30   STY SA
d941 60                 RTS ;Size   19 [Select_Free_SA]

              ; ********************
d942            Kernal_DOPEN ; $d942
              ; ********************

d942 20 68 dc           JSR Parse_DOS_Parameter
d945 20 2e d8           JSR Check_Record_Syntax
d948 29 22              AND #$22            ; 2nd. filename or drive ?
d94a d0 20              BNE DOPEN_Err
d94c 20 2f d9           JSR Select_Free_SA  ; choose free secondary address
d94f a2 00              LDX #0              ; buffer index
d951 a9 03              LDA #3              ; length of build string (open read)
d953 2c 3e 03           BIT DOS_Flags
d956 50 04              BVC DOPEN_20        ; -> not a write file
d958 08                 PHP                 ; save flags
d959 a9 07              LDA #7              ; length of build string (open write)
d95b 28                 PLP                 ; restore flags
d95c 10 06    DOPEN_20  BPL DOPEN_30        ; -> not a replacement
d95e a0 40              LDY #'@'            ; insert save & replace command
d960 8c 53 03           STY DOS_Command_Buffer
d963 e8                 INX                 ; advance buffer index
d964 a0 02    DOPEN_30  LDY #2              ; start  of build string (open)
d966 20 fc db           JSR Build_DOS_Command_X
d969 4c 63 f5           JMP Mf563
d96c 4c 00 bf DOPEN_Err JMP Syntax_Error

d96f                    .SIZE ;   45 [Kernal_DOPEN]

d96f 00 00 00           .FILL $d977-* (0) ; 8 bytes

              ; *********************
d977            Kernal_APPEND ; $d977
              ; *********************

d977 20 68 dc           JSR Parse_DOS_Parameter
d97a 20 2e d8           JSR Check_Record_Syntax
d97d 29 e2              AND #$e2            ; @,W,L,drive 2 or file 2 ?
d97f d0 eb              BNE DOPEN_Err
d981 20 2f d9           JSR Select_Free_SA
d984 a0 09              LDY #9              ; start  of build string (append)
d986 a9 05              LDA #5              ; length of build string (append)
d988 20 fa db           JSR Build_DOS_Command
d98b 4c 63 f5           JMP Mf563

d98e 00 00 00           .FILL $d991-* (0) ; 3 bytes

              ; **********************
d991            Kernal_Read_DS ; $d991
              ; **********************

d991 a5 d4              LDA FA
d993 d0 04              BNE KRD_10
d995 a9 08              LDA #8              ; default 8 if not set
d997 85 d4              STA FA
d999 20 d2 f0 KRD_10    JSR TALK
d99c a9 6f              LDA #$6f
d99e 85 d3              STA SA
d9a0 20 93 f1           JSR TKSA
d9a3 a2 00              LDX #0
d9a5 20 c0 f1 KDR_20    JSR ACPTR
d9a8 9d ad 03           STA DOS_Status,X
d9ab e8                 INX
d9ac c9 20              CMP #' '
d9ae 90 04              BCC KDR_30          ; end (normally CR)
d9b0 e0 29              CPX #41             ; buffer length
d9b2 90 f1              BCC KDR_20
d9b4 a9 00    KDR_30    LDA #0
d9b6 9d ad 03           STA DOS_Status,X
d9b9 20 ae f1           JSR UNTLK
d9bc ad ad 03           LDA DOS_Status      ; load first character
d9bf 60                 RTS ;Size   47 [Kernal_Read_DS]

d9c0 00 00 00           .FILL $d9d2-* (0) ; 18 bytes

              ; *********************
d9d2            Kernal_HEADER ; $d9d2
              ; *********************

d9d2 20 68 dc           JSR Parse_DOS_Parameter
d9d5 20 04 d8           JSR Allow_Drive_Unit_Filename
d9d8 29 11              AND #$11
d9da c9 11              CMP #$11            ; name & drive set ?
d9dc d0 8e              BNE DOPEN_Err
d9de 20 1b da           JSR Close_All_Device_Files
d9e1 20 9e db           JSR Are_You_Sure
d9e4 b0 1f              BCS HEAD_20         ; cancel if not 'YES'
d9e6 a0 0e              LDY #14             ; start  of build string
d9e8 a9 04              LDA #4              ; length of build string
d9ea ae 3f 03           LDX DOS_Id          ; ID given ?
d9ed f0 02              BEQ HEAD_10
d9ef a9 06              LDA #6              ; command includes ID
d9f1 20 98 da HEAD_10   JSR Put_DOS_Command
d9f4 20 91 d9           JSR Kernal_Read_DS
d9f7 c9 32              CMP #'2'
d9f9 90 0a              BCC HEAD_20         ; status < 20 are warnings
d9fb 20 51 f3           JSR In_Direct_Mode
d9fe d0 05              BNE HEAD_20
da00 a0 c5              LDY #<MSG_BAD_DISK  ; $c5
da02 4c 85 f1           JMP Display_Kernal_Message
da05 60       HEAD_20   RTS ;Size   52 [Kernal_HEADER]

da06 00                 .FILL $da07-* (0) ; 1 bytes

              ; *********************
da07            Kernal_DCLOSE ; $da07
              ; *********************

da07 20 68 dc           JSR Parse_DOS_Parameter
da0a 29 f3              AND #$f3            ; allow lfn only
da0c f0 03              BEQ CLOSE_10
da0e 4c 00 bf           JMP Syntax_Error
da11 20 e1 db CLOSE_10  JSR Clear_Status
da14 a5 d2              LDA LA
da16 f0 03              BEQ Close_All_Device_Files
da18 4c e2 f2           JMP Close_LA_in_A

              ; ******************************
da1b            Close_All_Device_Files ; $da1b
              ; ******************************

da1b a5 d4              LDA FA              ; Close all open files on device FA
da1d a6 ae              LDX LDTND
da1f ca       CLOSE_20  DEX
da20 30 0e              BMI CLOSE_Ret
da22 dd 5b 02           CMP FAT,X
da25 d0 f8              BNE CLOSE_20
da27 bd 51 02           LDA LAT,X
da2a 20 e7 f2           JSR Close_File_A
da2d b8                 CLV
da2e 50 eb              BVC Close_All_Device_Files
da30 60       CLOSE_Ret RTS ;Size   22 [Close_All_Device_Files]

              ; ****************************
da31            Build_Record_Command ; $da31
              ; ****************************

da31 a5 d2              LDA LA
da33 20 c1 f2           JSR LOOKUP_LA
da36 f0 05              BEQ BRC_10
da38 a0 17              LDY #<MSG_FILE_NOT_O; $17
da3a 4c af f5           JMP Handle_IO_Error
da3d 20 cd f2 BRC_10    JSR Set_LFS_From_X
da40 20 e1 db           JSR Clear_Status

              ; *********************
da43            DOS_Record_No ; $da43
              ; *********************

da43 a9 50              LDA #'P'
da45 8d 53 03           STA DOS_Command_Buffer
da48 a5 d3              LDA SA
da4a 8d 54 03           STA DOS_Command_Buffer+1
da4d a5 11              LDA LINNUM
da4f 8d 55 03           STA DOS_Command_Buffer+2
da52 a5 12              LDA LINNUM+1
da54 8d 56 03           STA DOS_Command_Buffer+3
da57 ad 3a 03           LDA DOS_Tmp
da5a 8d 57 03           STA DOS_Command_Buffer+4
da5d a2 05              LDX #5
da5f 20 4c dc           JSR DOS_SETNAM
da62 4c 9b da           JMP PDC_10

              ; **********************
da65            Kernal_COLLECT ; $da65
              ; **********************

da65 20 68 dc           JSR Parse_DOS_Parameter
da68 20 18 d8           JSR Allow_Drive_And_Unit
da6b 20 1b da           JSR Close_All_Device_Files
da6e a0 14              LDY #$14
da70 a2 01              LDX #1
da72 ad 3e 03           LDA DOS_Flags
da75 29 10              AND #16             ; drive set ?
da77 f0 01              BEQ COLL_10
da79 e8                 INX
da7a 8a       COLL_10   TXA
da7b 4c 98 da           JMP Put_DOS_Command

              ; *************
da7e            Kernal_BACKUP
              ; *************

da7e 20 68 dc           JSR Parse_DOS_Parameter
da81 29 30              AND #$30
da83 c9 30              CMP #$30            ; two drives set ?
da85 f0 03              BEQ BACK_10
da87 4c 00 bf BACK_Err  JMP Syntax_Error
da8a ad 3e 03 BACK_10   LDA DOS_Flags
da8d 29 c7              AND #$c7
da8f d0 f6              BNE BACK_Err
da91 20 1b da           JSR Close_All_Device_Files
da94 a0 16              LDY #$16
da96 a9 04              LDA #4

              ; ***************
da98            Put_DOS_Command
              ; ***************

da98 20 fa db           JSR Build_DOS_Command
da9b 20 d5 f0 PDC_10    JSR LISTEN
da9e a9 6f              LDA #$6f            ; SA #15
daa0 4c ba f4           JMP Send_DOS_Command

daa3 00 00 00           .FILL $daa7-* (0) ; 4 bytes

              ; *******************
daa7            Kernal_COPY ; $daa7
              ; *******************

daa7 20 68 dc           JSR Parse_DOS_Parameter
daaa a5 9c              LDA Source_Unit     ; check source unit
daac f0 07              BEQ KECO_10         ; not specified
daae c5 d4              CMP FA              ; same as target ?
dab0 f0 03              BEQ KECO_10         ; yes, stay here
dab2 4c 3a ee           JMP DOS_Copy        ; -> extended COPY
dab5 a0 1a    KECO_10   LDY #$1a            ; offset
dab7 a9 08              LDA #8              ; command length
dab9 4c 98 da           JMP Put_DOS_Command

dabc 00 00 00           .FILL $dac7 - * (0) ; 11 bytes

              ; *********************
dac7            Kernal_CONCAT ; $dac7
              ; *********************

dac7 20 68 dc           JSR Parse_DOS_Parameter
daca 20 1d d8           JSR No_WL_Record
dacd a0 22              LDY #$22
dacf a9 0c              LDA #12
dad1 4c 98 da           JMP Put_DOS_Command

              ; ***************************
dad4            Copy_Filename_To_DOS_Buffer
              ; ***************************

dad4 a5 d1              LDA FNLEN
dad6 8d 3a 03           STA DOS_Tmp
dad9 a5 da              LDA FNADR
dadb 85 fd              STA MEMUSS
dadd a5 db              LDA FNADR+1
dadf 85 fe              STA MEMUSS+1

              ; *************************
dae1            Copy_MEMUSS_To_DOS_Buffer
              ; *************************

dae1 98                 TYA
dae2 48                 PHA
dae3 ac 3a 03           LDY DOS_Tmp
dae6 f0 10              BEQ CMDB_20
dae8 a0 00              LDY #0
daea b1 fd    CMDB_10   LDA (MEMUSS),Y
daec 9d 53 03           STA DOS_Command_Buffer,X
daef e8                 INX
daf0 c8                 INY
daf1 cc 3a 03           CPY DOS_Tmp
daf4 d0 f4              BNE CMDB_10
daf6 f0 01              BEQ CMDB_30
daf8 ca       CMDB_20   DEX
daf9 68       CMDB_30   PLA
dafa a8                 TAY
dafb 38                 SEC
dafc 60                 RTS ;Size   28 [Copy_MEMUSS_To_DOS_Buffer]

              ; *************
dafd            Insert_DOS_Id
              ; *************

dafd ad 3f 03           LDA DOS_Id
db00 9d 53 03           STA DOS_Command_Buffer,X
db03 e8                 INX
db04 ad 40 03           LDA DOS_Id+1
db07 9d 53 03           STA DOS_Command_Buffer,X
db0a e8                 INX
db0b 8a                 TXA
db0c 60                 RTS ;Size   16 [Insert_DOS_Id]

              ; ********************
db0d            Kernal_DSAVE ; $db0d
              ; ********************

db0d 20 68 dc           JSR Parse_DOS_Parameter
db10 20 0b d8           JSR Check_Filename_Given
db13 29 66              AND #$66            ; no 2nd. file ?
db15 f0 03              BEQ DSAVE_10
db17 4c 00 bf           JMP Syntax_Error
db1a a0 02    DSAVE_10  LDY #2
db1c ad 3e 03           LDA DOS_Flags
db1f 29 80              AND #$80
db21 f0 0f              BEQ DSAVE_20
db23 a9 40              LDA #'@'            ; save & replace
db25 8d 53 03           STA DOS_Command_Buffer
db28 a2 01              LDX #1
db2a a9 03              LDA #3
db2c 20 fc db           JSR Build_DOS_Command_X
db2f 4c e0 f6           JMP Mf6e0
db32 a9 03    DSAVE_20  LDA #3
db34 20 fa db           JSR Build_DOS_Command
db37 4c e0 f6           JMP Mf6e0

              ; ********************
db3a            Kernal_DLOAD ; $db3a
              ; ********************

db3a 20 68 dc           JSR Parse_DOS_Parameter
db3d 20 0b d8           JSR Check_Filename_Given
db40 29 e6              AND #$e6
db42 f0 03              BEQ DLOAD_20
db44 4c 00 bf DLOAD_10  JMP Syntax_Error
db47 a0 02    DLOAD_20  LDY #2
db49 a9 03              LDA #3
db4b 20 fa db           JSR Build_DOS_Command
db4e a9 00              LDA #0
db50 85 9d              STA VERCK
db52 4c 1d f4           JMP Load_Verify_Params_Set

              ; *********************
db55            Kernal_RENAME ; $db55
              ; *********************

db55 20 68 dc           JSR Parse_DOS_Parameter
db58 20 24 d8           JSR Check_Filename_Syntax
db5b 29 e4              AND #$e4
db5d d0 e5              BNE DLOAD_10
db5f a0 2e              LDY #$2e
db61 a9 08              LDA #8
db63 4c 98 da           JMP Put_DOS_Command

              ; **********************
db66            Kernal_SCRATCH ; $db66
              ; **********************

db66 20 68 dc           JSR Parse_DOS_Parameter
db69 20 04 d8           JSR Allow_Drive_Unit_Filename
db6c 20 9e db           JSR Are_You_Sure
db6f b0 21              BCS DiSt_Ret
db71 a0 36              LDY #$36
db73 a9 04              LDA #4
db75 20 98 da           JSR Put_DOS_Command
db78 20 51 f3           JSR In_Direct_Mode
db7b d0 15              BNE DiSt_Ret
db7d 20 91 d9           JSR Kernal_Read_DS
db80 a9 0d              LDA #CR
db82 20 02 e2           JSR EDIT_CHROUT

              ; **************
db85            Display_Status
              ; **************

db85 a0 00              LDY #0
db87 b9 ad 03 DiSt_10   LDA DOS_Status,Y
db8a c8                 INY
db8b 20 02 e2           JSR EDIT_CHROUT
db8e c9 20              CMP #' '            ; check for end
db90 b0 f5              BCS DiSt_10
db92 60       DiSt_Ret  RTS ;Size   14 [Display_Status]

db93 00 00 00           .FILL $db9e-* (0) ; 11 bytes

              ; ********************
db9e            Are_You_Sure ; $db9e
              ; ********************

db9e 20 51 f3           JSR In_Direct_Mode
dba1 d0 32              BNE AYS_20
dba3 a0 b6              LDY #<MSG_SURE      ; $b6
dba5 20 85 f1           JSR Display_Kernal_Message
dba8 20 a6 f2           JSR Kernal_CLRCHN
dbab 20 15 f2           JSR Kernal_CHRIN
dbae c9 59              CMP #'Y'
dbb0 d0 19              BNE AYS_10
dbb2 20 15 f2           JSR Kernal_CHRIN
dbb5 c9 0d              CMP #CR
dbb7 f0 1c              BEQ AYS_20
dbb9 c9 45              CMP #'E'
dbbb d0 0e              BNE AYS_10
dbbd 20 15 f2           JSR Kernal_CHRIN
dbc0 c9 53              CMP #'S'
dbc2 d0 07              BNE AYS_10
dbc4 20 15 f2           JSR Kernal_CHRIN
dbc7 c9 0d              CMP #CR
dbc9 f0 0a              BEQ AYS_20
dbcb c9 0d    AYS_10    CMP #CR
dbcd 38                 SEC
dbce f0 06              BEQ AYS_Ret
dbd0 20 15 f2           JSR Kernal_CHRIN
dbd3 d0 f6              BNE AYS_10
dbd5 18       AYS_20    CLC
dbd6 60       AYS_Ret   RTS ;Size   57 [Are_You_Sure]

dbd7 00 00 00           .FILL $dbe1-* (0) ; 10 bytes

              ; ********************
dbe1            Clear_Status ; $dbe1
              ; ********************

dbe1 a9 00              LDA #0
dbe3 85 96              STA STATUS          ; clear STATUS
dbe5 60                 RTS ;Size    5 [Clear_Status]

dbe6 00 00 00           .FILL $dbfa-* (0) ; 20 bytes

              ; *************************
dbfa            Build_DOS_Command ; $dbfa
              ; *************************

dbfa a2 00              LDX #0

              ; *******************
dbfc            Build_DOS_Command_X
              ; *******************

dbfc 8d 41 03           STA DOS_Command_Length
dbff 20 e1 db           JSR Clear_Status
dc02 ce 41 03 BDC_10    DEC DOS_Command_Length
dc05 30 45              BMI DOS_SETNAM      ; -> finished
dc07 c8                 INY
dc08 b9 38 d8           LDA DOS_Build_Table,Y
dc0b 10 39              BPL BDC_90          ; -> insert
dc0d c9 f1              CMP #$f1            ; insert file 1
dc0f d0 03              BNE BDC_20
dc11 20 d4 da           JSR Copy_Filename_To_DOS_Buffer
dc14 c9 f2    BDC_20    CMP #$f2            ; insert file 2
dc16 d0 03              BNE BDC_30
dc18 20 e1 da           JSR Copy_MEMUSS_To_DOS_Buffer
dc1b c9 e0    BDC_30    CMP #$e0            ; insert 2nd. attribute
dc1d d0 05              BNE BDC_40          ; W,S or R,record length
dc1f ad 3d 03           LDA DOS_Attr        ; record length
dc22 d0 22              BNE BDC_90          ; always
dc24 c9 d0    BDC_40    CMP #$d0            ; insert ID
dc26 d0 03              BNE BDC_50
dc28 20 fd da           JSR Insert_DOS_Id
dc2b c9 e1    BDC_50    CMP #$e1            ; insert 1st. attribute
dc2d d0 05              BNE BDC_60
dc2f 20 57 dc           JSR Write_Attribute
dc32 d0 12              BNE BDC_90
dc34 c9 d1    BDC_60    CMP #$d1            ; insert drive 1
dc36 d0 05              BNE BDC_70
dc38 ad 3b 03           LDA DOS_Drive_1
dc3b 10 07              BPL BDC_80
dc3d c9 d2    BDC_70    CMP #$d2            ; insert drive 2
dc3f d0 c1              BNE BDC_10
dc41 ad 3c 03           LDA DOS_Drive_2
dc44 09 30    BDC_80    ORA #'0'
dc46 9d 53 03 BDC_90    STA DOS_Command_Buffer,X
dc49 e8                 INX
dc4a d0 b6              BNE BDC_10

              ; **********
dc4c            DOS_SETNAM
              ; **********

dc4c 86 d1              STX FNLEN
dc4e a9 53              LDA #<DOS_Command_Buffer
dc50 85 da              STA FNADR
dc52 a9 03              LDA #>DOS_Command_Buffer
dc54 85 db              STA FNADR+1
dc56 60                 RTS ;Size   11 [DOS_SETNAM]

              ; ***************
dc57            Write_Attribute
              ; ***************

dc57 ad 3d 03           LDA DOS_Attr
dc5a f0 04              BEQ WrAt_10
dc5c a9 4c              LDA #'L'            ; L,record length
dc5e d0 07              BNE WrAt_Ret
dc60 a9 53    WrAt_10   LDA #'S'            ; W,S
dc62 8d 3d 03           STA DOS_Attr
dc65 a9 57              LDA #'W'
dc67 60       WrAt_Ret  RTS ;Size   17 [Write_Attribute]

              ; This is the universal DOS parser
              ; It is called by all BASIC 4 DOS commands and scans and stores

              ; LA              = logical address
              ; FA              = primary address (UNIT)
              ; DOS_Drive_1     = source drive
              ; DOS_Drive_2     = target drive
              ; FNADR, FNLEN    = source filename
              ; MEMUSS, DOS_Tmp = target filename
              ; Access  mode
              ; Replace mode

              ; DOS_Flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

              ; The routine returns with the flags stored in DOS_Flags
              ; and in the accumulator.

              ; ***************************
dc68            Parse_DOS_Parameter ; $dc68
              ; ***************************

dc68 a2 00              LDX #0              ; clear:
dc6a 8e 3e 03           STX DOS_Flags       ; all flags
dc6d 86 d2              STX LA              ; logical address
dc6f 8e 3d 03           STX DOS_Attr        ; attribute
dc72 8e 3b 03           STX DOS_Drive_1     ; source drive
dc75 8e 3c 03           STX DOS_Drive_2     ; target drive
dc78 86 d1              STX FNLEN           ; filename length
dc7a 8e 3a 03           STX DOS_Tmp         ; temporary storage
dc7d 8e 3f 03           STX DOS_Id          ; ID
dc80 86 9c              STX Source_Unit     ; for cross UNIT copy
dc82 a2 08              LDX #8              ; preset DOS device
dc84 86 d4              STX FA              ; with unit 8
dc86 20 76 00           JSR CHRGOT          ; start parsing
dc89 d0 03              BNE PDP_02          ; continue
dc8b 4c f9 dd           JMP PDP_68          ; finish

dc8e c9 23    PDP_02    CMP #'#'            ; logical address ?
dc90 f0 2a              BEQ PDP_10
dc92 c9 57              CMP #'W'            ; write mode ?
dc94 f0 3e              BEQ PDP_12
dc96 c9 4c              CMP #'L'            ; relative file ?
dc98 f0 45              BEQ PDP_14
dc9a c9 52              CMP #'R'            ; read mode ?
dc9c d0 03              BNE PDP_04
dc9e 4c 4a dd           JMP PDP_37

dca1 c9 44    PDP_04    CMP #'D'            ; Drive ?
dca3 f0 63              BEQ PDP_26          ; parse drive #
dca5 c9 91              CMP #$91            ; ON token
dca7 f0 4f              BEQ PDP_22          ; parse unit D(value)
dca9 c9 55              CMP #'U'            ; Unit ?
dcab f0 53              BEQ PDP_24          ; parse unit value
dcad c9 22              CMP #QUOTE
dcaf f0 44              BEQ PDP_20
dcb1 c9 49              CMP #'I'            ; ID parameter on HEADER ?
dcb3 f0 72              BEQ PDP_30
dcb5 c9 28              CMP #'('
dcb7 f0 3c              BEQ PDP_20
dcb9 4c 00 bf PDP_08    JMP Syntax_Error    ; parse error

dcbc ad 3e 03 PDP_10    LDA DOS_Flags       ; get logical address
dcbf 29 04              AND #4              ; test if set already
dcc1 d0 f6              BNE PDP_08          ; error if set
dcc3 20 87 de           JSR DOS_Parse_Value ; get logical address
dcc6 e0 00              CPX #0              ; is address equal zero ?
dcc8 f0 5a              BEQ PDP_28          ; -> illegal quantity
dcca 86 d2              STX LA              ; store logical address
dccc a9 04              LDA #4              ; logical address defined
dcce 20 fd dd           JSR Set_DOS_Flags
dcd1 4c 72 dd           JMP PDP_44

dcd4 2c 3e 03 PDP_12    BIT DOS_Flags       ; process W parameter
dcd7 70 e0              BVS PDP_08          ; bit 6 already set ?
dcd9 20 70 00           JSR CHRGET          ; skip 'W'
dcdc 4c ed dc           JMP PDP_16          ; continue

dcdf 20 87 de PDP_14    JSR DOS_Parse_Value ; get record length
dce2 e0 00              CPX #0              ; is it zero ?
dce4 f0 3e              BEQ PDP_28          ; -> illegal quantity
dce6 e0 ff              CPX #$ff            ; ist it 255 ?
dce8 f0 3a              BEQ PDP_28          ; -> illegal quantity
dcea 8e 3d 03           STX DOS_Attr        ; store record length

dced a9 40    PDP_16    LDA #$40            ; mark W or L set
dcef 20 fd dd           JSR Set_DOS_Flags
dcf2 4c 72 dd           JMP PDP_44

dcf5 4c 50 dd PDP_20    JMP PDP_38

dcf8 20 2c de PDP_22    JSR DOS_Parse_Unit
dcfb 86 9c              STX Source_Unit
dcfd 4c 72 dd           JMP PDP_44
dd00 20 33 de PDP_24    JSR Get_Unit_Value
dd03 86 9c              STX Source_Unit
dd05 4c 72 dd           JMP PDP_44
dd08 ad 3e 03 PDP_26    LDA DOS_Flags
dd0b 29 10              AND #16             ; drive # already set ?
dd0d d0 aa              BNE PDP_08          ; error if so
dd0f 20 87 de           JSR DOS_Parse_Value
dd12 e0 0a              CPX #10             ; original ROM had CPX #2 (D0 and D1 only)
dd14 b0 0e              BCS PDP_28          ; error for drive # > 9
dd16 8e 3b 03           STX DOS_Drive_1     ; store drive #
dd19 8e 3c 03           STX DOS_Drive_2     ; store drive #
dd1c a9 10              LDA #16             ; mark drive # set
dd1e 20 fd dd           JSR Set_DOS_Flags
dd21 4c 72 dd           JMP PDP_44
dd24 4c 27 de PDP_28    JMP DOS_JMP_Illegal_Quantity
dd27 ad 3d 03 PDP_30    LDA DOS_Attr        ; test DOS_Attr
dd2a 29 ff              AND #$ff            ; this is needless
dd2c f0 03              BEQ PDP_32          ; continue if zero
dd2e 4c 00 bf           JMP Syntax_Error    ; error if not zero
dd31 a0 00    PDP_32    LDY #0              ; parse ID string for HEADER
dd33 a2 00              LDX #0
dd35 e6 77    PDP_34    INC TXTPTR          ; advance TXTPTR
dd37 d0 02              BNE PDP_36
dd39 e6 78              INC TXTPTR+1
dd3b b1 77    PDP_36    LDA (TXTPTR),Y      ; get ID string
dd3d 9d 3f 03           STA DOS_Id,X
dd40 e8                 INX
dd41 e0 02              CPX #2              ; maximum 2 characters
dd43 90 f0              BCC PDP_34
dd45 a9 ff              LDA #$ff
dd47 8d 3d 03           STA DOS_Attr        ; mark ID defined
dd4a 20 70 00 PDP_37    JSR CHRGET          ; advance to next character
dd4d 4c 72 dd           JMP PDP_44
dd50 ad 3e 03 PDP_38    LDA DOS_Flags
dd53 29 01              AND #1              ; error if filename defined
dd55 20 49 de           JSR DOS_Parse_Filename
dd58 85 d1              STA FNLEN
dd5a 8d 41 03           STA DOS_Command_Length
dd5d 20 c5 d6           JSR Set_DOS_FNADR
dd60 a0 00              LDY #0
dd62 b1 1f    PDP_40    LDA (INDEXA),Y      ; copy string to filename
dd64 99 42 03           STA DOS_Filename,Y  ; store filename
dd67 c8                 INY
dd68 cc 41 03           CPY DOS_Command_Length
dd6b 90 f5              BCC PDP_40
dd6d a9 01              LDA #1              ; mark filename defined
dd6f 20 fd dd           JSR Set_DOS_Flags
dd72 20 76 00 PDP_44    JSR CHRGOT          ; next character to parse
dd75 d0 03              BNE PDP_46          ; there is more
dd77 4c f9 dd           JMP PDP_68          ; finish parsing
dd7a c9 2c    PDP_46    CMP #','            ; comma ?
dd7c d0 06              BNE PDP_48          ; look for tokens
dd7e 20 70 00           JSR CHRGET          ; next character after comma
dd81 4c 8e dc           JMP PDP_02          ; parse next sequence
dd84 c9 91    PDP_48    CMP #$91            ; ON token
dd86 d0 03              BNE PDP_50
dd88 4c f8 dc           JMP PDP_22          ; parse unit
dd8b c9 a4    PDP_50    CMP #$a4            ; TO token
dd8d f0 03              BEQ PDP_52
dd8f 4c 00 bf           JMP Syntax_Error
dd92 20 70 00 PDP_52    JSR CHRGET
dd95 c9 44              CMP #'D'
dd97 f0 13              BEQ PDP_56          ; parse target drive
dd99 c9 91              CMP #$91            ; ON token
dd9b f0 28              BEQ PDP_58          ; get UNIT
dd9d c9 55              CMP #'U'
dd9f f0 2a              BEQ PDP_60          ; get UNIT value
dda1 c9 22              CMP #QUOTE
dda3 f0 2c              BEQ PDP_62
dda5 c9 28              CMP #'('
dda7 f0 28              BEQ PDP_62
dda9 4c 00 bf PDP_54    JMP Syntax_Error
ddac ad 3e 03 PDP_56    LDA DOS_Flags
ddaf 29 20              AND #$20            ; Drive 2 defined ?
ddb1 d0 f6              BNE PDP_54          ; error if so
ddb3 20 87 de           JSR DOS_Parse_Value
ddb6 e0 0a              CPX #10             ; original ROM: CPX #2 (D0 and D1 only)
ddb8 b0 6d              BCS DOS_JMP_Illegal_Quantity
ddba 8e 3c 03           STX DOS_Drive_2
ddbd a9 20              LDA #$20            ; mark drive 2 defined
ddbf 20 fd dd           JSR Set_DOS_Flags
ddc2 4c e5 dd           JMP PDP_64
ddc5 20 2c de PDP_58    JSR DOS_Parse_Unit
ddc8 4c e5 dd           JMP PDP_64
ddcb 20 33 de PDP_60    JSR Get_Unit_Value
ddce 4c e5 dd           JMP PDP_64
ddd1 ad 3e 03 PDP_62    LDA DOS_Flags
ddd4 29 02              AND #2              ; error if target filename there
ddd6 20 49 de           JSR DOS_Parse_Filename
ddd9 8d 3a 03           STA DOS_Tmp         ; length of target filename
dddc 86 fd              STX MEMUSS          ; save descriptor in MEMUSS
ddde 84 fe              STY MEMUSS+1
dde0 a9 02              LDA #2              ; mark target filename parsed
dde2 20 fd dd           JSR Set_DOS_Flags
dde5 20 76 00 PDP_64    JSR CHRGOT          ; current character
dde8 f0 0f              BEQ PDP_68          ; finish
ddea c9 2c              CMP #','            ; another comma
ddec f0 a4              BEQ PDP_52          ; continue
ddee c9 91              CMP #$91            ; ON token
ddf0 f0 d3              BEQ PDP_58          ; continue
ddf2 c9 55              CMP #'U'
ddf4 f0 d5              BEQ PDP_60          ; get UNIT
ddf6 4c 00 bf PDP_66    JMP Syntax_Error
ddf9 ad 3e 03 PDP_68    LDA DOS_Flags
ddfc 60                 RTS ;Size  405 [Parse_DOS_Parameter]

              ; *************
ddfd            Set_DOS_Flags
              ; *************

ddfd 0d 3e 03           ORA DOS_Flags
de00 8d 3e 03           STA DOS_Flags
de03 60                 RTS ;Size    7 [Set_DOS_Flags]

de04 00 00 00           .FILL $de27 - * (0) ; 35 bytes

              ; ************************
de27            DOS_JMP_Illegal_Quantity
              ; ************************

de27 a2 35              LDX #Msg_QUANT-Msg_Start ; $35
de29 4c cf b3           JMP Basic_Error

              ; **************
de2c            DOS_Parse_Unit
              ; **************

de2c 20 70 00           JSR CHRGET
de2f c9 55              CMP #'U'
de31 d0 c3              BNE PDP_66

              ; **************
de33            Get_Unit_Value
              ; **************

de33 20 87 de           JSR DOS_Parse_Value
de36 e0 20              CPX #32
de38 b0 ed              BCS DOS_JMP_Illegal_Quantity
de3a e0 03              CPX #3
de3c 90 e9              BCC DOS_JMP_Illegal_Quantity
de3e 86 d4              STX FA
de40 a9 08              LDA #8
de42 4c fd dd           JMP Set_DOS_Flags

de45 00 00 00           .FILL $de49 - * (0) ; 4 bytes

              ; ******************
de49            DOS_Parse_Filename
              ; ******************

de49 d0 ab              BNE PDP_66
de4b 20 98 bd           JSR Eval_Expression
de4e 20 b5 c7           JSR Eval_And_Free_String
de51 aa                 TAX                 ; string length
de52 f0 d3              BEQ DOS_JMP_Illegal_Quantity
de54 a0 00              LDY #0
de56 b1 1f              LDA (INDEXA),Y
de58 c9 40              CMP #'@'            ; replace character
de5a d0 14              BNE DPF_30
de5c 2c 3e 03           BIT DOS_Flags       ; @ already used ?
de5f 10 03              BPL DPF_10
de61 4c 00 bf           JMP Syntax_Error
de64 e6 1f    DPF_10    INC INDEXA          ; skip @
de66 d0 02              BNE DPF_20
de68 e6 20              INC INDEXA+1
de6a ca       DPF_20    DEX                 ; length - @
de6b a9 80              LDA #$80
de6d 20 fd dd           JSR Set_DOS_Flags
de70 8a       DPF_30    TXA                 ; string length
de71 f0 b4              BEQ DOS_JMP_Illegal_Quantity
de73 c9 11              CMP #17
de75 90 05              BCC DPF_40
de77 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
de79 4c cf b3           JMP Basic_Error
de7c a6 1f    DPF_40    LDX INDEXA          ; string address low
de7e a4 20              LDY INDEXA+1        ; string address high
de80 60                 RTS ;Size   56 [DOS_Parse_Filename]

de81 00 00 00           .FILL $de87 - * (0) ; 6 bytes

              ; ***************
de87            DOS_Parse_Value
              ; ***************

de87 20 70 00           JSR CHRGET

              ; ************
de8a            DOS_Get_Byte
              ; ************

de8a d0 03              BNE DGB_10
de8c 4c 00 bf           JMP Syntax_Error
de8f 90 09    DGB_10    BCC DGB_20
de91 20 f2 be           JSR Need_Left_Parenthesis
de94 20 d4 c8           JSR Get_Byte_Value
de97 4c ef be           JMP Need_Right_Parenthesis
de9a 4c d4 c8 DGB_20    JMP Get_Byte_Value

              ; *************
de9d            Start_Message
              ; *************

de9d 2a 2a 2a           .PET '*** BSOS 8296 ***\r\r',0

              ; ********
deb1            Renumber
              ; ********

              ; check for arguments: RENUMBER new start, increment, old start

deb1 a9 0a              LDA #10
deb3 85 21              STA RENINC          ; preset increment low
deb5 85 23              STA RENNEW          ; preset start low
deb7 a9 00              LDA #0
deb9 85 22              STA RENINC+1
debb 85 24              STA RENNEW+1
debd 20 76 00           JSR CHRGOT
dec0 b0 4d              BCS Renu_15         ; no arguments
dec2 20 f6 b8           JSR Scan_Linenumber
dec5 a5 11              LDA LINNUM
dec7 85 23              STA RENNEW          ; start low
dec9 05 12              ORA LINNUM+1
decb d0 03              BNE Renu_10
decd 4c 73 c3 Renu_Err  JMP Jump_To_Illegal_Quantity
ded0 a5 12    Renu_10   LDA LINNUM+1
ded2 85 24              STA RENNEW+1        ; start high
ded4 20 76 00           JSR CHRGOT
ded7 c9 2c              CMP #','
ded9 d0 34              BNE Renu_15
dedb 20 70 00           JSR CHRGET
dede 20 f6 b8           JSR Scan_Linenumber
dee1 a5 11              LDA LINNUM
dee3 85 21              STA RENINC          ; inc low
dee5 05 12              ORA LINNUM+1
dee7 f0 e4              BEQ Renu_Err
dee9 a5 12              LDA LINNUM+1
deeb 85 22              STA RENINC+1        ; inc high
deed 20 76 00           JSR CHRGOT
def0 c9 2c              CMP #','
def2 d0 1b              BNE Renu_15
def4 20 70 00           JSR CHRGET
def7 20 f6 b8           JSR Scan_Linenumber ; get old start
defa 20 e4 ea           JSR Find_Power_Line ; find start line
defd a0 02              LDY #2
deff b1 57              LDA (TMPPTB),Y      ; previous # low
df01 c5 23              CMP RENNEW
df03 c8                 INY
df04 b1 57              LDA (TMPPTB),Y      ; previous # high
df06 e5 24              SBC RENNEW+1
df08 b0 c3              BCS Renu_Err        ; New line # would be less than previous
df0a 20 2a ed           JSR Reset_BPTR
df0d d0 03              BNE Renu_20         ; always

              ; phase 1: build table of old and new numbers

df0f 20 22 ed Renu_15   JSR Reset_Renumber_Pointer
df12 20 43 ec Renu_20   JSR Install_Bank_Access
df15 a9 80              LDA #$80
df17 85 b6              STA R_Bank
df19 85 b7              STA W_Bank

              ; start of new line numbers

df1b a0 01    Renu_25   LDY #1
df1d b1 5c              LDA (TMPPTC),Y      ; link high
df1f f0 34              BEQ Renu_30         ; finished
df21 c8                 INY                 ; Y = 2

              ; next table entry

df22 b1 5c              LDA (TMPPTC),Y      ; old line low
df24 20 8b 02           JSR Bank_Store
df27 c8                 INY                 ; Y = 3
df28 b1 5c              LDA (TMPPTC),Y      ; old line high
df2a 20 8b 02           JSR Bank_Store
df2d a0 01              LDY #1
df2f a5 24              LDA RENNEW+1        ; new line high
df31 20 8b 02           JSR Bank_Store
df34 88                 DEY                 ; Y = 0
df35 a5 23              LDA RENNEW          ; new line low
df37 20 8b 02           JSR Bank_Store

              ; increment new line

df3a 18                 CLC
df3b a5 23              LDA RENNEW
df3d 65 21              ADC RENINC
df3f 85 23              STA RENNEW
df41 a5 24              LDA RENNEW+1
df43 65 22              ADC RENINC+1
df45 85 24              STA RENNEW+1
df47 c9 fa              CMP #$fa            ; > 64000
df49 b0 82              BCS Renu_Err        ; line # overflow

              ; increment table pointer

df4b a9 04              LDA #4
df4d 20 27 fb           JSR Add_BPTR

              ; next basic line

df50 20 33 ed           JSR Update_Link
df53 d0 c6              BNE Renu_25         ; branch if link is not zero

              ; table finished

df55 a0 03    Renu_30   LDY #3
df57 a9 ff              LDA #$ff            ; end marker
df59 20 8b 02 Renu_35   JSR Bank_Store
df5c 88                 DEY
df5d 10 fa              BPL Renu_35

              ; phase 2: build a renumbered copy in bank 2

df5f a9 8c              LDA #$8c
df61 85 b7              STA W_Bank
df63 20 22 ed           JSR Reset_Renumber_Pointer

              ; copy link - will be recalculated at end

df66 a0 00    Renu_40   LDY #0
df68 b1 5c              LDA (TMPPTC),Y      ; link low
df6a 20 8b 02           JSR Bank_Store
df6d c8                 INY
df6e b1 5c              LDA (TMPPTC),Y      ; link high
df70 20 8b 02           JSR Bank_Store
df73 f0 2b              BEQ Renu_45         ; finished

              ; exchange line number from table or copy if not found

df75 c8                 INY
df76 b1 5c              LDA (TMPPTC),Y      ; line # low
df78 aa                 TAX
df79 c8                 INY
df7a b1 5c              LDA (TMPPTC),Y      ; line # high
df7c 20 07 ec           JSR Find_Entry
df7f a0 02              LDY #2
df81 a5 11              LDA LINNUM
df83 20 8b 02           JSR Bank_Store
df86 c8                 INY
df87 a5 12              LDA LINNUM+1
df89 20 8b 02           JSR Bank_Store
df8c 20 7e ec           JSR Xfer_Line
df8f c8                 INY                 ; Add Y + 1
df90 98                 TYA
df91 20 27 fb           JSR Add_BPTR
df94 20 33 ed           JSR Update_Link
df97 a5 fa              LDA BPTR+1
df99 c9 fb              CMP #$fb
df9b 90 c9              BCC Renu_40
df9d 4c cd b3           JMP Error_Out_Of_Memory

              ; copy new program from bank 2 to BASIC memory

dfa0 a9 8c    Renu_45   LDA #$8c            ; bank 1
dfa2 85 b6              STA R_Bank
dfa4 18                 CLC
dfa5 a5 f9              LDA BPTR
dfa7 69 03              ADC #3
dfa9 85 23              STA RENNEW          ; end address low
dfab a5 fa              LDA BPTR+1
dfad 69 00              ADC #0
dfaf aa                 TAX                 ; end address high
dfb0 a9 00              LDA #0
dfb2 85 fb              STA STAL
dfb4 a9 80              LDA #$80
dfb6 85 fc              STA STAL+1
dfb8 20 22 ed           JSR Reset_Renumber_Pointer
dfbb a0 00              LDY #0
dfbd 20 7a 02 Renu_50   JSR Bank_Fetch
dfc0 91 5c              STA (TMPPTC),Y
dfc2 c4 23              CPY RENNEW
dfc4 d0 04              BNE Renu_55
dfc6 e4 fc              CPX STAL+1
dfc8 f0 09              BEQ Renu_60
dfca c8       Renu_55   INY
dfcb d0 f0              BNE Renu_50
dfcd e6 5d              INC TMPPTC+1
dfcf e6 fc              INC STAL+1
dfd1 d0 ea              BNE Renu_50
dfd3 a5 5d    Renu_60   LDA TMPPTC+1
dfd5 84 2a    Renu_90   STY VARTAB          ; entry for Delete routine
dfd7 85 2b              STA VARTAB+1
dfd9 20 e9 b5           JSR Reset_BASIC_Execution
dfdc 20 b6 b4           JSR Rechain
dfdf 4c ff b3           JMP Basic_Ready

dfe2 00 00 00           .FILL $e000-* (0) ; 30 bytes

              ; *****************
e000            EDITOR_JUMP_TABLE
              ; *****************

e000 4c 37 e0           JMP EDIT_RESET
e003 4c a7 e0           JMP EDIT_GETIN
e006 4c 16 e1           JMP EDIT_CHRIN
e009 4c 02 e2           JMP EDIT_CHROUT
e00c 4c 42 e4           JMP IRQ_MAIN
e00f 4c 55 e4           JMP IRQ_NORMAL
e012 4c 77 e4           JMP IRQ_END
e015 4c 3d e0           JMP EDIT_CLEAR
e018 4c d6 e9           JMP EDIT_CHARSET_TEXT
e01b 4c e4 e9           JMP EDIT_CHARSET_GRAPHICS
e01e 4c d3 e9           JMP EDIT_RESET_CRT
e021 4c 17 e4           JMP EDIT_SCROLL_DOWN
e024 4c 29 e4           JMP EDIT_SCROLL_UP
e027 4c 24 e9           JMP EDIT_KEY_SCAN
e02a 4c 8d e6           JMP EDIT_BEEP
e02d 4c 8d e6           JMP EDIT_BEEP
e030 4c ca e1           JMP EDIT_TOP_LEFT
e033 4c c5 e1           JMP EDIT_BOTTOM_RIGHT
e036 60                 RTS ; EDIT_REPEAT ;Size   55 [EDITOR_JUMP_TABLE]

              ; **********
e037            EDIT_RESET
              ; **********

e037 20 06 e6           JSR Edit_Init
e03a 20 d3 e9           JSR EDIT_RESET_CRT

              ; **********
e03d            EDIT_CLEAR
              ; **********

e03d a6 e0              LDX TopMargin
e03f 20 c9 e6 EDCL_10   JSR Cursor_BOL
e042 20 aa e1           JSR Edit_Erase_To_EOL
e045 e4 e1              CPX BotMargin
e047 e8                 INX
e048 90 f5              BCC EDCL_10         ; fall

              ; *********
e04a            EDIT_HOME
              ; *********

e04a a6 e0              LDX TopMargin
e04c 86 d8              STX CursorRow       ; fall

              ; *********************
e04e            Edit_Goto_Left_Margin
              ; *********************

e04e a4 e2              LDY LefMargin
e050 84 c6              STY CursorCol       ; fall

              ; ******************
e052            Edit_Use_CursorRow
              ; ******************

e052 a6 d8              LDX CursorRow
e054 4c cb e6           JMP Update_ScrPtr

              ; ************
e057            EDIT_SET_CRT
              ; ************

              ; Input:  A = table low
              ;         X = table high
              ;         Y = # of registers

e057 85 c7              STA SAL
e059 86 c8              STX SAL+1
e05b b1 c7    ESC_10    LDA (SAL),Y
e05d 8c 80 e8           STY CRT_Address
e060 8d 81 e8           STA CRT_Value
e063 88                 DEY
e064 10 f5              BPL ESC_10
e066 60                 RTS ;Size   16 [EDIT_SET_CRT]


              ; *****************
e067            Edit_Program_Rows
              ; *****************

              ; Input:  A = maximum raster address (7 or 9)
              ;         Y = screen rows (30 or 25)

e067 84 df              STY ScreenRows
e069 c8                 INY
e06a a2 06              LDX #6
e06c 8e 80 e8           STX CRT_Address
e06f 8c 81 e8           STY CRT_Value
e072 a2 09              LDX #9
e074 8e 80 e8           STX CRT_Address
e077 8d 81 e8           STA CRT_Value
e07a 60                 RTS ;Size   20 [Edit_Program_Rows]

e07b 00 00 00           .FILL $e0a7-* (0) ; 44 bytes

              ; ******************
e0a7            EDIT_GETIN ; $e0a7
              ; ******************

e0a7 ac 6f 02           LDY KEYD            ; get next character
e0aa a2 00              LDX #0              ; scroll keyboard buffer
e0ac bd 70 02 EDGE_10   LDA KEYD+1,X
e0af 9d 6f 02           STA KEYD,X
e0b2 e8                 INX
e0b3 e4 9e              CPX CharsInBuffer
e0b5 90 f5              BCC EDGE_10
e0b7 c6 9e              DEC CharsInBuffer
e0b9 98                 TYA                 ; return character in (A)
e0ba 58                 CLI
e0bb 60                 RTS ;Size   21 [EDIT_GETIN]

              ; *************
e0bc            Edit_Get_Line
              ; *************

e0bc 20 02 e2           JSR EDIT_CHROUT
e0bf a5 9e    EGL_10    LDA CharsInBuffer
e0c1 85 a7              STA BLNSW           ; empty buffer -> blink cursor
e0c3 f0 fa              BEQ EGL_10          ; loop until char in buffer
e0c5 78                 SEI                 ; disable IRQ while working with buffer
e0c6 a5 aa              LDA BLNON           ; blink phase
e0c8 f0 0d              BEQ EGL_20          ; normal ?
e0ca a0 00              LDY #0
e0cc 84 aa              STY BLNON           ; blink phase normal
e0ce c8                 INY
e0cf 84 a8              STY BLNCT           ; start with visible cursor
e0d1 a5 a9              LDA GDBLN           ; character under cursor
e0d3 a4 c6              LDY CursorCol
e0d5 91 c4              STA (ScrPtr),Y
e0d7 20 a7 e0 EGL_20    JSR EDIT_GETIN
e0da c9 83              CMP #$83            ; RUN key ?
e0dc d0 0f              BNE EGL_40
e0de a2 08              LDX #8
e0e0 86 9e              STX CharsInBuffer
e0e2 bd dc e6 EGL_30    LDA RUN_String-1,X  ; DLOAD"*" RUN
e0e5 9d 6e 02           STA KEYD-1,X
e0e8 ca                 DEX
e0e9 d0 f7              BNE EGL_30
e0eb f0 d2              BEQ EGL_10          ; always
e0ed c9 0d    EGL_40    CMP #CR             ; RETURN ?
e0ef d0 cb              BNE Edit_Get_Line
e0f1 a4 d5              LDY RigMargin
e0f3 84 ac              STY CRSW            ; not 0 -> Screen Input
e0f5 a9 20              LDA #' '            ; Ignore trailing blanks
e0f7 d1 c4    EGL_50    CMP (ScrPtr),Y
e0f9 d0 03              BNE EGL_60
e0fb 88                 DEY
e0fc d0 f9              BNE EGL_50
e0fe c8       EGL_60    INY
e0ff 84 a1              STY LastInputCol    ; position after last non blank char
e101 20 b4 e1           JSR Edit_To_Left_Margin
e104 84 cd              STY QTSW            ; = 0 (off)
e106 a5 a3              LDA InputRow
e108 c5 d8              CMP CursorRow
e10a d0 15              BNE Edit_CHRIN_Screen
e10c a5 a4              LDA InputCol
e10e 85 c6              STA CursorCol
e110 c5 a1              CMP LastInputCol
e112 90 0d              BCC Edit_CHRIN_Screen
e114 b0 36              BCS ECS_40

e116                    .SIZE ;   90 [Edit_Get_Line]

e116                    .FILL $e116-* (0) ; 0 bytes

              ; ******************
e116            EDIT_CHRIN ; $e116
              ; ******************

e116 98                 TYA
e117 48                 PHA
e118 8a                 TXA
e119 48                 PHA
e11a 6c e9 00           JMP (SCRIV)         ; default: jump to next statement

              ; *******************
e11d            Edit_CHRIN_Standard
              ; *******************

e11d a5 ac              LDA CRSW
e11f f0 9e              BEQ EGL_10

              ; *****************
e121            Edit_CHRIN_Screen
              ; *****************

e121 a4 c6              LDY CursorCol
e123 b1 c4              LDA (ScrPtr),Y      ; get char at cursor position
e125 c9 74              CMP #$74            ; code for Pi
e127 d0 04              BNE ECS_05
e129 a9 ff              LDA #$ff
e12b d0 16              BNE ECS_30
e12d 85 d9    ECS_05    STA DATAX           ; save it in DATAX
e12f 29 3f              AND #$3f            ; lower case, symbols and digits
e131 06 d9              ASL DATAX           ; reverse bit 7 -> carry
e133 24 d9              BIT DATAX           ; uppercase or graphics ?
e135 10 02              BPL ECS_10          ; branch if not
e137 09 80              ORA #$80            ; convert upper case to PETSCII
e139 90 04    ECS_10    BCC ECS_20          ; branch if not reversed
e13b a6 cd              LDX QTSW            ; quote mode ?
e13d d0 04              BNE ECS_30          ; no conversion in quote mode
e13f 70 02    ECS_20    BVS ECS_30          ; no conversion for graphics
e141 09 40              ORA #$40            ; display code to PETSCII
e143 e6 c6    ECS_30    INC CursorCol       ; advance cursor
e145 20 64 e1           JSR Edit_Quote_Toggle
e148 c4 a1              CPY LastInputCol    ; at end of input ?
e14a 90 0f              BCC ECS_50          ; return if not
e14c a9 00    ECS_40    LDA #0
e14e 85 ac              STA CRSW            ; switch input to keyboard
e150 a9 0d              LDA #CR             ; load CR
e152 a2 03              LDX #3              ; screen channel
e154 e4 b0              CPX DFLTO           ; output = screen ?
e156 f0 03              BEQ ECS_50          ; don't echo CR
e158 20 02 e2           JSR EDIT_CHROUT
e15b 85 d9    ECS_50    STA DATAX           ; save character in DATAX
e15d 68                 PLA
e15e aa                 TAX                 ; restore X
e15f 68                 PLA
e160 a8                 TAY                 ; restore Y
e161 a5 d9              LDA DATAX
e163 60       ECS_Ret   RTS ;Size   67 [Edit_CHRIN_Screen]

              ; *****************
e164            Edit_Quote_Toggle
              ; *****************

e164 c9 22              CMP #QUOTE
e166 d0 06              BNE EQT_Ret
e168 e5 cd              SBC QTSW
e16a 85 cd              STA QTSW
e16c a9 22              LDA #QUOTE
e16e 60       EQT_Ret   RTS ;Size   11 [Edit_Quote_Toggle]

              ; *****************
e16f            Edit_Display_Char
              ; *****************

e16f a6 9f              LDX ReverseFlag
e171 f0 02              BEQ EDC_10
e173 09 80              ORA #$80
e175 a6 dc    EDC_10    LDX INSRT        ;  3  ; # of inserts outstanding
e177 f0 02              BEQ EDC_20       ;  3
e179 c6 dc              DEC INSRT
e17b 91 c4    EDC_20    STA (ScrPtr),Y   ;  6
e17d a9 01              LDA #1           ;  2
e17f 85 a8              STA BLNCT        ;  3
e181 c4 d5              CPY RigMargin    ;  3
e183 c8                 INY              ;  2
e184 90 05              BCC EDC_30       ;  3 = 28 [total 85]

              ; ************************
e186           Edit_Chrout_Epilog_Return
              ; ************************

e186 20 e1 e3           JSR Edit_Cursor_Down
e189 a4 e2              LDY LefMargin
e18b 84 c6    EDC_30    STY CursorCol    ;  3

              ; ******************
e18d            Edit_Chrout_Epilog
              ; ******************

e18d 68                 PLA              ;  4
e18e a8                 TAY              ;  2 ; restore Y
e18f 68                 PLA              ;  4
e190 aa                 TAX              ;  2 ; restore X
e191 68                 PLA              ;  4
e192 85 e8              STA PrevChar     ;  3 ; save last used character
e194 58                 CLI              ;  2
e195 60                 RTS              ;  6 = 27 [total 112] ;Size    9 [Edit_Chrout_Epilog]

              ; **************
e196            Edit_Wrap_Back
              ; **************

e196 a4 e2              LDY LefMargin
e198 a6 e0              LDX TopMargin
e19a e4 d8              CPX CursorRow
e19c b0 07              BCS EWB_10          ; don't wrap on top row
e19e a4 d5              LDY RigMargin
e1a0 c6 d8              DEC CursorRow
e1a2 20 52 e0           JSR Edit_Use_CursorRow
e1a5 84 c6    EWB_10    STY CursorCol
e1a7 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *****************
e1aa            Edit_Erase_To_EOL
              ; *****************

e1aa a9 20              LDA #' '
e1ac 91 c4    EETE_10   STA (ScrPtr),Y
e1ae c4 d5              CPY RigMargin
e1b0 c8                 INY
e1b1 90 f9              BCC EETE_10
e1b3 60                 RTS ;Size   10 [Edit_Erase_To_EOL]

              ; *******************
e1b4            Edit_To_Left_Margin
              ; *******************

e1b4 a4 e2              LDY LefMargin
e1b6 84 c6              STY CursorCol
e1b8 a0 00              LDY #0
e1ba 60                 RTS ;Size    7 [Edit_To_Left_Margin]

              ; ****************
e1bb            Edit_Full_Screen
              ; ****************

e1bb a9 00              LDA #0
e1bd 85 e0              STA TopMargin
e1bf 85 e2              STA LefMargin
e1c1 a5 df              LDA ScreenRows      ; bottom margin
e1c3 a2 4f              LDX #79             ; right  margin

              ; *****************
e1c5            EDIT_BOTTOM_RIGHT
              ; *****************

e1c5 85 e1              STA BotMargin
e1c7 86 d5              STX RigMargin
e1c9 60                 RTS ;Size    5 [EDIT_BOTTOM_RIGHT]

              ; *************
e1ca            EDIT_TOP_LEFT
              ; *************

e1ca 85 e0              STA TopMargin
e1cc 86 e2              STX LefMargin
e1ce 60                 RTS ;Size    5 [EDIT_TOP_LEFT]

e1cf 4c 16 e3 CO_Shift  JMP Edit_CHROUT_Shifted

              ; ******
e1d2            CO_Tab
              ; ******

e1d2 a4 c6              LDY CursorCol
e1d4 c4 d5              CPY RigMargin
e1d6 b0 11              BCS EdDC_05         ; CO_Exit
e1d8 e6 c6              INC CursorCol
e1da 20 25 e5           JSR IS_TAB
e1dd f0 f3              BEQ CO_Tab
e1df 4c 66 e2           JMP CO_Exit

e1e2                    .SIZE ;   16 [CO_Tab]

e1e2 4c e2 e2 CO_Size   JMP Edit_Screen_25

              ; ****************
e1e5            Edit_Delete_Char
              ; ****************

e1e5 a6 e2              LDX LefMargin
e1e7 e4 c6              CPX CursorCol
e1e9 b0 7b    EdDC_05   BCS CO_Exit        ; no delete on left margin
e1eb c6 c6              DEC CursorCol
e1ed b1 c4    EdDC_10   LDA (ScrPtr),Y
e1ef 88                 DEY
e1f0 91 c4              STA (ScrPtr),Y
e1f2 c8                 INY
e1f3 c4 d5              CPY RigMargin
e1f5 c8                 INY
e1f6 90 f5              BCC EdDC_10
e1f8 88                 DEY
e1f9 a9 20              LDA #' '
e1fb 91 c4              STA (ScrPtr),Y
e1fd d0 67              BNE CO_Exit

e1ff                    .SIZE ;   26 [Edit_Delete_Char]

e1ff 00 00 00           .FILL $e202-* (0) ; 3 bytes

              ; *******************
e202            EDIT_CHROUT ; $e202
              ; *******************

e202 48                 PHA            ;  3
e203 85 d9              STA DATAX      ;  3
e205 8a                 TXA            ;  2
e206 48                 PHA            ;  3
e207 98                 TYA            ;  2
e208 48                 PHA            ;  3
e209 6c eb 00           JMP (SCROV)    ;  5    ; -> Edit_CHROUT_Standard
                                       ; 19

              ; ****************************
e20c            Edit_CHROUT_Standard ; $e20c
              ; ****************************

e20c a9 00              LDA #0         ;  2
e20e 85 ac              STA CRSW       ;  3 ; input from keyboard
e210 a4 c6              LDY CursorCol  ;  3
e212 a5 d9              LDA DATAX      ;  3 ; char to display (PETSCII)
e214 30 b9              BMI CO_Shift   ;  2
e216 c9 20              CMP #' '       ;  2 ; printable ?
e218 b0 4f              BCS CO_Normal  ;  3 = 16 [total 35]
e21a c9 0d              CMP #CR             ; RETURN
e21c f0 71              BEQ CO_Return
e21e c9 1b              CMP #ESC            ; ESCAPE
e220 f0 70              BEQ CO_Escape
e222 a6 dc              LDX INSRT           ; insert mode ?
e224 d0 76              BNE CO_Rev
e226 c9 14              CMP #DEL            ; DELETE
e228 f0 bb              BEQ Edit_Delete_Char
e22a a6 cd              LDX QTSW            ; quote mode ?
e22c d0 6e              BNE CO_Rev
e22e c9 1d              CMP #RIGHT          ; cursor RIGHT
e230 f0 3f              BEQ CO_Right
e232 c9 11              CMP #DOWN           ; cursor DOWN
e234 f0 44              BEQ CO_Down
e236 c9 12              CMP #RVS            ; REVERSE
e238 f0 45              BEQ CO_RVS
e23a c9 07              CMP #BELL           ; ring bell
e23c f0 47              BEQ CO_Bell
e23e c9 0e              CMP #CTRLN          ; select text character set
e240 f0 48              BEQ CO_ChText
e242 c9 02              CMP #CTRLB          ; select new character set
e244 f0 4f              BEQ CO_ChNew
e246 c9 0f              CMP #CTRLO          ; set top left window corner
e248 f0 57              BEQ CO_Top
e24a c9 09              CMP #TAB            ; TAB
e24c f0 84              BEQ CO_Tab
e24e c9 19              CMP #CTRLY          ; scroll window up
e250 f0 5a              BEQ CO_ScUp
e252 c9 16              CMP #CTRLV          ; Delete to EOL
e254 f0 61              BEQ CO_DEOL
e256 c9 15              CMP #CTRLU          ; delete line
e258 f0 68              BEQ CO_DLine
e25a c9 04              CMP #CTRLD          ; toggle screen size
e25c f0 84              BEQ CO_Size
e25e c9 13              CMP #HOME           ; HOME
e260 f0 6d              BEQ CO_Home
e262 c9 01              CMP #CTRLA          ; scroll window down
e264 f0 43              BEQ CO_ScDown
e266 4c 8d e1 CO_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Standard

e269 29 3f    CO_Normal AND #$3f               ;  2 ; PETSCII -> display code
e26b 20 64 e1           JSR Edit_Quote_Toggle  ; 17
e26e 4c 6f e1           JMP Edit_Display_Char  ;  3 = 22 [total 57]

e271 c4 d5    CO_Right  CPY RigMargin
e273 e6 c6              INC CursorCol
e275 90 ef              BCC CO_Exit
e277 4c 86 e1           JMP Edit_Chrout_Epilog_Return

e27a 20 e1 e3 CO_Down   JSR Edit_Cursor_Down
e27d d0 e7              BNE CO_Exit         ; always

e27f a9 80    CO_RVS    LDA #$80
e281 85 9f              STA ReverseFlag
e283 d0 e1              BNE CO_Exit         ; always

e285 20 8d e6 CO_Bell   JSR EDIT_BEEP
e288 f0 dc              BEQ CO_Exit         ; always

e28a 20 d6 e9 CO_ChText JSR EDIT_CHARSET_TEXT
e28d 30 d7              BMI CO_Exit         ; always

e28f 4c f4 e3 CO_Return JMP CO_Screen_Return

e292 4c ff e3 CO_Escape JMP CO_JMP_Escape

e295 a9 10    CO_ChNew  LDA #$10
e297 20 ca e9 CO_Switch JSR Edit_Switch_Char_ROM
e29a d0 ca              BNE CO_Exit         ; always

e29c 09 80    CO_Rev    ORA #$80
e29e 4c 6f e1           JMP Edit_Display_Char

e2a1 a6 d8    CO_Top    LDX CursorRow
e2a3 86 e0              STX TopMargin
e2a5 84 e2              STY LefMargin
e2a7 10 bd              BPL CO_Exit         ; always

e2a9 4c b5 e3 CO_ScDown JMP CS_ScDown

e2ac 20 29 e4 CO_ScUp   JSR EDIT_SCROLL_UP
e2af 20 39 ea           JSR Power_Scroll_Up
e2b2 20 52 e0           JSR Edit_Use_CursorRow
e2b5 d0 af              BNE CO_Exit         ; always

e2b7 a9 20    CO_DEOL   LDA #' '
e2b9 91 c4    CODE_10   STA (ScrPtr),Y
e2bb c4 d5              CPY RigMargin
e2bd c8                 INY
e2be 90 f9              BCC CODE_10
e2c0 b0 a4              BCS CO_Exit

e2c2 a5 e0    CO_DLine  LDA TopMargin
e2c4 48                 PHA
e2c5 a5 d8              LDA CursorRow
e2c7 85 e0              STA TopMargin
e2c9 20 29 e4           JSR EDIT_SCROLL_UP
e2cc 4c d8 e3           JMP TM_Epi

e2cf c5 e8    CO_Home   CMP PrevChar             ; twice pressed ?
e2d1 d0 03              BNE COHo_10
e2d3 20 bb e1 CoHo_05   JSR Edit_Full_Screen     ; 2nd. <HOME> resets margins
e2d6 20 4a e0 COHo_10   JSR EDIT_HOME
e2d9 4c 8d e1           JMP Edit_Chrout_Epilog

e2dc          Edit_Screen_30
e2dc a9 07              LDA #7              ; maximum raster address
e2de a0 1d              LDY #29             ; 30 rows
e2e0 d0 04              BNE Edit_Screen_Program
e2e2          Edit_Screen_25
e2e2 a9 09              LDA #9              ; maximum raster address
e2e4 a0 18              LDY #24             ; 25 rows (default)
e2e6          Edit_Screen_Program
e2e6 20 67 e0           JSR Edit_Program_Rows
e2e9 20 bb e1           JSR Edit_Full_Screen
e2ec 4c 79 e3           JMP CS_Clear

e2ef 4c f4 e3 CS_Return JMP CO_Screen_Return

              ; ****************
e2f2            Edit_Insert_Char
              ; ****************

e2f2 a4 d5              LDY RigMargin
e2f4 b1 c4              LDA (ScrPtr),Y
e2f6 c9 20              CMP #' '
e2f8 d0 66              BNE CS_Exit       ; right most char not blank
e2fa 88       InCh_10   DEY
e2fb c4 c6              CPY CursorCol     ; clc if left from cursor
e2fd b1 c4              LDA (ScrPtr),Y
e2ff c8                 INY
e300 90 05              BCC InCh_20
e302 91 c4              STA (ScrPtr),Y
e304 88                 DEY
e305 d0 f3              BNE InCh_10       ; at first column
e307 a9 20    InCh_20   LDA #' '
e309 91 c4              STA (ScrPtr),Y
e30b 98                 TYA
e30c 65 dc              ADC INSRT
e30e c5 d5              CMP RigMargin
e310 b0 4e              BCS CS_Exit
e312 e6 dc              INC INSRT
e314 d0 4a              BNE CS_Exit         ; always

e316                    .SIZE ;   36 [Edit_Insert_Char]

              ; *******************
e316            Edit_CHROUT_Shifted
              ; *******************

e316 29 7f              AND #$7f
e318 c9 7f              CMP #$7f            ; Pi
e31a f0 4a              BEQ CS_Pi
e31c c9 20              CMP #' '            ; printable ?
e31e b0 49              BCS CS_Print
e320 c9 0d              CMP #CR             ; shifted RETURN
e322 f0 cb              BEQ CS_Return
e324 a6 cd              LDX QTSW            ; quote mode
e326 d0 46              BNE CS_Rev
e328 c9 14              CMP #DEL            ; INSERT
e32a f0 c6              BEQ Edit_Insert_Char
e32c a6 dc              LDX INSRT           ; insert mode ?
e32e d0 3e              BNE CS_Rev
e330 c9 1d              CMP #RIGHT          ; cursor LEFT
e332 f0 5d              BEQ CS_Left
e334 c9 11              CMP #DOWN           ; cursor UP
e336 f0 73              BEQ CS_Up
e338 c9 12              CMP #RVS            ; REVERSE OFF
e33a f0 37              BEQ CS_RVS
e33c c9 13              CMP #HOME           ; CLEAR
e33e f0 39              BEQ CS_Clear
e340 c9 09              CMP #TAB            ; shifted TAB
e342 f0 58              BEQ CS_Tab
e344 c9 16              CMP #CTRLV          ; shifted Ctrl-V
e346 f0 79              BEQ CS_Delete_BOL
e348 c9 02              CMP #CTRLB          ; select old character set
e34a f0 32              BEQ CS_ChOld
e34c c9 19              CMP #CTRLY          ; scroll window down
e34e f0 65              BEQ CS_ScDown
e350 c9 0f              CMP #CTRLO          ; set window bottom right
e352 f0 2f              BEQ CS_Bottom
e354 c9 0e              CMP #CTRLN          ; select graphics character set
e356 f0 33              BEQ CS_Graph
e358 c9 15              CMP #CTRLU          ; shifted Ctrl-U
e35a f0 72              BEQ CS_Insert_Line
e35c c9 04              CMP #CTRLD          ; switch to 26 row screen
e35e f0 03              BEQ CS_Size
e360 4c 8d e1 CS_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Shifted

e363 4c dc e2 CS_Size   JMP Edit_Screen_30
e366 a9 74    CS_Pi     LDA #$74
e368 2c                 .BYTE $2c
e369 09 40    CS_Print  ORA #$40            ; PETSCII to display
e36b 4c 6f e1           JMP Edit_Display_Char

e36e 09 c0    CS_Rev    ORA #$c0            ; reverse upper case
e370 4c 6f e1           JMP Edit_Display_Char

e373 a9 00    CS_RVS    LDA #0
e375 85 9f              STA ReverseFlag
e377 f0 e7              BEQ CS_Exit         ; always

e379 20 3d e0 CS_Clear  JSR EDIT_CLEAR
e37c d0 e2              BNE CS_Exit         ; always

e37e a9 30    CS_ChOld  LDA #$30
e380 4c 97 e2           JMP CO_Switch

e383 a5 d8    CS_Bottom LDA CursorRow
e385 85 e1              STA BotMargin
e387 84 d5              STY RigMargin
e389 10 d5              BPL CS_Exit       ; always

e38b 20 e4 e9 CS_Graph  JSR EDIT_CHARSET_GRAPHICS
e38e 4c 8d e1           JMP Edit_Chrout_Epilog

e391 a4 e2    CS_Left   LDY LefMargin
e393 c4 c6              CPY CursorCol
e395 c6 c6              DEC CursorCol
e397 90 c7              BCC CS_Exit
e399 4c 96 e1           JMP Edit_Wrap_Back

e39c 20 25 e5 CS_Tab    JSR IS_TAB
e39f bd ee 03           LDA TABS_SET,X
e3a2 59 37 e5           EOR BITPOS,Y        ; toggle TAB bit
e3a5 9d ee 03           STA TABS_SET,X
e3a8 4c 8d e1           JMP Edit_Chrout_Epilog

e3ab a6 e0    CS_Up     LDX TopMargin
e3ad e4 d8              CPX CursorRow
e3af b0 04              BCS CS_ScDown
e3b1 c6 d8              DEC CursorRow
e3b3 10 06              BPL COSW_10         ; always

e3b5 20 17 e4 CS_ScDown JSR EDIT_SCROLL_DOWN
e3b8 20 71 ea           JSR Power_Scroll_Down
e3bb 20 52 e0 COSW_10   JSR Edit_Use_CursorRow
e3be 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *************
e3c1            CS_Delete_BOL
              ; *************

e3c1 a9 20              LDA #' '
e3c3 a4 e2              LDY LefMargin
e3c5 c4 c6    CSDB_10   CPY CursorCol
e3c7 b0 97              BCS CS_Exit
e3c9 91 c4              STA (ScrPtr),Y
e3cb c8                 INY
e3cc d0 f7              BNE CSDB_10

e3ce                    .SIZE ;   13 [CS_Delete_BOL]

              ; **************
e3ce            CS_Insert_Line
              ; **************

e3ce a5 e0              LDA TopMargin
e3d0 48                 PHA
e3d1 a5 d8              LDA CursorRow
e3d3 85 e0              STA TopMargin
e3d5 20 17 e4           JSR EDIT_SCROLL_DOWN
e3d8 68       TM_Epi    PLA
e3d9 85 e0              STA TopMargin
e3db 20 4e e0           JSR Edit_Goto_Left_Margin
e3de 4c 8d e1           JMP Edit_Chrout_Epilog

e3e1                    .SIZE ;   19 [CS_Insert_Line]

              ; ****************
e3e1            Edit_Cursor_Down
              ; ****************

e3e1 46 a3              LSR InputRow        ; invalidate InputRow
e3e3 a6 d8              LDX CursorRow
e3e5 e4 e1              CPX BotMargin
e3e7 90 06              BCC CSCD_10
e3e9 20 29 e4           JSR EDIT_SCROLL_UP
e3ec 4c 39 ea           JMP Power_Scroll_Up
e3ef e6 d8    CSCD_10   INC CursorRow
e3f1 4c 52 e0           JMP Edit_Use_CursorRow

e3f4                    .SIZE ;   19 [Edit_Cursor_Down]

              ; ****************
e3f4            CO_Screen_Return
              ; ****************

e3f4 a0 00              LDY #0
e3f6 84 99              STY Power_Flag
e3f8 a4 e2              LDY LefMargin
e3fa 84 c6              STY CursorCol
e3fc 20 e1 e3           JSR Edit_Cursor_Down

              ; *************
e3ff            CO_JMP_Escape
              ; *************

e3ff a9 00              LDA #0
e401 85 dc              STA INSRT           ; clear insert mode
e403 85 9f              STA ReverseFlag     ; clear reverse mode
e405 85 cd              STA QTSW            ; clear quote mode
e407 4c 8d e1           JMP Edit_Chrout_Epilog

              ; ***********
e40a            Edit_Scroll
              ; ***********

e40a 20 b7 e6           JSR Set_Screen_SAL  ; 25
e40d b1 c7    ES_10     LDA (SAL),Y         ;  5
e40f 91 c4              STA (ScrPtr),Y      ;  6
e411 c4 d5              CPY RigMargin       ;  3
e413 c8                 INY                 ;  2
e414 90 f7              BCC ES_10           ;  3
e416 60                 RTS ;Size   13 [Edit_Scroll]
                                            ; total = 25 + 80 * 19 + 2 = 1547

              ; ****************
e417            EDIT_SCROLL_DOWN
              ; ****************

e417 a6 e1              LDX BotMargin       ;    3
e419 20 c9 e6 ESD_10    JSR Cursor_BOL      ;   28
e41c e4 e0              CPX TopMargin       ;    3
e41e f0 06              BEQ ESD_30          ;    2
e420 ca                 DEX                 ;    2
e421 20 0a e4           JSR Edit_Scroll     ; 1552
e424 b0 f3              BCS ESD_10          ;    3
e426 4c aa e1 ESD_30    JMP Edit_Erase_To_EOL  ; total = 1100 + 24 * 1590 = 39260

e429                    .SIZE ;   18 [EDIT_SCROLL_DOWN]

              ; **************
e429            EDIT_SCROLL_UP
              ; **************

e429 a6 e0              LDX TopMargin
e42b 20 c9 e6 ESU_10    JSR Cursor_BOL
e42e e4 e1              CPX BotMargin
e430 b0 06              BCS ESU_30
e432 e8                 INX
e433 20 0a e4           JSR Edit_Scroll
e436 b0 f3              BCS ESU_10
e438 4c aa e1 ESU_30    JMP Edit_Erase_To_EOL

e43b                    .SIZE ;   18 [EDIT_SCROLL_UP]

e43b 00 00 00           .FILL $e442-* (0) ; 7 bytes

              ; ********
e442            IRQ_MAIN
              ; ********

e442 48                 PHA
e443 8a                 TXA
e444 48                 PHA
e445 98                 TYA
e446 48                 PHA
e447 ba                 TSX
e448 bd 04 01           LDA STACK+4,X
e44b 29 10              AND #16
e44d f0 03              BEQ IRQ_05
e44f 6c 92 00           JMP (CBINV)
e452 6c 90 00 IRQ_05    JMP (CINV)

              ; **********
e455            IRQ_NORMAL
              ; **********

e455 20 68 f7           JSR Kernal_UDTIM    ; increment jiffy clock
e458 a5 a7              LDA BLNSW           ; software cursor
e45a d0 18              BNE IRQ_20          ; branch if not visible
e45c c6 a8              DEC BLNCT           ; blink count down
e45e d0 14              BNE IRQ_20
e460 a9 14              LDA #20             ; reset blink count down
e462 85 a8              STA BLNCT
e464 a4 c6              LDY CursorCol
e466 46 aa              LSR BLNON           ; BLNON = 0 : C = old value
e468 b1 c4              LDA (ScrPtr),Y
e46a b0 04              BCS IRQ_10
e46c e6 aa              INC BLNON           ; BLNON = 1 : reverse character
e46e 85 a9              STA GDBLN           ; save character under cursor
e470 49 80    IRQ_10    EOR #$80
e472 91 c4              STA (ScrPtr),Y      ; invert character
e474 20 24 e9 IRQ_20    JSR EDIT_KEY_SCAN
e477 68       IRQ_END   PLA
e478 a8                 TAY
e479 68                 PLA
e47a aa                 TAX
e47b 68                 PLA
e47c 40                 RTI

              ; ******
e47d            Delete
              ; ******

e47d 20 76 00           JSR CHRGOT
e480 20 f6 b8           JSR Scan_Linenumber ; start #
e483 20 a3 b5           JSR Find_BASIC_Line
e486 a5 5c              LDA TMPPTC
e488 85 21              STA RENINC
e48a a5 5d              LDA TMPPTC+1
e48c 85 22              STA RENINC+1
e48e 20 76 00           JSR CHRGOT
e491 c9 2d              CMP #'-'
e493 d0 30              BNE DelErr
e495 20 70 00           JSR CHRGET
e498 20 f6 b8           JSR Scan_Linenumber ; end #
e49b a5 11              LDA LINNUM
e49d 05 12              ORA LINNUM+1
e49f d0 02              BNE Del_10
e4a1 c6 12              DEC LINNUM+1        ; end number = $ff00
e4a3 20 a3 b5 Del_10    JSR Find_BASIC_Line
e4a6 90 03              BCC Del_20          ; -> not found
e4a8 20 33 ed           JSR Update_Link     ; First line after DELETE range
e4ab a6 2b    Del_20    LDX VARTAB+1
e4ad a0 00              LDY #0              ; Y = 0
e4af b1 5c    Del_30    LDA (TMPPTC),Y      ; copy upper part of program
e4b1 91 21              STA (RENINC),Y      ; into area to delete
e4b3 c8                 INY
e4b4 d0 f9              BNE Del_30
e4b6 e6 22              INC RENINC+1
e4b8 e6 5d              INC TMPPTC+1
e4ba e4 5d              CPX TMPPTC+1        ; reached VARTAB ?
e4bc b0 f1              BCS Del_30
e4be a4 21              LDY RENINC
e4c0 a5 22              LDA RENINC+1
e4c2 4c d5 df           JMP Renu_90         ; set VARTAB, reset BASIC
e4c5 4c 73 c3 DelErr    JMP Jump_To_Illegal_Quantity
e4c8                    .SIZE ;   75 [Delete]

              ; ***************
e4c8            Get_Record_Size
              ; ***************

e4c8 a0 00              LDY #0
e4ca 84 96              STY STATUS
e4cc 20 af f4           JSR Send_Filename
e4cf 20 91 d9           JSR Kernal_Read_DS
e4d2 a9 6d              LDA #$6d
e4d4 85 d3              STA SA
e4d6 ad ad 03           LDA DOS_Status
e4d9 c9 35              CMP #'5'
e4db d0 1d              BNE GRS_90
e4dd c6 b9              DEC DOS_RL
e4df a9 9d              LDA #$9d
e4e1 20 d2 ff           JSR CHROUT
e4e4 20 d2 ff           JSR CHROUT
e4e7 a5 b9              LDA DOS_RL
e4e9 20 54 d7           JSR Print_Hex_Byte
e4ec a5 b9              LDA DOS_RL
e4ee c9 02              CMP #2
e4f0 90 08              BCC GRS_90
e4f2 a4 d1              LDY FNLEN
e4f4 88                 DEY
e4f5 91 da              STA (FNADR),Y       ; try next record length
e4f7 4c c8 e4           JMP Get_Record_Size
e4fa 60       GRS_90    RTS ;Size   51 [Get_Record_Size]

              ; ***********
e4fb            Mon_Message
              ; ***********

e4fb 0d 20 20           .BYTE "\r   PC  IRQ  SR AC XR YR SP RB WB SV-BDIZC"

              ; ******
e525            IS_TAB
              ; ******

e525 a5 c6              LDA CursorCol
e527 29 07              AND #7
e529 a8                 TAY                 ; bit position
e52a a5 c6              LDA CursorCol
e52c 4a                 LSR A
e52d 4a                 LSR A
e52e 4a                 LSR A               ; Column / 8
e52f aa                 TAX                 ; word index
e530 b9 37 e5           LDA BITPOS,Y
e533 3d ee 03           AND TABS_SET,X
e536 60                 RTS ;Size   18 [IS_TAB]

              ; ******
e537            BITPOS
              ; ******

e537 80 40 20           .BYTE $80,$40,$20,$10,$08,$04,$02,$01

              ; ********
e53f            Mon_Fill
              ; ********

e53f a2 f9              LDX #BPTR           ; start address
e541 20 6c d7           JSR Read_Hex_Word
e544 90 26              BCC MoFi_Err
e546 a2 fd              LDX #MEMUSS         ; end   address
e548 20 6c d7           JSR Read_Hex_Word
e54b 90 1f              BCC MoFi_Err
e54d 20 79 d7           JSR  Read_Hex       ; fill byte
e550 90 1a              BCC MoFi_Err
e552 aa                 TAX
e553 a0 00              LDY #0
e555 a5 fd    MoFi_10   LDA MEMUSS
e557 c5 f9              CMP BPTR            ; set or clear carry
e559 a5 fe              LDA MEMUSS+1
e55b e5 fa              SBC BPTR+1
e55d 90 0a              BCC MoFi_End        ; BPTR > MEMUSS ?
e55f 8a                 TXA
e560 20 8b 02           JSR Bank_Store
e563 20 25 fb           JSR Inc_BPTR
e566 4c 55 e5           JMP MoFi_10
e569 4c ae d4 MoFi_End  JMP Mon_Main
e56c 4c a9 d4 MoFi_Err  JMP Mon_Error

e56f                    .SIZE ;   48 [Mon_Fill]


              ; ****************
e56f            Open_Disk_Buffer
              ; ****************

e56f 20 ae e7           JSR Preset_U1
e572 20 15 f2           JSR Kernal_CHRIN
e575 8d 54 03           STA DOS_Command_Buffer+1
e578 20 6a d7           JSR Hex_To_STAL
e57b 20 15 f2           JSR Kernal_CHRIN    ; skip blank
e57e a2 05              LDX #5
e580 20 f4 d8 ODB_20    JSR Mon_CHRIN
e583 9d 53 03           STA DOS_Command_Buffer,X
e586 e8                 INX
e587 e0 28              CPX #40
e589 b0 04              BCS ODB_30
e58b c9 20              CMP #' '
e58d b0 f1              BCS ODB_20
e58f 20 4c dc ODB_30    JSR DOS_SETNAM
e592 20 c7 f8           JSR Wedge_Prepare   ; set FA, clear status
e595 85 ba              STA Dis_Line        ; Dis_Line = 0
e597 20 d5 f0           JSR LISTEN          ; open fa,9,"#"
e59a a9 f9              LDA #$f9            ; sa = 9
e59c 20 43 f1           JSR SECOND
e59f a9 23              LDA #'#'            ; open buffer
e5a1 20 9e f1           JSR CIOUT
e5a4 4c b9 f1           JMP UNLSN


              ; ********
e5a7            Mon_Disk
              ; ********

              ;         U1 1000 0 18 01 - memory,drive,track,sector

e5a7 20 6f e5           JSR Open_Disk_Buffer
e5aa ad 54 03           LDA DOS_Command_Buffer+1
e5ad c9 32              CMP #'2'
e5af f0 20              BEQ Mon_Output_Block
e5b1 20 ba e7           JSR Mon_Disk_Comm
e5b4 20 d2 f0           JSR TALK
e5b7 a9 69              LDA #$69
e5b9 85 d3              STA SA
e5bb 20 93 f1           JSR TKSA
e5be a0 00              LDY #0
e5c0 20 c0 f1 MIB_30    JSR ACPTR
e5c3 91 fb              STA (STAL),Y
e5c5 c8                 INY
e5c6 d0 f8              BNE MIB_30
e5c8 20 ae f1           JSR UNTLK
e5cb 20 2a f7           JSR Close_Disk_File
e5ce 4c f7 d5           JMP DiMe_10         ; display loaded block

              ; ****************
e5d1            Mon_Output_Block
              ; ****************

              ;         U2 1000 0 18 01 - memory,drive,track,sector

e5d1 20 9b e7           JSR Reset_BP
e5d4 20 d5 f0           JSR LISTEN
e5d7 a9 69              LDA #$69
e5d9 85 d3              STA SA
e5db 20 43 f1           JSR SECOND
e5de a0 00              LDY #0
e5e0 b1 fb    MOB_10    LDA (STAL),Y
e5e2 20 9e f1           JSR CIOUT
e5e5 c8                 INY
e5e6 d0 f8              BNE MOB_10
e5e8 20 b9 f1           JSR UNLSN
e5eb 20 ba e7           JSR Mon_Disk_Comm
e5ee 20 2a f7           JSR Close_Disk_File
e5f1 4c f7 d5           JMP DiMe_10         ; display output block

e5f4 00 00 00           .FILL $e606-* (0) ; 18 bytes

              ; *********
e606            Edit_Init
              ; *********

e606 a9 7f              LDA #$7f
e608 8d 4e e8           STA VIA_IER         ; disable all interrupts
e60b a2 6d              LDX #$6d
e60d a9 00              LDA #0
e60f 85 e8              STA PrevChar        ; clear # of HOME key pressed
e611 95 8d    EdIn_10   STA JIFFY_CLOCK,X   ; clear all kernal variables
e613 ca                 DEX
e614 10 fb              BPL EdIn_10
e616 86 98              STX Key_Flags       ; $FF = Clear all flags
e618 ad 99 b3           LDA BSOS_Bank_Init
e61b 85 9a              STA Default_Bank
e61d a9 55              LDA #<IRQ_NORMAL    ; set default IRQ vector
e61f 85 90              STA CINV
e621 a9 e4              LDA #>IRQ_NORMAL
e623 85 91              STA CINV+1
e625 a9 09              LDA #9
e627 85 e3              STA XMAX            ; size of keyboard bufferX
e629 a9 03              LDA #3
e62b 85 b0              STA DFLTO           ; standard output channel
e62d a9 0f              LDA #15
e62f 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e632 0a                 ASL A
e633 8d 40 e8           STA VIA_Port_B
e636 8d 42 e8           STA VIA_DDR_B
e639 8e 22 e8           STX PIA2_Port_B
e63c 8e 45 e8           STX VIA_Timer_1_Hi  ; Timer 1 latch hi = $ff
e63f a9 3d              LDA #$3d
e641 8d 13 e8           STA PIA1_Cont_B
e644 2c 12 e8           BIT PIA1_Port_B     ; Keyboard row
e647 a9 3c              LDA #$3c
e649 8d 21 e8           STA PIA2_Cont_A
e64c 8d 23 e8           STA PIA2_Cont_B
e64f 8d 11 e8           STA PIA1_Cont_A
e652 8e 22 e8           STX PIA2_Port_B
e655 a9 0e              LDA #14
e657 85 a8              STA BLNCT
e659 85 a7              STA BLNSW
e65b 85 e6              STA DELAY
e65d 85 e5              STA KOUNT
e65f 8d 4e e8           STA VIA_IER         ; enable CA1, SR, CB2 interrupt
e662 a9 18              LDA #24
e664 85 df              STA ScreenRows
e666 20 bb e1           JSR Edit_Full_Screen
e669 a2 0c              LDX #12
e66b a9 00              LDA #0
e66d 9d ee 03 EdIn_20   STA TABS_SET,X
e670 ca                 DEX
e671 10 fa              BPL EdIn_20
e673 a9 1d              LDA #<Edit_CHRIN_Standard
e675 a2 e1              LDX #>Edit_CHRIN_Standard
e677 85 e9              STA SCRIV
e679 86 ea              STX SCRIV+1
e67b a9 0c              LDA #<Edit_CHROUT_Standard
e67d a2 e2              LDX #>Edit_CHROUT_Standard
e67f 85 eb              STA SCROV
e681 86 ec              STX SCROV+1
e683 a9 10              LDA #16
e685 85 e7              STA CHIME
e687 20 8a e6           JSR Double_Beep

              ; ***********
e68a            Double_Beep
              ; ***********

e68a 20 8d e6           JSR EDIT_BEEP

              ; *********
e68d            EDIT_BEEP
              ; *********

e68d a4 e7              LDY CHIME
e68f f0 25              BEQ BEEP_Ret
e691 a9 10              LDA #16             ; shift out - rate controlled by timer 2
e693 8d 4b e8           STA VIA_ACR         ; free running mode
e696 a9 0f              LDA #15
e698 8d 4a e8           STA VIA_Shift       ; set shift pattern 0000 1111
e69b a2 07              LDX #7
e69d bd 4d e7 BEEP_10   LDA SOUND_TAB-1,X
e6a0 8d 48 e8           STA VIA_Timer_2_Lo  ; set sustain time
e6a3 a5 e7              LDA CHIME
e6a5 88       BEEP_20   DEY
e6a6 d0 fd              BNE BEEP_20           ; inner wait loop
e6a8 38                 SEC
e6a9 e9 01              SBC #1
e6ab d0 f8              BNE BEEP_20           ; outer wait loop
e6ad ca                 DEX
e6ae d0 ed              BNE BEEP_10           ; next note
e6b0 8e 4a e8           STX VIA_Shift       ; x=0 clear shift register
e6b3 8e 4b e8           STX VIA_ACR         ; x=0 clear access control register
e6b6 60       BEEP_Ret  RTS ;Size   42 [EDIT_BEEP]

              ; **************
e6b7            Set_Screen_SAL
              ; **************

e6b7 8a                 TXA
e6b8 48                 PHA
e6b9 29 0f              AND #15
e6bb aa                 TAX
e6bc bd 55 e7           LDA Line_Addr_Lo,X
e6bf 85 c7              STA SAL
e6c1 68                 PLA
e6c2 aa                 TAX
e6c3 bd 6e e7           LDA Line_Addr_Hi,X
e6c6 85 c8              STA SAL+1
e6c8 60                 RTS ;Size   18 [Set_Screen_SAL]

              ; **********
e6c9            Cursor_BOL
              ; **********

              ; Input:  X       = cursor row (0 - 24)
              ; Output: ScrPtr  = screen address of row X
              ;         Y       = left margin

e6c9 a4 e2              LDY LefMargin

              ; *************
e6cb            Update_ScrPtr
              ; *************

e6cb 8a                 TXA
e6cc 48                 PHA
e6cd 29 0f              AND #15             ; Line lo repeats after 16 lines
e6cf aa                 TAX
e6d0 bd 55 e7           LDA Line_Addr_Lo,X
e6d3 85 c4              STA ScrPtr
e6d5 68                 PLA
e6d6 aa                 TAX
e6d7 bd 6e e7           LDA Line_Addr_Hi,X
e6da 85 c5              STA ScrPtr+1
e6dc 60                 RTS ;Size   18 [Update_ScrPtr]

              ; **********
e6dd            RUN_String
              ; **********

              ;               dL"*<CR>rU<CR>
e6dd 44 cc 22           .BYTE $44,$cc,$22,$2a,$0d,$52,$d5,$0d

              ; ********
e6e5            CRT_TEXT
              ; ********

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6e5 3a                 .BYTE  58           ;  0: Horizontal Total
e6e6 28                 .BYTE  40           ;  1: Horizontal Displayed
e6e7 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6e8 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6e9 20                 .BYTE  32           ;  4: Vertical Total
e6ea 09                 .BYTE   9           ;  5: Vertical Total Adjust
e6eb 19                 .BYTE  25           ;  6: Vertical Displayed
e6ec 1e                 .BYTE  30           ;  7: Vertical Sync position
e6ed 00                 .BYTE   0           ;  8: Interlace and Skew
e6ee 09                 .BYTE   9           ;  9: Maximum Raster Address
e6ef 00                 .BYTE   0           ; 10: Cursor Start Raster
e6f0 00                 .BYTE   0           ; 11: Cursor End Raster
e6f1 10                 .BYTE $10           ; 12: Display Start Address (High)
e6f2 00                 .BYTE $00           ; 13: Display Start Address (Low)
e6f3 00                 .BYTE $00           ; 14: Cursor Address (High)
e6f4 00                 .BYTE $00           ; 15: Cursor Address (Low)
e6f5 00                 .BYTE $00           ; 16: Light Pen Address (High)
e6f6 00                 .BYTE $00           ; 17: Light Pen Address (Low)


              ; ************
e6f7            CRT_GRAPHICS
              ; ************

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6f7 3a                 .BYTE  58           ;  0: Horizontal Total
e6f8 28                 .BYTE  40           ;  1: Horizontal Displayed
e6f9 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6fa 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6fb 29                 .BYTE  41           ;  4: Vertical Total                  !!!
e6fc 03                 .BYTE   3           ;  5: Vertical Total Adjust           !!!
e6fd 19                 .BYTE  25           ;  6: Vertical Displayed
e6fe 22                 .BYTE  34           ;  7: Vertical Sync position          !!!
e6ff 00                 .BYTE   0           ;  8: Interlace and Skew
e700 07                 .BYTE   7           ;  9: Maximum Raster Address          !!!


              ; ***
e701            OLD
              ; ***
e701 a9 01              LDA #1
e703 a8                 TAY
e704 91 28              STA (TXTTAB),Y      ; non zero link
e706 88                 DEY
e707 91 28              STA (TXTTAB),Y
e709 20 b6 b4           JSR Rechain         ; restore all links
e70c 18                 CLC
e70d a5 1f              LDA INDEXA
e70f 69 02              ADC #2
e711 a8                 TAY
e712 a5 20              LDA INDEXA+1
e714 69 00              ADC #0
e716 4c d5 df           JMP Renu_90         ; set VARTAB and reset BASIC

e719 00 00 00           .FILL $e74e-* (0) ; 53 bytes

              ; ****************
e74e            SOUND_TAB ; e74e
              ; ****************

e74e 0e 1e 3e           .BYTE $0e,$1e,$3e,$7e,$3e,$1e,$0e

              ; ********************
e755            Line_Addr_Lo ; $e755
              ; ********************

e755 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e75d 80 d0 20           .BYTE $80,$d0,$20,$70,$c0,$10,$60,$b0
e765 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e76d 80                 .BYTE $80

              ; ********************
e76e            Line_Addr_Hi ; $e76e
              ; ********************

e76e 80 80 80           .BYTE $80,$80,$80,$80,$81,$81,$81,$82 ;  0 -  7
e776 82 82 83           .BYTE $82,$82,$83,$83,$83,$84,$84,$84 ;  8 - 15
e77e 85 85 85           .BYTE $85,$85,$85,$85,$86,$86,$86,$87 ; 16 - 23
e786 87 87 88           .BYTE $87,$87,$88,$88,$88,$89,$89,$89 ; 24 - 31

e78e 42 2d 50 B_P_0     .BYTE "B-P 9 0\r"
e796 55 31 3a U1        .BYTE "U1:9 "

              ; ********
e79b            Reset_BP
              ; ********

e79b 20 31 fb           JSR DOS_Open_Comm_Write
e79e a0 00              LDY #0
e7a0 b9 8e e7 RBP_30    LDA B_P_0,Y
e7a3 20 9e f1           JSR CIOUT
e7a6 c8                 INY
e7a7 c0 08              CPY #?B_P_0
e7a9 90 f5              BCC RBP_30
e7ab 4c b9 f1           JMP UNLSN

              ; *********
e7ae            Preset_U1
              ; *********

e7ae a2 04              LDX #4
e7b0 bd 96 e7 PU1_10    LDA U1,X
e7b3 9d 53 03           STA DOS_Command_Buffer,X
e7b6 ca                 DEX
e7b7 10 f7              BPL PU1_10
e7b9 60                 RTS ;Size   12 [Preset_U1]

              ; *************
e7ba            Mon_Disk_Comm
              ; *************

e7ba 20 31 fb           JSR DOS_Open_Comm_Write
e7bd a2 00              LDX #0
e7bf bd 53 03 MDC_10    LDA DOS_Command_Buffer,X
e7c2 e8                 INX
e7c3 20 9e f1           JSR CIOUT
e7c6 c9 20              CMP #' '
e7c8 b0 f5              BCS MDC_10
e7ca 4c b9 f1           JMP UNLSN

e7cd 00 00 00           .FILL $e800-* (0) ; 51 bytes

e800 48 41 4c           .BYTE "HALL OF FAME:"
e80d 43 48 55           .BYTE "CHUCK PEDDLE - "
e81c 42 49 4c           .BYTE "BILL MENSCH - "
e82a 4a 41 43           .BYTE "JACK TRAMIEL - "
e839 49 52 41           .BYTE "IRA VELINSKY - "
e848 4a 4f 48           .BYTE "JOHN FEAGANS - "
e857 42 49 4c           .BYTE "BILL GATES - "
e864 4a 49 4d           .BYTE "JIM BUTTERFIELD - "
e876 42 52 41           .BYTE "BRAD TEMPLETON - "
e887 4a 49 4d           .BYTE "JIM CONELLEY - "
e896 4e 49 4c           .BYTE "NILS EILERS - "
e8a4 56 49 43           .BYTE "VICE TEAM - "


e8b0 00 00 00           .FILL $e924-* (0) ; 116 bytes

              ; *************
e924            EDIT_KEY_SCAN
              ; *************

              ; Initialize

e924 ad 10 e8           LDA PIA1_Port_A     ; Keyboard row select
e927 29 f0              AND #%11110000      ; Select row 0
e929 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e92c a5 98              LDA Key_Flags
e92e 09 c0              ORA #%11000000      ; 7 no <shift> and 6 no <ctrl>
e930 85 98              STA Key_Flags
e932 a9 ff              LDA #$ff
e934 85 97              STA Key_Index       ; invalidate Key_Index
e936 85 a6              STA SFDX            ; invalidate SFDX
e938 a2 4f              LDX #$4f            ; check key 79 -> 0

              ; Load next keyboard row int oaccumulator

e93a ad 12 e8 ScKbd_02  LDA PIA1_Port_B     ; Keyboard row
e93d cd 12 e8           CMP PIA1_Port_B     ; Keyboard row
e940 d0 f8              BNE ScKbd_02        ; repeat until no bounce

              ; Rotate accumulator for all 8 keys of this row

e942 a0 08              LDY #8              ; Test the 8 keys of the row
e944 4a       ScKbd_04  LSR A               ; next key -> carry
e945 b0 1a              BCS ScKbd_10        ; 1 -> not pressed
e947 48                 PHA                 ; Save scanned row

              ; Test for right or left shift key

e948 a9 7f              LDA #%01111111      ; mask for <shift> pressed
e94a e0 19              CPX #$19            ; Right Shift ?
e94c f0 0e              BEQ ScKbd_06        ; -> pressed
e94e e0 1f              CPX #$1f            ; Left Shift ?
e950 f0 0a              BEQ ScKbd_06        ; -> pressed

              ; Test for control key (RVS on older keyboards)

e952 a9 bf              LDA #%10111111      ; mask for <ctrl> pressed
e954 e0 0f              CPX #15             ; <RVS = CTRL> ?
e956 f0 04              BEQ ScKbd_06        ; -> pressed

              ; normal key, save key index

e958 86 97              STX Key_Index
e95a d0 04              BNE ScKbd_08        ; branch always

              ; flag shift or control in Key_Flags

e95c 25 98    ScKbd_06  AND Key_Flags
e95e 85 98              STA Key_Flags       ; save shift and control status

              ; continue with next index

e960 68       ScKbd_08  PLA                 ; restore row
e961 ca       ScKbd_10  DEX                 ; next key index
e962 30 08              BMI ScKbd_12        ; finished

              ; next key in this row

e964 88                 DEY                 ; next column
e965 d0 dd              BNE ScKbd_04

              ; row scan finished -> next row

e967 ee 10 e8           INC PIA1_Port_A     ; next keyboard row
e96a d0 ce              BNE ScKbd_02        ; Branch always

              ; keyboard scan finished - check if a keypress occured

e96c a6 97    ScKbd_12  LDX Key_Index       ; any key ?
e96e 10 03              BPL ScKbd_13        ; branch on key press
e970 86 e4              STX LSTX            ; invalidate last key pressed
e972 60       ScKbd_22  RTS ;Size   79 [EDIT_KEY_SCAN]

              ; is it the same key index as in the last scan ?

e973 e4 e4    ScKbd_13  CPX LSTX            ; still holding the same key ?
e975 d0 18              BNE ScKbd_16        ; other key
e977 a4 e6              LDY DELAY
e979 f0 04              BEQ ScKbd_14        ; branch if delay expired
e97b c6 e6              DEC DELAY           ; else decrement repeat delay counter
e97d d0 f3              BNE ScKbd_22        ; branch if delay not expired
e97f c6 e5    ScKbd_14  DEC KOUNT           ; decrement repeat speed counter
e981 d0 ef              BNE ScKbd_22        ; branch if repeat speed count not expired
e983 a0 04              LDY #4              ; set for 4/60ths of a second
e985 e0 0b              CPX #$0b            ; index for cursor <- ->
e987 d0 02              BNE ScKbd_15        ; normaö repeat speed
e989 a0 02              LDY #2              ; cursor left right repeat faster
e98b 84 e5    ScKbd_15  STY KOUNT           ; set repeat speed counter
e98d d0 06              BNE ScKbd_18        ; branch always

              ; new key press - reset delay

e98f 86 e4    ScKbd_16  STX LSTX            ; save key index
e991 a9 15              LDA #21
e993 85 e6              STA DELAY           ; set repeat delay count
e995 20 b4 e9 ScKbd_18  JSR Lookup_Keycode
e998 e0 0f              CPX #15
e99a f0 15              BEQ ScKbd_30        ; <CONTROL> doesn't go into buffer
e99c a6 9e              LDX CharsInBuffer
e99e e4 e3              CPX XMAX
e9a0 b0 05              BCS ScKbd_26        ; buffer full

              ; add key to keyboard buffer

e9a2 9d 6f 02 ScKbd_24  STA KEYD,X
e9a5 e6 9e              INC CharsInBuffer   ; put key into buffer

              ; check for STOP key

e9a7 a0 ff    ScKbd_26  LDY #$ff            ; Clear STOP flag
e9a9 c9 03              CMP #3              ; <STOP>
e9ab d0 02              BNE ScKbd_28
e9ad a0 ef              LDY #$ef            ; Set STOP flag
e9af 84 9b    ScKbd_28  STY Stop_Flag
e9b1 85 a6    ScKbd_30  STA SFDX
e9b3 60                 RTS ;Size  144 [EDIT_KEY_SCAN]

              ; **************
e9b4            Lookup_Keycode
              ; **************

e9b4 bd b6 eb           LDA KEYBOARD_CONTROL,X
e9b7 24 98              BIT Key_Flags
e9b9 70 05              BVS LoKe_20         ; no control
e9bb 30 02              BMI LoKe_10
e9bd 09 80              ORA #$80            ; shift control
e9bf 60       LoKe_10   RTS ;Size   12 [Lookup_Keycode]
e9c0 30 04    LoKe_20   BMI LoKe_30         ; no shift
e9c2 bd 65 eb           LDA KEYBOARD_SHIFTED,X
e9c5 60                 RTS ;Size   18 [Lookup_Keycode]
e9c6 bd 15 eb LoKe_30   LDA KEYBOARD_NORMAL,X
e9c9 60                 RTS ;Size   22 [Lookup_Keycode]

              ; ********************
e9ca            Edit_Switch_Char_ROM
              ; ********************

              ; Input:   A = $10 (new charset)   $30 (old charset)

e9ca a0 0c               LDY #12
e9cc 8c 80 e8            STY CRT_Address
e9cf 8d 81 e8            STA CRT_Value
e9d2 60                  RTS ;Size    9 [Edit_Switch_Char_ROM]


              ; **************
e9d3            EDIT_RESET_CRT
              ; **************

e9d3 a0 11              LDY #17
e9d5 2c                 .BYTE $2c           ; skip next instruction

              ; *****************
e9d6            EDIT_CHARSET_TEXT
              ; *****************

e9d6 a0 09              LDY #9
e9d8 a9 0e              LDA #14
e9da 8d 4c e8           STA VIA_PCR
e9dd a9 e5              LDA #<CRT_TEXT
e9df a2 e6              LDX #>CRT_TEXT
e9e1 4c 57 e0           JMP EDIT_SET_CRT

              ; *********************
e9e4            EDIT_CHARSET_GRAPHICS
              ; *********************

e9e4 a0 09              LDY #9
e9e6 a9 0c              LDA #12
e9e8 8d 4c e8           STA VIA_PCR
e9eb a9 f7              LDA #<CRT_GRAPHICS
e9ed a2 e6              LDX #>CRT_GRAPHICS
e9ef 4c 57 e0           JMP EDIT_SET_CRT

              ; *****************
e9f2            Read_Power_String
              ; *****************

e9f2 a9 ff              LDA #$ff
e9f4 85 99              STA Power_Flag
e9f6 20 e2 b4           JSR Read_String
e9f9 e6 99              INC Power_Flag
e9fb 60                 RTS ;Size   10 [Read_Power_String]

              ; ****************
e9fc            Check_Linenumber
              ; ****************

e9fc 8a                 TXA                 ; X = Row
e9fd 48                 PHA
e9fe 48                 PHA
e9ff 29 0f              AND #15
ea01 aa                 TAX
ea02 18                 CLC
ea03 bd 55 e7           LDA Line_Addr_Lo,X
ea06 65 e2              ADC LefMargin
ea08 85 77              STA TXTPTR
ea0a 68                 PLA
ea0b aa                 TAX
ea0c bd 6e e7           LDA Line_Addr_Hi,X
ea0f 69 00              ADC #0
ea11 85 78              STA TXTPTR+1
ea13 20 76 00           JSR CHRGOT
ea16 b0 04              BCS ChLi_Ret        ; no  number
ea18 20 f6 b8           JSR Scan_Linenumber
ea1b 18                 CLC                 ; has number
ea1c 68       ChLi_Ret  PLA
ea1d aa                 TAX
ea1e 60                 RTS ;Size   35 [Check_Linenumber]

              ; ******************
ea1f            Check_Line_Upwards
              ; ******************

ea1f a6 e1              LDX BotMargin
ea21 e4 e0    CLU_10    CPX TopMargin
ea23 f0 06              BEQ CLU_Ret         ; carry set -> no number
ea25 ca                 DEX
ea26 20 fc e9           JSR Check_Linenumber
ea29 b0 f6              BCS CLU_10
ea2b 60       CLU_Ret   RTS ;Size   13 [Check_Line_Upwards]

              ; ********************
ea2c            Check_Line_Downwards
              ; ********************

ea2c a6 e0              LDX TopMargin
ea2e e4 e1    CLD_10    CPX BotMargin
ea30 f0 06              BEQ CLD_Ret         ; carry set -> no number
ea32 e8                 INX
ea33 20 fc e9           JSR Check_Linenumber
ea36 b0 f6              BCS CLD_10
ea38 60       CLD_Ret   RTS ;Size   13 [Check_Line_Downwards]

              ; ***************
ea39            Power_Scroll_Up
              ; ***************

ea39 24 99              BIT Power_Flag      ; active ?
ea3b 10 33              BPL PSU_Ret
ea3d a5 d8              LDA CursorRow       ; save row
ea3f 48                 PHA
ea40 a5 c6              LDA CursorCol
ea42 48                 PHA                 ; save col
ea43 a6 e1              LDX BotMargin
ea45 ca                 DEX
ea46 20 c9 e6           JSR Cursor_BOL      ; one row above bottom line
ea49 a9 20              LDA #' '            ; check, if this line is blank
ea4b d1 c4    PSU_10    CMP (ScrPtr),Y
ea4d d0 18              BNE PSU_30          ; don't list on non empty line
ea4f c8                 INY
ea50 c4 d5              CPY RigMargin
ea52 90 f7              BCC PSU_10
ea54 86 d8              STX CursorRow
ea56 20 1f ea           JSR Check_Line_Upwards
ea59 b0 0c              BCS PSU_30
ea5b e6 11              INC LINNUM
ea5d d0 02              BNE PSU_20
ea5f e6 12              INC LINNUM+1
ea61 20 e4 ea PSU_20    JSR Find_Power_Line
ea64 20 ce ea           JSR List_BASIC_Line
ea67 68       PSU_30    PLA
ea68 85 c6              STA CursorCol
ea6a 68                 PLA
ea6b 85 d8              STA CursorRow       ; restore row
ea6d 20 52 e0           JSR Edit_Use_CursorRow
ea70 60       PSU_Ret   RTS ;Size   56 [Power_Scroll_Up]

              ; *****************
ea71            Power_Scroll_Down
              ; *****************

ea71 24 99              BIT Power_Flag
ea73 10 fb              BPL PSU_Ret
ea75 a5 d8              LDA CursorRow       ; save row
ea77 48                 PHA
ea78 a5 c6              LDA CursorCol
ea7a 48                 PHA                 ; save col
ea7b 20 2c ea           JSR Check_Line_Downwards
ea7e b0 e7              BCS PSU_30
ea80 20 e4 ea           JSR Find_Power_Line
ea83 a5 5c              LDA TMPPTC
ea85 c5 28              CMP TXTTAB
ea87 d0 06              BNE PSD_20
ea89 a5 5d              LDA TMPPTC+1
ea8b c5 29              CMP TXTTAB+1
ea8d f0 d8              BEQ PSU_30
ea8f a5 57    PSD_20    LDA TMPPTB
ea91 85 5c              STA TMPPTC
ea93 a5 58              LDA TMPPTB+1
ea95 85 5d              STA TMPPTC+1
ea97 20 4a e0           JSR EDIT_HOME
ea9a 20 ce ea           JSR List_BASIC_Line
ea9d a6 d8              LDX CursorRow
ea9f e4 e0              CPX TopMargin
eaa1 f0 c4              BEQ PSU_30
eaa3 a4 c6              LDY CursorCol       ; Basic line was oversize
eaa5 a9 20              LDA #' '            ; erase to EOL and scroll again
eaa7 91 c4    PSD_30    STA (ScrPtr),Y
eaa9 c4 d5              CPY RigMargin
eaab c8                 INY
eaac 90 f9              BCC PSD_30
eaae a5 e0              LDA TopMargin
eab0 48                 PHA
eab1 e8                 INX
eab2 86 e0              STX TopMargin
eab4 20 17 e4           JSR EDIT_SCROLL_DOWN
eab7 68                 PLA
eab8 85 e0              STA TopMargin
eaba a0 01              LDY #1
eabc b1 5c              LDA (TMPPTC),Y      ; link hi
eabe aa                 TAX
eabf 88                 DEY
eac0 b1 5c              LDA (TMPPTC),Y      ; link lo
eac2 85 5c              STA TMPPTC
eac4 86 5d              STX TMPPTC+1
eac6 e6 d8              INC CursorRow
eac8 20 ce ea           JSR List_BASIC_Line
eacb 4c 67 ea           JMP PSU_30          ; always

eace                    .SIZE ;   93 [Power_Scroll_Down]

              ; ***************
eace            List_BASIC_Line
              ; ***************

eace 20 4e e0           JSR Edit_Goto_Left_Margin
ead1 a0 01              LDY #1
ead3 b1 5c              LDA (TMPPTC),Y      ; check link for valid line
ead5 f0 0c              BEQ LBL_Ret
ead7 c8                 INY
ead8 b1 5c              LDA (TMPPTC),Y      ; line # lo
eada aa                 TAX
eadb c8                 INY
eadc b1 5c              LDA (TMPPTC),Y      ; line # hi
eade 20 89 b6           JSR List_Line       ; returns A=0
eae1 85 cd              STA QTSW
eae3 60       LBL_Ret   RTS ;Size   22 [List_BASIC_Line]

              ; ***************
eae4            Find_Power_Line
              ; ***************

eae4 a5 28              LDA TXTTAB
eae6 a6 29              LDX TXTTAB+1
eae8 85 57              STA TMPPTB
eaea 86 58              STX TMPPTB+1
eaec 85 5c    FPL_10    STA TMPPTC
eaee 86 5d              STX TMPPTC+1
eaf0 a0 01              LDY #1
eaf2 b1 5c              LDA (TMPPTC),Y      ; link hi
eaf4 f0 1e              BEQ FPL_40
eaf6 c8                 INY                 ; Y = 2
eaf7 b1 5c              LDA (TMPPTC),Y      ; line # lo
eaf9 c5 11              CMP LINNUM
eafb c8                 INY                 ; Y = 3
eafc b1 5c              LDA (TMPPTC),Y      ; line # hi
eafe e5 12              SBC LINNUM+1
eb00 b0 12              BCS FPL_40          ; >= LINNUM
eb02 a5 5c              LDA TMPPTC
eb04 85 57              STA TMPPTB
eb06 a6 5d              LDX TMPPTC+1        ; last ptr
eb08 86 58              STX TMPPTB+1
eb0a 88                 DEY                 ; Y = 2
eb0b 88                 DEY                 ; Y = 1
eb0c b1 5c              LDA (TMPPTC),Y      ; link hi
eb0e aa                 TAX
eb0f 88                 DEY                 ; Y = 0
eb10 b1 5c              LDA (TMPPTC),Y      ; link lo
eb12 90 d8              BCC FPL_10          ; branch always
eb14 60       FPL_40    RTS ;Size   49 [Find_Power_Line]

              ; ***************
eb15            KEYBOARD_NORMAL
              ; ***************

              ; The keyboard table has 80 ($50) entries scanned backwards
              ; The map is organized in 10 rows x 8 columns
              ; Val = Scancode assigned to this key
              ; X   = Index of this key
              ; R   = Physical row on keyboard (1-5)
              ; C   = Physical column on keyboard (1-16 and k1-k3 for keypad)
              ; Key = Description

              ;               Val     X  R  C Key
              ;         --------------------------------
eb15 16                 .PET $16  ; 00  -  - Ctrl V
eb16 00                 .PET $00  ; 01  -  -
eb17 be                 .PET $be  ; 02  1 12 SZ  ?
0000 TRUE     #if BSOS_KBD
eb18 14                 .PET $14  ; 03  1 16 DEL INST
              #else
SKIP                    .PET $13  ; 03  1 16 HOME CLR
              #endif
eb19 39                 .PET '9'  ; 04  1 10 9   )
eb1a 36                 .PET '6'  ; 05  1  7 6   &
eb1b 33                 .PET '3'  ; 06  1  4 3   Paragraph
eb1c 3c                 .PET '<'  ; 07  1  1 <   >

eb1d 31                 .PET '1'  ; 08  3 k1 1
eb1e 2d                 .PET '-'  ; 09  4 12 -   _
eb1f 15                 .PET $15  ; 0a  -  - Ctrl U
0000 TRUE     #if BSOS_KBD
eb20 1d                 .PET $1d  ; 0b  4 15 RIGHT LEFT
              #else
SKIP                    .PET $14  ; 0b  4 15 DEL INST
              #endif
eb21 4d                 .PET 'm'  ; 0c  4  9 m
eb22 20                 .PET ' '  ; 0d  5  1 SPACE
eb23 58                 .PET 'x'  ; 0e  4  4 x
eb24 00                 .PET $00  ; 0f  4  1 CTRL (used by index)

eb25 32                 .PET '2'  ; 10  3 k2 2
0000 TRUE     #if BSOS_KBD
eb26 11                 .PET $11  ; 11  4 14 DOWN UP
              #else
SKIP                    .PET $03  ; 11  4 14 STOP RUN
              #endif
eb27 0f                 .PET $0f  ; 12  -  - Ctrl O
eb28 30                 .PET '0'  ; 13  4 k1 0
eb29 2c                 .PET ','  ; 14  4 10 ,
eb2a 4e                 .PET 'n'  ; 15  4  8 n
eb2b 56                 .PET 'v'  ; 16  4  6 v
eb2c 59                 .PET 'y'  ; 17  4  3 y

eb2d 33                 .PET '3'  ; 18  3 k3 3
eb2e 00                 .PET $00  ; 19  4 13 Right SHIFT (used by index)
eb2f 19                 .PET $19  ; 1a  -  - Ctrl Y
eb30 2e                 .PET '.'  ; 1b  4 11 .
eb31 2e                 .PET '.'  ; 1c  4 k2 .
eb32 42                 .PET 'b'  ; 1d  4  7 b
eb33 43                 .PET 'c'  ; 1e  4  5 c
eb34 00                 .PET $00  ; 1f  4  2 Left SHIFT (used by index)

eb35 34                 .PET '4'  ; 20  2 k1 4
eb36 bd                 .PET $bd  ; 21  2 12 u umlaut
eb37 4f                 .PET 'o'  ; 22  2 10 o
eb38 5b                 .PET '['  ; 23  2 14 [   ^
eb39 55                 .PET 'u'  ; 24  2  8 u
eb3a 54                 .PET 't'  ; 25  2  6 t
eb3b 45                 .PET 'e'  ; 26  2  4 e
eb3c 51                 .PET 'q'  ; 27  2  2 q

eb3d 5d                 .PET ']'  ; 28  2 15 ]   \
eb3e 50                 .PET 'p'  ; 29  2 11 p
eb3f 49                 .PET 'i'  ; 2a  2  9 i
eb40 2b                 .PET '+'  ; 2b  2 13 +
eb41 5a                 .PET 'z'  ; 2c  2  7 z
eb42 52                 .PET 'r'  ; 2d  2  5 r
eb43 57                 .PET 'w'  ; 2e  2  3 w
eb44 09                 .PET $09  ; 2f  2  1 TAB

eb45 36                 .PET '6'  ; 30  2 k3 6
eb46 bb                 .PET $bb  ; 31  3 13 a umlaut
eb47 4c                 .PET 'l'  ; 32  3 11 l
eb48 0d                 .PET $0d  ; 33  3 15 RETURN
eb49 4a                 .PET 'j'  ; 34  3  9 j
eb4a 47                 .PET 'g'  ; 35  3  7 g
eb4b 44                 .PET 'd'  ; 36  3  5 d
eb4c 41                 .PET 'a'  ; 37  3  3 a

eb4d 35                 .PET '5'  ; 38  2 k2 5
eb4e bc                 .PET $bc  ; 39  3 12 o umlaut
eb4f 4b                 .PET 'k'  ; 3a  3 10 k
eb50 23                 .PET '#'  ; 3b  3 14 #
eb51 48                 .PET 'h'  ; 3c  3  8 h
eb52 46                 .PET 'f'  ; 3d  3  6 f
eb53 53                 .PET 's'  ; 3e  3  4 s
eb54 1b                 .PET $1b  ; 3f  3  1 ESC

eb55 39                 .PET '9'  ; 40  1 k3 9
eb56 00                 .PET $00  ; 41  -  -
0000 TRUE     #if BSOS_KBD
eb57 13                 .PET $13  ; 42  1 16 HOME
              #else
SKIP                    .PET $11  ; 42  1 16 DOWN UP
              #endif
eb58 37                 .PET '7'  ; 43  1 k1 7
eb59 30                 .PET '0'  ; 44  1 11 0
eb5a 37                 .PET '7'  ; 45  1  8 7
eb5b 34                 .PET '4'  ; 46  1  5 4
eb5c 31                 .PET '1'  ; 47  1  2 1

eb5d 00                 .PET $00  ; 48  -  -
eb5e 0e                 .PET $0e  ; 49  -  - Ctrl N
0000 TRUE     #if BSOS_KBD
eb5f 03                 .PET $03  ; 4a  1 15 STOP (RUN)
              #else
SKIP                    .PET $1d  ; 4a  1 15 RIGHT LEFT
              #endif
eb60 38                 .PET '8'  ; 4b  1 k2 Keypad 8
eb61 af                 .PET $af  ; 4c  1 13 ACUTE (GRAVE)
eb62 38                 .PET '8'  ; 4d  1  9
eb63 35                 .PET '5'  ; 4e  1  6
eb64 32                 .PET '2'  ; 4f  1  3

              ; ****************
eb65            KEYBOARD_SHIFTED
              ; ****************

eb65 96                 .PET $96  ; 00    Shift Ctrl V
eb66 00                 .PET $00  ; 01
eb67 3f                 .PET '?'  ; 02
0000 TRUE     #if BSOS_KBD
eb68 94                 .PET $94  ; 03    INST
              #else
SKIP                    .PET $93  ; 03    CLR
              #endif
eb69 29                 .PET ')'  ; 04    )
eb6a 26                 .PET '&'  ; 05    &
eb6b 40                 .PET '@'  ; 06    Paragraph
eb6c 3e                 .PET '>'  ; 07    >

eb6d a2                 .PET $a2  ; 08    Graph a2  KP 1
eb6e 5f                 .PET '_'  ; 09    UNDERLINE
eb6f 95                 .PET $95  ; 0a    Shift Ctrl U
0000 TRUE     #if BSOS_KBD
eb70 9d                 .PET $9d  ; 0b    LEFT
              #else
SKIP                    .PET $94  ; 0b    INST
              #endif
eb71 cd                 .PET 'M'  ; 0c    M
eb72 a0                 .PET $a0  ; 0d    SHIFT SPACE
eb73 d8                 .PET 'X'  ; 0e    X
eb74 00                 .PET $00  ; 0f    CTRL (used by index)

eb75 a3                 .PET $a3  ; 10    Graph a3
0000 TRUE     #if BSOS_KBD
eb76 91                 .PET $91  ; 11    Cursor UP
              #else
SKIP                    .PET $93  ; 11    RUN
              #endif
eb77 8f                 .PET $8f  ; 12    Shift Ctrl O
eb78 a1                 .PET $a1  ; 13    Graph a1  KP 0
eb79 3b                 .PET ';'  ; 14    ;
eb7a ce                 .PET 'N'  ; 15    N
eb7b d6                 .PET 'V'  ; 16    V
eb7c d9                 .PET 'Y'  ; 17    Y

eb7d a4                 .PET $a4  ; 18    Graph a4   KP 3
eb7e 00                 .PET $00  ; 19    Right SHIFT (used by index)
eb7f 99                 .PET $99  ; 1a    Shift Ctrl Y
eb80 ff                 .PET $ff  ; 1b    KP . Pi
eb81 3a                 .PET ':'  ; 1c    :
eb82 c2                 .PET 'B'  ; 1d    B
eb83 c3                 .PET 'C'  ; 1e    C
eb84 00                 .PET $00  ; 1f    Left SHIFT (used by index)

eb85 a5                 .PET $a5  ; 20    Graph a5   KP 4
eb86 f3                 .PET $f3  ; 21    U umlaut
eb87 cf                 .PET 'O'  ; 22    O
eb88 5e                 .PET '^'  ; 23    Circumflex
eb89 d5                 .PET 'U'  ; 24    U
eb8a d4                 .PET 'T'  ; 25    T
eb8b c5                 .PET 'E'  ; 26    E
eb8c d1                 .PET 'Q'  ; 27    Q

eb8d 5c                 .PET $5c  ; 28    Backslash
eb8e d0                 .PET 'P'  ; 29    P
eb8f c9                 .PET 'I'  ; 2a    I
eb90 2a                 .PET '*'  ; 2b    *
eb91 da                 .PET 'Z'  ; 2c    Z
eb92 d2                 .PET 'R'  ; 2d    R
eb93 d7                 .PET 'W'  ; 2e    W
eb94 89                 .PET $89  ; 2f    Shift TAB

eb95 a7                 .PET $a7  ; 30    Graph a7   KP 6
eb96 f1                 .PET $f1  ; 31    A umlaut
eb97 cc                 .PET 'L'  ; 32    L
eb98 8d                 .PET $8d  ; 33    SHIFT RETURN
eb99 ca                 .PET 'J'  ; 34    J
eb9a c7                 .PET 'G'  ; 35    G
eb9b c4                 .PET 'D'  ; 36    D
eb9c c1                 .PET 'A'  ; 37    A

eb9d a6                 .PET $a6  ; 38    Graph a6   KP 5
eb9e f2                 .PET $f2  ; 39    O umlaut
eb9f cb                 .PET 'K'  ; 3a    K
eba0 27                 .PET $27  ; 3b    '
eba1 c8                 .PET 'H'  ; 3c    H
eba2 c6                 .PET 'F'  ; 3d    F
eba3 d3                 .PET 'S'  ; 3e    S
eba4 1b                 .PET $1b  ; 3f    ESC

eba5 aa                 .PET $aa  ; 40    Graph aa   KP 9
eba6 00                 .PET $00  ; 41
0000 TRUE     #if BSOS_KBD
eba7 93                 .PET $93  ; 42    CLR
              #else
SKIP                    .PET $91  ; 42    CURSOR UP
              #endif
eba8 a8                 .PET $a8  ; 43    Graph a8   KP 7
eba9 3d                 .PET '='  ; 44    =
ebaa 2f                 .PET '/'  ; 45    /
ebab 24                 .PET '$'  ; 46    $
ebac 21                 .PET '!'  ; 47    !

ebad 00                 .PET $00  ; 48
ebae 8e                 .PET $8e  ; 49    Shift Ctrl N
0000 TRUE     #if BSOS_KBD
ebaf 83                 .PET $83  ; 4a    RUN
              #else
SKIP                    .PET $9d  ; 4a    CURSOR LEFT
              #endif
ebb0 a9                 .PET $a9  ; 4b    Graph a9   KP 8
ebb1 c0                 .PET $c0  ; 4c    GRAVE
ebb2 28                 .PET '('  ; 4d    (
ebb3 25                 .PET '%'  ; 4e    %
ebb4 22                 .PET '"'  ; 4f    "

ebb5 00                 .PET 0

              ; ****************
ebb6            KEYBOARD_CONTROL
              ; ****************

ebb6 00                 .BYTE $00           ;                                  10h  -------
ebb7 00                 .BYTE $00           ; SHIFT                            10g  LEFT SHIFT
ebb8 00                 .BYTE $00           ; ?                                10f  SZ ?
ebb9 00                 .BYTE $00           ; INS                              10e  DEL INST
ebba dd                 .BYTE $dd           ; }                                10d  9 )
ebbb 00                 .BYTE $00           ; &                                10c  6 &
ebbc 00                 .BYTE $00           ; `                                10b  3 Paragraph
ebbd 00                 .BYTE $00           ; >                                10a  < >

ebbe 00                 .BYTE $00           ; Graph a2                         9h  KP 1
ebbf 00                 .BYTE $00           ; UNDERLINE                        9g  - _
ebc0 00                 .BYTE $00           ; Shift Ctrl U                     9f  -------
ebc1 00                 .BYTE $00           ; LEFT                             9e  CURSOR <->
ebc2 00                 .BYTE $00           ; M                                9d  M
ebc3 00                 .BYTE $00           ; SHIFT SPC                        9c  SPACE
ebc4 18                 .BYTE $18           ; X                                9b  X
ebc5 00                 .BYTE $00           ; Control                          9a  CTRL (by index)

ebc6 00                 .BYTE $00           ; Graph a3                         8h  KP 2
ebc7 00                 .BYTE $00           ; 8g  CURSOR V^
ebc8 00                 .BYTE $00           ; Shift Ctrl O                     8f  -------
ebc9 00                 .BYTE $00           ; Graph a1                         8e  KP 0
ebca 00                 .BYTE $00           ; ;                                8d  ,
ebcb 0e                 .BYTE $0e           ; N                                8c  N
ebcc 16                 .BYTE $16           ; V                                8b  V
ebcd 19                 .BYTE $19           ; Y                                8a  Y

ebce 00                 .BYTE $00           ; Graph a4                         7h  KP 3
ebcf 00                 .BYTE $00           ; SHIFT                            7g  RIGHT SHIFT
ebd0 00                 .BYTE $00           ; Shift Ctrl Y                     7f  -------
ebd1 de                 .BYTE $de           ; ~                                7e  KP . Pi
ebd2 00                 .BYTE $00           ; :                                7d  . :
ebd3 02                 .BYTE $02           ; B                                7c  B
ebd4 03                 .BYTE $03           ; C                                7b  C
ebd5 00                 .BYTE $00           ; SHIFT                            7a  LEFT SHIFT

ebd6 00                 .BYTE $00           ; Graph a5                         6h  KP 4
ebd7 00                 .BYTE $00           ;                                  6g  UE
ebd8 0f                 .BYTE $0f           ; O                                6f  O
ebd9 00                 .BYTE $00           ; ARROW UP                         6e  Arrow up
ebda 15                 .BYTE $15           ; U                                6d  U
ebdb 14                 .BYTE $14           ; T                                6c  T
ebdc 05                 .BYTE $05           ; E                                6b  E
ebdd 11                 .BYTE $11           ; Q                                6a  Q

ebde 00                 .BYTE $00           ; 5h  ] Backslash
ebdf 10                 .BYTE $10           ; P                                5g  P
ebe0 09                 .BYTE $09           ; I                                5f  I
ebe1 00                 .BYTE $00           ; *                                5e  + *
ebe2 1a                 .BYTE $1a           ; Z                                5d  Z
ebe3 12                 .BYTE $12           ; R                                5c  R
ebe4 17                 .BYTE $17           ; W                                5b  W
ebe5 00                 .BYTE $00           ; SET TAB                          5a  TAB

ebe6 00                 .BYTE $00           ; Graph a7                         4h  KP 6
ebe7 00                 .BYTE $00           ;                                  4g  AE
ebe8 0c                 .BYTE $0c           ; L                                4f  L
ebe9 00                 .BYTE $00           ; SHIFT RET                        4e  RETURN
ebea 0a                 .BYTE $0a           ; J                                4d  J
ebeb 07                 .BYTE $07           ; G                                4c  G
ebec 04                 .BYTE $04           ; D                                4b  D
ebed 01                 .BYTE $01           ; A                                4a  A

ebee 00                 .BYTE $00           ; Graph a6                         3h  KP 5
ebef 00                 .BYTE $00           ;                                  3g  OE
ebf0 0b                 .BYTE $0b           ; K                                3f  K
ebf1 00                 .BYTE $00           ; '                                3e  # '
ebf2 08                 .BYTE $08           ; H                                3d  H
ebf3 06                 .BYTE $06           ; F                                3c  F
ebf4 13                 .BYTE $13           ; S                                3b  S
ebf5 1b                 .BYTE $1b           ; ESC                              3a  ESC

ebf6 00                 .BYTE $00           ; Graph aa                         2h  KP 9
ebf7 00                 .BYTE $00           ; SHIFT                            2g  -------
ebf8 00                 .BYTE $00           ; CLR                              2f  HOME CLR
ebf9 00                 .BYTE $00           ; Graph a8                         2e  KP 7
ebfa 00                 .BYTE $00           ; =                                2d  0 =
ebfb dc                 .BYTE $dc           ; |                                2c  7 /
ebfc 00                 .BYTE $00           ; $                                2b  4 $
ebfd 00                 .BYTE $00           ; !                                2a  1 !

ebfe 00                 .BYTE $00           ; SHIFT                            1h  -------
ebff 00                 .BYTE $00           ; Shift Ctrl N                     1g  -------
ec00 00                 .BYTE $00           ; 1f  [ \
ec01 00                 .BYTE $00           ; Graph a9                         1e  KP 8
ec02 00                 .BYTE $00           ;                                  1d  ACUTE GRAVE
ec03 db                 .BYTE $db           ; {                                1c  8 (
ec04 00                 .BYTE $00           ; %                                1b  5 %
ec05 00                 .BYTE $00           ; "                                1a  2 "
ec06 00                 .BYTE $00           ; SHIFT

              ; **********
ec07            Find_Entry
              ; **********

ec07 86 11              STX LINNUM          ; save old #
ec09 85 12              STA LINNUM+1

              ; ***********
ec0b            Find_LINNUM
              ; ***********

ec0b 98                 TYA
ec0c 48                 PHA
ec0d a0 00              LDY #0
ec0f 84 fb              STY STAL            ; STAL = $8000
ec11 a9 80              LDA #$80
ec13 85 fc              STA STAL+1
ec15 85 b6              STA R_Bank
ec17 a0 03    FiEn_10   LDY #3              ; old line high
ec19 20 7a 02           JSR Bank_Fetch
ec1c c9 ff              CMP #$ff            ; EOT
ec1e f0 18              BEQ FiEn_20
ec20 c5 12              CMP LINNUM+1
ec22 d0 17              BNE FiEn_30
ec24 88                 DEY                 ; old line low
ec25 20 7a 02           JSR Bank_Fetch
ec28 c5 11              CMP LINNUM
ec2a d0 0f              BNE FiEn_30
ec2c 88                 DEY                 ; new line high
ec2d 20 7a 02           JSR Bank_Fetch
ec30 85 12              STA LINNUM+1
ec32 88                 DEY                 ; new line low
ec33 20 7a 02           JSR Bank_Fetch
ec36 85 11              STA LINNUM
ec38 68       FiEn_20   PLA
ec39 a8                 TAY
ec3a 60                 RTS ;Size   48 [Find_LINNUM]
ec3b a9 04    FiEn_30   LDA #4
ec3d 20 1b fb           JSR Add_STAL
ec40 d0 d5              BNE FiEn_10
ec42 60                 RTS ;Size   56 [Find_LINNUM]

              ; *******************
ec43            Install_Bank_Access
              ; *******************

ec43 a2 00              LDX #0
ec45 bd 51 ec FSC_10    LDA Bank_Fetch_Start,X
ec48 9d 7a 02           STA Bank_Fetch,X
ec4b e8                 INX
ec4c e0 24              CPX #[Bank_Store_End - Bank_Fetch_Start]
ec4e 90 f5              BCC FSC_10
ec50 60                 RTS ;Size   14 [Install_Bank_Access]

              ; ****************
ec51            Bank_Fetch_Start
              ; ****************

ec51 a5 b6              LDA R_Bank
ec53 78                 SEI
ec54 8d f0 ff           STA $FFF0
ec57 b1 fb              LDA (STAL),Y
ec59 48                 PHA
ec5a a5 9a              LDA Default_Bank
ec5c 8d f0 ff           STA $FFF0
ec5f 58                 CLI
ec60 68                 PLA
ec61 60                 RTS ;Size   17 [Bank_Fetch_Start]

              ; **************
ec62            Bank_Fetch_End
              ; **************

              ; ****************
ec62            Bank_Store_Start
              ; ****************

ec62 48                 PHA
ec63 a5 b7              LDA W_Bank
ec65 78                 SEI
ec66 8d f0 ff           STA $FFF0
ec69 68                 PLA
ec6a 91 f9              STA (BPTR),Y
ec6c 48                 PHA
ec6d a5 9a              LDA Default_Bank
ec6f 8d f0 ff           STA $FFF0
ec72 58                 CLI
ec73 68                 PLA
ec74 60                 RTS ;Size   19 [Bank_Store_Start]

              ; **************
ec75            Bank_Store_End
              ; **************


              ; ********
ec75            Get_Next
              ; ********

ec75 e6 77              INC TXTPTR
ec77 d0 02              BNE GeNe_10
ec79 e6 78              INC TXTPTR+1
ec7b a1 77    GeNe_10   LDA (TXTPTR,X)      ; X = 0
ec7d 60                 RTS ;Size    9 [Bank_Store_End]

              ; *********
ec7e            Xfer_Line
              ; *********

              ; copy BASIC line and adjust targets for

              ; GOTO
              ; GOSUB
              ; THEN
              ; GO TO
              ; RUN

              ; Set TXTPTR to start of BASIC line

ec7e 18                 CLC
ec7f a5 5c              LDA TMPPTC
ec81 69 03              ADC #3
ec83 85 77              STA TXTPTR
ec85 a5 5d              LDA TMPPTC+1
ec87 69 00              ADC #0
ec89 85 78              STA TXTPTR+1
ec8b a2 00              LDX #0              ; source index
ec8d a0 03              LDY #3              ; destination index
ec8f c8       XfLi_10   INY
ec90 20 75 ec           JSR Get_Next        ; next byte
ec93 20 8b 02           JSR Bank_Store      ; store
ec96 f0 4d              BEQ XfLi_Ret        ; finished
ec98 c9 22              CMP #QUOTE
ec9a d0 0f              BNE XfLi_30
ec9c c8       XfLi_20   INY
ec9d 20 75 ec           JSR Get_Next        ; inside string
eca0 20 8b 02           JSR Bank_Store      ; store
eca3 f0 40              BEQ XfLi_Ret        ; finished
eca5 c9 22              CMP #QUOTE
eca7 d0 f3              BNE XfLi_20         ; continue string copy
eca9 f0 e4              BEQ XfLi_10         ; reenter normal loop
ecab c9 8f    XfLi_30   CMP #$8f            ; REM token
ecad d0 0a              BNE XfLi_50
ecaf c8       XfLi_40   INY
ecb0 20 75 ec           JSR Get_Next        ; after REM
ecb3 20 8b 02           JSR Bank_Store      ; store
ecb6 d0 f7              BNE XfLi_40
ecb8 60                 RTS ;Size   59 [Xfer_Line]
ecb9 c9 89    XfLi_50   CMP #$89            ; GOTO token
ecbb 90 d2              BCC XfLi_10         ; no further action
ecbd f0 1f              BEQ XfLi_70
ecbf c9 8a              CMP #$8a            ; RUN token
ecc1 f0 1b              BEQ XfLi_70
ecc3 c9 8d              CMP #$8d            ; GOSUB token
ecc5 f0 17              BEQ XfLi_70
ecc7 c9 a7              CMP #$a7            ; THEN token
ecc9 f0 13              BEQ XfLi_70
eccb c9 cb              CMP #$cb            ; GO token
eccd d0 0b              BNE XfLi_60
eccf c8       XfLi_55   INY
ecd0 20 75 ec           JSR Get_Next
ecd3 20 8b 02           JSR Bank_Store
ecd6 c9 20              CMP #' '            ; skip blanks after GO
ecd8 f0 f5              BEQ XfLi_55
ecda c9 a4    XfLi_60   CMP #$a4            ; TO token
ecdc d0 b1              BNE XfLi_10         ; continue
ecde 20 e6 ec XfLi_70   JSR Exchange_Number
ece1 c9 00              CMP #0
ece3 d0 d4              BNE XfLi_50         ; continue if not EOL
ece5 60       XfLi_Ret  RTS ;Size  104 [Xfer_Line]


              ; ***************
ece6            Exchange_Number
              ; ***************

ece6 c8                 INY                 ; char after token
ece7 20 70 00           JSR CHRGET
ecea b0 29              BCS ExNu_20         ; no number e.g. after THEN
ecec 20 f6 b8           JSR Scan_Linenumber
ecef 20 0b ec           JSR Find_LINNUM
ecf2 98                 TYA
ecf3 48                 PHA
ecf4 a5 11              LDA LINNUM
ecf6 85 60              STA FAC1M2
ecf8 a5 12              LDA LINNUM+1
ecfa 85 5f              STA FAC1M1
ecfc a2 90              LDX #$90
ecfe 38                 SEC
ecff 20 7f cd           JSR Convert_Integer_To_Real
ed02 20 93 cf           JSR Format_FAC1
ed05 68                 PLA
ed06 a8                 TAY
ed07 a2 01              LDX #1
ed09 bd 00 01 ExNu_10   LDA STACK,X
ed0c f0 07              BEQ ExNu_20
ed0e 20 8b 02           JSR Bank_Store
ed11 c8                 INY
ed12 e8                 INX
ed13 d0 f4              BNE ExNu_10
ed15 a2 00    ExNu_20   LDX#0
ed17 20 76 00           JSR CHRGOT          ; char after target
ed1a 20 8b 02           JSR Bank_Store
ed1d c9 2c              CMP #','            ; on .. goto or on .. gosub ?
ed1f f0 c5              BEQ Exchange_Number
ed21 60       ExNu_Ret  RTS ;Size   60 [Exchange_Number]

              ; **********************
ed22            Reset_Renumber_Pointer
              ; **********************

              ; read basic program with pointer TMPPTC

ed22 a5 28              LDA TXTTAB
ed24 85 5c              STA TMPPTC
ed26 a5 29              LDA TXTTAB+1
ed28 85 5d              STA TMPPTC+1

              ; **********
ed2a            Reset_BPTR
              ; **********

ed2a a9 00              LDA #0
ed2c 85 f9              STA BPTR
ed2e a9 80              LDA #$80
ed30 85 fa              STA BPTR+1
ed32 60                 RTS ;Size    9 [Reset_BPTR]

              ; ***********
ed33            Update_Link
              ; ***********

ed33 a0 00              LDY #0
ed35 b1 5c              LDA (TMPPTC),Y      ; link low
ed37 aa                 TAX
ed38 c8                 INY                 ; Y = 1
ed39 b1 5c              LDA (TMPPTC),Y      ; link high
ed3b 86 5c              STX TMPPTC
ed3d 85 5d              STA TMPPTC+1        ; Z flag set if link high is zero
ed3f 60                 RTS ;Size   13 [Update_Link]


              ; ****************
ed40            Extended_Command
              ; ****************

ed40 a0 00              LDY #0
ed42 84 05              STY COUNT           ; count command #
ed44 88       ExCo_10   DEY
ed45 a6 77              LDX TXTPTR
ed47 ca                 DEX
ed48 e8       ExCo_20   INX
ed49 c8                 INY
ed4a bd 00 02           LDA BUF,X
ed4d 38                 SEC
ed4e f9 3a bf           SBC Extended_Keyword_Table,Y
ed51 f0 f5              BEQ ExCo_20         ; character match
ed53 c9 80              CMP #$80            ; match with difference $80 -> OK
ed55 d0 13              BNE ExCo_30         ; not this keyword
ed57 68                 PLA                 ; remove CALL
ed58 68                 PLA
ed59 86 77              STX TXTPTR
ed5b a5 05              LDA COUNT           ; command #
ed5d 0a                 ASL A
ed5e a8                 TAY
ed5f b9 2d bf           LDA Extended_Statement_Table+1,Y
ed62 48                 PHA
ed63 b9 2c bf           LDA Extended_Statement_Table,Y
ed66 48                 PHA
ed67 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
ed6a e6 05    ExCo_30   INC COUNT           ; try next keyword
ed6c c8       ExCo_40   INY
ed6d b9 39 bf           LDA Extended_Keyword_Table-1,Y
ed70 10 fa              BPL ExCo_40
ed72 b9 2c bf           LDA Extended_Statement_Table,Y
ed75 d0 cd              BNE ExCo_10         ; next keyword if not end of table
ed77 60                 RTS                 ; finished scan ;Size   56 [Extended_Command]


              ; *********
ed78            Find_Text
              ; *********

ed78 20 fb b4           JSR Tokenize_Line
ed7b 20 70 00           JSR CHRGET
ed7e 85 23              STA RENNEW          ; delimiter
ed80 20 22 ed           JSR Reset_Renumber_Pointer
ed83 a0 03    FiTe_10   LDY #3
ed85 84 24              STY RENNEW+1
ed87 20 9a ed           JSR Contains_Pattern
ed8a d0 06              BNE FiTe_20
ed8c 20 ce ea           JSR List_BASIC_Line
ed8f 20 1e d5           JSR Mon_Print_CR
ed92 20 33 ed FiTe_20   JSR Update_Link
ed95 d0 ec              BNE FiTe_10
ed97 4c ff b3           JMP Basic_Ready

              ; ****************
ed9a            Contains_Pattern
              ; ****************

ed9a a6 77    CoPa_10   LDX TXTPTR          ; text to find - 1
ed9c a4 24              LDY RENNEW+1
ed9e c8       CoPa_20   INY
ed9f e8                 INX
eda0 bd 00 02           LDA BUF,X           ; next pattern
eda3 f0 10              BEQ CoPa_Ret        ; match
eda5 c5 23              CMP RENNEW          ; delimiter
eda7 f0 0c              BEQ CoPa_Ret        ; match
eda9 d1 5c              CMP (TMPPTC),Y      ; next program byte
edab f0 f1              BEQ CoPa_20         ; continue compare
edad e6 24              INC RENNEW+1        ; advance search pos
edaf b1 5c              LDA (TMPPTC),Y
edb1 d0 e7              BNE CoPa_10
edb3 a9 01              LDA #1
edb5 60       CoPa_Ret  RTS ;Size   28 [Contains_Pattern]

              ; **************
edb6            Load_Directory
              ; **************

edb6 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
edb9 a4 2f              LDY STREND+1        ; load directory into free RAM
edbb c8                 INY
edbc 84 ca              STY EAL+1
edbe a0 00              LDY #0
edc0 84 c9              STY EAL
edc2 84 96              STY STATUS
edc4 a0 02              LDY #2              ; header start
edc6 a6 ca    LoDi_10   LDX EAL+1           ; next page
edc8 e8                 INX
edc9 e4 31              CPX FRETOP+1        ; end of free RAM
edcb 90 03              BCC LoDi_20         ; branch if OK
edcd 4c cd b3           JMP Error_Out_Of_Memory
edd0 86 ca    LoDi_20   STX EAL+1
edd2 20 c0 f1 LoDi_30   JSR ACPTR           ; read next byte
edd5 91 c9              STA (EAL),Y
edd7 a5 96              LDA STATUS
edd9 d0 05              BNE LoDi_40         ; branch on EOI
eddb c8                 INY
eddc d0 f4              BNE LoDi_30         ; loop
edde f0 e6              BEQ LoDi_10         ; increment page
ede0 4c c1 f3 LoDi_40   JMP LoFi_70         ; Untalk & Close

              ; *****************
ede3            DOS_Get_Dir_Entry
              ; *****************

              ; Read directory entry from loaded $ file
              ; and store results in FNLEN and DOS_FC
              ; Store filename address in FNADR
              ; X = 0 flags no entry found on exit

ede3 18                 CLC                 ; advance to next entry
ede4 a5 bb              LDA DosPtr          ; start address
ede6 69 20              ADC #32
ede8 85 bb              STA DosPtr
edea 90 02              BCC DGDE_05
edec e6 bc              INC DosPtr+1

edee a0 03    DGDE_05   LDY #3              ; scan after size word

edf0 c8       DGDE_10   INY
edf1 b1 bb              LDA (DosPtr),Y
edf3 c9 22              CMP #QUOTE
edf5 90 f9              BCC DGDE_10         ; skip blanks before filename
edf7 d0 3a              BNE DGDE_80         ; no quote -> blocks free
edf9 88                 DEY                 ; byte for drive
edfa 88                 DEY                 ; byte for 'S' command
edfb 98                 TYA
edfc 05 bb              ORA DosPtr          ; set FNADR
edfe 85 da              STA FNADR
ee00 a5 bc              LDA DosPtr+1
ee02 85 db              STA FNADR+1
ee04 a0 00              LDY #0              ; prepare scratch command
ee06 a9 53              LDA #'S'
ee08 91 da              STA (FNADR),Y
ee0a c8                 INY
ee0b ad 3c 03           LDA DOS_Drive_2     ; target drive
ee0e 09 30              ORA #'0'
ee10 91 da              STA (FNADR),Y
ee12 c8                 INY
ee13 a9 3a              LDA #':'
ee15 91 da              STA (FNADR),Y       ; overwrite opening quote

ee17 c8       DGDE_20   INY
ee18 b1 da              LDA (FNADR),Y
ee1a c9 22              CMP #QUOTE          ; closing quote
ee1c f0 04              BEQ DGDE_40
ee1e c0 13              CPY #19             ; max length + "S0:"
ee20 90 f5              BCC DGDE_20

ee22 84 d1    DGDE_40   STY FNLEN           ; length of filename

ee24 c8       DGDE_60   INY
ee25 b1 da              LDA (FNADR),Y
ee27 c9 20              CMP #' '            ; skip blanks
ee29 f0 f9              BEQ DGDE_60
ee2b c9 2a              CMP #'*'            ; splat file ?
ee2d f0 b4              BEQ DOS_Get_Dir_Entry
ee2f 85 b1              STA DOS_FC          ; PRG, SEQ, USR, REL
ee31 a0 00              LDY #0              ; flag success

ee33 60       DGDE_80   RTS                 ; Y != 0 for no file ;Size   81 [DOS_Get_Dir_Entry]

              ; *************
ee34            DOS_Add_Comma
              ; *************

ee34 a9 2c              LDA #','
ee36 91 da              STA (FNADR),Y
ee38 c8                 INY
ee39 60                 RTS ;Size    6 [DOS_Add_Comma]

              ; DOS_Copy is an enhancement of the BASIC 4 COPY command.
              ; It is called from the original COPY if Source Unit and
              ; Target unit differ
              ; DOS_Copy uses the free RAM between variable storage and
              ; string storage (STREND - FRETOP)
              ; First a call to the Garbage_Collection maximises the
              ; free RAM area. The first 256 byte block after STREND is
              ; used as a transfer buffer. The area STREND + 256 is used
              ; to store the directory of the source unit. If the
              ; remaining space is not sufficient to load the directory
              ; an OOM (Out Of Memory) error occurs.

              ; ********
ee3a            DOS_Copy
              ; ********

ee3a 20 6a c6           JSR Garbage_Collection
ee3d a5 d4              LDA FA              ; target unit
ee3f 85 ad              STA Target_Unit     ; save it
ee41 a5 9c              LDA Source_Unit
ee43 85 d4              STA FA
ee45 a9 24              LDA #'$'            ; directory command
ee47 8d 53 03           STA DOS_Command_Buffer
ee4a a9 03              LDA #3              ; 3 parameter
ee4c a2 01              LDX #1              ; write after $
ee4e a0 02              LDY #2              ; build d1:f1
ee50 20 fc db           JSR Build_DOS_Command_X
ee53 20 b6 ed           JSR Load_Directory
ee56 a9 00              LDA #0              ; start of directory
ee58 85 bb              STA DosPtr
ee5a a6 2f              LDX STREND+1
ee5c e8                 INX
ee5d e8                 INX
ee5e 86 bc              STX DosPtr+1

ee60 20 e3 ed DOSC_10   JSR DOS_Get_Dir_Entry
ee63 98                 TYA                 ; 0: success
ee64 f0 01              BEQ DOSC_15
ee66 60                 RTS ;Size   45 [DOS_Copy]

ee67 84 b9    DOSC_15   STY DOS_RL          ; record length
ee69 84 11              STY LINNUM          ; initialize record #
ee6b 84 12              STY LINNUM+1
ee6d c8                 INY
ee6e 8c 3a 03           STY DOS_Tmp         ; pos in record# = 1
ee71 a4 d1              LDY FNLEN
ee73 20 34 ee           JSR DOS_Add_Comma
ee76 a5 b1              LDA DOS_FC          ; Filetype
ee78 c9 52              CMP #'R'            ; REL file ?
ee7a d0 0e              BNE DOSC_20
ee7c a9 4c              LDA #'L'            ; REL type
ee7e 91 da              STA (FNADR),Y
ee80 c8                 INY
ee81 20 34 ee           JSR DOS_Add_Comma   ; "St:FILENAME,L,CHR$(RL)"
ee84 a9 fe              LDA #254            ; max record length
ee86 85 b9              STA DOS_RL
ee88 d0 08              BNE DOSC_25         ; branch always

ee8a 91 da    DOSC_20   STA (FNADR),Y       ; "St:FILENAME,S"
ee8c c8                 INY
ee8d 20 34 ee           JSR DOS_Add_Comma
ee90 a9 57              LDA #'W'

ee92 91 da    DOSC_25   STA (FNADR),Y       ; "St:FILENAME,S,W"

              ; Scratch target file (avoid @ syntax)

ee94 a5 ad              LDA Target_Unit
ee96 85 d4              STA FA
ee98 20 9b da           JSR PDC_10          ; send DOS command

              ; Remove 'S' from Scratch command

ee9b e6 da              INC FNADR           ; always inside page

              ; Add ",S" ",P" ",U" or ",L,CHR$(RL)"

ee9d e6 d1              INC FNLEN           ; "t:FILENAME,S"
ee9f a5 b9              LDA DOS_RL          ; REL file ?
eea1 f0 04              BEQ DOSC_35         ; branch if not
eea3 e6 d1              INC FNLEN           ; "t:FILENAME,L,"
eea5 e6 d1              INC FNLEN           ; "t:FILENAME,L,(RL)"

              ; print filename

eea7 20 5d ef DOSC_35   JSR Print_Filename
eeaa 20 87 ef           JSR Open_Read_File

              ; Open write file

eead a5 b9    DOSC_47   LDA DOS_RL
eeaf d0 04              BNE DOSC_50
eeb1 e6 d1              INC FNLEN           ; "s:FILENAME,S,W"
eeb3 e6 d1              INC FNLEN

eeb5 20 a4 ef DOSC_50   JSR Open_Write_File

              ; Copy file

eeb8 a5 9c    DOSC_55   LDA Source_Unit
eeba 85 d4              STA FA
eebc 20 d2 f0           JSR TALK
eebf a9 6d              LDA #$6d
eec1 85 d3              STA SA
eec3 20 93 f1           JSR TKSA
eec6 a0 00              LDY #0
eec8 84 96              STY STATUS

eeca 20 c0 f1 DOSC_60   JSR ACPTR
eecd 91 2e              STA (STREND),Y
eecf c8                 INY
eed0 a5 96              LDA STATUS
eed2 85 b2              STA DOS_EOF
eed4 d0 04              BNE DOSC_65
eed6 c4 b9              CPY DOS_RL          ; copy max DOS_RL bytes
eed8 d0 f0              BNE DOSC_60         ; DOS_RL=0 -> copy 256 bytes

eeda 84 b1    DOSC_65   STY DOS_FC          ; Byte count
eedc 20 ae f1           JSR UNTLK
eedf a5 b9              LDA DOS_RL
eee1 f0 07              BEQ DOSC_66
eee3 20 91 d9           JSR Kernal_Read_DS
eee6 c9 30              CMP #'0'
eee8 d0 41              BNE DOSC_75

eeea a5 ad    DOSC_66   LDA Target_Unit
eeec 85 d4              STA FA
eeee a9 6e              LDA #$6e
eef0 85 d3              STA SA
eef2 a0 00              LDY #0
eef4 84 96              STY STATUS
eef6 a5 b9              LDA DOS_RL
eef8 f0 03              BEQ DOSC_67
eefa 20 4c ef           JSR Send_Record_No

eefd 20 d5 f0 DOSC_67   JSR LISTEN
ef00 a9 6e              LDA #$6e
ef02 85 d3              STA SA
ef04 20 43 f1           JSR SECOND

ef07 b1 2e    DOSC_70   LDA (STREND),Y
ef09 20 9e f1           JSR CIOUT
ef0c a5 96              LDA STATUS
ef0e d0 1b              BNE DOSC_75
ef10 c8                 INY
ef11 c4 b1              CPY DOS_FC
ef13 d0 f2              BNE DOSC_70
ef15 20 b9 f1           JSR UNLSN
ef18 a5 b2              LDA DOS_EOF
ef1a f0 9c              BEQ DOSC_55
ef1c a5 b9              LDA DOS_RL
ef1e f0 0b              BEQ DOSC_75
ef20 20 91 d9           JSR Kernal_Read_DS
ef23 c9 30              CMP #'0'
ef25 f0 91              BEQ DOSC_55
ef27 c9 35              CMP #'5'            ; ignore record not present
ef29 f0 8d              BEQ DOSC_55

ef2b 20 b9 f1 DOSC_75   JSR UNLSN
ef2e a5 ad              LDA Target_Unit
ef30 85 d4              STA FA
ef32 a9 6e              LDA #$6e
ef34 85 d3              STA SA
ef36 20 2a f7           JSR Close_Disk_File ; close write file
ef39 a9 0d              LDA #CR
ef3b 20 d2 ff           JSR CHROUT
ef3e a5 9c              LDA Source_Unit
ef40 85 d4              STA FA
ef42 a9 6d              LDA #$6d
ef44 85 d3              STA SA
ef46 20 2a f7           JSR Close_Disk_File ; close read file
ef49 4c 60 ee           JMP DOSC_10         ; next file

              ; **************
ef4c            Send_Record_No
              ; **************

ef4c e6 11              INC LINNUM
ef4e d0 02              BNE SRN_10
ef50 e6 12              INC LINNUM+1
ef52 20 43 da SRN_10    JSR DOS_Record_No
ef55 20 91 d9           JSR Kernal_Read_DS
ef58 a0 00              LDY #0
ef5a 84 96              STY STATUS
ef5c 60                 RTS ;Size   17 [Send_Record_No]

              ; **************
ef5d            Print_Filename
              ; **************

ef5d 20 51 f3           JSR In_Direct_Mode
ef60 d0 24              BNE PrFi_90
ef62 a0 00              LDY #0
ef64 b1 da    PrFi_10   LDA (FNADR),Y
ef66 c8                 INY
ef67 20 d2 ff           JSR CHROUT
ef6a c9 4c              CMP #'L'
ef6c d0 14              BNE PrFi_20
ef6e b1 da              LDA (FNADR),Y
ef70 c9 2c              CMP#','
ef72 d0 0e              BNE PrFi_20
ef74 20 d2 ff           JSR CHROUT
ef77 a9 24              LDA #'$'
ef79 20 d2 ff           JSR CHROUT
ef7c c8                 INY
ef7d b1 da              LDA (FNADR),Y
ef7f 4c 54 d7           JMP Print_Hex_Byte
ef82 c4 d1    PrFi_20   CPY FNLEN
ef84 90 de              BCC PrFi_10
ef86 60       PrFi_90   RTS ;Size   42 [Print_Filename]

              ; **************
ef87            Open_Read_File
              ; **************

ef87 a5 9c              LDA Source_Unit
ef89 85 d4              STA FA
ef8b a9 6d              LDA #$6d            ; channel 13
ef8d 85 d3              STA SA
ef8f a0 00              LDY #0
ef91 84 96              STY STATUS          ; clear status
ef93 ad 3b 03           LDA DOS_Drive_1     ; source drive
ef96 09 30              ORA #'0'
ef98 91 da              STA (FNADR),Y       ; into filename
ef9a a5 b9              LDA DOS_RL          ; REL file ?
ef9c f0 03              BEQ ORF_10          ; branch if not
ef9e 4c c8 e4           JMP Get_Record_Size
efa1 4c af f4 ORF_10    JMP Send_Filename

              ; ***************
efa4            Open_Write_File
              ; ***************

efa4 a5 ad              LDA Target_Unit
efa6 85 d4              STA FA
efa8 a9 6e              LDA #$6e
efaa 85 d3              STA SA
efac a0 00              LDY #0
efae 84 96              STY STATUS
efb0 ad 3c 03           LDA DOS_Drive_2
efb3 09 30              ORA #'0'
efb5 91 da              STA (FNADR),Y
efb7 4c af f4           JMP Send_Filename


efba 00 00 00           .FILL $f000 - * (0) ; 70 bytes

              ; ***************
f000            KERNAL_MESSAGES
              ; ***************

f000 54 4f 4f MSG_TOO_MANY    .BYTE "TOO MANY FILES"^
f00e 46 49 4c MSG_FILE_OPEN   .BYTE "FILE OPEN"^
f017 46 49 4c MSG_FILE_NOT_O  .BYTE "FILE NOT OPEN"^
f024 46 49 4c MSG_FILE_NOT_F  .BYTE "FILE NOT FOUND"^
f032 0d 53 45 MSG_SEARCHING   .BYTE "\rSEARCHING "^
f03d 46 4f 52 MSG_FOR         .BYTE "FOR "^
f041 0d 50 52 MSG_PRESS       .BYTE "\rPRESS PLAY "^
f04d 26 20 52 MSG_RECORD      .BYTE "& RECORD "^
f056 4f 4e 20 MSG_ON_TAPE     .BYTE "ON TAPE #"^
f05f 0d 4c 4f MSG_LOAD        .BYTE "\rLOAD"^
f064 0d 57 52 MSG_WRITING     .BYTE "\rWRITING "^
f06d 0d 56 45 MSG_VERIFY      .BYTE "\rVERIFY"^
f074 44 45 56 MSG_DEVICE_NOT  .BYTE "DEVICE NOT PRESENT"^
f086 4e 4f 54 MSG_NOT_INPUT   .BYTE "NOT INPUT FILE"^
f094 4e 4f 54 MSG_NOT_OUTPUT  .BYTE "NOT OUTPUT FILE"^
f0a3 0d 46 4f MSG_FOUND       .BYTE "\rFOUND "^
f0aa 0d 4f 4b MSG_OK          .BYTE "\rOK\r"^
f0ae 0d 52 45 MSG_READY       .BYTE "\rREADY.\r"^
f0b6 0d 41 52 MSG_SURE        .BYTE "\rARE YOU SURE ?"^
f0c5 0d 3f 20 MSG_BAD_DISK    .BYTE "\r? BAD DISK \r"^

              ; ****
f0d2            TALK
              ; ****

f0d2 a9 40              LDA #%01000000      ; TALK cmd: $40..$5e
f0d4 2c                 .BYTE $2c           ; skip next statement

              ; ******
f0d5            LISTEN
              ; ******

f0d5 a9 20              LDA #%00100000      ; LISTEN cmd: $20..$3e

              ; *******
f0d7            TALI_10
              ; *******

f0d7 48                 PHA                 ; save talk or listen bit
f0d8 ad 40 e8           LDA VIA_Port_B
f0db 09 02              ORA #%00000010      ; $02
f0dd 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f0e0 a9 3c              LDA #%00111100      ; $3c
f0e2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f0e5 24 a0              BIT C3PO            ; data in output buffer ?
f0e7 f0 11              BEQ TALI_20         ; branch if not
f0e9 a9 34              LDA #%00110100      ; $34
f0eb 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) low
f0ee 20 09 f1           JSR Send_IEEE_Byte  ; flush buffer (BSOUR)
f0f1 a9 00              LDA #0
f0f3 85 a0              STA C3PO            ; clear buffer flag
f0f5 a9 3c              LDA #%00111100      ; $3c
f0f7 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) high
f0fa 68       TALI_20   PLA                 ; restore talk or listen bit
f0fb 05 d4              ORA FA              ; combine signal with adress
f0fd 85 a5              STA BSOUR           ; store in output buffer
f0ff ad 40 e8 TALI_30   LDA VIA_Port_B      ; load signals
f102 10 fb              BPL TALI_30         ; wait until DAV high
f104 29 fb              AND #%11111011      ; $fb
f106 8d 40 e8           STA VIA_Port_B      ; set ATN (bit 2) low

              ; **************
f109            Send_IEEE_Byte
              ; **************

f109 a9 3c              LDA #%00111100      ; $3c
f10b 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f10e ad 40 e8           LDA VIA_Port_B      ; loadsignals
f111 29 41              AND #%01000001      ; mask NRFD & NDAC
f113 c9 41              CMP #%01000001      ; both high ?
f115 f0 55              BEQ Device_Not_Present
f117 a5 a5              LDA BSOUR           ; load byte to send
f119 49 ff              EOR #$ff            ; invert it
f11b 8d 22 e8           STA PIA2_Port_B     ; DATA OUT
f11e 2c 40 e8 SIB_10    BIT VIA_Port_B      ; test signals
f121 50 fb              BVC SIB_10          ; wait until NRFD high
f123 a9 34              LDA #%00110100      ; $34
f125 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) low
f128 a9 ff    SIB_20    LDA #$ff            ; set timer to MAX
f12a 8d 45 e8           STA VIA_Timer_1_Hi
f12d ad 40 e8 SIB_30    LDA VIA_Port_B      ; load signals
f130 2c 4d e8           BIT VIA_IFR         ; check timer, expect NDAC high in ca. 65 ms
f133 70 1c              BVS Time_Out_Writing
f135 4a                 LSR A               ; NDAC -> carry
f136 90 f5              BCC SIB_30          ; repeat until NDAC high
f138 a9 3c    tby6      LDA #%00111100      ; $3c
f13a 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f13d a9 ff              LDA #$ff            ; release data lines
f13f 8d 22 e8           STA PIA2_Port_B
f142 60                 RTS ;Size   58 [Send_IEEE_Byte]

              ; ******
f143            SECOND
              ; ******

f143 85 a5              STA BSOUR           ; output buffer
f145 20 09 f1           JSR Send_IEEE_Byte  ; send it

              ; *******
f148            Set_ATN
              ; *******

f148 ad 40 e8           LDA VIA_Port_B
f14b 09 04              ORA #%00000100      ; $04
f14d 8d 40 e8           STA VIA_Port_B      ; set ATN high
f150 60                 RTS ;Size    9 [Set_ATN]

              ; ****************
f151            Time_Out_Writing
              ; ****************

f151 ad fc 03           LDA Ignore_Timeout  ; load timeout flag (addr. 1020, bit 7)
f154 10 0f              BPL Timo_W          ; timeout if flag cleared (default value)
f156 20 43 f3           JSR Kernal_STOP
f159 d0 cd              BNE SIB_20          ; restart timer and try again to transmit

              ; ****************
f15b            Time_Out_Reading
              ; ****************

f15b ad fc 03           LDA Ignore_Timeout
f15e 10 10              BPL Timo_R
f160 20 43 f3           JSR Kernal_STOP
f163 d0 68              BNE Acptr_10
f165 a9 01    Timo_W    LDA #1              ; flag time out on writing
f167 20 c4 fb Timo_S    JSR Set_STATUS
f16a d0 cc              BNE tby6            ; branch always

              ; ******************
f16c            Device_Not_Present
              ; ******************

f16c a9 80              LDA #$80
f16e 30 f7              BMI Timo_S
f170 a9 02    Timo_R    LDA #2              ; flag time out reading
f172 20 c4 fb           JSR Set_STATUS

              ; *****************
f175            Set_NRFD_NDAC_low
              ; *****************

f175 ad 40 e8           LDA VIA_Port_B
f178 29 fd              AND #%11111101      ; $fd
f17a 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f17d a9 34              LDA #%00110100      ; $34
f17f 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f182 a9 0d              LDA #CR             ; load CR
f184 60                 RTS ;Size   16 [Set_NRFD_NDAC_low]

              ; **********************
f185            Display_Kernal_Message
              ; **********************

f185 b9 00 f0           LDA KERNAL_MESSAGES,Y  ; Y = offset for string
f188 08                 PHP                 ; save status (possible end marker)
f189 29 7f              AND #$7f            ; clear bit 7
f18b 20 02 e2           JSR EDIT_CHROUT     ; dispay it
f18e c8                 INY                 ; next character
f18f 28                 PLP                 ; restore status
f190 10 f3              BPL Display_Kernal_Message
f192 60                 RTS                 ; bit 7 = end marker ;Size   14 [Display_Kernal_Message]

              ; ****
f193            TKSA
              ; ****

f193 85 a5              STA BSOUR           ; SA (A) to Buffer
f195 20 09 f1           JSR Send_IEEE_Byte  ; send it
f198 20 75 f1           JSR Set_NRFD_NDAC_low
f19b 4c 48 f1           JMP Set_ATN

              ; *****
f19e            CIOUT
              ; *****

f19e 24 a0              BIT C3PO            ; C3PO = 0 flags empty buffer
f1a0 30 04              BMI Ciout_10        ; branch if not empty
f1a2 c6 a0              DEC C3PO            ; set flag for not empty
f1a4 d0 05              BNE Ciout_20        ; branch always
f1a6 48       Ciout_10  PHA                 ; save current byte
f1a7 20 09 f1           JSR Send_IEEE_Byte  ; send byte from buffer
f1aa 68                 PLA                 ; restore current byte
f1ab 85 a5    Ciout_20  STA BSOUR           ; put it into buffer
f1ad 60                 RTS ;Size   16 [CIOUT]

              ; *****
f1ae            UNTLK
              ; *****

f1ae ad 40 e8           LDA VIA_Port_B
f1b1 29 fb              AND #%11111011      ; $fb
f1b3 8d 40 e8           STA VIA_Port_B      ; set ATN low
f1b6 a9 5f              LDA #%01011111      ; $5f
f1b8 2c                 .BYTE $2c           ; skip next statement

              ; *****
f1b9            UNLSN
              ; *****

f1b9 a9 3f              LDA #%00111111      ; $3f
f1bb 20 d7 f0           JSR TALI_10
f1be d0 88              BNE Set_ATN         ; branch always

              ; *****
f1c0            ACPTR
              ; *****

f1c0 a9 34              LDA #%00110100      ; $34
f1c2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f1c5 ad 40 e8           LDA VIA_Port_B
f1c8 09 02              ORA #%00000010      ; $02
f1ca 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f1cd a9 ff    Acptr_10  LDA #$ff
f1cf 8d 45 e8           STA VIA_Timer_1_Hi  ; set timer
f1d2 2c 4d e8 Acptr_20  BIT VIA_IFR
f1d5 70 84              BVS Time_Out_Reading; timeout after 65 ms
f1d7 2c 40 e8           BIT VIA_Port_B      ; test DAV (bit 7)
f1da 30 f6              BMI Acptr_20        ; loop until DAV (bit 7) low
f1dc ad 40 e8           LDA VIA_Port_B
f1df 29 fd              AND #%11111101      ; $fd
f1e1 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f1e4 2c 10 e8           BIT PIA1_Port_A     ; test for EOI
f1e7 70 05              BVS Acptr_30        ; branch if not
f1e9 a9 40              LDA #%01000000      ; set EOI flag
f1eb 20 c4 fb           JSR Set_STATUS
f1ee ad 20 e8 Acptr_30  LDA PIA2_Port_A     ; read data byte
f1f1 49 ff              EOR #$ff            ; invert it
f1f3 48                 PHA                 ; save read byte
f1f4 a9 3c              LDA #%00111100      ; $3c
f1f6 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f1f9 2c 40 e8 Acptr_40  BIT VIA_Port_B      ; test DAV
f1fc 10 fb              BPL Acptr_40        ; loop until DAV (bit 7) high
f1fe a9 34              LDA #%00110100      ; $34
f200 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f203 68                 PLA                 ; restore read byte
f204 60                 RTS ;Size   69 [ACPTR]

              ; ************
f205            Kernal_GETIN
              ; ************

f205 a9 00              LDA #0
f207 85 96              STA STATUS          ; clear status
f209 a5 af              LDA DFLTN           ; current input device
f20b d0 17              BNE KeIn_10         ; branch if not keyboard
f20d a5 9e    GETIN_10  LDA CharsInBuffer   ; test keyboard queue
f20f f0 26              BEQ KeIn_30         ; return if empty
f211 78                 SEI                 ; disable interrupt
f212 4c a7 e0           JMP EDIT_GETIN      ; get character from keyboard queue

              ; ************
f215            Kernal_CHRIN
              ; ************

f215 a5 af              LDA DFLTN           ; current input device
f217 d0 0b              BNE KeIn_10         ; branch if not keyboard
f219 a5 c6              LDA CursorCol       ; get current cursor column
f21b 85 a4              STA InputCol        ; start input here
f21d a5 d8              LDA CursorRow       ; get current cursor row
f21f 85 a3              STA InputRow        ; start input here
f221 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f224 c9 04    KeIn_10   CMP #4              ; test device number
f226 b0 09              BCS KeIn_20         ; branch if IEEE-488 device
f228 85 ac              STA CRSW            ; device is screen (3)
f22a a5 d5              LDA RigMargin       ; limit input column
f22c 85 a1              STA LastInputCol    ; at right margin
f22e 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f231 a5 96    KeIn_20   LDA STATUS          ; It's IEEE-488 input
f233 f0 03              BEQ KeIn_40         ; continue at ACPTR if status is OK
f235 a9 0d              LDA #CR             ; status flags some error, return CR
f237 60       KeIn_30   RTS                 ; return ;Size   35 [Kernal_CHRIN]
f238 4c c0 f1 KeIn_40   JMP ACPTR           ; continue at ACPTR

f23b 00 00 00           .FILL $f266 - * (0) ; 43 bytes

              ; *************
f266            Kernal_CHROUT
              ; *************

f266 48                 PHA                 ; save character
f267 a5 b0              LDA DFLTO           ; load current output device
f269 c9 04              CMP #4              ; 4 = start of IEEE-488 devices
f26b 68                 PLA                 ; restore character
f26c b0 03              BCS KeCH_10         ; branch if IEEE-488 device
f26e 4c 02 e2           JMP EDIT_CHROUT     ; continue at display on screen
f271 4c 9e f1 KeCH_10   JMP CIOUT           ; continue on IEEE-488 output

f274 00 00 00           .FILL $f2a2 - * (0) ; 46 bytes

              ; ************
f2a2            Kernal_CLALL
              ; ************

f2a2 a9 00              LDA #0
f2a4 85 ae              STA LDTND           ; set # of open files to zero

              ; *************
f2a6            Kernal_CLRCHN
              ; *************

f2a6 a5 b0              LDA DFLTO           ; default output device
f2a8 c9 04              CMP #4              ; screen or IEEE-488 ?
f2aa 90 03              BCC KeCL_10         ; branch if screen
f2ac 20 b9 f1           JSR UNLSN           ; send unlisten
f2af a5 af    KeCL_10   LDA DFLTN           ; default input device
f2b1 c9 04              CMP #4              ; IEEE-488 or not ?
f2b3 90 03              BCC Set_Default_IO
f2b5 20 ae f1           JSR UNTLK           ; send untalk

              ; **************
f2b8            Set_Default_IO
              ; **************

f2b8 a9 03              LDA #3
f2ba 85 b0              STA DFLTO
f2bc a9 00              LDA #0
f2be 85 af              STA DFLTN
f2c0 60                 RTS ;Size    9 [Set_Default_IO]

              ; *********
f2c1            LOOKUP_LA
              ; *********

f2c1 a6 ae              LDX LDTND           ; # of open files
f2c3 ca       LOOK_10   DEX
f2c4 30 05              BMI LOOK_Ret        ; -> not found
f2c6 dd 51 02           CMP LAT,X
f2c9 d0 f8              BNE LOOK_10
f2cb 60       LOOK_Ret  RTS ;Size   11 [LOOKUP_LA]

f2cc 00                 .FILL $f2cd-* (0) ; 1 bytes

              ; **********************
f2cd            Set_LFS_From_X ; $f2cd
              ; **********************

              ; Input:  X = index to file
              ; Output: A = FA

f2cd bd 51 02           LDA LAT,X
f2d0 85 d2              STA LA
f2d2 bd 65 02           LDA SAT,X
f2d5 85 d3              STA SA
f2d7 bd 5b 02           LDA FAT,X
f2da 85 d4              STA FA
f2dc 60                 RTS ;Size   16 [Set_LFS_From_X]

              ; ************
f2dd            Kernal_CLOSE
              ; ************

f2dd 20 0d f5           JSR Get_Open_Close_Parameter
f2e0 a5 d2              LDA LA

              ; *************
f2e2            Close_LA_in_A
              ; *************

f2e2 20 c1 f2           JSR LOOKUP_LA
f2e5 d0 24              BNE ClFi_20

              ; ************
f2e7            Close_File_A
              ; ************

f2e7 20 cd f2           JSR Set_LFS_From_X
f2ea c9 04              CMP #4
f2ec 90 03              BCC ClFi_10         ; keyboard or screen
f2ee 20 2a f7           JSR Close_Disk_File
f2f1 c6 ae    ClFi_10   DEC LDTND
f2f3 e4 ae              CPX LDTND
f2f5 f0 14              BEQ ClFi_20
f2f7 a4 ae              LDY LDTND
f2f9 b9 51 02           LDA LAT,Y
f2fc 9d 51 02           STA LAT,X
f2ff b9 5b 02           LDA FAT,Y
f302 9d 5b 02           STA FAT,X
f305 b9 65 02           LDA SAT,Y
f308 9d 65 02           STA SAT,X
f30b 60       ClFi_20   RTS ;Size   37 [Close_File_A]

f30c 00 00 00           .FILL $f335 - * (0) ; 41 bytes

              ; **************
f335            Check_STOP_Key
              ; **************

f335 a5 9b              LDA Stop_Flag
f337 c9 ef              CMP #$ef
f339 d0 07              BNE ChST_Ret
f33b 08                 PHP
f33c 20 a6 f2           JSR Kernal_CLRCHN
f33f 85 9e              STA CharsInBuffer
f341 28                 PLP
f342 60       ChST_Ret  RTS ;Size   14 [Check_STOP_Key]

              ; ***********
f343            Kernal_STOP
              ; ***********

f343 20 35 f3           JSR Check_STOP_Key
f346 4c c6 b7           JMP Basic_STOP

              ; ************************
f349            Kernal_Message_If_Direct
              ; ************************

f349 20 51 f3           JSR In_Direct_Mode
f34c d0 f4              BNE ChST_Ret
f34e 4c 85 f1           JMP Display_Kernal_Message

              ; **************
f351            In_Direct_Mode
              ; **************

f351 a5 78              LDA TXTPTR+1
f353 c9 02              CMP #2
f355 60                 RTS ;Size    5 [In_Direct_Mode]

              ; *********
f356            Load_File
              ; *********

f356 a5 d4              LDA FA              ; primary device address
f358 c9 04              CMP #4              ; start of IEEE-488 devices
f35a b0 03              BCS LoFi_15
f35c 4c 00 bf LoFi_10   JMP Syntax_Error    ; no loading from devices 0-3
f35f a4 d1    LoFi_15   LDY FNLEN
f361 f0 f9              BEQ LoFi_10         ; error for zero length filenames
f363 a6 d3              LDX SA              ; 1: use load address from file
f365 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
f368 e0 00              CPX #0              ; ignore load address ?
f36a f0 04              BEQ LoFi_20
f36c 84 c9              STY EAL
f36e 85 ca              STA EAL+1
f370 a5 96    LoFi_20   LDA STATUS          ; check time out bit
f372 f0 03              BEQ LoFi_25         ; no time out -> continue
f374 4c ad f5           JMP Display_File_Not_Found
f377 20 51 f3 LoFi_25   JSR In_Direct_Mode
f37a d0 12              BNE LoFi_30
f37c 20 6d f4           JSR Display_Load_Or_Verify
f37f a5 ca              LDA EAL+1
f381 20 54 d7           JSR Print_Hex_Byte
f384 a5 c9              LDA EAL
f386 20 54 d7           JSR Print_Hex_Byte
f389 a9 2d              LDA #'-'
f38b 20 02 e2           JSR EDIT_CHROUT
f38e a0 00    LoFi_30   LDY #0              ; remains zero for loop
f390 84 96    LoFi_35   STY STATUS          ; clear status bits
f392 20 43 f3 LoFi_40   JSR Kernal_STOP     ; STOP key pressed?
f395 20 c0 f1           JSR ACPTR           ; read next byte
f398 24 9d              BIT VERCK           ; load (0) or verify ($80)
f39a 10 0b              BPL LoFi_45         ; branch if loading
f39c d1 c9              CMP (EAL),Y         ; verify
f39e f0 0f              BEQ LoFi_55         ; branch if OK
f3a0 a9 10              LDA #%00010000      ; flag verify error $10
f3a2 20 c4 fb           JSR Set_STATUS      ; and stop verifying
f3a5 d0 1a              BNE LoFi_70         ; branch always
f3a7 91 c9    LoFi_45   STA (EAL),Y         ; store byte
f3a9 b1 c9    LoFi_50   LDA (EAL),Y         ; this comparison is false for an
f3ab d1 c9              CMP (EAL),Y         ; unfinished write cycle to EEPROM
f3ad d0 fa              BNE LoFi_50         ; repeat until EEPROM bit toggle ceased
f3af e6 c9    LoFi_55   INC EAL             ; increment write address
f3b1 d0 0a              BNE LoFi_60
f3b3 e6 ca              INC EAL+1
f3b5 20 51 f3           JSR In_Direct_Mode
f3b8 d0 03              BNE LoFi_60
f3ba 20 40 f4           JSR Print_EAL
f3bd 24 96    LoFi_60   BIT STATUS          ; Get EOF marker in bit 6
f3bf 50 d1              BVC LoFi_40         ; repeat until EOF
f3c1 20 ae f1 LoFi_70   JSR UNTLK
f3c4 20 2a f7           JSR Close_Disk_File
f3c7 20 51 f3           JSR In_Direct_Mode
f3ca f0 01              BEQ LoFi_80
f3cc 60                 RTS ;Size  119 [Load_File]
f3cd 4c 40 f4 LoFi_80   JMP Print_EAL

              ; **************
f3d0            Open_Load_File
              ; **************

f3d0 a9 60              LDA #$60            ; secondary address for loading
f3d2 85 d3              STA SA
f3d4 20 af f4           JSR Send_Filename
f3d7 20 d2 f0           JSR TALK            ; send primary address
f3da a5 d3              LDA SA
f3dc 20 93 f1           JSR TKSA            ; send secondary address
f3df 20 c0 f1           JSR ACPTR           ; load address low
f3e2 a8                 TAY                 ; Y = load address low
f3e3 4c c0 f1           JMP ACPTR           ; A = load address high

              ; *****
f3e6            Merge
              ; *****

f3e6 a9 40              LDA #$40            ; load and merge file
f3e8 d0 19              BNE KeLO_10         ; always

f3ea 00 00 00           .FILL $f401 - * (0) ; 23 bytes

              ; ***********
f401            Kernal_LOAD
              ; ***********

f401 a9 00              LDA #0
f403 85 9d    KeLO_10   STA VERCK

              ; ***********
f405            Load_Verify
              ; ***********

f405 20 7d f4           JSR Get_File_Parameter
f408 24 9d              BIT VERCK
f40a 50 11              BVC Load_Verify_Params_Set
f40c 38                 SEC
f40d a5 2a              LDA VARTAB          ; set merge address
f40f e9 02              SBC #2
f411 85 c9              STA EAL
f413 a5 2b              LDA VARTAB+1
f415 e9 00              SBC #0
f417 85 ca              STA EAL+1
f419 a9 00              LDA #0
f41b 85 d3              STA SA

              ; **********************
f41d            Load_Verify_Params_Set
              ; **********************

f41d 20 56 f3           JSR Load_File       ; load file into RAM
f420 24 9d              BIT VERCK           ; (0) LOAD, ($80) VERIFY
f422 30 1b              BMI LVPS_Ret        ; done for verify
f424 a0 ae              LDY #<MSG_READY     ; $ae
f426 20 49 f3           JSR Kernal_Message_If_Direct
f429 20 51 f3           JSR In_Direct_Mode
f42c d0 0b              BNE LVPS_20
f42e a5 ca              LDA EAL+1
f430 85 2b              STA VARTAB+1        ; update VARPTR
f432 a5 c9              LDA EAL
f434 85 2a              STA VARTAB
f436 4c ad b4           JMP Reset_And_Rechain
f439 20 22 b6 LVPS_20   JSR Reset_BASIC_Exec_Pointer
f43c 4c 0b b6           JMP RVP_10
f43f 60       LVPS_Ret  RTS ;Size   35 [Load_Verify_Params_Set]

              ; *********
f440            Print_EAL
              ; *********

f440 a5 ca              LDA EAL+1
f442 20 54 d7           JSR Print_Hex_Byte
f445 a5 c9              LDA EAL
f447 20 54 d7           JSR Print_Hex_Byte
f44a a2 04              LDX #4
f44c a9 9d              LDA #$9d            ; cursor left
f44e 20 02 e2 PrEA_10   JSR EDIT_CHROUT
f451 ca                 DEX
f452 d0 fa              BNE PrEA_10
f454 60       PrEA_Ret  RTS ;Size   21 [Print_EAL]

f455 00 00 00           .FILL $f46d - * (0) ; 24 bytes

              ; **********************
f46d            Display_Load_Or_Verify
              ; **********************

f46d a0 5f              LDY #<MSG_LOAD      ; $5f
f46f 24 9d              BIT VERCK
f471 10 02              BPL DLOV_10
f473 a0 6d              LDY #<MSG_VERIFY    ; $6d
f475 20 49 f3 DLOV_10   JSR Kernal_Message_If_Direct
f478 a0 39              LDY #<[MSG_SEARCHING + 7];$39 add "ING"
f47a 4c 49 f3           JMP Kernal_Message_If_Direct

              ; ******************
f47d            Get_File_Parameter
              ; ******************

f47d a2 00              LDX #0
f47f 86 96              STX STATUS
f481 86 d1              STX FNLEN
f483 e8                 INX
f484 86 d3              STX SA              ; SA = 1
f486 a2 08              LDX #8
f488 86 d4              STX FA              ; FA = 8
f48a 20 4d f5           JSR ChrGot_Or_RTS
f48d 20 3c f5           JSR Set_Filename_From_String
f490 20 4d f5           JSR ChrGot_Or_RTS
f493 20 a9 f4           JSR Get_Comma_And_Byte
f496 86 d4              STX FA
f498 20 4d f5           JSR ChrGot_Or_RTS
f49b 20 a9 f4           JSR Get_Comma_And_Byte
f49e 86 d3              STX SA
f4a0 a6 28              LDX TXTTAB          ; default: start of BASIC
f4a2 a5 29              LDA TXTTAB+1
f4a4 86 c9              STX EAL
f4a6 85 ca              STA EAL+1
f4a8 60       GFP_Ret   RTS ;Size   44 [Get_File_Parameter]

              ; ******************
f4a9            Get_Comma_And_Byte
              ; ******************

f4a9 20 55 f5           JSR Get_Comma_And_Chr
f4ac 4c d4 c8           JMP Get_Byte_Value

              ; *************
f4af            Send_Filename
              ; *************

f4af a4 d1              LDY FNLEN
f4b1 f0 f5              BEQ GFP_Ret
f4b3 20 d5 f0           JSR LISTEN
f4b6 a5 d3              LDA SA
f4b8 09 f0              ORA #$f0

              ; ****************
f4ba            Send_DOS_Command
              ; ****************

f4ba 20 43 f1           JSR SECOND
f4bd a5 96              LDA STATUS
f4bf 10 05              BPL SeDC_10
f4c1 a0 74              LDY #<MSG_DEVICE_NOT; $74
f4c3 4c af f5           JMP Handle_IO_Error
f4c6 a0 00    SeDC_10   LDY #0
f4c8 b1 da    SeDC_20   LDA (FNADR),Y
f4ca 20 9e f1           JSR CIOUT
f4cd c8                 INY
f4ce c4 d1              CPY FNLEN
f4d0 d0 f6              BNE SeDC_20
f4d2 4c b9 f1           JMP UNLSN

f4d5 00 00 00           .FILL $f4f6 - * (0) ; 33 bytes

              ; *************
f4f6            Kernal_VERIFY
              ; *************

f4f6 a9 80              LDA #$80
f4f8 85 9d              STA VERCK
f4fa 20 05 f4           JSR Load_Verify
f4fd a5 96              LDA STATUS
f4ff 29 10              AND #16
f501 f0 05              BEQ VERI_OK
f503 a0 6e              LDY #<[MSG_VERIFY+1]; $6e
f505 4c af f5           JMP Handle_IO_Error
f508 a0 aa    VERI_OK   LDY #<MSG_OK        ; $aa
f50a 4c 85 f1           JMP Display_Kernal_Message

              ; ************************
f50d            Get_Open_Close_Parameter
              ; ************************

f50d a2 00              LDX #0              ; clear
f50f 86 d3              STX SA              ; secondary address
f511 86 96              STX STATUS          ; status
f513 86 d1              STX FNLEN           ; length of filename
f515 20 4c fd           JSR Set_FA_to_8     ; default device 8
f518 20 58 f5           JSR Assert_Not_At_End
f51b 20 d4 c8           JSR Get_Byte_Value
f51e 86 d2              STX LA              ; store logical address
f520 20 4d f5           JSR ChrGot_Or_RTS
f523 20 a9 f4           JSR Get_Comma_And_Byte
f526 86 d4              STX FA              ; store primary address
f528 20 4d f5           JSR ChrGot_Or_RTS
f52b 20 a9 f4           JSR Get_Comma_And_Byte
f52e 86 d3              STX SA              ; store secondary address
f530 20 4d f5           JSR ChrGot_Or_RTS
f533 20 55 f5           JSR Get_Comma_And_Chr
f536 4c 3c f5           JMP Set_Filename_From_String

f539 00 00 00           .FILL $f53c - * (0) ; 3 bytes

              ; ************************
f53c            Set_Filename_From_String
              ; ************************

f53c 20 98 bd           JSR Eval_Expression
f53f 20 b5 c7           JSR Eval_And_Free_String
f542 85 d1              STA FNLEN
f544 a5 1f              LDA INDEXA
f546 85 da              STA FNADR
f548 a5 20              LDA INDEXA+1
f54a 85 db              STA FNADR+1
f54c 60                 RTS ;Size   17 [Set_Filename_From_String]

              ; *************
f54d            ChrGot_Or_RTS
              ; *************

f54d 20 76 00           JSR CHRGOT
f550 d0 02              BNE Get_Ret
f552 68                 PLA
f553 68                 PLA
f554 60       Get_Ret   RTS ;Size    8 [ChrGot_Or_RTS]

              ; *****************
f555            Get_Comma_And_Chr
              ; *****************

f555 20 f5 be           JSR Need_Comma

              ; *****************
f558            Assert_Not_At_End
              ; *****************

f558 20 76 00           JSR CHRGOT
f55b d0 f7              BNE Get_Ret
f55d 4c 00 bf Err_f55d  JMP Syntax_Error

              ; ***********
f560            Kernal_OPEN
              ; ***********

f560 20 0d f5           JSR Get_Open_Close_Parameter
f563 a5 d2    Mf563     LDA LA

              ; *********
f565            Open_File
              ; *********

f565 f0 f6              BEQ Err_f55d
f567 a0 0e              LDY #<MSG_FILE_OPEN
f569 20 c1 f2           JSR LOOKUP_LA
f56c f0 41              BEQ Handle_IO_Error
f56e a6 ae              LDX LDTND
f570 a0 00              LDY #0              ; also MSG # for TOO MANY FILES
f572 84 96              STY STATUS
f574 e0 0a              CPX #10
f576 f0 37              BEQ Handle_IO_Error
f578 e6 ae              INC LDTND
f57a a5 d2              LDA LA
f57c 9d 51 02           STA LAT,X
f57f a5 d3              LDA SA
f581 09 60              ORA #$60
f583 85 d3              STA SA
f585 9d 65 02           STA SAT,X
f588 a5 d4              LDA FA
f58a 9d 5b 02           STA FAT,X
f58d f0 c5              BEQ Get_Ret         ; open keyboard
f58f c9 03              CMP #3
f591 f0 c1              BEQ Get_Ret         ; open screen
f593 90 c8              BCC Err_f55d        ; no tape support
f595 4c af f4           JMP Send_Filename

f598 00 00 00           .FILL $f5ad - * (0) ; 21 bytes


              ; **********************
f5ad            Display_File_Not_Found
              ; **********************

f5ad a0 24              LDY #<MSG_FILE_NOT_F; $24

              ; ***************
f5af            Handle_IO_Error
              ; ***************

f5af 20 a2 f2           JSR Kernal_CLALL
f5b2 a9 0d              LDA #CR
f5b4 20 66 f2           JSR Kernal_CHROUT
f5b7 a9 3f              LDA #$3f            ; '?'
f5b9 20 66 f2           JSR Kernal_CHROUT
f5bc 20 85 f1           JSR Display_Kernal_Message
f5bf 4c ed b3           JMP Berr_30

              ; ***********
f5c2            Disassemble
              ; ***********

f5c2 20 18 d6           JSR Mon_Get_Addr
f5c5 20 35 f3 Disa_10   JSR Check_STOP_Key  ; STOP key pressed?
f5c8 f0 19              BEQ Disa_Main
f5ca 20 e0 d5           JSR Mon_Cmp_Addr
f5cd 90 14              BCC Disa_Main       ; STAL > MEMUSS ?
f5cf a9 2e    Disa_15   LDA #'.'
f5d1 20 74 d5           JSR Mon_Prompt
f5d4 20 1b d5           JSR Mon_Print_Blank
f5d7 20 14 f6           JSR Dis_Inst        ; Disassemble
f5da 20 e6 f5           JSR Print_Dis_Line
f5dd a5 b3              LDA PC_Adjust
f5df d0 e4              BNE Disa_10
f5e1 e6 b3              INC PC_Adjust
f5e3 4c ae d4 Disa_Main JMP Mon_Main

              ; **************
f5e6            Print_Dis_Line
              ; **************

f5e6 48                 PHA                 ; save mne index
f5e7 a0 00              LDY #0
f5e9 b9 c1 00 Disa_20   LDA Mon_Op,Y        ; next byte
f5ec 20 54 d7           JSR Print_Hex_Byte
f5ef 4c f8 f5           JMP Disa_50
f5f2 20 1b d5 Disa_40   JSR Mon_Print_Blank
f5f5 20 1b d5           JSR Mon_Print_Blank
f5f8 20 1b d5 Disa_50   JSR Mon_Print_Blank
f5fb c4 be              CPY Dis_Length
f5fd c8                 INY
f5fe 90 e9              BCC Disa_20         ; next byte
f600 c0 03              CPY #3
f602 90 ee              BCC Disa_40         ; blanks
f604 68                 PLA                 ; restore mne index
f605 20 39 f7           JSR Store_Mnemonic
f608 20 8d f9           JSR Store_Address
f60b 20 f9 f9           JSR Print_Dis_Buf
f60e 38                 SEC
f60f a5 be              LDA Dis_Length      ; carry is set
f611 4c 1c fb           JMP AdST_00



              ; ********
f614            Dis_Inst
              ; ********

f614 20 4d d7           JSR Mon_Print_STAL
f617 20 1b d5           JSR Mon_Print_Blank
f61a a0 02              LDY #2              ; fetch 3 bytes
f61c 20 7a 02 DiIn_10   JSR Bank_Fetch
f61f 99 c1 00           STA Mon_Op,Y
f622 88                 DEY
f623 10 f7              BPL DiIn_10         ; opcode in A

              ; **************
f625            Analyze_Opcode
              ; **************

              ; instruction pattern: aaa bbb cc
              ; aaa = instruction
              ; bbb = addressing mode
              ; cc  = group

              ; 1. analyze group cc
              ; ------------------------------------------
              ; cc = 00  one byte instructions, branches
              ; cc = 01  ORA,AND,EOR,ADC,STA,LDA,CMP,SBC
              ; cc = 10  ASL,ROL,LSR,ROR,STX,LDX,DEC,INC
              ; cc = 11  illegal opcodes

f625 a8                 TAY                 ; save opcode
f626 4a                 LSR A               ; bit 0 -> carry
f627 90 0b              BCC AnOp_10
f629 4a                 LSR A               ; bit 1 -> carry
f62a b0 17              BCS AnOp_30         ; 11 -> no valid opcode
f62c c9 22              CMP #$22            ; invalid opcode $89 ?
f62e f0 13              BEQ AnOp_30
f630 29 07              AND #7              ; mask addressing mode bbb
f632 09 80              ORA #$80            ; set bit 7
f634 4a       AnOp_10   LSR A               ; A,X = aaa bbb (cc = x0)
f635 aa                 TAX                 ; A,X = aaa bb  (cc = 10)
f636 bd 6b f6           LDA admode_index,X  ; get addressing mode index
f639 b0 04              BCS AnOp_20         ; branch on cc = 10
f63b 4a                 LSR A               ; move nibble for cc = 00
f63c 4a                 LSR A
f63d 4a                 LSR A
f63e 4a                 LSR A
f63f 29 0f    AnOp_20   AND #15             ; mask addressing mode index
f641 d0 04              BNE AnOp_40         ; branch for valid mode
f643 a0 80    AnOp_30   LDY #$80            ; set invalid opcode
f645 a9 00              LDA #0
f647 aa       AnOp_40   TAX                 ; X = addressing mode index
f648 bd 73 f9           LDA admode_format,X ; A = addressing mode format
f64b 85 bd              STA Mon_Format      ; format
f64d 29 03              AND #3
f64f 85 be              STA Dis_Length      ; length
f651 98                 TYA                 ; restore opcode
f652 29 8f              AND #$8f            ; mask
f654 aa                 TAX                 ; X =
f655 98                 TYA                 ; restore opcode
f656 a0 03              LDY #3              ; Y = 3
f658 e0 8a              CPX #$8a            ; TXS,TAX,TSX,DEX,NOP
f65a f0 0b              BEQ AnOp_70
f65c 4a       AnOp_50   LSR A
f65d 90 08              BCC AnOp_70
f65f 4a                 LSR A
f660 4a       AnOp_60   LSR A
f661 09 20              ORA #$20
f663 88                 DEY
f664 d0 fa              BNE AnOp_60
f666 c8                 INY
f667 88       AnOp_70   DEY
f668 d0 f2              BNE AnOp_50
f66a 60                 RTS ;Size   70 [Analyze_Opcode]

              ; ************
f66b            admode_index
              ; ************

f66b 40                 .BYTE $40           ; $4 BRK        $0 ---
f66c 02                 .BYTE $02           ; $0 ---        $2 ASL zz
f66d 45                 .BYTE $45           ; $4 PHP        $5 ASL A
f66e 03                 .BYTE $03           ; $0 ---        $3 ASL nnnn

f66f d0                 .BYTE $d0           ; $d BPL oo     $0 ---
f670 08                 .BYTE $08           ; $0 ---        $8 ASL zz,X
f671 40                 .BYTE $40           ; $4 CLC        $0 ---
f672 09                 .BYTE $09           ; $0 ---        $9 ASL nnnn,X

f673 30                 .BYTE $30           ; $3 JSR nnnn   $0 --
f674 22                 .BYTE $22           ; $2 BIT zz     $2 ROL zz
f675 45                 .BYTE $45           ; $4 PLP        $5 ROL A
f676 33                 .BYTE $33           ; $3 BIT nnnn   $3 ROL nnnn

f677 d0                 .BYTE $d0           ; $d BMI oo     $0 ---
f678 08                 .BYTE $08           ; $0 ---        $8 ROL zz,X
f679 40                 .BYTE $40           ; $4 SEC        $0 ---
f67a 09                 .BYTE $09           ; $0 ---        $9 ROL nnnn,X

f67b 40                 .BYTE $40           ; $4 RTI        $0 ---
f67c 02                 .BYTE $02           ; $0 ---        $2 LSR zz
f67d 45                 .BYTE $45           ; $4 PHA        $5 LSR A
f67e 33                 .BYTE $33           ; $3 JMP nnnn   $3 LSR nnnn

f67f d0                 .BYTE $d0           ; $d BVC oo     $0 ---
f680 08                 .BYTE $08           ; $0 ---        $8 LSR zz,X
f681 40                 .BYTE $40           ; $4 CLI        $0 ---
f682 09                 .BYTE $09           ; $0 ---        $9 LSR nnnn,X

f683 40                 .BYTE $40           ; $4 RTS        $0 ---
f684 02                 .BYTE $02           ; $0 ---        $2 ROR zz
f685 45                 .BYTE $45           ; $4 PLA        $5 ROR A
f686 b3                 .BYTE $b3           ; $b JMP (nnnn) $3 ROR nnnn

f687 d0                 .BYTE $d0           ; $d BVS oo     $0 ---
f688 08                 .BYTE $08           ; $0 ---        $8 ROR zz,X
f689 40                 .BYTE $40           ; $4 SEI        $0 ---
f68a 09                 .BYTE $09           ; $0 ---        $9 ROR nnnn,X

f68b 00                 .BYTE $00           ; $0 ---        $0 ---
f68c 22                 .BYTE $22           ; $2 STY zz     $2 STX zz
f68d 44                 .BYTE $44           ; $4 DEY        $4 TXA
f68e 33                 .BYTE $33           ; $3 STY nnnn   $3 STX nnnn

f68f d0                 .BYTE $d0           ; $d BCC oo     $0 ---
f690 8c                 .BYTE $8c           ; $8 STY zz,X   $c STX zz,Y
f691 44                 .BYTE $44           ; $4 TYA        $4 TXS
f692 00                 .BYTE $00           ; $0 ---        $0 ---

f693 11                 .BYTE $11           ; $1 LDY #      $1 LDX #
f694 22                 .BYTE $22           ; $2 LDY zz     $2 LDX zz
f695 44                 .BYTE $44           ; $4 TAY        $4 TAX
f696 33                 .BYTE $33           ; $3 LDY nnnn   $3 LDX nnnn

f697 d0                 .BYTE $d0           ; $d BCS oo     $0 ---
f698 8c                 .BYTE $8c           ; $8 LDY zz,X   $c LDX zz,Y
f699 44                 .BYTE $44           ; $4 CLV        $4 TSX
f69a 9a                 .BYTE $9a           ; $9 LDY nnnn,X $a LDX nnnn,Y

f69b 10                 .BYTE $10           ; $1 CPY #      $0 ---
f69c 22                 .BYTE $22           ; $2 CPY zz     $2 DEC zz
f69d 44                 .BYTE $44           ; $4 INY        $4 DEX
f69e 33                 .BYTE $33           ; $3 CPY nnnn   $3 DEC nnnn

f69f d0                 .BYTE $d0           ; $d BNE oo     $0 ---
f6a0 08                 .BYTE $08           ; $0 ---        $8 DEC zz,X
f6a1 40                 .BYTE $40           ; $4 CLD        $0 ---
f6a2 09                 .BYTE $09           ; $0 ---        $9 DEC nnnn,X

f6a3 10                 .BYTE $10           ; $1 CPX #      $0 ---
f6a4 22                 .BYTE $22           ; $2 CPX zz     $2 INC zz
f6a5 44                 .BYTE $44           ; $4 INX        $4 NOP
f6a6 33                 .BYTE $33           ; $3 CPX nnnn   $3 INC nnnn

f6a7 d0                 .BYTE $d0           ; $d BEQ oo     $0 ---
f6a8 08                 .BYTE $08           ; $0 ---        $8 INC zz,X
f6a9 40                 .BYTE $40           ; $4 SED        $0 ---
f6aa 09                 .BYTE $09           ; $0 ---        $9 INC nnnn,X

f6ab 62                 .BYTE $62           ; $6 (zz,X)     $2 zz
f6ac 13                 .BYTE $13           ; $1 #          $3 nnnn
f6ad 78                 .BYTE $78           ; $7 (zz),Y     $8 zz,X
f6ae a9                 .BYTE $a9           ; $a nnnn,Y     $9 nnnn,X

f6af 00 00 00            .FILL $f6c3 - * (0) ; 20 bytes


              ; **********
f6c3            Kernal_SYS
              ; **********

f6c3 20 84 bd           JSR Eval_Numeric
f6c6 20 2d c9           JSR FAC1_To_LINNUM
f6c9 6c 11 00           JMP (LINNUM)

              ; **************
f6cc            Set_Save_Range
              ; **************

f6cc a5 2a              LDA VARTAB
f6ce 85 c9              STA EAL
f6d0 a5 2b              LDA VARTAB+1
f6d2 85 ca              STA EAL+1
f6d4 a5 29              LDA TXTTAB+1
f6d6 85 fc              STA STAL+1
f6d8 a5 28              LDA TXTTAB
f6da 85 fb              STA STAL
f6dc 60                 RTS ;Size   17 [Set_Save_Range]

              ; ***********
f6dd            Kernal_SAVE
              ; ***********

f6dd 20 7d f4           JSR Get_File_Parameter
f6e0 20 cc f6 Mf6e0     JSR Set_Save_Range

              ; *********
f6e3            Save_File
              ; *********

f6e3 a5 d4              LDA FA              ; primary address
f6e5 c9 04              CMP #4              ; unit number >= 4
f6e7 b0 03              BCS SaFi_20         ; branch if OK
f6e9 4c 00 bf SaFi_10   JMP Syntax_Error    ; wrong unit or no filename
f6ec a9 61    SaFi_20   LDA #$61            ; secondary address for saving
f6ee 85 d3              STA SA
f6f0 a4 d1              LDY FNLEN           ; length of filename
f6f2 f0 f5              BEQ SaFi_10         ; error if zero
f6f4 20 af f4           JSR Send_Filename
f6f7 20 d5 f0           JSR LISTEN          ; Send Listen
f6fa a5 d3              LDA SA
f6fc 20 43 f1           JSR SECOND          ; Send Listen Secondary
f6ff a4 fb              LDY STAL            ; save start low
f701 a6 fc              LDX STAL+1          ; save start high
f703 98                 TYA
f704 20 9e f1           JSR CIOUT           ; send start low
f707 8a                 TXA
f708 20 9e f1           JSR CIOUT           ; send start high
f70b a9 00              LDA #0
f70d 85 fb              STA STAL            ; clear pointer low
f70f c4 c9    SaFi_30   CPY EAL             ; compare to end address low
f711 d0 04              BNE SaFi_40         ; not yet
f713 e4 ca              CPX EAL+1           ; compare to end address high
f715 f0 10              BEQ SaFi_50         ; branch if at end
f717 b1 fb    SaFi_40   LDA (STAL),Y        ; load next byte
f719 20 9e f1           JSR CIOUT           ; send it
f71c 20 43 f3           JSR Kernal_STOP     ; check STOP key
f71f c8                 INY                 ; increment Y (low address)
f720 d0 ed              BNE SaFi_30         ; continue loop if not zero
f722 e8                 INX                 ; increment X (high address)
f723 86 fc              STX STAL+1          ; update piointer
f725 d0 e8              BNE SaFi_30         ; branch always
f727 20 b9 f1 SaFi_50   JSR UNLSN           ; Unlisten and fall through

              ; ***************
f72a            Close_Disk_File
              ; ***************

f72a 20 d5 f0           JSR LISTEN          ; send listen
f72d a5 d3              LDA SA
f72f 29 ef              AND #%11101111      ; $ef
f731 09 e0              ORA #%11100000      ; $e0 + unit
f733 20 43 f1           JSR SECOND          ; send secondary listen
f736 4c b9 f1           JMP UNLSN           ; send unlisten

              ; **************
f739            Store_Mnemonic
              ; **************

f739 a2 00              LDX #0
f73b a8                 TAY
f73c b9 f3 f8           LDA Mnemonic_Left,Y
f73f 85 bf              STA Mon_A
f741 b9 33 f9           LDA Mnemonic_Right,Y
f744 85 c0              STA Mon_B
f746 a9 00    PrMn_10   LDA #0
f748 a0 05              LDY #5
f74a 06 c0    PrMn_20   ASL Mon_B
f74c 26 bf              ROL Mon_A
f74e 2a                 ROL A
f74f 88                 DEY
f750 d0 f8              BNE PrMn_20
f752 69 3f              ADC #$3f
f754 9d b1 02           STA Dis_Buf,X
f757 e8                 INX
f758 e0 03              CPX #3
f75a 90 ea              BCC PrMn_10
f75c 60                 RTS ;Size   36 [Store_Mnemonic]


f75d 00 00 00           .FILL $f768 - * (0) ; 11 bytes

              ; ************
f768            Kernal_UDTIM
              ; ************

f768 e6 8f              INC JIFFY_CLOCK+2   ; 1 jiffy = 1/60 sec
f76a d0 18              BNE ud_20
f76c e6 8e              INC JIFFY_CLOCK+1
f76e d0 02              BNE ud_10
f770 e6 8d              INC JIFFY_CLOCK
f772 a5 8d    ud_10     LDA JIFFY_CLOCK
f774 c9 4f              CMP #$4f            ; MSB of $4f1a00 = 24 * 60 * 60 * 60
f776 90 0c              BCC ud_20
f778 a5 8e              LDA JIFFY_CLOCK+1
f77a c9 1a              CMP #$1a
f77c 90 06              BCC ud_20
f77e a9 00              LDA #0
f780 85 8d              STA JIFFY_CLOCK
f782 85 8e              STA JIFFY_CLOCK+1
f784 c6 f8    ud_20     DEC JIFFY6          ; insert additional jiffy count every 5th. call
f786 d0 06              BNE ud_30           ; to generate 60Hz jiffy clock from 50Hz signal
f788 a9 06              LDA #6
f78a 85 f8              STA JIFFY6
f78c d0 da              BNE Kernal_UDTIM    ; branch always
f78e 60       ud_30     RTS ;Size   39 [Kernal_UDTIM]

f78f 00 00 00           .FILL $f7af - * (0) ; 32 bytes

              ; ************
f7af            Kernal_CHKIN
              ; ************

              ; Input:  X = local address
              ; Output: DFLTN (Default Input) set to device FA
              ;         IEEE-488 device will be talker

f7af 48                 PHA                 ; save A
f7b0 a9 00              LDA #0
f7b2 85 96              STA STATUS          ; clear status
f7b4 8a                 TXA
f7b5 48                 PHA                 ; save X
f7b6 20 c1 f2           JSR LOOKUP_LA
f7b9 d0 1b              BNE CHERR_17
f7bb 20 cd f2           JSR Set_LFS_From_X
f7be c9 04              CMP #4              ; A = FA
f7c0 90 0e              BCC CHKIN_10        ; keyboard or screen
f7c2 20 d2 f0           JSR TALK
f7c5 a5 d3              LDA SA
f7c7 20 93 f1           JSR TKSA
f7ca a5 96              LDA STATUS
f7cc 30 0b              BMI CHERR_74
f7ce a5 d4              LDA FA
f7d0 85 af    CHKIN_10  STA DFLTN
f7d2 68                 PLA
f7d3 aa                 TAX
f7d4 68                 PLA
f7d5 60                 RTS ;Size   39 [Kernal_CHKIN]

f7d6 a0 17    CHERR_17  LDY #<MSG_FILE_NOT_O
f7d8 2c                 .BYTE $2c
f7d9 a0 74    CHERR_74  LDY #<MSG_DEVICE_NOT
f7db 2c                 .BYTE $2c
f7dc a0 94    CHERR_94  LDY #<MSG_NOT_OUTPUT
f7de 4c af f5 CHERR_IO  JMP Handle_IO_Error

f7e1 00 00 00           .FILL $f7fe - * (0) ; 29 bytes

              ; *************
f7fe            Kernal_CHKOUT
              ; *************

              ; Input:  X = local address
              ; Output: DFLTO (Default Output) set to device FA
              ;         IEEE-488 device will be listener

f7fe 48                 PHA                 ; save A
f7ff a9 00              LDA #0
f801 85 96              STA STATUS          ; clear status
f803 8a                 TXA
f804 48                 PHA                 ; save X
f805 20 c1 f2           JSR LOOKUP_LA
f808 d0 cc              BNE CHERR_17        ; file not open
f80a 20 cd f2           JSR Set_LFS_From_X
f80d f0 cd              BEQ CHERR_94        ; cannot write to keyboard
f80f c9 04              CMP #4
f811 90 0e              BCC KeCo_10         ; -> screen
f813 20 d5 f0           JSR LISTEN
f816 a5 d3              LDA SA
f818 20 43 f1           JSR SECOND
f81b a5 96              LDA STATUS
f81d 30 ba              BMI CHERR_74
f81f a5 d4              LDA FA
f821 85 b0    KeCo_10   STA DFLTO
f823 68                 PLA
f824 aa                 TAX
f825 68                 PLA
f826 60                 RTS ;Size   41 [Kernal_CHKOUT]

              ; **************
f827            Set_Wedge_Unit
              ; **************

f827 20 70 00           JSR CHRGET
f82a 90 0c              BCC SWUN_10
f82c a6 ab              LDX Wedge_Unit      ; X = Unit
f82e 98                 TYA                 ; A = 0
f82f 20 83 cf           JSR Print_Integer_XA
f832 20 df ba           JSR Print_CR
f835 4c ff b3           JMP Basic_Ready
f838 20 f6 b8 SWUN_10   JSR Scan_Linenumber
f83b a5 11              LDA LINNUM
f83d 85 ab              STA Wedge_Unit
f83f 4c ff b3           JMP Basic_Ready

              ; ************
f842            Wedge_Parser
              ; ************

f842 a0 00              LDY #0
f844 84 9d              STY VERCK           ; no verify
f846 b1 77              LDA (TXTPTR),Y
f848 c9 40              CMP #'@'            ; wedge control
f84a f0 1d              BEQ Command_Or_Status
f84c c9 3e              CMP #'>'            ; wedge control
f84e f0 19              BEQ Command_Or_Status
f850 c9 24              CMP #'$'            ; directory
f852 f0 38              BEQ Wedge_Directory
f854 c9 23              CMP #'#'
f856 f0 cf              BEQ Set_Wedge_Unit
f858 c9 2f              CMP #'/'
f85a f0 57              BEQ Wedge_Load
f85c c9 5e              CMP #'^'
f85e f0 46              BEQ Wedge_Run
f860 20 40 ed           JSR Extended_Command
f863 20 fb b4           JSR Tokenize_Line
f866 4c 7c b7           JMP Start_Program

              ; *****************
f869            Command_Or_Status
              ; *****************

f869 e6 77              INC TXTPTR
f86b b1 77              LDA (TXTPTR),Y
f86d f0 14              BEQ Get_Status
f86f c9 24              CMP #'$'            ; dir command
f871 f0 19              BEQ Wedge_Directory

              ; ************
f873            Send_Command
              ; ************

f873 20 31 fb           JSR DOS_Open_Comm_Write
f876 b1 77    SeCo_10   LDA (TXTPTR),Y
f878 f0 06              BEQ SeCo_20
f87a 20 9e f1           JSR CIOUT
f87d c8                 INY
f87e 10 f6              BPL SeCo_10
f880 20 b9 f1 SeCo_20   JSR UNLSN

              ; **********
f883            Get_Status
              ; **********

f883 20 c7 f8           JSR Wedge_Prepare
f886 20 98 f8           JSR Print_Status
f889 4c ff b3           JMP Basic_Ready

              ; ***************
f88c            Wedge_Directory
              ; ***************

f88c 20 d0 f8           JSR Wedge_Filename
f88f 20 c7 f8           JSR Wedge_Prepare
f892 20 89 d8           JSR Wedge_Call_Dir
f895 4c ff b3           JMP Basic_Ready

              ; ************
f898            Print_Status
              ; ************

f898 20 e1 db           JSR Clear_Status
f89b 20 91 d9           JSR Kernal_Read_DS
f89e 4c 85 db           JMP Display_Status

f8a1 52 55 4e RUN_Now   .BYTE "RUN:\r"

              ; *********
f8a6            Wedge_Run
              ; *********

f8a6 a2 05              LDX #5              ; put "RUN" into keyboard buffer
f8a8 86 9e              STX CharsInBuffer
f8aa bd a0 f8 WeRu_10   LDA RUN_Now-1,X
f8ad 9d 6e 02           STA KEYD-1,X
f8b0 ca                 DEX
f8b1 d0 f7              BNE WeRu_10

              ; **********
f8b3            Wedge_Load
              ; **********

f8b3 20 70 00           JSR CHRGET
f8b6 c9 30              CMP #'0'            ; Skip size info in dir listings
f8b8 90 04              BCC WeLo_10
f8ba c9 3a              CMP #'9'+1
f8bc 90 f5              BCC Wedge_Load
f8be 20 d0 f8 WeLo_10   JSR Wedge_Filename
f8c1 20 c7 f8           JSR Wedge_Prepare
f8c4 4c 1d f4           JMP Load_Verify_Params_Set

              ; *************
f8c7            Wedge_Prepare
              ; *************

f8c7 a5 ab              LDA Wedge_Unit
f8c9 85 d4              STA FA
f8cb a9 00              LDA #0
f8cd 85 96              STA STATUS
f8cf 60                 RTS ;Size    9 [Wedge_Prepare]

              ; **************
f8d0            Wedge_Filename
              ; **************

f8d0 a0 ff              LDY #-1
f8d2 20 76 00           JSR CHRGOT
f8d5 c9 22              CMP #$22            ; quote
f8d7 d0 02              BNE WeFi_10
f8d9 e6 77              INC TXTPTR          ; skip quote
f8db c8       WeFi_10   INY
f8dc b1 77              LDA (TXTPTR),y
f8de f0 04              BEQ WeFi_20
f8e0 c9 22              CMP #$22            ; quote
f8e2 d0 f7              BNE WeFi_10
f8e4 84 d1    WeFi_20   STY FNLEN           ; store length
f8e6 a5 77              LDA TXTPTR
f8e8 85 da              STA FNADR
f8ea a5 78              LDA TXTPTR + 1
f8ec 85 db              STA FNADR + 1
f8ee a5 ab              LDA Wedge_Unit
f8f0 85 d4              STA FA
f8f2 60                 RTS ;Size   35 [Wedge_Filename]

              ; *************
f8f3            Mnemonic_Left
              ; *************

f8f3 1c                 .BYTE >"BRK"
f8f4 8a                 .BYTE >"PHP"
f8f5 1c                 .BYTE >"BPL"
f8f6 23                 .BYTE >"CLC"
f8f7 5d                 .BYTE >"JSR"
f8f8 8b                 .BYTE >"PLP"
f8f9 1b                 .BYTE >"BMI"
f8fa a1                 .BYTE >"SEC"
f8fb 9d                 .BYTE >"RTI"
f8fc 8a                 .BYTE >"PHA"
f8fd 1d                 .BYTE >"BVC"
f8fe 23                 .BYTE >"CLI"
f8ff 9d                 .BYTE >"RTS"
f900 8b                 .BYTE >"PLA"
f901 1d                 .BYTE >"BVS"
f902 a1                 .BYTE >"SEI"
f903 00                 .BYTE >"???"
f904 29                 .BYTE >"DEY"
f905 19                 .BYTE >"BCC"
f906 ae                 .BYTE >"TYA"
f907 69                 .BYTE >"LDY"
f908 a8                 .BYTE >"TAY"
f909 19                 .BYTE >"BCS"
f90a 23                 .BYTE >"CLV"
f90b 24                 .BYTE >"CPY"
f90c 53                 .BYTE >"INY"
f90d 1b                 .BYTE >"BNE"
f90e 23                 .BYTE >"CLD"
f90f 24                 .BYTE >"CPX"
f910 53                 .BYTE >"INX"
f911 19                 .BYTE >"BEQ"
f912 a1                 .BYTE >"SED"
f913 00                 .BYTE >"???"
f914 1a                 .BYTE >"BIT"
f915 5b                 .BYTE >"JMP"
f916 5b                 .BYTE >"JMP"
f917 a5                 .BYTE >"STY"
f918 69                 .BYTE >"LDY"
f919 24                 .BYTE >"CPY"
f91a 24                 .BYTE >"CPX"
f91b ae                 .BYTE >"TXA"
f91c ae                 .BYTE >"TXS"
f91d a8                 .BYTE >"TAX"
f91e ad                 .BYTE >"TSX"
f91f 29                 .BYTE >"DEX"
f920 00                 .BYTE >"???"
f921 7c                 .BYTE >"NOP"
f922 00                 .BYTE >"???"
f923 15                 .BYTE >"ASL"
f924 9c                 .BYTE >"ROL"
f925 6d                 .BYTE >"LSR"
f926 9c                 .BYTE >"ROR"
f927 a5                 .BYTE >"STX"
f928 69                 .BYTE >"LDX"
f929 29                 .BYTE >"DEC"
f92a 53                 .BYTE >"INC"
f92b 84                 .BYTE >"ORA"
f92c 13                 .BYTE >"AND"
f92d 34                 .BYTE >"EOR"
f92e 11                 .BYTE >"ADC"
f92f a5                 .BYTE >"STA"
f930 69                 .BYTE >"LDA"
f931 23                 .BYTE >"CMP"
f932 a0                 .BYTE >"SBC"

              ; **************
f933            Mnemonic_Right
              ; **************

f933 d8                 .BYTE <"BRK"
f934 62                 .BYTE <"PHP"
f935 5a                 .BYTE <"BPL"
f936 48                 .BYTE <"CLC"
f937 26                 .BYTE <"JSR"
f938 62                 .BYTE <"PLP"
f939 94                 .BYTE <"BMI"
f93a 88                 .BYTE <"SEC"
f93b 54                 .BYTE <"RTI"
f93c 44                 .BYTE <"PHA"
f93d c8                 .BYTE <"BVC"
f93e 54                 .BYTE <"CLI"
f93f 68                 .BYTE <"RTS"
f940 44                 .BYTE <"PLA"
f941 e8                 .BYTE <"BVS"
f942 94                 .BYTE <"SEI"
f943 00                 .BYTE <"???"
f944 b4                 .BYTE <"DEY"
f945 08                 .BYTE <"BCC"
f946 84                 .BYTE <"TYA"
f947 74                 .BYTE <"LDY"
f948 b4                 .BYTE <"TAY"
f949 28                 .BYTE <"BCS"
f94a 6e                 .BYTE <"CLV"
f94b 74                 .BYTE <"CPY"
f94c f4                 .BYTE <"INY"
f94d cc                 .BYTE <"BNE"
f94e 4a                 .BYTE <"CLD"
f94f 72                 .BYTE <"CPX"
f950 f2                 .BYTE <"INX"
f951 a4                 .BYTE <"BEQ"
f952 8a                 .BYTE <"SED"
f953 00                 .BYTE <"???"
f954 aa                 .BYTE <"BIT"
f955 a2                 .BYTE <"JMP"
f956 a2                 .BYTE <"JMP"
f957 74                 .BYTE <"STY"
f958 74                 .BYTE <"LDY"
f959 74                 .BYTE <"CPY"
f95a 72                 .BYTE <"CPX"
f95b 44                 .BYTE <"TXA"
f95c 68                 .BYTE <"TXS"
f95d b2                 .BYTE <"TAX"
f95e 32                 .BYTE <"TSX"
f95f b2                 .BYTE <"DEX"
f960 00                 .BYTE <"???"
f961 22                 .BYTE <"NOP"
f962 00                 .BYTE <"???"
f963 1a                 .BYTE <"ASL"
f964 1a                 .BYTE <"ROL"
f965 26                 .BYTE <"LSR"
f966 26                 .BYTE <"ROR"
f967 72                 .BYTE <"STX"
f968 72                 .BYTE <"LDX"
f969 88                 .BYTE <"DEC"
f96a c8                 .BYTE <"INC"
f96b c4                 .BYTE <"ORA"
f96c ca                 .BYTE <"AND"
f96d 26                 .BYTE <"EOR"
f96e 48                 .BYTE <"ADC"
f96f 44                 .BYTE <"STA"
f970 44                 .BYTE <"LDA"
f971 a2                 .BYTE <"CMP"
f972 c8                 .BYTE <"SBC"

              ; *************
f973            admode_format
              ; *************

              ;                 76543210
              ;                 --------
              ;                 x         $
              ;                  x        ($
              ;                   x       #$
              ;                    x      ,X
              ;                     x     )
              ;                      x    ,Y
              ;                       xx  length - 1

f973 00                  .BYTE %00000000  ; 0         implicit
f974 21                  .BYTE %00100001  ; 1  $#     immediate
f975 81                  .BYTE %10000001  ; 2  $zz    zeropage
f976 82                  .BYTE %10000010  ; 3  $nnnn  absolute
f977 00                  .BYTE %00000000  ; 4         implicit
f978 00                  .BYTE %00000000  ; 5         implicit
f979 59                  .BYTE %01011001  ; 6 ($zz,X) indexed indirect
f97a 4d                  .BYTE %01001101  ; 7 ($zz),Y indirect indexed
f97b 91                  .BYTE %10010001  ; 8 $zz,X   zeropage,X
f97c 92                  .BYTE %10010010  ; 9 $nnnn,X absolute,X
f97d 86                  .BYTE %10000110  ; a $nnnn,Y absolute,Y
f97e 4a                  .BYTE %01001010  ; b ($nnnn) indirect
f97f 85                  .BYTE %10000101  ; c $zz,Y   zeropage,Y
f980 9d                  .BYTE %10011101  ; d $nnnn   relative

f981 2c 29 2c adr_char1  .BYTE ",),#($"
f987 59 00 58 adr_char2  .BYTE "Y",0,"X$$",0

              ; *************
f98d            Store_Address
              ; *************

f98d a5 bd              LDA Mon_Format
f98f 85 bf              STA Mon_A
f991 a0 03              LDY #3              ; buffer pointer after mnemonic
f993 a5 be              LDA Dis_Length
f995 f0 41              BEQ StAd_Ret        ; finish for implied address
f997 a9 20              LDA #' '            ; store blank
f999 8d b4 02           STA Dis_Buf+3
f99c c8                 INY                 ; inc buffer pointer
f99d a2 05              LDX #5              ; 6 flags to process
f99f e0 02    StAd_10   CPX #2              ; flag2: address
f9a1 d0 16              BNE StAd_30
f9a3 a5 be              LDA Dis_Length
f9a5 c9 01              CMP #1
f9a7 f0 05              BEQ StAd_20         ; 8 bit operand
f9a9 a5 c3              LDA Mon_Hi
f9ab 20 e2 f9           JSR Store_Hex
f9ae a5 bf    StAd_20   LDA Mon_A
f9b0 c9 e8              CMP #$e8            ; branch ?
f9b2 b0 1e              BCS StAd_50         ; compute target
f9b4 a5 c2              LDA Mon_Lo          ; low  byte of operand
f9b6 20 e2 f9           JSR Store_Hex
f9b9 06 bf    StAd_30   ASL Mon_A
f9bb 90 10              BCC StAd_40
f9bd bd 81 f9           LDA adr_char1,X
f9c0 99 b1 02           STA Dis_Buf,Y
f9c3 c8                 INY
f9c4 bd 87 f9           LDA adr_char2,X
f9c7 f0 04              BEQ StAd_40
f9c9 99 b1 02           STA Dis_Buf,Y
f9cc c8                 INY
f9cd ca       StAd_40   DEX
f9ce 10 cf              BPL StAd_10
f9d0 30 06              BMI StAd_Ret
f9d2 20 46 fe StAd_50   JSR Offset_To_Target
f9d5 20 dc f9           JSR Store_Hex_XA
f9d8 8c b0 02 StAd_Ret  STY Dis_Buf_Length
f9db 60                 RTS ;Size   79 [Store_Address]


              ; ************
f9dc            Store_Hex_XA
              ; ************
f9dc 48                 PHA
f9dd 8a                 TXA
f9de 20 e2 f9           JSR Store_Hex
f9e1 68                 PLA

              ; *********
f9e2            Store_Hex
              ; *********

f9e2 48                 PHA
f9e3 4a                 LSR A
f9e4 4a                 LSR A
f9e5 4a                 LSR A
f9e6 4a                 LSR A
f9e7 20 60 d7           JSR Nibble_To_Hex
f9ea 99 b1 02           STA Dis_Buf,Y
f9ed c8                 INY
f9ee 68                 PLA
f9ef 29 0f              AND #15
f9f1 20 60 d7           JSR Nibble_To_Hex
f9f4 99 b1 02           STA Dis_Buf,Y
f9f7 c8                 INY
f9f8 60                 RTS ;Size   23 [Store_Hex]


              ; *************
f9f9            Print_Dis_Buf
              ; *************

f9f9 a0 00              LDY #0
f9fb b9 b1 02 PDB_10    LDA Dis_Buf,Y
f9fe 20 02 e2           JSR EDIT_CHROUT
fa01 c8                 INY
fa02 cc b0 02           CPY Dis_Buf_Length
fa05 90 f4              BCC PDB_10
fa07 60                 RTS ;Size   15 [Print_Dis_Buf]

              ; ***********
fa08            Ass_Operand
              ; ***********

fa08 20 f4 d8           JSR Mon_CHRIN
fa0b f0 11              BEQ AsOp_30         ; finished
fa0d c9 20              CMP #' '
fa0f f0 f7              BEQ Ass_Operand     ; ignore blanks
fa11 20 99 fd           JSR Get_Constant
fa14 f0 08              BEQ AsOp_30         ; no chars left
fa16 99 c1 02           STA Ass_Buf,Y
fa19 c8                 INY
fa1a c0 10              CPY #16
fa1c 90 ea              BCC Ass_Operand
fa1e ad c1 02 AsOp_30   LDA Ass_Buf         ; 1.st char of mnemonic
fa21 c9 42              CMP #'B'
fa23 d0 19              BNE AsOp_Ret        ; no branch
fa25 ad c2 02           LDA Ass_Buf+1       ; 2nd. char of mnemonic
fa28 c9 49              CMP #'I'
fa2a f0 12              BEQ AsOp_Ret        ; BIT
fa2c c9 52              CMP #'R'
fa2e f0 0e              BEQ AsOp_Ret        ; BRK
fa30 a5 c3              LDA Mon_Hi
fa32 f0 0b              BEQ AsOp_40
fa34 38                 SEC                 ; convert target to offset
fa35 a5 c2              LDA Mon_Lo
fa37 e5 fb              SBC STAL
fa39 38                 SEC
fa3a e9 02              SBC #2
fa3c 85 c2              STA Mon_Lo
fa3e 60       AsOp_Ret  RTS ;Size   55 [Ass_Operand]
fa3f 4c 36 fe AsOp_40   JMP Expand_Target


              ; ********
fa42            Assemble
              ; ********

              ; Strategy: convert operand to disassembler format
              ; Loop opcode from 0 to 255 and call disassembler
              ; until mnemonic and operand match.

fa42 20 6a d7           JSR Hex_To_STAL      ; target address
fa45 90 63              BCC Ass_Err
fa47 a0 00    Ass_010   LDY #0               ; reset buffer pointer
fa49 84 c1              STY Mon_Op
fa4b 84 c2              STY Mon_Lo
fa4d 84 c3              STY Mon_Hi
fa4f 8c d1 02           STY Ass_Dollar
fa52 8c d2 02           STY Ass_Length
fa55 20 f4 d8 Ass_020   JSR Mon_CHRIN        ; get next char
fa58 f0 50              BEQ Ass_Err
fa5a c9 20              CMP #' '
fa5c f0 e9              BEQ Ass_010          ; restart on blank
fa5e 99 c1 02           STA Ass_Buf,Y        ; save char
fa61 c8                 INY
fa62 c0 03              CPY #3
fa64 d0 ef              BNE Ass_020          ; look for more
fa66 20 f4 d8           JSR Mon_CHRIN
fa69 f0 0b              BEQ Ass_040          ; Mnemonic only
fa6b c9 20              CMP #' '
fa6d d0 3b              BNE Ass_Err          ; blank after mnemonic is mandatory
fa6f 8d c4 02           STA Ass_Buf+3
fa72 c8                 INY
fa73 20 08 fa           JSR Ass_Operand
fa76 8c c0 02 Ass_040   STY Ass_Buf_Length
fa79 a5 c1    Ass_050   LDA Mon_Op
fa7b 20 25 f6           JSR Analyze_Opcode
fa7e 8d d0 02           STA Ass_Index
fa81 20 39 f7           JSR Store_Mnemonic
fa84 20 8d f9           JSR Store_Address
fa87 ae c0 02           LDX Ass_Buf_Length
fa8a ec b0 02           CPX Dis_Buf_Length
fa8d d0 0b              BNE Ass_070
fa8f ca       Ass_060   DEX
fa90 30 1b              BMI Ass_080         ; match
fa92 bd c1 02           LDA Ass_Buf,X
fa95 dd b1 02           CMP Dis_Buf,X
fa98 f0 f5              BEQ Ass_060
fa9a e6 c1    Ass_070   INC Mon_Op          ; try next op code
fa9c d0 db              BNE Ass_050
fa9e a5 cc              LDA Mon_ZP          ; was a zP mode ?
faa0 d0 08              BNE Ass_Err
faa2 c6 cc              DEC Mon_ZP          ; invalidate
faa4 20 17 fe           JSR Expand_Address
faa7 4c 79 fa           JMP Ass_050         ; now try two byte operands
faaa 4c a9 d4 Ass_Err   JMP Mon_Error
faad 86 ba    Ass_080   STX Dis_Line        ; disable disassembler line count
faaf a5 fb              LDA STAL
fab1 85 f9              STA BPTR
fab3 a5 fc              LDA STAL+1
fab5 85 fa              STA BPTR+1
fab7 a4 be              LDY Dis_Length
fab9 b9 c1 00 Ass_090   LDA Mon_Op,Y        ; store instruction
fabc 20 8b 02           JSR Bank_Store
fabf 20 7a 02           JSR Bank_Fetch
fac2 d9 c1 00           CMP Mon_Op,Y        ; successfull ?
fac5 d0 e3              BNE Ass_Err
fac7 88                 DEY
fac8 10 ef              BPL Ass_090
faca 20 b4 e1           JSR Edit_To_Left_Margin
facd a9 9d              LDA #$9d            ; Cursor UP
facf 20 02 e2           JSR EDIT_CHROUT
fad2 a9 41              LDA #'A'
fad4 20 74 d5           JSR Mon_Prompt
fad7 20 1b d5           JSR Mon_Print_Blank
fada 20 4d d7           JSR Mon_Print_STAL
fadd 20 1b d5           JSR Mon_Print_Blank
fae0 ad d0 02           LDA Ass_Index
fae3 20 e6 f5           JSR Print_Dis_Line
fae6 a9 0d              LDA #CR
fae8 20 02 e2           JSR EDIT_CHROUT
faeb 78                 SEI                 ; prompt to keyboard buffer
faec a9 41              LDA #'A'
faee 8d 6f 02           STA KEYD
faf1 a9 20              LDA #' '
faf3 8d 70 02           STA KEYD+1
faf6 a5 fc              LDA STAL+1
faf8 20 3e d7           JSR Make_Hex_Byte
fafb 8e 71 02           STX KEYD+2
fafe 8d 72 02           STA KEYD+3
fb01 a5 fb              LDA STAL
fb03 20 3e d7           JSR Make_Hex_Byte
fb06 8e 73 02           STX KEYD+4
fb09 8d 74 02           STA KEYD+5
fb0c a9 20              LDA #' '
fb0e 8d 75 02           STA KEYD+6
fb11 a2 07              LDX #7
fb13 86 9e              STX CharsInBuffer
fb15 58                 CLI
fb16 4c b1 d4           JMP Mon_10

              ; ********
fb19            Inc_STAL
              ; ********

fb19 a9 01              LDA #1

              ; ********
fb1b            Add_STAL
              ; ********

fb1b 18                 CLC
fb1c 65 fb    AdST_00   ADC STAL
fb1e 85 fb              STA STAL
fb20 90 02              BCC AdST_Ret
fb22 e6 fc    AdST_10   INC STAL+1
fb24 60       AdST_Ret  RTS ;Size   10 [Add_STAL]


              ; ********
fb25            Inc_BPTR
              ; ********

fb25 a9 01              LDA #1

              ; ********
fb27            Add_BPTR
              ; ********

fb27 18                 CLC
fb28 65 f9    AdBP_00   ADC BPTR
fb2a 85 f9              STA BPTR
fb2c 90 02              BCC AdBP_Ret
fb2e e6 fa    AdBP_10   INC BPTR+1
fb30 60       AdBP_Ret  RTS ;Size   10 [Add_BPTR]


              ; *******************
fb31            DOS_Open_Comm_Write
              ; *******************

fb31 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
fb34 20 d5 f0           JSR LISTEN
fb37 a9 6f              LDA #$6f
fb39 85 d3              STA SA
fb3b 4c 43 f1           JMP SECOND

              ; *********
fb3e            Mon_Wedge
              ; *********

fb3e 20 f4 d8           JSR Mon_CHRIN
fb41 f0 10              BEQ Mon_Wedge_Status
fb43 48                 PHA
fb44 20 31 fb           JSR DOS_Open_Comm_Write
fb47 68                 PLA
fb48 20 9e f1 MoWe_10   JSR CIOUT
fb4b 20 f4 d8           JSR Mon_CHRIN
fb4e d0 f8              BNE MoWe_10
fb50 20 b9 f1           JSR UNLSN

              ; ****************
fb53            Mon_Wedge_Status
              ; ****************

fb53 20 1e d5           JSR Mon_Print_CR
fb56 20 c7 f8           JSR Wedge_Prepare
fb59 20 98 f8           JSR Print_Status
fb5c 4c ae d4           JMP Mon_Main

              ; *******
fb5f            Mon_Dir
              ; *******

fb5f a0 00              LDY #0
fb61 a9 24              LDA #'$'
fb63 99 42 03 MoDi_10   STA DOS_Filename,Y
fb66 c8                 INY
fb67 20 f4 d8           JSR Mon_CHRIN
fb6a d0 f7              BNE MoDi_10
fb6c 84 d1              STY FNLEN
fb6e 20 c5 d6           JSR Set_DOS_FNADR
fb71 20 1e d5           JSR Mon_Print_CR
fb74 20 c7 f8           JSR Wedge_Prepare
fb77 20 89 d8           JSR Wedge_Call_Dir
fb7a 4c ae d4           JMP Mon_Main

fb7d 00 00 00           .FILL $fbc4 - * (0) ; 71 bytes

              ; **********
fbc4            Set_STATUS
              ; **********

fbc4 05 96              ORA STATUS
fbc6 85 96              STA STATUS
fbc8 60                 RTS ;Size    5 [Set_STATUS]


              ; *********
fbc9            Mon_Get_3
              ; *********

fbc9 20 6a d7           JSR Hex_To_STAL
fbcc 90 11              BCC MG3_Err
fbce a2 fd              LDX #MEMUSS
fbd0 20 6c d7           JSR Read_Hex_Word
fbd3 90 0a              BCC MG3_Err
fbd5 a2 f9              LDX #BPTR
fbd7 20 6c d7           JSR Read_Hex_Word
fbda 90 03              BCC MG3_Err
fbdc a0 00              LDY #0
fbde 60                 RTS ;Size   22 [Mon_Get_3]
fbdf 68       MG3_Err   PLA
fbe0 68                 PLA
fbe1 4c a9 d4           JMP Mon_Error

              ; ***********
fbe4            Mon_Compare
              ; ***********

fbe4 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fbe7 20 1e d5           JSR Mon_Print_CR
fbea a9 f9    MoCo_10   LDA #BPTR
fbec 8d 81 02           STA Bank_Fetch+7
fbef a5 b7              LDA W_Bank
fbf1 20 7c 02           JSR Bank_Fetch+2    ; LDA (BPTR),Y
fbf4 85 bf              STA Mon_A
fbf6 a9 fb              LDA #STAL
fbf8 8d 81 02           STA Bank_Fetch+7
fbfb 20 7a 02           JSR Bank_Fetch      ; LDA (STAL),Y
fbfe c5 bf              CMP Mon_A
fc00 f0 06              BEQ MoCo_20
fc02 20 4d d7           JSR Mon_Print_STAL
fc05 20 1b d5           JSR Mon_Print_Blank
fc08 20 19 fb MoCo_20   JSR Inc_STAL
fc0b 20 25 fb           JSR Inc_BPTR
fc0e 20 eb d5           JSR Cmp_STAL_MEMUSS
fc11 b0 d7              BCS MoCo_10
fc13 4c ae d4           JMP Mon_Main

              ; ************
fc16            Mon_Transfer
              ; ************

fc16 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fc19 a5 f9              LDA BPTR            ; BPTR > STAL ?
fc1b c5 fb              CMP STAL
fc1d a5 fa              LDA BPTR+1
fc1f e5 fc              SBC STAL+1
fc21 b0 17              BCS MoTr_20         ; BPTR > STAL: copy backward
fc23 20 7a 02 MoTr_10   JSR Bank_Fetch
fc26 20 8b 02           JSR Bank_Store
fc29 20 19 fb           JSR Inc_STAL
fc2c 20 25 fb           JSR Inc_BPTR
fc2f 20 eb d5           JSR Cmp_STAL_MEMUSS
fc32 b0 ef              BCS MoTr_10
fc34 4c ae d4 MoTr_Ret  JMP Mon_Main
fc37 4c a9 d4 MoTr_Err  JMP Mon_Error
fc3a 38       MoTr_20   SEC
fc3b a5 fd              LDA MEMUSS          ; exchange STAL <-> MEMUSS
fc3d a6 fb              LDX STAL
fc3f 86 fd              STX MEMUSS
fc41 85 fb              STA STAL
fc43 e5 fd              SBC MEMUSS
fc45 85 bf              STA Mon_A           ; Mon_A = MEMUSS - STAL
fc47 a5 fe              LDA MEMUSS+1
fc49 a6 fc              LDX STAL+1
fc4b 86 fe              STX MEMUSS+1
fc4d 85 fc              STA STAL+1
fc4f e5 fe              SBC MEMUSS+1
fc51 85 c0              STA Mon_A+1
fc53 90 e2              BCC MoTr_Err        ; Error: MEMUSS < STAL
fc55 18                 CLC
fc56 a5 f9              LDA BPTR            ; BPTR += (MEMUSS - STAL)
fc58 65 bf              ADC Mon_A
fc5a 85 f9              STA BPTR
fc5c a5 fa              LDA BPTR+1
fc5e 65 c0              ADC Mon_A+1
fc60 85 fa              STA BPTR+1
fc62 20 7a 02 MoTr_30   JSR Bank_Fetch
fc65 20 8b 02           JSR Bank_Store
fc68 20 eb d5           JSR Cmp_STAL_MEMUSS ; STAL == MEMUSS -> finished
fc6b b0 c7              BCS MoTr_Ret
fc6d a5 fb              LDA STAL
fc6f d0 02              BNE MoTr_40
fc71 c6 fc              DEC STAL+1
fc73 c6 fb    MoTr_40   DEC STAL
fc75 a5 f9              LDA BPTR
fc77 d0 02              BNE MoTr_50
fc79 c6 fa              DEC BPTR+1
fc7b c6 f9    MoTr_50   DEC BPTR
fc7d 4c 62 fc           JMP MoTr_30

              ; ********
fc80            Mon_Hunt
              ; ********

fc80 20 18 d6           JSR Mon_Get_Addr    ; get range
fc83 a0 00              LDY #0
fc85 20 f4 d8 MoHu_10   JSR Mon_CHRIN       ; skip blanks
fc88 f0 5b              BEQ MoHu_Err
fc8a c9 20              CMP #' '
fc8c f0 f7              BEQ MoHu_10
fc8e c9 22              CMP #$22            ; quote ?
fc90 f0 16              BEQ MoHu_40         ; string
fc92 20 80 d7           JSR Read_Hex_A      ; get first byte
fc95 90 4e              BCC MoHu_Err
fc97 b0 05              BCS MoHu_30         ; continue reading hex
fc99 20 79 d7 MoHu_20   JSR Read_Hex        ; loop for reading hex bytes
fc9c 90 1b              BCC MoHu_50         ; end of line
fc9e 99 42 03 MoHu_30   STA DOS_Filename,Y
fca1 c8                 INY
fca2 c0 10              CPY #16
fca4 90 f3              BCC MoHu_20
fca6 b0 11              BCS MoHu_50
fca8 20 f4 d8 MoHu_40   JSR Mon_CHRIN       ; loop for reading string
fcab f0 0c              BEQ MoHu_50
fcad c9 22              CMP #$22            ; quote
fcaf f0 08              BEQ MoHu_50
fcb1 99 42 03           STA DOS_Filename,Y
fcb4 c8                 INY
fcb5 c0 10              CPY #16
fcb7 90 ef              BCC MoHu_40
fcb9 84 b5    MoHu_50   STY MONCNT
fcbb 20 1e d5           JSR Mon_Print_CR
fcbe 20 35 f3 MoHu_60   JSR Check_STOP_Key  ; STOP key pressed?
fcc1 f0 1f              BEQ MoHu_Ret
fcc3 20 e0 d5           JSR Mon_Cmp_Addr
fcc6 90 1a              BCC MoHu_Ret
fcc8 a0 00              LDY #0
fcca 20 7a 02 MoHu_70   JSR Bank_Fetch
fccd d9 42 03           CMP DOS_Filename,Y
fcd0 d0 0b              BNE MoHu_80         ; no match
fcd2 c8                 INY
fcd3 c4 b5              CPY MONCNT
fcd5 90 f3              BCC MoHu_70
fcd7 20 4d d7           JSR Mon_Print_STAL
fcda 20 1b d5           JSR Mon_Print_Blank
fcdd 20 19 fb MoHu_80   JSR Inc_STAL
fce0 d0 dc              BNE MoHu_60
fce2 4c ae d4 MoHu_Ret  JMP Mon_Main
fce5 4c a9 d4 MoHu_Err  JMP Mon_Error


fce8 00 00 00           .FILL $fd16 - * (0) ; 46 bytes

              ; ***********
fd16            Entry_RESET
              ; ***********

fd16 a2 ff              LDX #$ff
fd18 78                 SEI
fd19 9a                 TXS
fd1a d8                 CLD
fd1b 20 37 e0           JSR EDIT_RESET
fd1e a9 ff              LDA #<Basic_Ready
fd20 85 94              STA NMINV
fd22 a9 b3              LDA #>Basic_Ready
fd24 85 95              STA NMINV+1
fd26 a9 4e              LDA #<MONITOR_BREAK
fd28 85 92              STA CBINV
fd2a a9 d4              LDA #>MONITOR_BREAK
fd2c 85 93              STA CBINV+1
fd2e a9 a9              LDA #<Mon_Error
fd30 8d fa 03           STA Reset_Vector
fd33 a9 d4              LDA #>Mon_Error
fd35 8d fb 03           STA Reset_Vector+1
fd38 a9 00              LDA #0
fd3a 8d fc 03           STA Ignore_Timeout
fd3d 58                 CLI
fd3e 4c b6 d3           JMP Init_BASIC_RAM_Vectors

fd41 00 00 00           .FILL $fd49 - * (0) ; 8 bytes

              ; *********
fd49            Entry_NMI
              ; *********

fd49 6c 94 00           JMP (NMINV)

              ; ***********
fd4c            Set_FA_to_8
              ; ***********

fd4c a2 08              LDX #8
fd4e 86 d4              STX FA
fd50 60                 RTS ;Size    5 [Set_FA_to_8]

              ; ********
fd51            Mon_Unit
              ; ********

fd51 20 79 d7           JSR Read_Hex
fd54 90 0a              BCC MoUn_10
fd56 c9 10              CMP #16
fd58 b0 06              BCS MoUn_10
fd5a c9 04              CMP #4
fd5c 90 02              BCC MoUn_10
fd5e 85 ab              STA Wedge_Unit
fd60 20 1b d5 MoUn_10   JSR Mon_Print_Blank
fd63 a5 ab              LDA Wedge_Unit
fd65 20 54 d7           JSR Print_Hex_Byte
fd68 20 1e d5           JSR Mon_Print_CR
fd6b 4c ae d4           JMP Mon_Main

              ; ********
fd6e            Mon_Next
              ; ********

fd6e 78                 SEI
fd6f a9 89              LDA #<Mon_Step_IRQ
fd71 85 90              STA CINV
fd73 a9 fd              LDA #>Mon_Step_IRQ
fd75 85 91              STA CINV+1
fd77 a9 a0              LDA #$a0            ; enable T2 time out interrupt
fd79 8d 4e e8           STA VIA_IER         ; interrupt enable register
fd7c a9 2f              LDA #47             ; overhead + 1 cycle
fd7e 8d 48 e8           STA VIA_Timer_2_Lo
fd81 a9 00              LDA #0
fd83 8d 49 e8           STA VIA_Timer_2_Hi  ; trigger start of timer T2
fd86 4c a4 d6           JMP Mon_Step

              ; ************
fd89            Mon_Step_IRQ
              ; ************

fd89 ad 4d e8           LDA VIA_IFR
fd8c 29 20              AND #$20            ; T2 timeout interrupt ?
fd8e f0 06              BEQ MSI_10
fd90 2c 48 e8           BIT VIA_Timer_2_Lo  ; clear interrupt
fd93 6c 92 00           JMP (CBINV)
fd96 4c 55 e4 MSI_10    JMP IRQ_NORMAL


              ; ************
fd99            Get_Constant
              ; ************

fd99 20 05 d9           JSR Is_Int
fd9c 90 51              BCC GeCo_Ret
fd9e c9 24              CMP #'$'
fda0 d0 50              BNE GeCo_45
fda2 20 f4 d8 GeCo_10   JSR Mon_CHRIN       ; parse hex constant
fda5 20 11 d9           JSR Is_Hex
fda8 90 25              BCC GeCo_30
fdaa 20 fa d8           JSR Hex_To_Bin
fdad a2 04              LDX #4
fdaf 06 c2    GeCo_20   ASL Mon_Lo
fdb1 26 c3              ROL Mon_Hi
fdb3 ca                 DEX
fdb4 d0 f9              BNE GeCo_20
fdb6 05 c2              ORA Mon_Lo
fdb8 85 c2              STA Mon_Lo
fdba 4c a2 fd           JMP GeCo_10
fdbd a6 cb    GeCo_25   LDX Mon_Tmp
fdbf e0 2d              CPX #'-'
fdc1 d0 0c              BNE GeCo_30
fdc3 a6 c3              LDX Mon_Hi
fdc5 d0 28              BNE GeCo_Ret        ; no negative 16 bit values
fdc7 48                 PHA
fdc8 a9 00              LDA #0
fdca e5 c2              SBC Mon_Lo          ; carry was set from CPX
fdcc 85 c2              STA Mon_Lo
fdce 68                 PLA
fdcf 48       GeCo_30   PHA                 ; push char after constant
fdd0 a9 24              LDA #'$'
fdd2 99 c1 02           STA Ass_Buf,Y
fdd5 c8                 INY
fdd6 98                 TYA
fdd7 18                 CLC
fdd8 69 10              ADC #16
fdda a8                 TAY
fddb a5 c3              LDA Mon_Hi
fddd 85 cc              STA Mon_ZP
fddf f0 03              BEQ GeCo_40
fde1 20 e2 f9           JSR Store_Hex
fde4 a5 c2    GeCo_40   LDA Mon_Lo
fde6 20 e2 f9           JSR Store_Hex
fde9 98                 TYA
fdea 38                 SEC
fdeb e9 10              SBC #16
fded a8                 TAY
fdee 68                 PLA                 ; pop char after constant
fdef c9 0d    GeCo_Ret  CMP #CR             ; EOI
fdf1 60                 RTS ;Size   89 [Get_Constant]
fdf2 85 cb    GeCo_45   STA Mon_Tmp         ; save sign
fdf4 c9 2b              CMP #'+'
fdf6 f0 15              BEQ GeCo_70
fdf8 c9 2d              CMP #'-'
fdfa f0 11              BEQ GeCo_70
fdfc a6 c2    GeCo_50   LDX Mon_Lo
fdfe 86 11              STX LINNUM
fe00 a6 c3              LDX Mon_Hi
fe02 86 12              STX LINNUM+1
fe04 20 0d b9           JSR Dec_Char
fe07 85 c2              STA Mon_Lo
fe09 a5 12              LDA LINNUM+1
fe0b 85 c3              STA Mon_Hi
fe0d 20 f4 d8 GeCo_70   JSR Mon_CHRIN
fe10 20 19 d9           JSR Is_Dec
fe13 b0 e7              BCS GeCo_50
fe15 90 a6              BCC GeCo_25         ; finished


              ; **************
fe17            Expand_Address
              ; **************

fe17 ac c0 02           LDY Ass_Buf_Length
fe1a b9 c0 02 ExAd_10   LDA Ass_Buf-1,Y
fe1d c9 24              CMP #'$'
fe1f f0 06              BEQ ExAd_20
fe21 99 c2 02           STA Ass_Buf+1,Y
fe24 88                 DEY
fe25 d0 f3              BNE ExAd_10
fe27 a9 30    ExAd_20   LDA #'0'
fe29 99 c1 02           STA Ass_Buf,Y
fe2c 99 c2 02           STA Ass_Buf+1,Y
fe2f ee c0 02           INC Ass_Buf_Length
fe32 ee c0 02           INC Ass_Buf_Length
fe35 60                 RTS ;Size   31 [Expand_Address]

              ; *************
fe36            Expand_Target
              ; *************

              ; Take branch offset, stored in Mon_Lo
              ; Convert it it to ASCII target of format $xxxx
              ; Store it in Ass_Buf after the branch mnemonic
              ; E.g.: BEQ $1234
              ;       ^   ^    ^
              ;       0   4    9

fe36 a9 24              LDA #'$'
fe38 8d c5 02           STA Ass_Buf+4
fe3b a0 15              LDY #21             ; 5 + 16
fe3d 20 46 fe           JSR Offset_To_Target
fe40 20 dc f9           JSR Store_Hex_XA
fe43 a0 09              LDY #9              ; length of branch instruction
fe45 60                 RTS ;Size   16 [Expand_Target]


              ; ****************
fe46            Offset_To_Target
              ; ****************

              ; Input:  Mon_Lo  = Offset
              ;         STAL    = PC
              ; Output: X       = Target Hi
              ;         A       = Target Lo

fe46 a6 fc              LDX STAL+1
fe48 a5 c2              LDA Mon_Lo
fe4a 10 01              BPL OTT_10
fe4c ca                 DEX
fe4d 18       OTT_10    CLC
fe4e 65 fb              ADC STAL
fe50 90 01              BCC OTT_20
fe52 e8                 INX
fe53 18       OTT_20    CLC
fe54 69 02              ADC #2
fe56 90 01              BCC OTT_30
fe58 e8                 INX
fe59 60       OTT_30    RTS ;Size   20 [Offset_To_Target]

fe5a                    .SIZE ;   20 [Offset_To_Target]

              ; *******
fe5a            Replace
              ; *******

fe5a 20 76 00           JSR CHRGOT
fe5d c9 22              CMP #QUOTE
fe5f f0 06              BEQ Repl_00
fe61 20 fb b4           JSR Tokenize_Line
fe64 20 70 00           JSR CHRGET
fe67 85 23    Repl_00   STA RENNEW          ; 1st. delimiter
fe69 a6 77              LDX TXTPTR
fe6b e8       Repl_01   INX
fe6c bd 00 02           LDA BUF,X
fe6f f0 4a              BEQ Repl_Err
fe71 c5 23              CMP RENNEW          ; 2nd. delimiter ?
fe73 d0 f6              BNE Repl_01
fe75 86 25              STX RENNEW+2        ; remember position
fe77 a9 00              LDA #0
fe79 9d 00 02           STA BUF,X
fe7c 8a                 TXA
fe7d 18                 CLC                 ; subtract one more
fe7e e5 77              SBC TXTPTR
fe80 85 26              STA RENNEW+3        ; length of search string
fe82 e8       Repl_02   INX
fe83 bd 00 02           LDA BUF,X
fe86 f0 33              BEQ Repl_Err
fe88 c5 23              CMP RENNEW          ; 3rd. delimiter ?
fe8a d0 f6              BNE Repl_02
fe8c a9 00              LDA #0
fe8e 9d 00 02           STA BUF,X
fe91 8a                 TXA
fe92 18                 CLC                 ; subtract one more
fe93 e5 25              SBC RENNEW+2
fe95 85 27              STA RENNEW+4        ; length of replace string
fe97 20 22 ed           JSR Reset_Renumber_Pointer
fe9a a0 03    Repl_08   LDY #3
fe9c 84 24              STY RENNEW+1        ; start position for scan
fe9e 20 35 f3 Repl_10   JSR Check_STOP_Key  ; STOP key pressed?
fea1 f0 15              BEQ Repl_Ret
fea3 20 9a ed           JSR Contains_Pattern
fea6 d0 08              BNE Repl_20
fea8 20 be fe           JSR Replace_String
feab e6 24              INC RENNEW+1
fead 4c 9e fe           JMP Repl_10
feb0 20 33 ed Repl_20   JSR Update_Link
feb3 d0 e5              BNE Repl_08
feb5 20 f0 b5           JSR Reset_Variable_Pointer
feb8 4c ff b3 Repl_Ret  JMP Basic_Ready
febb 4c 00 bf Repl_Err  JMP Syntax_Error


              ; **************
febe            Replace_String
              ; **************

febe 38                 SEC
febf a5 27              LDA RENNEW+4        ; length of replacement string
fec1 e5 26              SBC RENNEW+3        ; length of search string
fec3 85 23              STA RENNEW          ; difference
fec5 d0 20              BNE ReSt_30
fec7 98       ReSt_05   TYA
fec8 38                 SEC
fec9 e5 26              SBC RENNEW+3        ; length of search string
fecb a8                 TAY
fecc a6 25              LDX RENNEW+2        ; position of replacement
fece e8       ReSt_10   INX
fecf bd 00 02           LDA BUF,X
fed2 f0 05              BEQ ReSt_20
fed4 91 5c              STA (TMPPTC),Y
fed6 c8                 INY
fed7 d0 f5              BNE ReSt_10         ; always
fed9 a5 23    ReSt_20   LDA RENNEW
fedb f0 03              BEQ ReSt_25
fedd 20 b6 b4           JSR Rechain
fee0 20 ce ea ReSt_25   JSR List_BASIC_Line
fee3 20 1e d5           JSR Mon_Print_CR
fee6 60                 RTS ;Size   41 [Replace_String]
fee7 90 38    ReSt_30   BCC ReSt_50
fee9 98                 TYA
feea 48                 PHA
feeb a5 5c              LDA TMPPTC
feed 48                 PHA
feee a5 5d              LDA TMPPTC+1
fef0 48                 PHA
fef1 18                 CLC
fef2 98                 TYA
fef3 65 5c              ADC TMPPTC
fef5 85 5c              STA TMPPTC
fef7 90 02              BCC ReSt_35
fef9 e6 5d              INC TMPPTC+1
fefb a5 2a    ReSt_35   LDA VARTAB          ; search str < replace str
fefd 85 57              STA TMPPTB
feff 65 23              ADC RENNEW
ff01 85 55              STA TMPPTA
ff03 a4 2b              LDY VARTAB+1
ff05 84 58              STY TMPPTB+1
ff07 90 01              BCC ReSt_40
ff09 c8                 INY
ff0a 84 56    ReSt_40   STY TMPPTA+1
ff0c 20 50 b3           JSR Open_Up_Space
ff0f a5 2e              LDA STREND
ff11 85 2a              STA VARTAB
ff13 a5 2f              LDA STREND+1
ff15 85 2b              STA VARTAB+1
ff17 68                 PLA
ff18 85 5d              STA TMPPTC+1
ff1a 68                 PLA
ff1b 85 5c              STA TMPPTC
ff1d 68       ReSt_45   PLA
ff1e a8                 TAY
ff1f d0 a6              BNE ReSt_05         ; always
ff21 98       ReSt_50   TYA
ff22 48                 PHA
ff23 65 5c              ADC TMPPTC
ff25 85 55              STA TMPPTA
ff27 a5 5d              LDA TMPPTC+1
ff29 69 00              ADC #0
ff2b 85 56              STA TMPPTA+1
ff2d 38                 SEC
ff2e a5 26              LDA RENNEW+3        ; length of search string
ff30 e5 27              SBC RENNEW+4        ; length of replacement string
ff32 85 23              STA RENNEW
ff34 38                 SEC
ff35 a5 55              LDA TMPPTA
ff37 e5 23              SBC RENNEW
ff39 85 57              STA TMPPTB
ff3b a5 56              LDA TMPPTA+1
ff3d e9 00              SBC #0
ff3f 85 58              STA TMPPTB+1
ff41 a0 00              LDY #0
ff43 b1 55    ReSt_60   LDA (TMPPTA),Y
ff45 91 57              STA (TMPPTB),Y
ff47 e6 57              INC TMPPTB
ff49 d0 02              BNE ReSt_62
ff4b e6 58              INC TMPPTB+1
ff4d e6 55    ReSt_62   INC TMPPTA
ff4f d0 02              BNE ReSt_64
ff51 e6 56              INC TMPPTA+1
ff53 a5 2a    ReSt_64   LDA VARTAB
ff55 c5 55              CMP TMPPTA
ff57 d0 ea              BNE ReSt_60
ff59 a6 2b              LDX VARTAB+1
ff5b e4 56              CPX TMPPTA+1
ff5d d0 e4              BNE ReSt_60
ff5f e5 23              SBC RENNEW
ff61 85 2a              STA VARTAB
ff63 85 2e              STA STREND
ff65 8a                 TXA
ff66 e9 00              SBC #0
ff68 85 2b              STA VARTAB+1
ff6a 85 2f              STA STREND+1
ff6c 4c 1d ff           JMP ReSt_45
ff6f 60       ReSt_Ret  RTS ;Size  178 [Replace_String]

ff70 00 00 00           .FILL $ff93-* (0) ; 35 bytes

              ; ************
ff93            Basic_CONCAT
              ; ************

ff93 4c c7 da           JMP Kernal_CONCAT

              ; ***********
ff96            Basic_DOPEN
              ; ***********

ff96 4c 42 d9           JMP Kernal_DOPEN

              ; ************
ff99            Basic_DCLOSE
              ; ************

ff99 4c 07 da           JMP Kernal_DCLOSE

              ; ************
ff9c            Basic_RECORD
              ; ************

ff9c 4c af d7           JMP Kernal_RECORD

              ; ************
ff9f            Basic_HEADER
              ; ************

ff9f 4c d2 d9           JMP Kernal_HEADER

              ; *************
ffa2            Basic_COLLECT
              ; *************

ffa2 4c 65 da           JMP Kernal_COLLECT

              ; ************
ffa5            Basic_BACKUP
              ; ************

ffa5 4c 7e da           JMP Kernal_BACKUP

              ; **********
ffa8            Basic_COPY
              ; **********

ffa8 4c a7 da           JMP Kernal_COPY

              ; ************
ffab            Basic_APPEND
              ; ************

ffab 4c 77 d9           JMP Kernal_APPEND

              ; ***********
ffae            Basic_DSAVE
              ; ***********

ffae 4c 0d db           JMP Kernal_DSAVE

              ; ***********
ffb1            Basic_DLOAD
              ; ***********

ffb1 4c 3a db           JMP Kernal_DLOAD

              ; ***************
ffb4            Basic_DIRECTORY
              ; ***************

ffb4 4c 73 d8           JMP Kernal_DIRECTORY

              ; ************
ffb7            Basic_RENAME
              ; ************

ffb7 4c 55 db           JMP Kernal_RENAME

              ; *************
ffba            Basic_SCRATCH
              ; *************

ffba 4c 66 db           JMP Kernal_SCRATCH

              ; *******
ffbd            Read_DS
              ; *******

ffbd 4c 91 d9           JMP Kernal_Read_DS

              ; ****
ffc0            OPEN
              ; ****

ffc0 4c 60 f5           JMP Kernal_OPEN

              ; *****
ffc3            CLOSE
              ; *****

ffc3 4c dd f2           JMP Kernal_CLOSE

              ; *****
ffc6            CHKIN
              ; *****

ffc6 4c af f7           JMP Kernal_CHKIN

              ; ******
ffc9            CHKOUT
              ; ******

ffc9 4c fe f7           JMP Kernal_CHKOUT

              ; ******
ffcc            CLRCHN
              ; ******

ffcc 4c a6 f2           JMP Kernal_CLRCHN

              ; *****
ffcf            CHRIN
              ; *****

ffcf 4c 15 f2           JMP Kernal_CHRIN

              ; ******
ffd2            CHROUT
              ; ******

ffd2 4c 66 f2           JMP Kernal_CHROUT

              ; **********
ffd5            Basic_LOAD
              ; **********

ffd5 4c 01 f4           JMP Kernal_LOAD

              ; **********
ffd8            Basic_SAVE
              ; **********

ffd8 4c dd f6           JMP Kernal_SAVE

              ; ************
ffdb            Basic_VERIFY
              ; ************

ffdb 4c f6 f4           JMP Kernal_VERIFY

              ; *********
ffde            Basic_SYS
              ; *********

ffde 4c c3 f6           JMP Kernal_SYS

              ; ****
ffe1            STOP
              ; ****

ffe1 4c 43 f3           JMP Kernal_STOP

              ; *****
ffe4            GETIN
              ; *****

ffe4 4c 05 f2           JMP Kernal_GETIN

              ; *****
ffe7            CLALL
              ; *****

ffe7 4c a2 f2           JMP Kernal_CLALL

              ; *****
ffea            UDTIM
              ; *****

ffea 4c 68 f7           JMP Kernal_UDTIM
ffed 8c 8c 8c           .FILL $fffa-* ($8c) ; 13 bytes

              ; ***************
fffa            HardwareVectors
              ; ***************

fffa 49 fd              .WORD Entry_NMI
fffc 16 fd              .WORD Entry_RESET
fffe 42 e4              .WORD IRQ_MAIN


 1854 Symbols
-------------
Basic_USR                      $0000   252D  1107   7015
BSOS_KBD                       $0001    15D 10637  10650  10661  10720
                                     10733  10751  10764  10775  10834
                                     10847
CTRLA                          $0001   228D  9396
USRVEC                         $0001   253D  7018   7019
CTRLB                          $0002   229D  9380   9537
CHARAC                         $0003   255D  2304   2308   2309   3004
                                      3009   3013   3713   3722   4610
                                      4625   6172   6667   6724
CTRLD                          $0004   230D  9392   9547
ENDCHR                         $0004   256D  1655   1703   1706   2306
                                      2307   2310   2313   3016   4611
                                      4627
COUNT                          $0005   257D  1514   1563   1579   1670
                                      1687   1713   4079   4166   4220
                                      4244   4268   4306   4338  11202
                                     11217  11225
DIMFLG                         $0006   264D  3831   4134   4173   4217
                                      4251   4302
VALTYP                         $0007   270D  2430   2717   2997   3187
                                      3235   3257   3358   3544   3764
                                      3848   3862   4137   4169   4409
                                      4425   4670   5123
BELL                           $0007   231D  9376
INTFLG                         $0008   276D  2428   3030   3576   3849
                                      3869   4135   4171
GARBFL                         $0009   291D  1646   1658   1699   3638
                                      3641   3642   3645   4688   4725
                                      4729
TAB                            $0009   232D  9384   9533
SUBFLG                         $000a   297D  1839   1995   3866   3878
                                      3883   4469   4494
INPFLG                         $000b   301D  2832   2959   2978   2999
                                      3081
TANSGN                         $000c   311D  3333   3802   6883   6885
                                      6903   6913
DS_Len                         $000d   315
CR                             $000d   233D  1630   2740   7227   7900
                                      7930   8337   8367   8375   8377
                                      9102   9172   9360   9517  11533
                                     11766  11889  12379  13307  13711
DS_Ptr                         $000e   316
CTRLN                          $000e   234D  9378   9543
CTRLO                          $000f   235D  9382   9541
IOPMPT                         $0010   323D  1455   1459   2693   2733
                                      2807   2842   2866   2873   2886
                                      2893   2896   2920   2939   2987
                                      3087   3492   7025
DOWN                           $0011   236D  9372   9527
LINNUM                         $0011   331D  1571   1572   1749   1754
                                      1874   1875   1877   1900   1902
                                      2227   2374   2375   2377   2398
                                      2400   2402   2403   2404   2406
                                      2407   2408   2409   2411   2412
                                      2414   5233   5234   5241   5243
                                      5247y  5250   5252   5262y  5277y
                                      7030   7031   7036y  7039y  7040y
                                      7043y  7044y  7047y  7050   7052
                                      8147   8149   8788   8790   8793
                                      8800   8802   8804   8906   8909
                                      9772   9773   9775  10504  10506
                                     10602  10605  10959  10960  10977
                                     10981  10985  10988  11138  11140
                                     11410  11411  11546  11548  12603
                                     12811  13719  13721  13724
RVS                            $0012   237D  9374   9529
TEMPPT                         $0013   336D  1828   4654   4675   4997
HOME                           $0013   238D  9394   9531
DEL                            $0014   239D  9366   9521
LASTPT                         $0014   341D  4671   4993   4995   4999
                                      7026
CTRLU                          $0015   240D  9390   9545
CTRLV                          $0016   241D  9388   9535
TEMPST                         $0016   348D  1827   4655
CTRLY                          $0019   242D  9386   9539
ESC                            $001b   243D  9362
RIGHT                          $001d   244D  2811   9370   9525
INDEXA                         $001f   352D  1363   1373   1379   1519
                                      1521   1544   1546   1548y  1552
                                      1604y  1608   1611y  1613   1615y
                                      1616   1617   1618y  1673   1675
                                      1678   1680   1683y  1714y  1716
                                      1718   1721y  1964   1966   1970
                                      1972   1973y  1977y  2501y  2575
                                      2576   2589   2591   2622y  2626y
                                      2629y  2636   2637   2641   2643
                                      2794y  3240   3242   3297   3299
                                      3314   3316   3981   3982   3984y
                                      3987y  3990y  3994y  4002y  4006
                                      4007   4009   4010   4016y  4020y
                                      4024y  4033   4036   4040   4041
                                      4043   4267   4335   4368   4695
                                      4698   4703   4715y  4718y  4770
                                      4772   4775y  4785   4789y  4800y
                                      4810y  4813y  4903   4904   4914y
                                      4947   4948   4958   4959   4974y
                                      4977y  4980y  4982   4983   5041
                                      5042   5044   5134y  5174   5177
                                      5179   5690   5691   5693y  5696y
                                      5699y  5702y  5710y  5890   5891
                                      5893y  5945   5946   5949y  5952y
                                      5955y  5960y  5963y  8609y  8725y
                                      8731   8733   8743   8744  10153
                                     10156  12300  12302
RENINC                         $0021   360D  8780   8783   8801   8805
                                      8855   8858   9764   9766   9782y
                                      9785   9789   9790
INDEXB                         $0021   356D  1523   1530   1542   1549y
                                      1553   3128   5178   5183   5185y
                                      5188y  5193y  6075   6081   6083y
                                      6087y  6092y  6097y  6101y  6107
QUOTE                          $0022   245D  1937   1946   2316   2905
                                      3010   3377   4609   4629   7530
                                      7534   8529   8636   9189   9193
                                     11087  11093  11319  11342  13800
FAC3M1                         $0023   364D  5523   5526   5625   5666
                                      5668   5669   5876
RENNEW                         $0023   373D  8781   8784   8789   8794
                                      8814   8817   8845   8848   8854
                                      8856   8857   8859   8928   8940
                                     11240  11243  11257  11262  11266
                                     13804  13809  13811  13817  13821
                                     13827  13828  13831  13837  13851
                                     13852  13853  13857  13859  13866
                                     13887  13914  13915  13916  13919
                                     13939
FAC3M2                         $0024   365D  5521   5524   5626   5663
                                      5665   5670   5878
FAC3M3                         $0025   366D  4349   4370   4395   5519
                                      5522   5627   5660   5662   5671
                                      5880
FAC3M4                         $0026   367D  4378   4398   5517   5520
                                      5628   5657   5659   5672   5825
                                      5882
FAC3M5                         $0027   369
TXTTAB                         $0028   377D  1598   1599   1735   1736
                                      1778y  1780y  1781   1785   1847
                                      1850   2132   2134   2236   2237
                                      6355   6356   7029   7035   7062
                                      7065  10148y 10150y 10530  10533
                                     10591  10592  11168  11170  12212
                                     12213  12613  12615
VARTAB                         $002a   381D  1520   1528   1529   1531
                                      1533   1538   1561   1565   1577
                                      1578   1784   1787   1815   1816
                                      2547   2551   3884   3885   6366
                                      6368   8950   8951   9779  12135
                                     12138  12156  12158  12609  12611
                                     13885  13889  13896  13898  13933
                                     13936  13940  13944
ARYTAB                         $002c   385D  1817   1818   3888   3890
                                      3949   3950   3967   3968   4174
                                      4175
STREND                         $002e   389D  1358   1359   1575   1576
                                      1819   1820   3953   3954   3977
                                      3979   4178   4180   4280   4281
                                      4294   4298   4415   4418   4706
                                      4709  11277  11399  11478y 11509y
                                     13895  13897  13941  13945
FRETOP                         $0030   393D  1422   1425   1434   1437
                                      1808   1809   2540   2544   2631
                                      2634   4027   4030   4414   4417
                                      4693   4696   4721   4722   4746
                                      4748   4816   4818   4960   4962
                                      4967   4970   7055   7056  11286
FRESPC                         $0032   397D  4711   4712   4719   4720
                                      4740   4743   4780   4782   4783
                                      4786y  4788   4790   4792   4796
                                      4803y  4807y  4809   4812   4815
                                      4817   4915y  4920   4921   4923
MEMSIZ                         $0034   401D  1806   1807   4739   4742
                                      7053   7054   7060   7064
CURLIN                         $0036   407D  1473   1497   2014   2016
                                      2069   2072   2155   2160   2161
                                      2186   2187   2208   2210   2226
                                      2266   2268   2839   2840   3146
                                      3148   4448   6382   6383
OLDLIN                         $0038   412D  2162   2163   2184   2185
OLDTXT                         $003a   419D  1838   2058   2059   2158
                                      2159   2178   2181   2849   2850
DATLIN                         $003c   427D  2837   2838   3066   3070
DATPTR                         $003e   433D  2137   2138   2949   2950
INPPTR                         $0040   439D  2960   2961   2972   2973
                                      3043   3044   3079   3080   3085
VARNAM                         $0042   449D  3542   3543   3837   3870
                                      3871   3876   3892   3895   3930
                                      3931   4047   4050   4142   4144
                                      4148   4150   4185   4187   4233
                                      4238   4342   4345
VARPTR                         $0044   455D  4069   4070   4354   4357
                                      4359   4476   4478   4516   4521
                                      4523y  4527   4538   4540   6541
                                      6553
FORPNT                         $0046   460D  1329   1332   1334   1337
                                      2039   2041   2254   2424   2425
                                      2448y  2451y  2461   2580   2583
                                      2588   2590   2604y  2966   2967
                                      3116   3117   3135   3136   5270
                                      5275   5278   5279   5937   5938
YSAVE                          $0048   466D  2970   2971   3045   3046
                                      3251   3330
ACCSYM                         $004a   470D  3214   3223   3224   3226
                                      3230   3265   3280   3765
FUNCPT                         $004b   476D  4496   4497   4511   4513
                                      4515y  4519y  4533y  4536y  4544
                                      4546   4556y  4559y  4562y  4565y
                                      4568y  4741   4744   4747   4749
                                      4752   4754   4756   4759y  4763
                                      4764y  4765   4767   4771y  4774
                                      4776   4778   4794   4797   4802y
                                      4806y  6656   6657   6662   6663
                                      6672   6673   6905   6906   6915
                                      6916
DESCPT                         $004d   480D  2573   2574   2603y  4592
                                      4593   4874   4875   5024y  5027y
                                      5034   5035   5055y  5077y  5099
                                      5101
INDEXC                         $004f   484D  2581y  2584y  2595y  2598y
                                      2642   2645   4954y  4957y  4965
                                      4968
JUMPER                         $0051   489D  3698   7014
FUNJMP                         $0052   494D  3695   3697   5093   5102
                                      5324   5354   5368   5419   6717
                                      6734
FACTPA                         $0054   499D  5929   5930   6756   6759
                                      6760   6908   6909
TMPPTA                         $0055   500D  1378   1380   1382   1385y
                                      1389y  1391   1564   1569   3961
                                      3962   3964   3965   3969   3970
                                      3975   3976   3991   3992   3995
                                      3996   4011   4013   4086   4087
                                      4270   4272   4275   4287y  4289
                                      4292   4353   4356  13888  13893
                                     13909  13912  13918  13921  13925y
                                     13930  13932  13934  13937
TMPPTB                         $0057   501D  1361   1365   1371   1374
                                      1376   1384y  1388y  1390   1562
                                      1566   3955   3956   4021   4026
                                      4034y  4037y  8813y  8816y 10535
                                     10537  10593  10594  10608  10610
                                     13886  13890  13920  13923  13926y
                                     13927  13929
FACTPB                         $0059   506D  5922   6794   6795
TMPVAR                         $005a   507D  3553   3557   4380   4401
                                      6191   6223   6230   6232   6233
                                      6238   6243   6255   6280   6290
                                      6297   6417   6449   6458   6464
                                      6480   6491   6492   6547   6574
                                      6579
TMPPTC                         $005c   508D  1362   1366   1518y  1522
                                      1524   1526y  1534   1537   1582y
                                      1743   1744   1745y  1750y  1755y
                                      1759y  1885y  1893y  1896y  1914y
                                      1917y  1918   1919   1943y  1952y
                                      2240   2243   3886   3887   3893y
                                      3897y  3902   3951   3952   4048y
                                      4051y  4054y  4056y  4058y  4060y
                                      4062y  4063   4066   4082   4083
                                      4176   4177   4183y  4188y  4191y
                                      4193   4196y  4197   4222y  4234y
                                      4239y  4248y  4260y  4263y  4295
                                      4297y  4300   4301y  4305y  4316y
                                      4321y  4369y  4372y  6216   6219
                                      6226   6227   6253   6284   8833y
                                      8839y  8842y  8890y  8893y  8900y
                                      8903y  8939y  8946   8949   9763
                                      9765   9781y  9786   9787  10529
                                     10532  10536  10538  10558y 10561y
                                     10562  10563  10576y 10579y 10582y
                                     10595  10596  10598y 10601y 10604y
                                     10607  10609  10613y 10616y 11075
                                     11078  11169  11171  11188y 11191y
                                     11192  11193  11264y 11267y 13863y
                                     13875  13877  13881  13882  13884
                                     13900  13902  13908  13910
FAC1EX                         $005e   512D  2330   2468   2568   2569
                                      3312   3348   3767   3777   3781
                                      4117   4602   4632   4659   4825
                                      5227   5306   5345   5348   5355
                                      5362   5415   5443   5447   5454
                                      5587   5591   5712   5722   5729
                                      5762   5803   5804   5806   5894
                                      5903   5962   5980   5997   6008
                                      6025   6059   6090   6123   6160
                                      6165   6275   6434   6684   6719
                                      6729   6730   6843   6846   6949
FAC1M1/FAC1M2                  $005f   513D  2023   2024   3310   3613
                                      3768   3794y  4426   4600   4619
                                      4661   5014y  5381   5395   5398
                                      5430   5432   5440   5456   5475
                                      5477   5503   5637   5811   5849
                                      5877   5899   5902   5910   5959
                                      6044   6048   6094   6133   6389
                                      6523   6525   6816   6834   6836
                                     11141    514D  2490   3308   3769
                                      4427   4601   4620   4663   5378
                                      5397   5400   5427   5429   5439
                                      5457   5478   5480   5501   5635
                                      5814   5846   5879   5911   5954
                                      6046   6098   6134   6390   6520
                                      6522   6818   6837   6839  11139
FAC1M3/FAC1M4                  $0061   515D  2447   2531y  2534y  2550
                                      2553   2560y  2565   2670   2671
                                      3306   3410   3540   3579y  3582y
                                      3654   3681   3715   3727   3732
                                      4158   4313   4332   4590   4666
                                      4857   4868y  4936   5158   5231
                                      5375   5399   5402   5424   5426
                                      5438   5458   5481   5483   5499
                                      5633   5817   5843   5881   5912
                                      5951   6058   6102   6135   6517
                                      6519   6820   6838   6840    516D
                                      2354   2450   2546   2554   2566
                                      2667   2668   3304   3407   3541
                                      3546   3591   3655   3679   3717
                                      3724   3729   4160   4315   4336
                                      4591   4667   4855   4937   5064
                                      5080   5082   5160   5232   5372
                                      5401   5404   5421   5423   5437
                                      5459   5484   5486   5497   5631
                                      5820   5840   5883   5913   5948
                                      6057   6108   6136   6166   6171
                                      6514   6516   6822   6833   6835
FAC1SI                         $0063   517D  2021   2036   2469   2663
                                      3134   3301   3346   3783   3789
                                      4110   5225   5301   5303   5350
                                      5416   5467   5469   5704   5732
                                      5734   5900   5957   5977   6027
                                      6061   6068   6088   6110   6141
                                      6167   6273   6423   6427   6686
                                      6688   6842   6877   6881   6912
                                      6945   6948   6965
SGNFLG                         $0064   518D  6199   6246   6776   6796
BITS                           $0065   520D  4827   4833   4834   6130
FAC2EX                         $0066   524D  3335   3758   3759   5325
                                      5326   5363   5365   5711   5719
                                      5979   5998   6653   6728   6731
FAC2M1                         $0067   525D  3337   3756   3757   5431
                                      5667   5708   5810   5834   5848
                                      5850
FAC2M2                         $0068   526D  3339   5428   5664   5700
                                      5813   5833   5845   5847
FAC2M3/FAC2M4                  $0069   527D  3341   3770   3773   3793y
                                      5425   5661   5697   5816   5832
                                      5842   5844    528D  3343   3771
                                      3774   5422   5658   5694   5819
                                      5831   5839   5841
FAC2SI                         $006b   529D  3345   3754   5304   5349
                                      5703   5706   5971   6272   6659
                                      6867
STRPTR/FROUND                  $006c   533D  2532   2535   2539   2543
                                      2562   2563   3347   4617   4618
                                      4623y  4634   4636   4640   4646
                                      4647   4862   4864   4866y  4878
                                      4879   4889y  4892y  4895y  5305
                                      5360   5705   5731   5760   5785
                                      6274   6742   6872    538D  4668
                                      4832   5323   5358   5369   5403
                                      5405   5420   5436   5460   5487
                                      5489   5490   5518   5539   5629
                                      5673   5861   5898   5964   5983
                                      6001   6010   6060   6106   6137
                                      6138   6146   6713   6735   6844
TMPPTD                         $006e   542D  1668   1688   2470   2473
                                      2474   2482   3555   4231   4243
                                      4265   4266   4283   4284   4290
                                      4308   4309   4326   4327   4337
                                      4340   4390   4391   4635   4639
                                      5172   5173   5199   5200   6428
                                      6496   6505   6542   6552   6565
                                      6753   6754   6767   6768   6775y
                                      6777   6781   6782   6783   6785
                                      6786   6791   6792
CHRGET                         $0070   562D  1493   1869   2033   2112
                                      2358   2381   2777   2862   2996
                                      3161   3227   3359   3369   3455
                                      3483   3670   3850   3855   3875
                                      4102   5145   6200   6206   6217
                                      7022   8550   8600   8621   8629
                                      8696   8753   8798   8809   9770
                                     11132  11224  11239  12803  12902
                                     13803
CHRGOT                         $0076   563D  1865   2030   2122   2214
                                      2325   2339   2699   2976   3035
                                      3049   3158   3215   3486   3816
                                      3825   3838   4163   4547   5065
                                      5161   5189   5272   7674   7691
                                      7701   8509   8616   8663   8785
                                      8795   8806   9760   9767  10450
                                     11156  12310  12326  12926  13799
TXTPTR                         $0077   564D  1491   1492   1644   1671
                                      1712   1726   1728   1849   1852
                                      2009   2011   2054   2057   2061y
                                      2064y  2068y  2071y  2074   2075
                                      2077   2153   2154   2182   2183
                                      2204   2206   2231   2232   2242
                                      2245   2270   2272   2286   2287
                                      2289   2311y  2851   2852   2968
                                      2969   2974   2975   2991   2992
                                      3002   3017   3018   3041   3042
                                      3047   3048   3062y  3065y  3068y
                                      3071y  3150   3152   3202   3204
                                      3205   3260   3262   3263   3384
                                      3385   3453y  4480   4482   4529
                                      4531   4534   4537   4551   4553
                                      5170   5171   5175   5180   5201
                                      5202   6294y  6992   6994   8590
                                      8592   8593y 10444  10449  11054
                                     11056  11057x 11077  11080  11204
                                     11216  11256  12035  12821y 12842
                                     12843y 12853y 12929  12931y 12936
                                     12938  13805  13816
ISNUM                          $007d   565D  2502
RNDX                           $0088   569D  6824   6825   6848   6849
JIFFY_CLOCK                    $008d   578D  2491   3608   3609   9964
                                     12706  12708  12710  12711  12714
                                     12718  12719
CINV                           $0090   586D  7120   7122   7471   7473
                                      9727   9971   9973  13639  13641
CBINV                          $0092   594D  9726  13588  13590  13658
NMINV                          $0094   599D 13584  13586  13606
STATUS                         $0096   610D  2922   3495   3624   6360
                                      7878   7888   8392   9800  11282
                                     11292  11475  11480  11499  11511
                                     11552  11589  11607  11862  11887
                                     12055  12068  12088  12198  12240
                                     12261  12275  12347  12739  12750
                                     12778  12790  12918  13421  13422
Key_Index                      $0097   615D 10257  10290  10316
Key_Flags                      $0098   624D  6344   9967  10253  10255
                                     10295  10296  10370
Power_Flag                     $0099   629D  9653  10427  10429  10486
                                     10520
Default_Bank                   $009a   636D  9969  11018  11039
Stop_Flag                      $009b   641D 10361  12007
Source_Unit                    $009c   646D  8205   8506   8567   8570
                                     11388  11468  11535  11584
VERCK                          $009d   651D  7522   7542   7567   8308
                                     12071  12125  12132  12149  12186
                                     12259  12820
CharsInBuffer                  $009e   655D  9067   9069   9079   9096
                                     10346  10353  11865  12012  12892
                                     13325
ReverseFlag                    $009f   659D  9200   9415   9563   9664
C3PO                           $00a0   663D 11664  11670  11795  11797
LastInputCol                   $00a1   665D  9112   9120   9168  11885
InputRow                       $00a3   666D  9115   9637  11879
InputCol                       $00a4   667D  9118  11877
BSOUR                          $00a5   678D 11675  11691  11715  11786
                                     11802
SFDX                           $00a6   704D 10258  10362
BLNSW                          $00a7   711D  9080   9734   9995
BLNCT                          $00a8   718D  9088   9208   9736   9739
                                      9994
GDBLN                          $00a9   727D  9089   9745
BLNON                          $00aa   734D  9083   9086   9741   9744
Wedge_Unit                     $00ab   739D  7033  12805  12812  12915
                                     12940  13626  13628
CRSW                           $00ac   744D  9105   9142   9171   9354
                                     11883
Target_Unit                    $00ad   746D 11387  11436  11494  11528
                                     11602
LDTND                          $00ae   753D  7987   8116  11914  11943
                                     11989  11990  11992  12345  12350
DFLTN                          $00af   757D 11863  11874  11924  11936
                                     12753
DFLTO                          $00b0   761D  9174   9977  11900  11920
                                     11934  12793
DOS_FC                         $00b1   771D 11355  11416  11486  11514
DOS_EOF                        $00b2   772D 11481  11517
PC_Adjust                      $00b3   773D  7103   7115   7131   7341
                                     12400  12402
SCROLLING                      $00b4   774
MONCNT                         $00b5   775D  7173   7182   7185   7201
                                      7333   7336   7439   7453  13551
                                     13562
R_Bank                         $00b6   780D  7126   7314   7427   7914
                                      8827   8924  10972  11013
W_Bank                         $00b7   781D  7128   7316   7429   7922
                                      8828   8884  11033  13452
ZP_b8                          $00b8   782
DOS_RL                         $00b9   783D  9808   9812   9814  11409
                                     11424  11447  11459  11483  11488
                                     11500  11519  11593
Dis_Line                       $00ba   784D  7354   7356   7358   7396
                                      7409   9899  13284
DosPtr                         $00bb   785D 11309  11311  11313  11318y
                                     11325  11327  11398  11402
Mon_Format                     $00bd   786D 12483  13118
Dis_Length                     $00be   787D 12417  12427  12485  13121
                                     13129  13289
Mon_A                          $00bf   788D 12682  12688  13119  13134
                                     13139  13454  13458  13492  13498
                                     13502  13505
Mon_B                          $00c0   789D 12684  12687
Mon_Op                         $00c1   790D 12411  12440  13242  13263
                                     13276  13290  13293
Mon_Lo                         $00c2   791D 13137  13222  13226  13243
                                     13675  13679  13680  13689  13690
                                     13704  13718  13723  13780
Mon_Hi                         $00c3   792D 13132  13219  13244  13676
                                     13685  13700  13720  13725
ScrPtr                         $00c4   797D  9091y  9107y  9150y  9206y
                                      9253y  9320y  9322y  9329y  9448y
                                      9486y  9491y  9494y  9498y  9611y
                                      9674y  9742y  9747y 10085  10089
                                     10496y 10546
CursorCol                      $00c6   798D  2750   2769   4435   9012
                                      9090   9119   9149   9166   9219
                                      9245   9264   9300   9303   9317
                                      9319   9355   9407   9490   9581
                                      9582   9609   9655   9740   9833
                                      9836  10490  10510  10524  10544
                                     11876
SAL                            $00c7   800D  9029   9030   9031y  9673y
                                     10059  10063
EAL                            $00c9   801D  6357   6358   6365   6367
                                      7564  11279  11281  11284  11289
                                     11291y 12053  12054  12061  12063
                                     12073y 12078y 12079y 12080y 12082
                                     12084  12137  12140  12155  12157
                                     12168  12170  12214  12215  12610
                                     12612  12650  12652
Mon_Tmp                        $00cb   803D  7447   7450   7656   7661
                                     13682  13713
Mon_ZP                         $00cc   804D 13278  13280  13701
QTSW                           $00cd   824D  9114   9162   9191   9192
                                      9368   9519   9665  10584
BITTS                          $00ce   826
EOT                            $00cf   827
ZD0                            $00d0   828
FNLEN                          $00d1   830D  6351   7547   8230   8447
                                      8503   8605   9817  11347  11414
                                     11446  11449  11450  11461  11462
                                     11576  12047  12199  12229  12248
                                     12276  12299  12636  12935  13408
LA                             $00d2   831D  7680   7870   8107   8131
                                      8499   8543  11960  11972  12280
                                     12335  12351
SA                             $00d3   832D  6354   7524   7560   7868
                                      7993   8051   8145   9804   9921
                                      9941  11472  11497  11506  11531
                                     11538  11587  11605  11962  12049
                                     12102  12105  12142  12201  12211
                                     12232  12274  12286  12353  12355
                                     12635  12640  12669  12748  12788
                                     13372
FA                             $00d4   833D  7553   8045   8048   8115
                                      8207   8508   8709  11386  11389
                                     11437  11469  11495  11529  11536
                                     11585  11603  11674  11964  12043
                                     12203  12208  12283  12357  12630
                                     12752  12792  12916  12941  13613
RigMargin                      $00d5   835D  9104   9209   9242   9254
                                      9283   9301   9324   9406   9449
                                      9485   9501   9574   9675  10499
                                     10547  11884
TAPE1                          $00d6   836
CursorRow                      $00d8   837D  9005   9018   9116   9240
                                      9243   9435   9456   9572   9593
                                      9595   9623   9638   9643  10488
                                     10501  10512  10522  10541  10564
                                     11878
DATAX                          $00d9   838D  9155   9157   9158   9177
                                      9182   9341   9356
FNADR                          $00da   839D  6347   6349   7505   7507
                                      7536y  8232   8234   8449   8451
                                      9819y 11326  11328  11331y 11335y
                                     11338y 11341y 11350y 11365y 11420y
                                     11427y 11432y 11442  11562y 11567y
                                     11574y 11592y 11610y 12245y 12301
                                     12303  12937  12939
INSRT                          $00dc   840D  9203   9205   9364   9500
                                      9503   9523   9663
ROPRTY                         $00dd   841
FSBLK                          $00de   842
ScreenRows                     $00df   843D  9046   9275  10000
TopMargin                      $00e0   844D  8993   9004   9239   9273
                                      9290   9436   9454   9457   9592
                                      9621   9624   9627   9687   9700
                                     10463  10474  10542  10550  10553
                                     10556
BotMargin                      $00e1   845D  8996   9282   9573   9639
                                      9685   9702  10462  10475  10492
LefMargin                      $00e2   846D  9011   9218   9238   9263
                                      9274   9291   9316   9437   9580
                                      9608   9654  10074  10443
XMAX                           $00e3   847D  9975  10347
LSTX                           $00e4   848D 10318  10323  10340
KOUNT                          $00e5   849D  9997  10329  10335
DELAY                          $00e6   850D  9996  10325  10327  10342
CHIME                          $00e7   851D 10016  10029  10038
PrevChar                       $00e8   857D  9230   9461   9963
SCRIV                          $00e9   859D  9136  10009  10010
SCROV                          $00eb   860D  9346  10013  10014
JIFFY6                         $00f8   861D 12720  12723
BPTR                           $00f9   862D  7441   7443   8916   8926
                                      8929   9855   9866   9868  11037y
                                     11178  11180  13286  13288  13358
                                     13359  13361  13435  13450  13473
                                     13475  13501  13503  13504  13506
                                     13515  13517  13518
STAL                           $00fb   863D  7210   7212   7344   7346
                                      7366   7368   7440   7442   7591
                                      7593   7626   8933   8935   8942
                                      8947   9925y  9944y 10969  10971
                                     11016y 12614  12616  12642  12643
                                     12649  12654y 12660  13223  13285
                                     13287  13314  13318  13340  13341
                                     13343  13455  13474  13476  13488
                                     13490  13494  13496  13511  13513
                                     13514  13779  13784
MEMUSS                         $00fd   864D  7365   7367   7398   7399
                                      7406   8233   8235   8246y  8659
                                      8660   9858   9865   9867  13432
                                     13487  13489  13491  13493  13495
                                     13497
STACK                          $0100   865D  1326   1331   1333   1335
                                      1338   3130   3133   3139   3143
                                      3145   3147   3149   3151   4154
                                      4156   4159   4161   4582   4583
                                      6426   6499   6504   6546   6551
                                      6566   6582   6584   6592   6594
                                      6596   6599   6601   9723  11149
BUF                            $0200   866D  1558   1573   1574   1581
                                      1632   1647   1681   1691   1692
                                      1704   1709   1723   1725   2730
                                      2731   2732   2867   2868   2870
                                      2918   2927   2981   2982   2983
                                     11208  11260  13807  13813  13819
                                     13824  13861
LAT                            $0251   867D  8121  11946  11959  11993
                                     11994  12352
FAT                            $025b   868D  8119  11963  11995  11996
                                     12358
SAT                            $0265   869D  7990  11961  11997  11998
                                     12356
KEYD                           $026f   870D  9062   9064   9065   9098
                                     10352  12894  13311  13313  13316
                                     13317  13320  13321  13323
Bank_Fetch                     $027a   881D   880   7176   7189   7449
                                      8938  10974  10980  10984  10987
                                     11003  12439  13292  13451  13453
                                     13456  13457  13478  13507  13558
Bank_Store                     $028b   880D  7448   8840   8843   8846
                                      8849   8877   8891   8894   8907
                                      8910   9871  11085  11091  11100
                                     11116  11151  11157  13291  13479
                                     13508
Mon_Register                   $02a0   882D  7106   7108   7110   7112
                                      7116   7119   7121   7123   7125
                                      7127   7129   7209   7211   7315
                                      7317   7321   7323   7326   7328
                                      7332   7343   7345   7422   7426
                                      7428   7466   7468   7470   7472
                                      7479   7481   7483   7485   7487
                                      7488   7489   7496
Dis_Buf_Length                 $02b0   883D 13153  13193  13269
Dis_Buf                        $02b1   884D 12693  13124  13142  13146
                                     13175  13180  13190  13274
Ass_Buf_Length                 $02c0   885D 13262  13268  13736  13746
                                     13747
Ass_Buf                        $02c1   886D 13207  13211  13214  13251
                                     13259  13273  13694  13737  13740
                                     13744  13745  13762
Ass_Index                      $02d0   887D 13265  13305
Ass_Dollar                     $02d1   888D 13245
Ass_Length                     $02d2   889D 13246
DOS_Tmp                        $033a   895D  7673   7700   8151   8231
                                      8243   8250   8504   8658  11413
DOS_Drive_1                    $033b   896D  8433   8501   8578  11590
DOS_Drive_2                    $033c   897D  8437   8502   8579   8647
                                     11333  11608
DOS_Attr                       $033d   898D  8422   8458   8463   8500
                                      8558   8584   8599
DOS_Flags                      $033e   911D  7723   7727   7744   7753
                                      7763   7856   8007   8166   8182
                                      8282   8498   8537   8548   8572
                                      8602   8641   8655   8672   8679
                                      8680   8728
DOS_Id                         $033f   912D  8083   8263   8266   8505
                                      8594
DOS_Command_Length             $0341   913D  8407   8409   8606   8612
DOS_Filename                   $0342   914D  7504   7506   8610  13404
                                     13538  13547  13559
DOS_Command_Buffer             $0353   915D  8014   8144   8146   8148
                                      8150   8152   8247   8264   8267
                                      8286   8439   8448   8450   9886
                                      9891   9915  10208  10219  11391
DOS_Status                     $03ad   916D  3567   3568   3643   8055
                                      8062   8064   8345   9805
TABS_SET                       $03ee   917D  9587   9589   9842  10004
Reset_Vector                   $03fa   918D 13592  13594
Ignore_Timeout                 $03fc   919D 11731  11740  13596
SCREEN_RAM                     $8000   920
Basic_Statement_Table          $b000  1043D  2108   2110
Basic_Function_Table           $b066  1101D  3694   3696
Basic_Operator_Table           $b094  1131D  3245   3267   3275   3277
                                      3289
Basic_Keyword_Table            $b0b2  1148D  1672   1674   1963   1965
Msg_Start                      $b20d  1247D  1447   1462   1636   2259
                                      2261   2844   3192   3461   4204
                                      4211   4216   4451   4458   4657
                                      4724   4870   5510   5869   8689
                                      8741
Msg_SYNTA                      $b21d  1251D  3461
Msg_GOSUB                      $b223  1252D  2259
Msg_QUANT                      $b242  1254D  4211   8689
Msg_FLOW                       $b252  1255D  5510
Msg_OOM                        $b25a  1256D  1447   4724
Msg_UNDEF                      $b267  1257D  2261
Msg_SUBSC                      $b278  1258D  4204
Msg_REDIM                      $b285  1259D  4216
Msg_DIV                        $b292  1260D  5869
Msg_DIREC                      $b2a2  1261D  4451
Msg_TYPE                       $b2b0  1262D  3192
Msg_LONG                       $b2bd  1263D  1636   4870   8741
Msg_DATA                       $b2cc  1264D  2844
Msg_COMPL                      $b2d5  1265D  4657
Msg_FUNC                       $b2f6  1267D  4458
Msg_ERR                        $b306  1268D  1470   1471
Msg_IN                         $b30d  1269D  6379   6380
Msg_READY                      $b312  1274D  1482   1483
Msg_BREAK                      $b31b  1280D  2166   2167
Find_Active_FOR                $b322  1314D  1997   2255   3118
FAF_10                         $b327  1326D  1344
FAF_20                         $b33c  1335D  1330
FAF_30                         $b348  1340D  1336
FAF_Ret                        $b34f  1345D  1328   1339
Open_Up_Space                  $b350  1348D  1570   3963  13894
OUS_10                         $b374  1378D  1375
OUS_20                         $b380  1384D  1387
OUS_30                         $b384  1386D  1381   1383   1393
OUS_40                         $b38b  1390D  1370
Check_Stack_Avail              $b393  1397D  2005   2203   3211
BSOS_Bank_Init                 $b399  1406D  9968
Check_Mem_Avail                $b3a0  1414D  1357   4229   4279
CMA_10                         $b3aa  1427D  1424
CMA_Ret                        $b3bd  1439D  1423   1426   1435
Error_Out_Of_Memory            $b3cd  1444D  1402   1436   1438   4324
                                      8919  11288
Basic_Error                    $b3cf  1450D  1637   2180   2262   2845
                                      3193   3462   4212   4459   4658
                                      4871   5511   5870   8690   8742
Berr_10                        $b3da  1460D  1456
Berr_20                        $b3e0  1462D  1468
Berr_30                        $b3ed  1469D 12384
Berr_40                        $b3f4  1472D  2169
Basic_Ready                    $b3ff  1479D  1475   1924   2170   7073
                                      7084   7086   7498   8954  11250
                                     12809  12813  12866  12875  13583
                                     13585  13842
Get_Basic_Statement            $b406  1487D  1495   1559   1592
New_Basic_Line                 $b41f  1504D  1498
NBL_10                         $b45a  1543D  1540
NBL_20                         $b462  1548D  1545   1551   1555
NBL_30                         $b470  1556D  1516
NBL_40                         $b48b  1569D  1567
NBL_50                         $b4a5  1581D  1584
Reset_And_Rechain              $b4ad  1587D 12159
Rechain                        $b4b6  1595D  1557   1591   6370   8953
                                     10151  13868
Rech_10                        $b4be  1602D  1619
Rech_20                        $b4c0  1603D  1605
Rech_30                        $b4d4  1616D  1601
Read_String                    $b4e2  1625D  2943  10428
ReaS_10                        $b4e4  1629D  1635
ReaS_20                        $b4f8  1638D  1631
Tokenize_Line                  $b4fb  1641D  1513  11238  12835  13802
ToLi_01                        $b501  1647D  1652   1702
ToLi_02                        $b50d  1653D  1648
ToLi_03                        $b523  1664D  1661
ToLi_04                        $b52b  1668D  1665
ToLi_05                        $b53d  1677D  1684
ToLi_06                        $b544  1681D  1676   1679   1722
ToLi_07                        $b552  1688D  1724
ToLi_08                        $b554  1689D  1650   1654   1659   1663
                                      1667   1705   1707
ToLi_09                        $b567  1699D  1696
ToLi_10                        $b569  1700D  1698
ToLi_11                        $b570  1704D  1711
ToLi_12                        $b579  1708D  1657
ToLi_13                        $b580  1712D  1686
ToLi_14                        $b584  1714D  1720
ToLi_15                        $b58d  1719D  1717
ToLi_16                        $b599  1725D  1693
Find_BASIC_Line                $b5a3  1732D  1515   1864   9762   9776
Find_BASIC_Line_AX             $b5a7  1739D  1760   2238
FBL_10                         $b5c5  1758D  1752
FBL_30                         $b5cb  1761D  1746
FBL_Ret                        $b5cc  1762D  1751   1756   1757   1770
Basic_NEW                      $b5d2  1767D  1080
Perform_NEW                    $b5d4  1773D  7070
Reset_BASIC_Execution          $b5e9  1790D  1556   1590   2195   6369
                                      8952
Basic_CLR                      $b5ee  1797D  1074
Reset_Variable_Pointer         $b5f0  1803D  2196  13841
RVP_10                         $b60b  1821D 12161
Flush_BASIC_Stack              $b60e  1824D  1469   7012
FBS_Ret                        $b621  1840D  1800
Reset_BASIC_Exec_Pointer       $b622  1843D  1793  12160
RBEP_Ret                       $b62f  1853D  1862   1868   1871
Basic_LIST                     $b630  1856D  1073
LIST_10                        $b638  1863D  1859   1860
LIST_15                        $b64f  1872D  1866
LIST_20                        $b659  1881D  1876   1920
LIST_25                        $b674  1904D  1901
LIST_30                        $b676  1909D  1903
LIST_60                        $b679  1913
LIST_50                        $b686  1924D  1886   1904
List_Line                      $b689  1929D  1909  10583
LiLi_08                        $b690  1936D  1954   1956
LiLi_10                        $b697  1942D  1947
LiLi_20                        $b6a3  1951D  1938   1985
LiLi_30                        $b6bb  1968D  1975
LiLi_40                        $b6be  1970D  1974
LiLi_50                        $b6c4  1973D  1971
LiLi_60                        $b6ca  1976D  1969   1982
LiLi_Ret                       $b6da  1986D  1944   1953
Basic_FOR                      $b6de  1991D  1047
FOR_10                         $b6ef  2003D  1998
FOR_30                         $b72f  2035D  2032
Execute                        $b74a  2050D  2045   2089   2216   3153
                                      6371
Exec_10                        $b759  2060D  2056
Start_Program                  $b77c  2084D  1501   2076   2115  12836
Interpret                      $b785  2092D  2088   2342
Inpr_10                        $b787  2099D  2357
Inpr_20                        $b795  2106D  2102
Inpr_30                        $b7a2  2113D  2100
Inpr_40                        $b7a5  2114D  2062
Inpr_50                        $b7a9  2116D  2104
Basic_GO                       $b7ac  2119D  1081
Basic_RESTORE                  $b7b7  2128D  1058   1821
REST_10                        $b7c1  2137D  2135   3083
REST_Ret                       $b7c5  2139D  2098
Basic_STOP                     $b7c6  2142D  1062  12021
Basic_END                      $b7c8  2148D  1046
END_10                         $b7c9  2152D  2145
END_20                         $b7d8  2160D  2931
END_30                         $b7e0  2164D  2157
END_40                         $b7e2  2166D  2066
END_50                         $b7eb  2170D  2168
Basic_CONT                     $b7ee  2173D  1072
CONT_10                        $b7f9  2181D  2179
CONT_Ret                       $b807  2188D  2152   2176
Basic_RUN                      $b808  2191D  1056
RUN_10                         $b80a  2195
RUN_20                         $b80d  2196D  2194
Basic_GOSUB                    $b813  2200D  1059
GOSUB_10                       $b825  2214D  2197
Basic_GOTO                     $b830  2221D  1055   2125   2215   2341
GOTO_10                        $b847  2236D  2228
GOTO_20                        $b84b  2238D  2233   2235
GOTO_Ret                       $b85c  2246D  2252
Basic_RETURN                   $b85d  2249D  1060
RET_10                         $b86e  2261D  2239
RET_20                         $b873  2263D  2353
RET_30                         $b876  2264D  2258
Basic_DATA                     $b883  2275D  1049   2926   4484
Add_Y_To_Execution_Pointer     $b886  2281D  2338   3073
AYEP_Ret                       $b890  2290D  2288   2312   2314
Next_Statement                 $b891  2293D  2006   2278   3056
End_Of_Line                    $b894  2300D  2225   2337
NeSt_10                        $b89c  2307D  2318
NeSt_20                        $b8a4  2311D  2317
Basic_IF                       $b8b3  2321D  1057
IF_10                          $b8c2  2330D  2327
Basic_REM                      $b8c6  2334D  1061
REM_10                         $b8cb  2339D  2331
REM_20                         $b8d3  2342D  2340
Basic_ON                       $b8d6  2345D  1063
ON_10                          $b8de  2352D  2379
ON_20                          $b8e2  2354D  2351   2361
ON_30                          $b8ea  2358D  2355
Scan_Linenumber                $b8f6  2366D  1512   1863   1870   2224
                                      2359   8787   8799   8810   9761
                                      9771  10452  11134  12810
ScLi_10                        $b8fe  2377D  2382
ScLi_Ret                       $b90c  2383D  2376
Dec_Char                       $b90d  2386D  2380  13722
LIM_10                         $b92e  2415D  2413
Basic_LET                      $b930  2420D  1054   1996   2113
Assign_Numeric_variable        $b94d  2440D  3031
LET_10                         $b961  2453D  2443
LET_20                         $b964  2455D  2436
Assign_String_Variable         $b965  2458D  3024
CLOCK_10                       $b978  2470D  2485
CLOCK_20                       $b992  2482D  2478
CLOCK_30                       $b9a2  2490D  2493
Add_TI_String_Digit_To_FAC1    $b9ab  2498D  2471   2475
ATSD_10                        $b9b2  2504D  2466
ATSD_20                        $b9b5  2505D  2503
Assign_Normal_String           $b9ba  2509D  2463
ANS_10                         $b9c9  2539
ANS_20                         $b9cb  2540
ANS_30                         $b9d7  2546D  2542
ANS_40                         $b9e5  2553D  2541   2545   2548
ANS_50                         $b9ec  2559D  2537   2549   2552
ANS_60                         $ba05  2573D  2555
ANS_70                         $ba1e  2588D  2579
ANS_80                         $ba33  2602D  2593
ANS_90                         $ba35  2603D  2606
Back_Reference_Position        $ba3d  2610D  2578   2592   4951
BRP_10                         $ba57  2636D  2633
BRP_no                         $ba6c  2649D  2624   2630   2632   2635
FAC1_INT                       $ba6f  2659D  4124
FACI_Ret                       $ba81  2672D  2664
Basic_PRINTN                   $ba88  2677D  1070
Basic_CMD                      $ba8e  2684D  1075   2680
CMD_10                         $ba98  2691D  2688
PRINT_10                       $baa2  2698D  2718
PRINT_20                       $baa5  2699D  2723
Basic_PRINT                    $baa8  2702D  1071   2695
PRINT_30                       $baaa  2706D  2778
Terminate_BUF                  $bad2  2726D  1638
Print_CR                       $badf  2737D  1460   1888   2705  12808
PRINT_Ret                      $bae4  2742D  2706   2734
Comma_Tab                      $baf0  2747D  2713
CoTa_10                        $baf3  2752D  2753
Tab_Spc                        $bafd  2759D  2708   2711
TaSp_10                        $bb0d  2771D  2756
TaSp_20                        $bb0e  2772D  2767
TaSp_30                        $bb11  2774D  2776
TaSp_40                        $bb14  2775D  2773
TaSp_50                        $bb17  2777D  2715   2770
Print_String                   $bb1d  2781D  1472   1484   2848   3091
                                      6400   7059   7069
Print_String_From_Descriptor   $bb20  2787D  2698   2721   2910
PSFD_10                        $bb28  2794D  2798
PSFD_Ret                       $bb31  2799D  2792
Cursor_Right_Or_Space          $bb3a  2804D  2722   2774   2942
CROS_10                        $bb41  2811D  2808
Print_Question_Mark            $bb44  2815D  1461   2941   2989
Print_Char                     $bb46  2821D  1936   1945   1980
Bad_Input                      $bb4c  2829D  3039
BaIn_10                        $bb56  2837D  2834
BaIn_20                        $bb5a  2839D  2836
SynErr                         $bb5e  2841D  2765
BaIn_30                        $bb61  2842D  2833
BaIn_40                        $bb6a  2846D  2843
Basic_GET                      $bb7a  2856D  1079
GET_10                         $bb8f  2867D  2861
Basic_INPUTN                   $bba4  2880D  1050
Set_Default_Channels           $bbb2  2890D  2681   2925
SDC_10                         $bbb4  2894D  2874
Basic_INPUT                    $bbbe  2902D  1051
Input_String                   $bbcd  2913D  2887   2906
InSt_10                        $bbd5  2919D  3498
InSt_20                        $bbe8  2927D  2921   2924
InSt_30                        $bbf0  2930D  3494
Prompt_And_Input               $bbf5  2936D  2919   2990
PAI_10                         $bbff  2943D  2940
Basic_READ                     $bc02  2946D  1053
READ_10                        $bc09  2953D  2928   3499
Read_Get                       $bc0b  2956D  2872
READ_15                        $bc11  2965D  3052
READ_20                        $bc3d  2986D  2979
READ_25                        $bc46  2990D  2988
READ_30                        $bc49  2991D  2984
READ_35                        $bc4d  2996D  2977   3076
READ_40                        $bc61  3009D  3000
READ_45                        $bc6d  3015D  3005
READ_50                        $bc6e  3016D  3011
READ_55                        $bc79  3022D  3020
READ_60                        $bc85  3029D  2998
READ_65                        $bc8d  3035D  3025
READ_70                        $bc99  3041D  3036   3038
READ_75                        $bcb4  3056D  2986   3075
READ_80                        $bccd  3071D  3059
READ_85                        $bcda  3079D  3050
READ_90                        $bce5  3084D  3082
READ_Ret                       $bcf6  3092D  3086   3088
Msg_Extra_Ignored              $bcf7  3097D  3089   3090
Msg_Redo_From_Start            $bd07  3103D  2846   2847
Basic_NEXT                     $bd19  3109D  1048
NEXT_10                        $bd1f  3115D  3112   3162
NEXT_20                        $bd24  3117D  3114
NEXT_30                        $bd2d  3121D  3063
NEXT_40                        $bd2f  3122D  3119
NEXT_50                        $bd6f  3153D  3160
NEXT_60                        $bd72  3154D  3144
Eval_Numeric                   $bd84  3165D  2020   2034   4542   5151
                                      5211  12601
Is_Numeric                     $bd87  3171D  3247   3329   3699   4109
                                      4471   4498   4509   4577
Is_String                      $bd89  3178D  3676   4860   4930
Check_Var_Type                 $bd8a  3184D  2435   3752
CVT_10                         $bd90  3190D  3191
CVT_20                         $bd91  3191D  3188
CVT_30                         $bd93  3192D  3189
CVT_40                         $bd95  3193D  3121
Eval_Expression                $bd98  3199D  2324   2432   2716   3168
                                      3426   3674   4103   7685   7689
                                      8720  12297
EvEx_05                        $bd9e  3205D  3203
EvEx_10                        $bda3  3208D  3281
EvEx_15                        $bdb0  3215D  4882
EvEx_20                        $bdb3  3216D  3228
EvEx_25                        $bdce  3230D  3218   3220
EvEx_30                        $bddf  3239D  3236
EvEx_35                        $bde7  3244D  3266
EvEx_40                        $bdf0  3248D  3269
EvEx_45                        $bdf1  3249D  3471
EvEx_50                        $bdfe  3257D  3231
EvEx_55                        $be08  3263D  3261
EvEx_60                        $be10  3267D  3252
Use_Operator                   $be17  3272D  3249
SynErr1                        $be27  3283D  3225
Push_Operand                   $be2a  3286D  3279
Push_FAC1                      $be2e  3293D  2026   2038
PuFA_10                        $be39  3303D  3300
Pop_FAC2                       $be52  3321D  3232   3234
PoFA_10                        $be55  3326D  3254
PoFA_20                        $be57  3327D  3246
PoFA_30                        $be5e  3330D  3328
PoFA_40                        $be60  3331D  3255   3268
PoFA_50                        $be7a  3348D  3326
Evaluate                       $be81  3354D  3212   4859
Eva_10                         $be85  3359D  3376
Eva_20                         $be8a  3361D  3372
Eva_30                         $be8d  3362D  3360
Float_PI                       $bea0  3370D  3366   3367
Eva_40                         $bea5  3371D  3365
Make_String_Descriptor_From_Co $beb5  3381D  2907
MSDF_10                        $bebe  3389D  3387
Eva_50                         $bec4  3392D  3378
Op_NOT                         $becc  3398D  1142
Eva_60                         $bedb  3414D  3393
Eva_70                         $bee2  3417D  3415
Eval_In_Parenthesis            $bee9  3422D  3418   3691   4508
Need_Right_Parenthesis         $beef  3429D  4167   4472   5089   7687
                                      8764
Need_Left_Parenthesis          $bef2  3436D  3425   3673   4467   7684
                                      8762
Need_Comma                     $bef5  3443D  2864   2884   3051   3675
                                      3808   5068   5218   7681   7693
                                     12320
Need_A                         $bef7  3449D  2019   2124   2329   2427
                                      2690   2909   4474   4492   7676
Syntax_Error                   $bf00  3458D  2116   2263   2841   3283
                                      3454   3485   3841   3938   4549
                                      7717   8019   8105   8181   8280
                                      8303   8535   8587   8628   8640
                                      8671   8730   8760  12046  12328
                                     12633  13843
Negate                         $bf05  3465D  3374
Nega_10                        $bf07  3469D  3395
JMP_Get_Var                    $bf0c  3474D  3363
Any_Except_Pi                  $bf0f  3480D  2087
Input_String_Patch             $bf19  3489D  2929
InSt_40                        $bf20  3495D  3493
InSt_50                        $bf29  3499D  3497
Extended_Statement_Table       $bf2c  3502D 11220  11222  11229
Extended_Keyword_Table         $bf3a  3514D 11210  11227
Get_Var                        $bf8c  3529D  3477   3925
GeVa_10                        $bfbb  3562D  3549   3551
GeVa_Ret                       $bfcd  3570D  3547   3563   3565
Get_Numeric_Value              $bfce  3573D  3545
Load_Float                     $bfdf  3588D  3577
Load_Jiffyclock                $c003  3605D  3552   3597
Check_ST_Var                   $c00f  3617D  3594
Check_DS_Var                   $c01c  3628D  3621   3623
Load_Float_Var                 $c040  3651D  3592   3596   3632   3634
Function_Call                  $c047  3659D  3419
FuCa_10                        $c071  3691D  3672
FuCa_20                        $c076  3694D  3690
Op_OR                          $c086  3702D  1140
Op_AND                         $c088  3709D  1139
ANDOR_10                       $c0a8  3729D  3723
Op_COMPARE                     $c0b6  3744D  1143
OpCO_10                        $c0ce  3763D  3753
OpCO_20                        $c0f6  3783D  3778   3780
OpCO_30                        $c0fb  3786D  3795
OpCO_40                        $c101  3790D  3762
OpCO_50                        $c106  3793D  3788
OpCO_60                        $c112  3799D  3790   3792   3797
OpCO_70                        $c11b  3805D  3803
DIM_10                         $c11e  3808D  3817
Basic_DIM                      $c121  3811D  1052
Parse_Name                     $c12b  3821D  2423   2965   3115   3539
                                      4470
Get_Array_Address              $c130  3828D  3815
Get_FN_Address                 $c132  3834D  4495
GFA_Err                        $c13c  3841D  3867
Get_Address                    $c13f  3844D  3840
GeAd_05                        $c14f  3854D  3851
GeAd_10                        $c150  3855D  3856   3858
GeAd_15                        $c15a  3859D  3853
GeAd_20                        $c164  3864D  3860
GeAd_25                        $c174  3872D  3863
GeAd_30                        $c17b  3876D  3865
GeAd_35                        $c187  3882D  3880
GeAd_40                        $c18f  3886D  3906
GeAd_45                        $c191  3887D  3904
GeAd_50                        $c19b  3892D  3889
GeAd_55                        $c1ab  3900D  3898
GeAd_60                        $c1ac  3901D  3894
Is_Alpha                       $c1b6  3909D  3362   3839   3852   3857
IsAl_Ret                       $c1bf  3917D  3913
Create_Var                     $c1c0  3920D  3891
CrVa_05                        $c1c6  3927D  3935
CrVa_10                        $c1cb  3930D  3926
CrVa_15                        $c1db  3938D  3942   3946   3948
CrVa_20                        $c1de  3939D  3933   3937
CrVa_25                        $c1e6  3943D  3940
CrVa_30                        $c1f2  3949D  3944
CrVa_35                        $c208  3961D  3959
CrVa_40                        $c21c  3975D  3998   4000
CrVa_45                        $c220  3977D  4014
CrVa_50                        $c228  3981D  3978
CrVa_55                        $c259  4010D  4008   4042   4044
CrVa_60                        $c263  4015D  4012
CrVa_65                        $c281  4032D  4029
CrVa_70                        $c28b  4038D  4017   4028   4031
CrVa_75                        $c298  4046D  3980
CrVa_80                        $c2b4  4063D  3899
CrVa_85                        $c2be  4069D  4067
Array_Pointer_To_First         $c2c8  4076D  4219   4228
APTF_10                        $c2d4  4086D  4084
Float_M32768                   $c2d9  4091D  4120   4121
Eval_Positive_Integer          $c2dd  4099D  4146
Eval_Positive_Integer_Check    $c2e3  4106D  5157
Real_To_Integer                $c2ea  4114D  2445   3406   3714   3720
RIT_10                         $c2f7  4123D  4111
RIT_20                         $c2f9  4124D  4119
Find_Array                     $c2fc  4127D  3881
FiAr_05                        $c306  4140D  4165
FiAr_10                        $c347  4176D  4198
FiAr_15                        $c353  4182D  4179
FiAr_20                        $c362  4190D  4186
Bad_Subscript                  $c370  4201D  4223   4323
Jump_To_Illegal_Quantity       $c373  4208D  2504   4123   5137   5586
                                      7016   7017   8792   9792
FiAr_Err                       $c375  4212D  4218
FiAr_25                        $c378  4216D  4189
FiAr_30                        $c38c  4228D  4181
FiAr_35                        $c39f  4237D  4235
FiAr_40                        $c3a8  4243D  4240
FiAr_45                        $c3b1  4249D  4269
FiAr_50                        $c3c1  4259D  4252
FiAr_55                        $c3e4  4279D  4276
FiAr_60                        $c3f3  4286D  4288   4291
FiAr_65                        $c3f8  4289D  4285
FiAr_70                        $c415  4305D  4224
FiAr_72                        $c41d  4309D  4339
FiAr_74                        $c433  4323D  4318
FiAr_76                        $c436  4324D  4271   4278   4389   4400
FiAr_78                        $c439  4325D  4317
FiAr_80                        $c43a  4326D  4322
FiAr_82                        $c44b  4336D  4329
FiAr_84                        $c45c  4345D  4343
FiAr_86                        $c462  4349D  4346
FiAr_Ret                       $c476  4360D  4303   4450
Mult_16x16                     $c477  4365D  4264   4330
Mult_16x16_A                   $c480  4375D  4351
Mu16_10                        $c48a  4383D  4402
Mu16_20                        $c4a3  4401D  4392
Basic_FRE                      $c4a8  4406D  1108
FRE_10                         $c4af  4412D  4410
AY_To_Real                     $c4bc  4421D  3412   3585   3728   3733
                                      4442
Basic_POS                      $c4c9  4432D  1109
Y_To_Float                     $c4cb  4438D  5115   5136   5253
Assert_Non_Direct              $c4cf  4445D  2859   2916   4466
Undefined_Function             $c4d7  4455D  4520
Basic_DEF                      $c4dc  4462D  1068
Get_FN                         $c50a  4488D  4465   4504
Eval_FNX                       $c51d  4501D  3416
FNX_10                         $c53e  4523D  4526
FNX_20                         $c56f  4550D  4548
FNX_30                         $c575  4554D  4485
Basic_STR                      $c58e  4574D  1120
STR_10                         $c598  4582D  3560
Allocate_String_FAC1           $c59e  4587D  4645   4872
Allocate_String_A              $c5a6  4596D  2561   5011   5033
Create_String_Descriptor       $c5b0  4606D  2720   2784   3389   3569
                                      4584
Create_String_Descriptor_AY    $c5b6  4614D  3022
CSD_10                         $c5c0  4622D  4628
CSD_20                         $c5cd  4629D  4626
CSD_30                         $c5d1  4631D  4624
CSD_40                         $c5d2  4632D  4630
CSD_50                         $c5de  4639D  4637
CSD_60                         $c5e8  4644D  4641
Push_String_Descriptor         $c5f3  4651D  4643   4881   5017   5047
PuSD_Err                       $c5fb  4658D  4726
PuSD_10                        $c5fe  4659D  4656
Allocate_String_Space          $c61d  4679D  4599
ASS_10                         $c61f  4689D  4731
ASS_30                         $c63a  4706D  4704
ASS_40                         $c644  4711D  4708
ASS_50                         $c65a  4723D  4690
ASS_60                         $c65b  4724D  4707   4710
Garbage_Collection             $c66a  4736D  1430   4412   4727  11385
GaCo_05                        $c676  4746D  4766   4768   4798   4814
GaCo_10                        $c68a  4758D  4755
GaCo_15                        $c69f  4770D  4762
GaCo_20                        $c6b0  4780D  4777
GaCo_25                        $c6b6  4783D  4781
GaCo_30                        $c6c7  4794D  4791
GaCo_35                        $c6d1  4800D  4795
GaCo_40                        $c6d4  4802D  4805
GaCo_45                        $c6eb  4815D  4750
FAC1_LSB                       $c6f4  4822D  6128
FACX_LSB                       $c6f6  4826D  5538
FACB_10                        $c6fa  4828D  4845
FACB_Ret                       $c71c  4846D  4829
Concatenate                    $c74f  4852D  3237
Conc_10                        $c76f  4872D  4869
Store_String_STRPTR            $c78c  4885D  4873
Store_String_XY                $c79a  4900D  2564   4648
Store_String_INDEXA            $c79e  4907D  4877   5046
SSI_10                         $c7a2  4913D  4917
SSI_Ret                        $c7b4  4924D  4911   4922
Eval_And_Free_String           $c7b5  4927D  5121   8721  12298
Free_String_FAC1               $c7b8  4933D  2464   2790   3766   4411
Free_String_AY                 $c7bc  4940D  3772   4876   4880   5036
GSD_40                         $c7ed  4973D  4950   4952
GSD_Ret                        $c7ff  4985D  4961   4963
Pop_Descriptor_Stack           $c811  4990D  2567   2577   4949
PDS_Ret                        $c821  5001D  4994   4996
Basic_CHR                      $c822  5004D  1123
Basic_LEFT                     $c836  5020D  1124
LEFT_10                        $c83c  5026D  5057
LEFT_20                        $c842  5030D  5026
LEFT_30                        $c843  5031D  5078
LEFT_40                        $c844  5032D  5081   5083
LEFT_50                        $c85b  5045D  5043
Basic_RIGHT                    $c862  5050D  1125
Basic_MID                      $c86d  5060D  1126
MID_10                         $c87e  5070D  5067
Pop_DESCPT                     $c897  5086D  5023   5053   5070
Basic_LEN                      $c8b2  5111D  1119
Eval_String_Desc               $c8b8  5118D  5114   5131   5167
Basic_ASC                      $c8c1  5128D  1122
ASC_10                         $c8cb  5136D  5132
ASC_Err                        $c8ce  5137D  5071   5159   5226   5229
Get_Next_Byte_Value            $c8d1  5142D  2763
Get_Byte_Value                 $c8d4  5148D  2348   2687   2863   2883
                                      3685   5069   5219   8763   8765
                                     12223  12279
Eval_Byte                      $c8d7  5154D  5007
Basic_VAL                      $c8e3  5164D  1121
VAL_10                         $c8eb  5170D  5168
VAL_20                         $c903  5183D  5181
Restore_Execution_Pointer      $c918  5196D  3023   3390
Get_Word_And_Byte              $c921  5208D  5259   5269
Need_Comma_Get_Byte            $c927  5215D  5274
FAC1_To_LINNUM                 $c92d  5222D  5212   5245   7686   7690
                                     12602
Basic_PEEK                     $c943  5238D  1118
Basic_POKE                     $c95a  5256D  1069
Basic_WAIT                     $c963  5266D  1064
WAIT_10                        $c972  5275D  5273
WAIT_20                        $c976  5277D  5280
WAIT_Ret                       $c97e  5281D  5343
Add_0_5_To_FAC1                $c97f  5284D  6473   6880
AY_Minus_FAC1                  $c986  5292D  5600   6876   6963
Op_MINUS                       $c989  5298D  1135   6736   6873
Add_Var_AY_To_FAC1             $c99d  5312D  3137   5289   5594   5606
                                      6793   6832   6858   6889
Op_PLUS                        $c9a0  5318D  1134   5307   6276
PLUS_10                        $c9a5  5323D  5321
AddSub_FAC2_To_FAC1            $c9ad  5329D  5761
AFTF_10                        $c9c9  5357D  5347
AFTF_20                        $c9cd  5359D  5356
AFTF_30                        $c9d0  5360D  5346
AFTF_40                        $c9dc  5366D  5364
AFTF_50                        $c9ff  5382D  6062
Normalise_FAC1                 $ca0d  5389D  5382   5384   5884   6173
                                      6847
NF1_10                         $ca11  5395D  5408
Clear_FAC1                     $ca2d  5411D  5169   5444   5739
CF1_10                         $ca2f  5415D  6655
AFTF_60                        $ca34  5419D  5361
AFTF_65                        $ca53  5435D  5441
AFTF_70                        $ca5f  5441D  5396
Mantissa_Overflow              $ca6c  5450D  5433
AFTF_80                        $ca6e  5454D  6019
AFTF_Ret                       $ca7c  5461D  5453
Negate_FAC1                    $ca7d  5464D  5383
Negate_FAC1_Mantissa           $ca83  5472
Inc_FAC1_Mantissa              $caa5  5494D  6017   6145
IFM_Ret                        $cab3  5504D  5491   5498   5500   5502
Overflow_Error                 $cab4  5507D  5455   5740   6286
Shift_FAC3                     $cab9  5514D  5646
Shift_FACX_A                   $cacf  5535D  5359
SFA_10                         $cad8  5542D  5548
SFA_40                         $cae4  5549D  5541
REAL_1                         $caf2  5555D  2027   2028   5598   5599
                                      6953   6954
VLOG_A                         $caf7  5559D  5601   5602
HALF_SQRT_2                    $cb0c  5566D  5592   5593
SQRT_2                         $cb11  5570D  5595   5596
MINUS_0_5                      $cb16  5573D  5604   5605
LN_2                           $cb1b  5577D  5609   5610
Basic_LOG                      $cb20  5580D  1112   6671
LOG_10                         $cb27  5586D  5584
LOG_20                         $cb2a  5587D  5585
Multiply_FAC1_With_AY          $cb5e  5613D  6447   6674   6712   6757
                                      6761   6784   6829
Op_MULTIPLY                    $cb61  5619D  1136
Mult_SubA                      $cb8c  5642D  5630   5632   5634   5636
Mult_SubB                      $cb91  5649D  5638   5645
MULT_20                        $cb94  5654D  5676
MULT_30                        $cbb0  5669D  5655
MULT_Ret                       $cbbe  5677D  5622
Load_FAC2_From_AY              $cbc2  5682D  5295   5315   5616   5793
Check_FAC                      $cbed  5716D  5623   5805
ChFA_10                        $cbef  5720D  6744
ChFA_20                        $cbfa  5727D  5723
ChFA_30                        $cc04  5732D  5730
ChFA_40                        $cc07  5734D  6722
ChFA_50                        $cc0d  5737D  5720   5727
ChFA_Err                       $cc12  5740D  5724   5736   5753   5763
                                      5807
Multiply_FAC1_BY_10            $cc18  5745D  2472   2486   6242   6256
                                      6457
Add_And_Double                 $cc23  5756D  2481
Mul10_Ret                      $cc2e  5764D  5750
Float_10                       $cc2f  5767D  5777   5778
Divide_FAC1_By_10              $cc34  5773D  6237   6463
Divide_FAC2_By_AY              $cc3d  5782D  6868
AY_Divided_By_FAC1             $cc45  5790D  5597   6917   6955
Op_DIVIDE                      $cc48  5796D  1137   5787
DIV_10                         $cc5f  5810D  5836
DIV_20                         $cc75  5821D  5812   5815   5818   5835
                                      5837
DIV_30                         $cc82  5829D  5823   5854
DIV_40                         $cc85  5831D  5852
DIV_50                         $cc93  5838D  5830
DIV_60                         $ccb0  5853D  5826
DIV_70                         $ccb4  5855D  5827
Divide_By_Zero                 $ccc0  5866D  5799
FAC3_To_FAC1                   $ccc5  5873D  5639   5863
Load_FAC1_AY                   $ccd8  5887D  2029   3131   3368   3611
                                      3656   5786   6646   6826   6910
LFAY_10                        $ccde  5893D  5896
Set_FAC1                       $ccf4  5907D  6125
FAC1_To_FACTPB                 $ccfd  5919D  6774
FAC1_To_FACTPA                 $cd00  5926D  6755   6901
FAC1_To_FORPNT                 $cd06  5934D  2453   3138
FAC1_To_XY                     $cd0a  5941D  4528   5931   6658   6850
                                      6907
FAC2_To_FAC1                   $cd32  5968D  3719   5322
Copy_ABS_FAC2_To_FAC1          $cd34  5974D  6668
F1F2_10                        $cd38  5979D  5982
FAC1_Round_And_Copy_To_FAC2    $cd42  5987D  2476   5748   5776   6269
                                      6643   6864   6869
FAC1_To_FAC2                   $cd45  5993D  6718
FA12_10                        $cd47  5997D  6000
FA12_Ret                       $cd50  6002D  6009   6011   6018
Round_FAC1                     $cd51  6005D  2444   3303   5800   5944
                                      5990
Inc_FAC1                       $cd59  6014D  6716
Get_FAC1_Sign                  $cd61  6022D  2035   5583   6038   6086
                                      6812
GFS_10                         $cd65  6027D  6089
GFS_20                         $cd67  6028D  6113
GFS_Ret                        $cd6e  6032D  6026   6030
Basic_SGN                      $cd6f  6035D  1104
A_To_FAC1                      $cd72  6041D  3625   3646   3805   6271
ATOF_10                        $cd7a  6048D  4429
Convert_Integer_To_Real        $cd7f  6053D  6393  11144
CITR_10                        $cd85  6059D  3600
Basic_ABS                      $cd8e  6065D  1106
Compare_FAC1_AY                $cd91  6072D  3760   4122   6455   6467
                                      6664
Compare_FAC1_INDEXB_Y          $cd93  6078D  3140
CFAY_10                        $cdc8  6110D  6091   6095   6099   6103
CFAY_20                        $cdce  6113D  6111
FAC1_LSR                       $cdd1  6116D  2487   2662   5230   6163
                                      6474
FLSR_10                        $cdd5  6125
FLSR_20                        $cdd8  6126D  6124
FLSR_30                        $cde6  6133D  6131   6140
FLSR_40                        $cdff  6146D  6129   6142   6144
FLSR_Ret                       $ce01  6147D  6109   6162
Basic_INT                      $ce02  6152D  1105   6661   6723   6870
INT_10                         $ce1a  6172D  6168
Read_Real_To_FAC1              $ce29  6178D  3029   3361   5190
RRTF_02                        $ce2d  6191D  6193
RRTF_04                        $ce3e  6200D  6196   6228   6260
RRTF_06                        $ce43  6202D  6198
RRTF_08                        $ce60  6216D  6213
RRTF_10                        $ce62  6217D  6209   6211   6298
RRTF_12                        $ce67  6219D  6215
RRTF_20                        $ce73  6226D  6203
RRTF_22                        $ce79  6230D  6205   6220
RRTF_24                        $ce7b  6231D  6224
RRTF_26                        $ce84  6237D  6239
RRTF_28                        $ce8d  6242D  6235   6244
RRTF_30                        $ce94  6246D  6234   6240
RRTF_32                        $ce99  6250D  6247
RRTF_34                        $ce9c  6252D  6194   6201
RRTF_36                        $cea3  6256D  6254
Add_A_To_FAC1                  $ceb4  6265D  2506   5608   6259
RRTF_40                        $cec7  6280D  6207   6218
RRTF_42                        $ced6  6287D  6282
RRTF_44                        $cee4  6297D  6285
REAL_1e8                       $cee9  6301D  6453   6454
REAL_9x9                       $ceee  6307D  6465   6466
REAL_1e9                       $cef3  6313D  6445   6446
BSOS_TEXT                      $cef8  6318D  6326   6333   6346   6348
                                      6350
Option_ROM                     $cf01  6321D  7071
OpRO_10                        $cf03  6325D  6329
OpRO_20                        $cf11  6331D  6327
OpRO_30                        $cf13  6332D  6336
OpRO_40                        $cf21  6338D  6334   6345
BOOT_File                      $cf22  6341D  7072
BOFi_10                        $cf4e  6364D  6361
Print_IN                       $cf78  6376D  1476
Print_Integer_XA               $cf83  6386D  1932   7066   7883  12807
To_Print_String                $cf90  6397D  6381
Format_FAC1                    $cf93  6403D  2719   6394  11145
Format_FAC1_Y                  $cf95  6409D  4579
FoFA_02                        $cfa1  6426D  6424
FoFA_04                        $cfb2  6442D  6435
FoFA_06                        $cfc1  6449D  6444
FoFA_08                        $cfc3  6453D  6459
FoFA_10                        $cfd3  6463D  6468
FoFA_12                        $cfd8  6465D  6456
FoFA_14                        $cff9  6489D  6483
FoFA_16                        $cffa  6490D  6485
FoFA_18                        $d005  6496D  6494
FoFA_20                        $d016  6505D  6501
FoFA_22                        $d018  6506D  6495
Format_Jiffyclock              $d01a  6509D  3559
FoFA_78                        $d01c  6513D  6528   6531   6561
FoFA_80                        $d040  6531D  6527
FoFA_82                        $d042  6532D  6529
FoFA_84                        $d049  6536D  6533
FoFA_86                        $d064  6552D  6548
FoFA_88                        $d076  6565D  6559
FoFA_90                        $d078  6566D  6569
FoFA_91                        $d085  6573D  6571
FoFA_92                        $d095  6582D  6576
FoFA_93                        $d0a1  6588D  6590
FoFA_94                        $d0b6  6599D  6436
FoFA_95                        $d0b9  6600D  6575
FoFA_96                        $d0be  6602D  6597
Float_0_5                      $d0c7  6609D  2462   3927   3928   5287
                                      5288   6644   6645
Decimal_Conversion_Table       $d0cc  6615D  6515   6518   6521   6524
Jiffy_Conversion_Table         $d0f0  6629
Basic_SQR                      $d108  6640D  1110
Op_POWER                       $d112  6649D  1138
PWR_10                         $d11b  6656D  6654
PWR_20                         $d135  6668D  6660   6665
Op_NEGATE                      $d14b  6681D  1141   6250   6737   6886
                                      6892
NEGA_Ret                       $d155  6689D  6678   6685
REV_LOG_2                      $d156  6692D  6710   6711
VAR_EXP                        $d15b  6696D  6738   6739
Basic_EXP                      $d184  6707D  1113   6652   6675
EXP_10                         $d194  6717D  6715
EXP_20                         $d19f  6722
EXP_30                         $d1a2  6723D  6721
EXP_40                         $d1ac  6728D  6733
Square_And_Series_Eval         $d1d7  6750D  5603   6895   6958
Eval_Series_AY                 $d1ed  6764D  6740
Eval_Series                    $d1f1  6771D  6758
EvSe_10                        $d200  6782D  6780
EvSe_20                        $d204  6784D  6797
EvSe_30                        $d211  6791D  6789
RND_VA                         $d221  6800D  6827   6828
RND_VB                         $d225  6801D  6830   6831
Basic_RND                      $d229  6804D  1111
RND_10                         $d247  6824D  6814
RND_20                         $d25c  6833D  6813
RND_30                         $d26c  6841D  6823
Basic_COS                      $d282  6853D  1114
Basic_SIN                      $d289  6861D  1115   6904
SIN_10                         $d2bb  6886D  6879   6924
SIN_20                         $d2be  6887D  6882
SIN_30                         $d2cb  6893D  6891
Basic_TAN                      $d2d2  6898D  1116
TAN_10                         $d2fa  6920D  6914
PI_Half                        $d2fe  6925D  6856   6857   6961   6962
Two_PI                         $d303  6926D  6865   6866
Float_0_25                     $d308  6929D  6874   6875   6887   6888
VAR_SIN                        $d30d  6933D  6893   6894
Basic_ATN                      $d32c  6942D  1117
ATN_20                         $d341  6956D  6952
ATN_30                         $d352  6964D  6960
VAR_ATN                        $d35c  6971D  6956   6957
CHRGET_ROM                     $d399  6989D  6999   7021
CHRG_10                        $d39f  6995D  6993
CHRG_20                        $d3b0  7004D  6997
Init_BASIC_RAM_Vectors         $d3b6  7009D 13598
IBRV_10                        $d3c9  7021D  7024
IBRV_20                        $d3e8  7036D  7049   7051
IBRV_30                        $d404  7052D  7041   7045
Bytes_Free_Message             $d435  7076D  7067   7068
Monitor                        $d442  7082D  3506
MONITOR_BREAK                  $d44e  7095D 13587  13589
MOBR_05                        $d456  7103D  7101
MOBR_10                        $d499  7134D  7138
MOBR_20                        $d4a5  7139D  7132   7136
Mon_Error                      $d4a9  7143D  7160   7414   7540   9875
                                     13283  13442  13485  13569  13591
                                     13593
Mon_Main                       $d4ae  7150D  7155   7389   7430   7545
                                      7570   7915   7923   9874  12403
                                     13396  13413  13466  13484  13568
                                     13631
Mon_10                         $d4b1  7154D  7157  13327
Mon_20                         $d4ba  7158D  7140
Mon_30                         $d4bc  7159D  7162
Mon_Print_A_Hex_Values         $d4cd  7170D  7331   7384
MPAH_10                        $d4d1  7175D  7183
MPAH_12                        $d4e2  7182D  7180
MPAH_20                        $d4f1  7189D  7202
MPAH_30                        $d4fe  7195D  7192
MPAH_40                        $d500  7196D  7194
MPAH_42                        $d50b  7201D  7199
MPAH_Ret                       $d50f  7203D  7187
Mon_STAL_Register              $d510  7206D  7330
Mon_Print_Blank                $d51b  7217D  7175   7181   7184   7200
                                      7320   7325  12397  12414  12415
                                     12416  12437  13302  13304  13461
                                     13565  13627
Mon_Print_CR                   $d51e  7224D  7153   7300  11247  13393
                                     13410  13449  13552  13630  13870
Mon_Start                      $d523  7231D  7135
Mon_Commands                   $d52e  7234D  7161
Mon_Sub_Hi                     $d546  7240D  7163
Mon_Sub_Lo                     $d55d  7268D  7165
Mon_Prompt                     $d574  7296D  7319   7381  12396  13301
Display_Register               $d57c  7305D  7260   7288
DiRe_10                        $d57e  7309D  7313
DiRe_20                        $d5c3  7335D  7340
Mon_Cmp_Addr                   $d5e0  7351D  7378  12393  13555
Cmp_STAL_MEMUSS                $d5eb  7362D  7355  13464  13482  13509
Display_Memory                 $d5f4  7372D  7258   7286
DiMe_10                        $d5f7  7376D  7387   9930   9951
To_Mon_Main                    $d615  7388D  7342   7377   7379   7455
Mon_Get_Addr                   $d618  7392D  7375  12390  13525
MGA_Ret                        $d639  7410D  7401   7405
MGA_Err                        $d63a  7411D  7403   7408
To_Mon_Err                     $d63c  7413D  7437   7446   7451   7464
Modify_Register                $d63f  7417D  7248   7276
MoRe_10                        $d641  7421D  7425
Modify_Memory                  $d659  7433D  7247   7275
MoMe_10                        $d660  7439
MoMe_20                        $d66c  7445D  7454
MoMe_30                        $d67d  7452
Mon_Go                         $d684  7458D  7255   7283
MoGo_10                        $d699  7469D  7462
Mon_Step                       $d6a4  7476D 13648
Mon_Exit                       $d6be  7493D  7265   7293
Set_DOS_FNADR                  $d6c5  7501D  7526   8607  13409
Mon_Load                       $d6ce  7511D  7246   7257   7274   7285
Mon_Save                       $d6d1  7518D  7261   7289
MLS_10                         $d6e0  7528D  7531
MLS_20                         $d6e9  7532D  7539
MLS_Err                        $d6f9  7540D  7529   7533   7543   7557
                                      7563   7566   7568
MLS_30                         $d6fc  7542D  7549   7555
MLS_35                         $d6fe  7543
MLS_50                         $d706  7547D  7535   7551
Make_Hex_Byte                  $d73e  7573D  7599  13315  13319
Mon_Print_STAL                 $d74d  7588D  7382  12436  13303  13460
                                     13564
Print_Hex_Byte                 $d754  7596D  7177   7322   7324   7327
                                      7329   7592   9813  11575  12062
                                     12064  12169  12171  12412  13629
Mon_Print_XA                   $d757  7602
Nibble_To_Hex                  $d760  7612D  7581   7585  13174  13179
NTH_10                         $d767  7619D  7617
Hex_To_STAL                    $d76a  7623D  7402   7436   7558   9887
                                     13239  13430
Read_Hex_Word                  $d76c  7629D  7407   7565   9856   9859
                                     13433  13436
RHW_Ret                        $d778  7637D  7633
Read_Hex                       $d779  7640D  7421   7445   7465   7467
                                      7552   7632   7635   7647   7913
                                      7921   9861  13536  13620
Read_Hex_A                     $d780  7648D 13533
ReHe_Ret                       $d79c  7663D  7650   7659
Kernal_RECORD                  $d7af  7669D 13973
RECO_10                        $d7db  7689D  7683
RECO_20                        $d7e1  7691D  7688
RECO_30                        $d7fe  7703D  7692
RECO_40                        $d801  7704D  7679   7697   7699
Allow_Drive_Unit_Filename      $d804  7707D  8074   8328
DOS_JMP_Syntax_Error           $d808  7714D  7682   7694   7702   7726
                                      7735   7743   7752   7762
Check_Filename_Given           $d80b  7720D  7711   8277   8300
Allow_Drive_And_Unit           $d818  7731D  7853   8162
No_WL_Record                   $d81d  7739D  8221
Check_Filename_Syntax          $d824  7747D  8316
Check_Record_Syntax            $d82e  7757D  8001   8030
DOS_Build_Table                $d838  7767D  8412
Kernal_DIRECTORY               $d873  7849D 14021
DIRE_10                        $d885  7860D  7858
Wedge_Call_Dir                 $d889  7864D 12874  13412
WCD_10                         $d89e  7876D  7882   7903
WCD_20                         $d8b4  7886D  7895   7898
WCD_30                         $d8cc  7896D  7897
WCD_40                         $d8d3  7900D  7887
WCD_80                         $d8dc  7905D  7879   7889   7892
Mon_Set_Bank                   $d8e4  7910D  7251   7279
Mon_Write_Bank                 $d8ec  7918D  7264   7292
Mon_CHRIN                      $d8f4  7926D  7154   7400   7404   7461
                                      7528   7532   7548   7554   7561
                                      7645   7657   9890  13201  13247
                                     13255  13379  13385  13406  13527
                                     13543  13670  13726
Hex_To_Bin                     $d8fa  7934D  7651   7660  13673
HTB_Ret                        $d904  7943D  7941
Is_Int                         $d905  7946D 13666
Is_Hex                         $d911  7957D  7649   7658  13671
Is_Dec                         $d919  7966D 13727
IH_True                        $d921  7973D  7950   7952   7954   7963
IH_False                       $d923  7975D  7961   7970   7972
Select_Free_SA                 $d92f  7981D  8004   8033
SFSA_10                        $d931  7985D  7991
SFSA_20                        $d935  7988D  7992
SFSA_30                        $d93f  7993D  7989
Kernal_DOPEN                   $d942  7997D 13961
DOPEN_20                       $d95c  8012D  8008
DOPEN_30                       $d964  8016D  8012
DOPEN_Err                      $d96c  8019D  8003   8032   8077
Kernal_APPEND                  $d977  8026D 14003
Kernal_Read_DS                 $d991  8042D  3566   3635   6363   8087
                                      8336   9802  11490  11521  11550
                                     12882  14039
KRD_10                         $d999  8049D  8046
KDR_20                         $d9a5  8054D  8060
KDR_30                         $d9b4  8061D  8058
Kernal_HEADER                  $d9d2  8070D 13979
HEAD_10                        $d9f1  8086D  8084
HEAD_20                        $da05  8094D  8080   8089   8091
Kernal_DCLOSE                  $da07  8099D 13967
CLOSE_10                       $da11  8106D  8104
Close_All_Device_Files         $da1b  8112D  8078   8108   8124   8163
                                      8185
CLOSE_20                       $da1f  8117D  8120
CLOSE_Ret                      $da30  8125D  8118
Build_Record_Command           $da31  8128D  7703
BRC_10                         $da3d  8136D  8133
DOS_Record_No                  $da43  8140D 11549
Kernal_COLLECT                 $da65  8158D 13985
COLL_10                        $da7a  8170D  8168
Kernal_BACKUP                  $da7e  8174D 13991
BACK_Err                       $da87  8181D  8184
BACK_10                        $da8a  8182D  8180
Put_DOS_Command                $da98  8190D  8086   8171   8212   8224
                                      8321   8333
PDC_10                         $da9b  8194D  8155  11438
Kernal_COPY                    $daa7  8201D 13997
KECO_10                        $dab5  8210D  8206   8208
Kernal_CONCAT                  $dac7  8217D 13955
Copy_Filename_To_DOS_Buffer    $dad4  8227D  8416
Copy_MEMUSS_To_DOS_Buffer      $dae1  8238D  8419
CMDB_10                        $daea  8246D  8251
CMDB_20                        $daf8  8253D  8244
CMDB_30                        $daf9  8254D  8252
Insert_DOS_Id                  $dafd  8260D  8426
Kernal_DSAVE                   $db0d  8273D 14009
DSAVE_10                       $db1a  8281D  8279
DSAVE_20                       $db32  8291D  8284
Kernal_DLOAD                   $db3a  8296D 14015
DLOAD_10                       $db44  8303D  8318
DLOAD_20                       $db47  8304D  8302
Kernal_RENAME                  $db55  8312D 14027
Kernal_SCRATCH                 $db66  8324D 14033
Display_Status                 $db85  8341D 12883
DiSt_10                        $db87  8345D  8349
DiSt_Ret                       $db92  8350D  8330   8335
Are_You_Sure                   $db9e  8355D  8079   8329
AYS_10                         $dbcb  8377D  8365   8370   8373   8381
AYS_20                         $dbd5  8382D  8359   8368   8376
AYS_Ret                        $dbd6  8383D  8379
Clear_Status                   $dbe1  8388D  8106   8137   8408  12881
Build_DOS_Command              $dbfa  8398D  7861   8036   8193   8292
                                      8306
Build_DOS_Command_X            $dbfc  8404D  8017   8289  11395
BDC_10                         $dc02  8409D  8436   8441
BDC_20                         $dc14  8417D  8415
BDC_30                         $dc1b  8420D  8418
BDC_40                         $dc24  8424D  8421
BDC_50                         $dc2b  8427D  8425
BDC_60                         $dc34  8431D  8428
BDC_70                         $dc3d  8435D  8432
BDC_80                         $dc44  8438D  8434
BDC_90                         $dc46  8439D  8413   8423   8430
DOS_SETNAM                     $dc4c  8444D  8154   8410   9897
Write_Attribute                $dc57  8455D  8429
WrAt_10                        $dc60  8462D  8459
WrAt_Ret                       $dc67  8465D  8461
Parse_DOS_Parameter            $dc68  8494D  7852   8000   8029   8073
                                      8102   8161   8177   8204   8220
                                      8276   8299   8315   8327
PDP_02                         $dc8e  8513D  8510   8622
PDP_04                         $dca1  8523D  8520
PDP_08                         $dcb9  8535D  8539   8549   8574
PDP_10                         $dcbc  8537D  8514
PDP_12                         $dcd4  8548D  8516
PDP_14                         $dcdf  8553D  8518
PDP_16                         $dced  8560D  8551
PDP_20                         $dcf5  8564D  8530   8534
PDP_22                         $dcf8  8566D  8526   8625
PDP_24                         $dd00  8569D  8528
PDP_26                         $dd08  8572D  8524
PDP_28                         $dd24  8583D  8542   8555   8557   8577
PDP_30                         $dd27  8584D  8532
PDP_32                         $dd31  8588D  8586
PDP_34                         $dd35  8590D  8597
PDP_36                         $dd3b  8593D  8591
PDP_37                         $dd4a  8600D  8521
PDP_38                         $dd50  8602D  8564
PDP_40                         $dd62  8609D  8613
PDP_44                         $dd72  8616D  8546   8562   8568   8571
                                      8582   8601
PDP_46                         $dd7a  8619D  8617
PDP_48                         $dd84  8623D  8620
PDP_50                         $dd8b  8626D  8624
PDP_52                         $dd92  8629D  8627   8666
PDP_54                         $dda9  8640D  8643
PDP_56                         $ddac  8641D  8631
PDP_58                         $ddc5  8651D  8633   8668
PDP_60                         $ddcb  8653D  8635   8670
PDP_62                         $ddd1  8655D  8637   8639
PDP_64                         $dde5  8663D  8650   8652   8654
PDP_66                         $ddf6  8671D  8698   8719
PDP_68                         $ddf9  8672D  8511   8618   8664
Set_DOS_Flags                  $ddfd  8676D  8545   8561   8581   8615
                                      8649   8662   8711   8736
DOS_JMP_Illegal_Quantity       $de27  8686D  7704   8583   8646   8706
                                      8708   8723   8738
DOS_Parse_Unit                 $de2c  8693D  8566   8651
Get_Unit_Value                 $de33  8701D  8569   8653
DOS_Parse_Filename             $de49  8716D  8604   8657
DPF_10                         $de64  8731D  8729
DPF_20                         $de6a  8734D  8732
DPF_30                         $de70  8737D  8727
DPF_40                         $de7c  8743D  8740
DOS_Parse_Value                $de87  8750D  8540   8553   8575   8644
                                      8704
DOS_Get_Byte                   $de8a  8756D  7677   7695
DGB_10                         $de8f  8761D  8759
DGB_20                         $de9a  8765D  8761
Start_Message                  $de9d  8768D  7057   7058
Renumber                       $deb1  8774D  3505
Renu_Err                       $decd  8792D  8803   8818   8861
Renu_10                        $ded0  8793D  8791
Renu_15                        $df0f  8824D  8786   8797   8808
Renu_20                        $df12  8825D  8820
Renu_25                        $df1b  8832D  8871
Renu_30                        $df55  8875D  8834
Renu_35                        $df59  8877D  8879
Renu_40                        $df66  8889D  8918
Renu_45                        $dfa0  8923D  8895
Renu_50                        $dfbd  8938D  8945   8948
Renu_55                        $dfca  8944D  8941
Renu_60                        $dfd3  8949D  8943
Renu_90                        $dfd5  8950D  9791  10158
EDITOR_JUMP_TABLE              $e000  8959
EDIT_RESET                     $e037  8983D  8962  13582
EDIT_CLEAR                     $e03d  8990D  8969   9566
EDCL_10                        $e03f  8994D  8998
EDIT_HOME                      $e04a  9001D  9464  10539
Edit_Goto_Left_Margin          $e04e  9008D  9628  10574
Edit_Use_CursorRow             $e052  9015D  9244   9444   9600   9644
                                     10513
EDIT_SET_CRT                   $e057  9022D 10409  10420
ESC_10                         $e05b  9031D  9035
Edit_Program_Rows              $e067  9040D  9475
EDIT_GETIN                     $e0a7  9059D  8963   9092  11868
EDGE_10                        $e0ac  9064D  9068
Edit_Get_Line                  $e0bc  9075D  9103
EGL_10                         $e0bf  9079D  9081   9101   9143
EGL_20                         $e0d7  9092D  9084
EGL_30                         $e0e2  9097D  9100
EGL_40                         $e0ed  9102D  9094
EGL_50                         $e0f7  9107D  9110
EGL_60                         $e0fe  9111D  9108
EDIT_CHRIN                     $e116  9129D  8964  11880  11886
Edit_CHRIN_Standard            $e11d  9139D 10007  10008
Edit_CHRIN_Screen              $e121  9146D  9117   9121
ECS_05                         $e12d  9155D  9152
ECS_10                         $e139  9161D  9159
ECS_20                         $e13f  9164D  9161
ECS_30                         $e143  9166D  9154   9163   9164
ECS_40                         $e14c  9170D  9122
ECS_50                         $e15b  9177D  9169   9175
ECS_Ret                        $e163  9183
Edit_Quote_Toggle              $e164  9186D  9167   9403
EQT_Ret                        $e16e  9194D  9190
Edit_Display_Char              $e16f  9197D  9404   9433   9557   9560
EDC_10                         $e175  9203D  9201
EDC_20                         $e17b  9206D  9204
Edit_Chrout_Epilog_Return      $e186  9214D  9409
EDC_30                         $e18b  9219D  9211
Edit_Chrout_Epilog             $e18d  9222D  9246   9398   9465   9549
                                      9578   9590   9601   9629   9666
Edit_Wrap_Back                 $e196  9235D  9584
EWB_10                         $e1a5  9245D  9241
Edit_Erase_To_EOL              $e1aa  9249D  8995   9692   9707
EETE_10                        $e1ac  9253D  9256
Edit_To_Left_Margin            $e1b4  9260D  9113  13297
Edit_Full_Screen               $e1bb  9269D  9463   9476  10001
EDIT_BOTTOM_RIGHT              $e1c5  9279D  8979
EDIT_TOP_LEFT                  $e1ca  9287D  8978
CO_Shift                       $e1cf  9294D  9357
CO_Tab                         $e1d2  9297D  9305   9385
CO_Size                        $e1e2  9310D  9393
Edit_Delete_Char               $e1e5  9313D  9367
EdDC_05                        $e1e9  9318D  9302
EdDC_10                        $e1ed  9320D  9326
EDIT_CHROUT                    $e202  9337D  7137   7147   7196   7228
                                      7302   7310   7338   7607   7609
                                      7885   7890   7901   8338   8347
                                      8965   9078   9176  11776  11904
                                     12066  12174  13191  13299  13308
Edit_CHROUT_Standard           $e20c  9350D 10011  10012
CO_Exit                        $e266  9398D  9306   9318   9330   9408
                                      9412   9416   9419   9422   9430
                                      9438   9445   9452
CO_Normal                      $e269  9402D  9359
CO_Right                       $e271  9406D  9371
CO_Down                        $e27a  9411D  9373
CO_RVS                         $e27f  9414D  9375
CO_Bell                        $e285  9418D  9377
CO_ChText                      $e28a  9421D  9379
CO_Return                      $e28f  9424D  9361
CO_Escape                      $e292  9426D  9363
CO_ChNew                       $e295  9428D  9381
CO_Switch                      $e297  9429D  9570
CO_Rev                         $e29c  9432D  9365   9369
CO_Top                         $e2a1  9435D  9383
CO_ScDown                      $e2a9  9440D  9397
CO_ScUp                        $e2ac  9442D  9387
CO_DEOL                        $e2b7  9447D  9389
CODE_10                        $e2b9  9448D  9451
CO_DLine                       $e2c2  9454D  9391
CO_Home                        $e2cf  9461D  9395
CoHo_05                        $e2d3  9463
COHo_10                        $e2d6  9464D  9462
Edit_Screen_30                 $e2dc  9467D  9553
Edit_Screen_25                 $e2e2  9471D  9310
Edit_Screen_Program            $e2e6  9474D  9470
CS_Return                      $e2ef  9479D  9518
Edit_Insert_Char               $e2f2  9482D  9522
InCh_10                        $e2fa  9489D  9496
InCh_20                        $e307  9497D  9493
Edit_CHROUT_Shifted            $e316  9509D  9294
CS_Exit                        $e360  9549D  9488   9502   9504   9564
                                      9567   9575   9583   9610
CS_Size                        $e363  9553D  9548
CS_Pi                          $e366  9554D  9514
CS_Print                       $e369  9556D  9516
CS_Rev                         $e36e  9559D  9520   9524
CS_RVS                         $e373  9562D  9530
CS_Clear                       $e379  9566D  9477   9532
CS_ChOld                       $e37e  9569D  9538
CS_Bottom                      $e383  9572D  9542
CS_Graph                       $e38b  9577D  9544
CS_Left                        $e391  9580D  9526
CS_Tab                         $e39c  9586D  9534
CS_Up                          $e3ab  9592D  9528
CS_ScDown                      $e3b5  9598D  9440   9540   9594
COSW_10                        $e3bb  9600D  9596
CS_Delete_BOL                  $e3c1  9604D  9536
CSDB_10                        $e3c5  9609D  9613
CS_Insert_Line                 $e3ce  9618D  9546
TM_Epi                         $e3d8  9626D  9459
Edit_Cursor_Down               $e3e1  9634D  9217   9411   9656
CSCD_10                        $e3ef  9643D  9640
CO_Screen_Return               $e3f4  9649D  9424   9479
CO_JMP_Escape                  $e3ff  9659D  9426
Edit_Scroll                    $e40a  9669D  9690   9705
ES_10                          $e40d  9673D  9677
EDIT_SCROLL_DOWN               $e417  9682D  8973   9598   9625  10554
ESD_10                         $e419  9686D  9691
ESD_30                         $e426  9692D  9688
EDIT_SCROLL_UP                 $e429  9697D  8974   9442   9458   9641
ESU_10                         $e42b  9701D  9706
ESU_30                         $e438  9707D  9703
IRQ_MAIN                       $e442  9714D  8966  14138
IRQ_05                         $e452  9727D  9725
IRQ_NORMAL                     $e455  9730D  8967   9970   9972  13659
IRQ_10                         $e470  9746D  9743
IRQ_20                         $e474  9748D  9735   9737
IRQ_END                        $e477  9749D  8968
Delete                         $e47d  9757D  3507
Del_10                         $e4a3  9776D  9774
Del_20                         $e4ab  9779D  9777
Del_30                         $e4af  9781D  9784   9788
DelErr                         $e4c5  9792D  9769
Get_Record_Size                $e4c8  9796D  9820  11595
GRS_90                         $e4fa  9821D  9807   9816
Mon_Message                    $e4fb  9824D  7309
IS_TAB                         $e525  9830D  9304   9586
BITPOS                         $e537  9846D  9588   9841
Mon_Fill                       $e53f  9852D  7254   7282
MoFi_10                        $e555  9865D  9873
MoFi_End                       $e569  9874D  9869
MoFi_Err                       $e56c  9875D  9857   9860   9862
Open_Disk_Buffer               $e56f  9881D  9914
ODB_20                         $e580  9890D  9896
ODB_30                         $e58f  9897D  9894
Mon_Disk                       $e5a7  9909D  7263   7291
MIB_30                         $e5c0  9924D  9927
Mon_Output_Block               $e5d1  9933D  9917
MOB_10                         $e5e0  9944D  9947
Edit_Init                      $e606  9956D  8986
EdIn_10                        $e611  9964D  9966
EdIn_20                        $e66d 10004D 10006
Double_Beep                    $e68a 10020D 10017
EDIT_BEEP                      $e68d 10026D  8976   8977   9418  10023
BEEP_10                        $e69d 10036D 10045
BEEP_20                        $e6a5 10039D 10040  10043
BEEP_Ret                       $e6b6 10048D 10030
Set_Screen_SAL                 $e6b7 10051D  9672
Cursor_BOL                     $e6c9 10067D  8994   9686   9701  10494
Update_ScrPtr                  $e6cb 10077D  9019
RUN_String                     $e6dd 10093D  9097
CRT_TEXT                       $e6e5 10100D 10407  10408
CRT_GRAPHICS                   $e6f7 10126D 10418  10419
OLD                            $e701 10144D  3511
SOUND_TAB                      $e74e 10163D 10036
Line_Addr_Lo                   $e755 10169D 10058  10084  10442
Line_Addr_Hi                   $e76e 10178D 10062  10088  10447
B_P_0                          $e78e 10186D 10195  10198
U1                             $e796 10187D 10207
Reset_BP                       $e79b 10190D  9938
RBP_30                         $e7a0 10195D 10199
Preset_U1                      $e7ae 10203D  9884
PU1_10                         $e7b0 10207D 10210
Mon_Disk_Comm                  $e7ba 10214D  9918   9949
MDC_10                         $e7bf 10219D 10223
PIA1_Port_A                    $e810   937D  9979  10250  10252  10311
                                     11841
PIA1_Cont_A                    $e811   938D  9991  11667  11672
PIA1_Port_B                    $e812   939D  9987  10263  10264
PIA1_Cont_B                    $e813   940D  9986
PIA2_Port_A                    $e820   957D 11845
PIA2_Cont_A                    $e821   958D  9989  11663  11765  11828
                                     11849  11853
PIA2_Port_B                    $e822   959D  9983   9992  11693  11708
PIA2_Cont_B                    $e823   960D  9990  11686  11697  11706
VIA_Port_B                     $e840  1001D  9981  11659  11661  11676
                                     11679  11687  11694  11700  11722
                                     11724  11761  11763  11809  11811
                                     11829  11831  11836  11838  11840
                                     11850
VIA_Port_A                     $e841  1002
VIA_DDR_B                      $e842  1003D  9982
VIA_DDR_A                      $e843  1004
VIA_Timer_1_Lo                 $e844  1005D  6815
VIA_Timer_1_Hi                 $e845  1006D  6819   9984  11699  11833
VIA_Timer_1_Latch_Lo           $e846  1007
VIA_Timer_1_Latch_Hi           $e847  1008
VIA_Timer_2_Lo                 $e848  1009D  6817  10037  13645  13657
VIA_Timer_2_Hi                 $e849  1010D  6821  13647
VIA_Shift                      $e84a  1011D 10034  10046
VIA_ACR                        $e84b  1013D 10032  10047
VIA_PCR                        $e84c  1018D 10406  10417
VIA_IFR                        $e84d  1020D 11701  11834  13654
VIA_IER                        $e84e  1030D  9960   9998  13643
VIA_Port_A_no_HS               $e84f  1031
CRT_Address                    $e880  1036D  9032   9049   9052  10388
CRT_Value                      $e881  1037D  9033   9050   9053  10389
EDIT_KEY_SCAN                  $e924 10245D  8975   9748
ScKbd_02                       $e93a 10263D 10265  10312
ScKbd_04                       $e944 10270D 10307
ScKbd_06                       $e95c 10295D 10278  10280  10286
ScKbd_08                       $e960 10300D 10291
ScKbd_10                       $e961 10301D 10271
ScKbd_12                       $e96c 10316D 10302
ScKbd_22                       $e972 10319D 10328  10330
ScKbd_13                       $e973 10323D 10317
ScKbd_14                       $e97f 10329D 10326
ScKbd_15                       $e98b 10335D 10333
ScKbd_16                       $e98f 10340D 10324
ScKbd_18                       $e995 10343D 10336
ScKbd_24                       $e9a2 10352
ScKbd_26                       $e9a7 10357D 10348
ScKbd_28                       $e9af 10361D 10359
ScKbd_30                       $e9b1 10362D 10345
Lookup_Keycode                 $e9b4 10366D 10343
LoKe_10                        $e9bf 10374D 10372
LoKe_20                        $e9c0 10375D 10371
LoKe_30                        $e9c6 10378D 10375
Edit_Switch_Char_ROM           $e9ca 10382D  9429
EDIT_RESET_CRT                 $e9d3 10394D  8972   8987
EDIT_CHARSET_TEXT              $e9d6 10401D  8970   9421
EDIT_CHARSET_GRAPHICS          $e9e4 10412D  8971   9577
Read_Power_String              $e9f2 10423D  1490
Check_Linenumber               $e9fc 10433D 10466  10478
ChLi_Ret                       $ea1c 10454D 10451
Check_Line_Upwards             $ea1f 10459D 10502
CLU_10                         $ea21 10463D 10467
CLU_Ret                        $ea2b 10468D 10464
Check_Line_Downwards           $ea2c 10471D 10526
CLD_10                         $ea2e 10475D 10479
CLD_Ret                        $ea38 10480D 10476
Power_Scroll_Up                $ea39 10483D  9443   9642
PSU_10                         $ea4b 10496D 10500
PSU_20                         $ea61 10507D 10505
PSU_30                         $ea67 10509D 10497  10503  10527  10534
                                     10543  10566
PSU_Ret                        $ea70 10514D 10487  10521
Power_Scroll_Down              $ea71 10517D  9599
PSD_20                         $ea8f 10535D 10531
PSD_30                         $eaa7 10546D 10549
List_BASIC_Line                $eace 10571D 10508  10540  10565  11246
                                     13869
LBL_Ret                        $eae3 10585D 10577
Find_Power_Line                $eae4 10588D  8811  10507  10528
FPL_10                         $eaec 10595D 10617
FPL_40                         $eb14 10618D 10599  10606
KEYBOARD_NORMAL                $eb15 10621D 10378
KEYBOARD_SHIFTED               $eb65 10745D 10376
KEYBOARD_CONTROL               $ebb6 10861D 10369
Find_Entry                     $ec07 10956D  8904
Find_LINNUM                    $ec0b 10963D 11135
FiEn_10                        $ec17 10973D 10994
FiEn_20                        $ec38 10989D 10976
FiEn_30                        $ec3b 10992D 10978  10982
Install_Bank_Access            $ec43 10998D  7113   8825
FSC_10                         $ec45 11002D 11006
Bank_Fetch_Start               $ec51 11010D   880  11002  11005
Bank_Store_Start               $ec62 11029D   880
Bank_Fetch_End                 $ec62 11025
Bank_Store_End                 $ec75 11046D 11005
Get_Next                       $ec75 11051D 11084  11090  11099  11115
GeNe_10                        $ec7b 11057D 11055
Xfer_Line                      $ec7e 11061D  8911
XfLi_10                        $ec8f 11083D 11095  11104  11120
XfLi_20                        $ec9c 11089D 11094
XfLi_30                        $ecab 11096D 11088
XfLi_40                        $ecaf 11098D 11101
XfLi_50                        $ecb9 11103D 11097  11123
XfLi_55                        $eccf 11114D 11118
XfLi_60                        $ecda 11119D 11113
XfLi_70                        $ecde 11121D 11105  11107  11109  11111
XfLi_Ret                       $ece5 11124D 11086  11092
Exchange_Number                $ece6 11128D 11121  11159
ExNu_10                        $ed09 11149D 11154
ExNu_20                        $ed15 11155D 11133  11150
ExNu_Ret                       $ed21 11160
Reset_Renumber_Pointer         $ed22 11163D  8824   8885   8936  11241
                                     13829
Reset_BPTR                     $ed2a 11174D  8819
Update_Link                    $ed33 11184D  8870   8915   9778  11248
                                     13839
Extended_Command               $ed40 11198D 12834
ExCo_10                        $ed44 11203D 11230
ExCo_20                        $ed48 11206D 11211
ExCo_30                        $ed6a 11225D 11213
ExCo_40                        $ed6c 11226D 11228
Find_Text                      $ed78 11235D  3508
FiTe_10                        $ed83 11242D 11249
FiTe_20                        $ed92 11248D 11245
Contains_Pattern               $ed9a 11253D 11244  13834
CoPa_10                        $ed9a 11256D 11268
CoPa_20                        $ed9e 11258D 11265
CoPa_Ret                       $edb5 11270D 11261  11263
Load_Directory                 $edb6 11273D 11396
LoDi_10                        $edc6 11284D 11296
LoDi_20                        $edd0 11289D 11287
LoDi_30                        $edd2 11290D 11295
LoDi_40                        $ede0 11297D 11293
DOS_Get_Dir_Entry              $ede3 11300D 11354  11404
DGDE_05                        $edee 11315D 11312
DGDE_10                        $edf0 11317D 11320
DGDE_20                        $ee17 11340D 11345
DGDE_40                        $ee22 11347D 11343
DGDE_60                        $ee24 11349D 11352
DGDE_80                        $ee33 11358D 11321
DOS_Add_Comma                  $ee34 11361D 11415  11422  11429
DOS_Copy                       $ee3a 11382D  8209
DOSC_10                        $ee60 11404D 11540
DOSC_15                        $ee67 11409D 11406
DOSC_20                        $ee8a 11427D 11418
DOSC_25                        $ee92 11432D 11425
DOSC_35                        $eea7 11454D 11448
DOSC_47                        $eead 11459
DOSC_50                        $eeb5 11464D 11460
DOSC_55                        $eeb8 11468D 11518  11523  11525
DOSC_60                        $eeca 11477D 11484
DOSC_65                        $eeda 11486D 11482
DOSC_66                        $eeea 11494D 11489
DOSC_67                        $eefd 11504D 11501
DOSC_70                        $ef07 11509D 11515
DOSC_75                        $ef2b 11527D 11492  11512  11520
Send_Record_No                 $ef4c 11543D 11502
SRN_10                         $ef52 11549D 11547
Print_Filename                 $ef5d 11556D 11454
PrFi_10                        $ef64 11562D 11577
PrFi_20                        $ef82 11576D 11566  11569
PrFi_90                        $ef86 11578D 11560
Open_Read_File                 $ef87 11581D 11455
ORF_10                         $efa1 11596D 11594
Open_Write_File                $efa4 11599D 11464
KERNAL_MESSAGES                $f000 11617D 11773
MSG_TOO_MANY                   $f000 11620
MSG_FILE_OPEN                  $f00e 11621D 12342
MSG_FILE_NOT_O                 $f017 11622D  8134  12759
MSG_FILE_NOT_F                 $f024 11623D 12372
MSG_SEARCHING                  $f032 11624D 12190
MSG_FOR                        $f03d 11625
MSG_PRESS                      $f041 11626
MSG_RECORD                     $f04d 11627
MSG_ON_TAPE                    $f056 11628
MSG_LOAD                       $f05f 11629D 12185
MSG_WRITING                    $f064 11630
MSG_VERIFY                     $f06d 11631D 12188  12264
MSG_DEVICE_NOT                 $f074 11632D 12242  12761
MSG_NOT_INPUT                  $f086 11633
MSG_NOT_OUTPUT                 $f094 11634D 12763
MSG_FOUND                      $f0a3 11635
MSG_OK                         $f0aa 11636D 12266
MSG_READY                      $f0ae 11637D 12151
MSG_SURE                       $f0b6 11638D  8360
MSG_BAD_DISK                   $f0c5 11639D  8092
TALK                           $f0d2 11642D  8049   9919  11470  12104
                                     12747
LISTEN                         $f0d5 11649D  8194   9900   9939  11504
                                     12231  12639  12668  12787  13370
TALI_10                        $f0d7 11655D 11820
TALI_20                        $f0fa 11673D 11665
TALI_30                        $f0ff 11676D 11677
Send_IEEE_Byte                 $f109 11682D 11668  11716  11787  11800
SIB_10                         $f11e 11694D 11695
SIB_20                         $f128 11698D 11734
SIB_30                         $f12d 11700D 11704
tby6                           $f138 11705D 11746
SECOND                         $f143 11712D  9902   9942  11507  12239
                                     12641  12672  12789  13373
Set_ATN                        $f148 11719D 11789  11821
Time_Out_Writing               $f151 11728D 11702
Time_Out_Reading               $f15b 11737D 11835
Timo_W                         $f165 11744D 11732
Timo_S                         $f167 11745D 11753
Device_Not_Present             $f16c 11749D 11690
Timo_R                         $f170 11754D 11741
Set_NRFD_NDAC_low              $f175 11758D 11788
Display_Kernal_Message         $f185 11770D  8093   8361  11779  12029
                                     12267  12383
TKSA                           $f193 11783D  8052   9922  11473  12106
                                     12749
CIOUT                          $f19e 11792D  9904   9945  10196  10221
                                     11510  11905  12246  12645  12647
                                     12655  12855  13384
Ciout_10                       $f1a6 11799D 11796
Ciout_20                       $f1ab 11802D 11798
UNTLK                          $f1ae 11806D  6362   8063   9928  11487
                                     11927  12090
UNLSN                          $f1b9 11816D  7871   9905   9948  10200
                                     10224  11516  11527  11923  12250
                                     12662  12673  12858  13387
ACPTR                          $f1c0 11824D  7876   7880   7886   8054
                                      9924  11290  11477  11891  12070
                                     12107  12109
Acptr_10                       $f1cd 11832D 11743
Acptr_20                       $f1d2 11834D 11837
Acptr_30                       $f1ee 11845D 11842
Acptr_40                       $f1f9 11850D 11851
Kernal_GETIN                   $f205 11858D 14117
GETIN_10                       $f20d 11865D  7893   7896
Kernal_CHRIN                   $f215 11871D  7929   8363   8366   8371
                                      8374   8380   9885   9888  14075
KeIn_10                        $f224 11881D 11864  11875
KeIn_20                        $f231 11887D 11882
KeIn_30                        $f237 11890D 11866
KeIn_40                        $f238 11891D 11888
Kernal_CHROUT                  $f266 11896D 12380  12382  14081
KeCH_10                        $f271 11905D 11903
Kernal_CLALL                   $f2a2 11910D 12378  14123
Kernal_CLRCHN                  $f2a6 11917D  7104   7905   8362  12011
                                     14069
KeCL_10                        $f2af 11924D 11922
Set_Default_IO                 $f2b8 11930D 11926
LOOKUP_LA                      $f2c1 11940D  8132  11978  12343  12742
                                     12781
LOOK_10                        $f2c3 11944D 11947
LOOK_Ret                       $f2cb 11948D 11945
Set_LFS_From_X                 $f2cd 11953D  8136  11985  12744  12783
Kernal_CLOSE                   $f2dd 11968D 14051
Close_LA_in_A                  $f2e2 11975D  7907   8109
Close_File_A                   $f2e7 11982D  8122
ClFi_10                        $f2f1 11989D 11987
ClFi_20                        $f30b 11999D 11979  11991
Check_STOP_Key                 $f335 12004D  7376   7891  12020  12391
                                     13553  13832
ChST_Ret                       $f342 12014D 12009  12028
Kernal_STOP                    $f343 12017D  2053  11733  11742  12069
                                     12656  14111
Kernal_Message_If_Direct       $f349 12024D 12152  12189  12191
In_Direct_Mode                 $f351 12032D  8090   8334   8358  11559
                                     12027  12058  12085  12092  12153
Load_File                      $f356 12040D  7544  12148
LoFi_10                        $f35c 12046D 12048
LoFi_15                        $f35f 12047D 12045
LoFi_20                        $f370 12055D 12052
LoFi_25                        $f377 12058D 12056
LoFi_30                        $f38e 12067D  6364  12059
LoFi_35                        $f390 12068
LoFi_40                        $f392 12069D 12089
LoFi_45                        $f3a7 12078D 12072
LoFi_50                        $f3a9 12079D 12081
LoFi_55                        $f3af 12082D 12074
LoFi_60                        $f3bd 12088D 12083  12086
LoFi_70                        $f3c1 12090D 11297  12077
LoFi_80                        $f3cd 12095D 12093
Open_Load_File                 $f3d0 12098D  6359  11276  12050
Merge                          $f3e6 12112D  3510
Kernal_LOAD                    $f401 12121D 14087
KeLO_10                        $f403 12125D 12116
Load_Verify                    $f405 12128D 12260
Load_Verify_Params_Set         $f41d 12145D  8309  12133  12909
LVPS_20                        $f439 12160D 12154
LVPS_Ret                       $f43f 12162D 12150
Print_EAL                      $f440 12165D 12087  12095
PrEA_10                        $f44e 12174D 12176
PrEA_Ret                       $f454 12177
Display_Load_Or_Verify         $f46d 12182D 12060
DLOV_10                        $f475 12189D 12187
Get_File_Parameter             $f47d 12194D 12131  12623
GFP_Ret                        $f4a8 12216D 12230
Get_Comma_And_Byte             $f4a9 12219D 12207  12210  12282  12285
Send_Filename                  $f4af 12226D  9801  11596  11611  12103
                                     12363  12638
Send_DOS_Command               $f4ba 12236D  8196
SeDC_10                        $f4c6 12244D 12241
SeDC_20                        $f4c8 12245D 12249
Kernal_VERIFY                  $f4f6 12255D 14099
VERI_OK                        $f508 12266D 12263
Get_Open_Close_Parameter       $f50d 12270D 11971  12334
Set_Filename_From_String       $f53c 12294D 12205  12289
ChrGot_Or_RTS                  $f54d 12307D 12204  12206  12209  12281
                                     12284  12287
Get_Ret                        $f554 12314D 12311  12327  12359  12361
Get_Comma_And_Chr              $f555 12317D 12222  12288
Assert_Not_At_End              $f558 12323D 12278
Err_f55d                       $f55d 12328D 12341  12362
Kernal_OPEN                    $f560 12331D 14045
Mf563                          $f563 12335D  8018   8037
Open_File                      $f565 12338D  7872
Display_File_Not_Found         $f5ad 12369D 12057
Handle_IO_Error                $f5af 12375D  8135  12243  12265  12344
                                     12349  12764
Disassemble                    $f5c2 12387D  7253   7281
Disa_10                        $f5c5 12391D 12401
Disa_15                        $f5cf 12395D  7347
Disa_Main                      $f5e3 12403D 12392  12394
Print_Dis_Line                 $f5e6 12406D 12399  13306
Disa_20                        $f5e9 12411D 12419
Disa_40                        $f5f2 12414D 12421
Disa_50                        $f5f8 12416D 12413
Dis_Inst                       $f614 12433D 12398
DiIn_10                        $f61c 12439D 12442
Analyze_Opcode                 $f625 12445D 13264
AnOp_10                        $f634 12469D 12462
AnOp_20                        $f63f 12477D 12472
AnOp_30                        $f643 12479D 12464  12466
AnOp_40                        $f647 12481D 12478
AnOp_50                        $f65c 12493D 12502
AnOp_60                        $f660 12496D 12499
AnOp_70                        $f667 12501D 12492  12494
admode_index                   $f66b 12506D 12471
Kernal_SYS                     $f6c3 12598D 14105
Set_Save_Range                 $f6cc 12606D 12624
Kernal_SAVE                    $f6dd 12620D 14093
Mf6e0                          $f6e0 12624D  8290   8293
Save_File                      $f6e3 12627D  7569
SaFi_10                        $f6e9 12633D 12637
SaFi_20                        $f6ec 12634D 12632
SaFi_30                        $f70f 12650D 12658  12661
SaFi_40                        $f717 12654D 12651
SaFi_50                        $f727 12662D 12653
Close_Disk_File                $f72a 12665D  9929   9950  11532  11539
                                     11988  12091
Store_Mnemonic                 $f739 12676D 12423  13266
PrMn_10                        $f746 12685D 12696
PrMn_20                        $f74a 12687D 12691
Kernal_UDTIM                   $f768 12703D  9733  12724  14129
ud_10                          $f772 12711D 12709
ud_20                          $f784 12720D 12707  12713  12716
ud_30                          $f78e 12725D 12721
Kernal_CHKIN                   $f7af 12730D  7874  14057
CHKIN_10                       $f7d0 12753D 12746
CHERR_17                       $f7d6 12759D 12743  12782
CHERR_74                       $f7d9 12761D 12751  12791
CHERR_94                       $f7dc 12763D 12784
CHERR_IO                       $f7de 12764
Kernal_CHKOUT                  $f7fe 12769D 14063
KeCo_10                        $f821 12793D 12786
Set_Wedge_Unit                 $f827 12800D 12829
SWUN_10                        $f838 12810D 12804
Wedge_Parser                   $f842 12816D  1500
Command_Or_Status              $f869 12839D 12823  12825
Send_Command                   $f873 12849
SeCo_10                        $f876 12853D 12857
SeCo_20                        $f880 12858D 12854
Get_Status                     $f883 12861D 12844
Wedge_Directory                $f88c 12869D 12827  12846
Print_Status                   $f898 12878D 12865  13395
RUN_Now                        $f8a1 12885D 12893
Wedge_Run                      $f8a6 12888D 12833
WeRu_10                        $f8aa 12893D 12896
Wedge_Load                     $f8b3 12899D 12831  12906
WeLo_10                        $f8be 12907D 12904
Wedge_Prepare                  $f8c7 12912D  6352   7527   9898  12864
                                     12873  12908  13369  13394  13411
Wedge_Filename                 $f8d0 12922D 12872  12907
WeFi_10                        $f8db 12930D 12928  12934
WeFi_20                        $f8e4 12935D 12932
Mnemonic_Left                  $f8f3 12945D 12681
Mnemonic_Right                 $f933 13014D 12683
admode_format                  $f973 13083D 12482
adr_char1                      $f981 13111D 13141
adr_char2                      $f987 13112D 13144
Store_Address                  $f98d 13115D 12424  13267
StAd_10                        $f99f 13127D 13149
StAd_20                        $f9ae 13134D 13131
StAd_30                        $f9b9 13139D 13128
StAd_40                        $f9cd 13148D 13140  13145
StAd_50                        $f9d2 13151D 13136
StAd_Ret                       $f9d8 13153D 13122  13150
Store_Hex_XA                   $f9dc 13158D 13152  13765
Store_Hex                      $f9e2 13166D 13133  13138  13162  13703
                                     13705
Print_Dis_Buf                  $f9f9 13186D 12425
PDB_10                         $f9fb 13190D 13194
Ass_Operand                    $fa08 13198D 13204  13210  13261
AsOp_30                        $fa1e 13211D 13202  13206
AsOp_Ret                       $fa3e 13227D 13213  13216  13218
AsOp_40                        $fa3f 13228D 13220
Assemble                       $fa42 13232D  7245   7250   7273   7278
Ass_010                        $fa47 13241D 13250
Ass_020                        $fa55 13247D 13254
Ass_040                        $fa76 13262D 13256
Ass_050                        $fa79 13263D 13277  13282
Ass_060                        $fa8f 13271D 13275
Ass_070                        $fa9a 13276D 13270
Ass_Err                        $faaa 13283D 13240  13248  13258  13279
                                     13294
Ass_080                        $faad 13284D 13272
Ass_090                        $fab9 13290D 13296
Inc_STAL                       $fb19 13330D 13462  13480  13566
Add_STAL                       $fb1b 13336D  7386  10993
AdST_00                        $fb1c 13340D 12428
AdST_10                        $fb22 13343
AdST_Ret                       $fb24 13344D 13342
Inc_BPTR                       $fb25 13348D  9872  13463  13481
Add_BPTR                       $fb27 13354D  8866   8914
AdBP_00                        $fb28 13358
AdBP_10                        $fb2e 13361
AdBP_Ret                       $fb30 13362D 13360
DOS_Open_Comm_Write            $fb31 13366D 10193  10217  12852  13382
Mon_Wedge                      $fb3e 13376D  7249   7277
MoWe_10                        $fb48 13384D 13386
Mon_Wedge_Status               $fb53 13390D 13380
Mon_Dir                        $fb5f 13399D  7244   7272
MoDi_10                        $fb63 13404D 13407
Set_STATUS                     $fbc4 13418D 11745  11755  11844  12076
Mon_Get_3                      $fbc9 13427D 13448  13472
MG3_Err                        $fbdf 13440D 13431  13434  13437
Mon_Compare                    $fbe4 13445D  7252   7280
MoCo_10                        $fbea 13450D 13465
MoCo_20                        $fc08 13462D 13459
Mon_Transfer                   $fc16 13469D  7262   7290
MoTr_10                        $fc23 13478D 13483
MoTr_Ret                       $fc34 13484D 13510
MoTr_Err                       $fc37 13485D 13499
MoTr_20                        $fc3a 13486D 13477
MoTr_30                        $fc62 13507D 13519
MoTr_40                        $fc73 13514D 13512
MoTr_50                        $fc7b 13518D 13516
Mon_Hunt                       $fc80 13522D  7256   7284
MoHu_10                        $fc85 13527D 13530
MoHu_20                        $fc99 13536D 13541
MoHu_30                        $fc9e 13538D 13535
MoHu_40                        $fca8 13543D 13532  13550
MoHu_50                        $fcb9 13551D 13537  13542  13544  13546
MoHu_60                        $fcbe 13553D 13567
MoHu_70                        $fcca 13558D 13563
MoHu_80                        $fcdd 13566D 13560
MoHu_Ret                       $fce2 13568D 13554  13556
MoHu_Err                       $fce5 13569D 13528  13534
Entry_RESET                    $fd16 13575D 14137
Entry_NMI                      $fd49 13603D 14136
Set_FA_to_8                    $fd4c 13609D 12277
Mon_Unit                       $fd51 13617D  7243   7271
MoUn_10                        $fd60 13627D 13621  13623  13625
Mon_Next                       $fd6e 13634D  7259   7287
Mon_Step_IRQ                   $fd89 13651D 13638  13640
MSI_10                         $fd96 13659D 13656
Get_Constant                   $fd99 13663D 13205
GeCo_10                        $fda2 13670D 13681
GeCo_20                        $fdaf 13675D 13678
GeCo_25                        $fdbd 13682D 13729
GeCo_30                        $fdcf 13692D 13672  13684
GeCo_40                        $fde4 13704D 13702
GeCo_Ret                       $fdef 13711D 13667  13686
GeCo_45                        $fdf2 13713D 13669
GeCo_50                        $fdfc 13718D 13728
GeCo_70                        $fe0d 13726D 13715  13717
Expand_Address                 $fe17 13733D 13281
ExAd_10                        $fe1a 13737D 13742
ExAd_20                        $fe27 13743D 13739
Expand_Target                  $fe36 13751D 13228
Offset_To_Target               $fe46 13771D 13151  13764
OTT_10                         $fe4d 13783D 13781
OTT_20                         $fe53 13787D 13785
OTT_30                         $fe59 13791D 13789
Replace                        $fe5a 13796D  3509
Repl_00                        $fe67 13804D 13801
Repl_01                        $fe6b 13806D 13810
Repl_02                        $fe82 13818D 13822
Repl_08                        $fe9a 13830D 13840
Repl_10                        $fe9e 13832D 13838
Repl_20                        $feb0 13839D 13835
Repl_Ret                       $feb8 13842D 13833
Repl_Err                       $febb 13843D 13808  13820
Replace_String                 $febe 13847D 13836
ReSt_05                        $fec7 13855D 13905
ReSt_10                        $fece 13860D 13865
ReSt_20                        $fed9 13866D 13862
ReSt_25                        $fee0 13869D 13867
ReSt_30                        $fee7 13872D 13854
ReSt_35                        $fefb 13885D 13883
ReSt_40                        $ff0a 13893D 13891
ReSt_45                        $ff1d 13903D 13946
ReSt_50                        $ff21 13906D 13872
ReSt_60                        $ff43 13925D 13935  13938
ReSt_62                        $ff4d 13930D 13928
ReSt_64                        $ff53 13933D 13931
ReSt_Ret                       $ff6f 13947
Basic_CONCAT                   $ff93 13952D  1082
Basic_DOPEN                    $ff96 13958D  1083
Basic_DCLOSE                   $ff99 13964D  1084
Basic_RECORD                   $ff9c 13970D  1085
Basic_HEADER                   $ff9f 13976D  1086
Basic_COLLECT                  $ffa2 13982D  1087
Basic_BACKUP                   $ffa5 13988D  1088
Basic_COPY                     $ffa8 13994D  1089
Basic_APPEND                   $ffab 14000D  1090
Basic_DSAVE                    $ffae 14006D  1091
Basic_DLOAD                    $ffb1 14012D  1092
Basic_DIRECTORY                $ffb4 14018D  1093   1096
Basic_RENAME                   $ffb7 14024D  1094
Basic_SCRATCH                  $ffba 14030D  1095
Read_DS                        $ffbd 14036
OPEN                           $ffc0 14042D  1077
CLOSE                          $ffc3 14048D  1078
CHKIN                          $ffc6 14054D  2865   2885
CHKOUT                         $ffc9 14060D  2692
CLRCHN                         $ffcc 14066D  1457   2894
CHRIN                          $ffcf 14072D  1629
CHROUT                         $ffd2 14078D  1465   2741   2795   2824
                                      9810   9811  11534  11564  11570
                                     11572
Basic_LOAD                     $ffd5 14084D  1065
Basic_SAVE                     $ffd8 14090D  1066
Basic_VERIFY                   $ffdb 14096D  1067
Basic_SYS                      $ffde 14102D  1076
STOP                           $ffe1 14108D  1887
GETIN                          $ffe4 14114D  2980
CLALL                          $ffe7 14120D  1814
UDTIM                          $ffea 14126
HardwareVectors                $fffa 14133
INDEXA                         $001f   352D  1363   1373   1379   1519
                                      1521   1544   1546   1548y  1552
                                      1604y  1608   1611y  1613   1615y
                                      1616   1617   1618y  1673   1675
                                      1678   1680   1683y  1714y  1716
                                      1718   1721y  1964   1966   1970
                                      1972   1973y  1977y  2501y  2575
                                      2576   2589   2591   2622y  2626y
                                      2629y  2636   2637   2641   2643
                                      2794y  3240   3242   3297   3299
                                      3314   3316   3981   3982   3984y
                                      3987y  3990y  3994y  4002y  4006
                                      4007   4009   4010   4016y  4020y
                                      4024y  4033   4036   4040   4041
                                      4043   4267   4335   4368   4695
                                      4698   4703   4715y  4718y  4770
                                      4772   4775y  4785   4789y  4800y
                                      4810y  4813y  4903   4904   4914y
                                      4947   4948   4958   4959   4974y
                                      4977y  4980y  4982   4983   5041
                                      5042   5044   5134y  5174   5177
                                      5179   5690   5691   5693y  5696y
                                      5699y  5702y  5710y  5890   5891
                                      5893y  5945   5946   5949y  5952y
                                      5955y  5960y  5963y  8609y  8725y
                                      8731   8733   8743   8744  10153
                                     10156  12300  12302
TMPPTC                         $005c   508D  1362   1366   1518y  1522
                                      1524   1526y  1534   1537   1582y
                                      1743   1744   1745y  1750y  1755y
                                      1759y  1885y  1893y  1896y  1914y
                                      1917y  1918   1919   1943y  1952y
                                      2240   2243   3886   3887   3893y
                                      3897y  3902   3951   3952   4048y
                                      4051y  4054y  4056y  4058y  4060y
                                      4062y  4063   4066   4082   4083
                                      4176   4177   4183y  4188y  4191y
                                      4193   4196y  4197   4222y  4234y
                                      4239y  4248y  4260y  4263y  4295
                                      4297y  4300   4301y  4305y  4316y
                                      4321y  4369y  4372y  6216   6219
                                      6226   6227   6253   6284   8833y
                                      8839y  8842y  8890y  8893y  8900y
                                      8903y  8939y  8946   8949   9763
                                      9765   9781y  9786   9787  10529
                                     10532  10536  10538  10558y 10561y
                                     10562  10563  10576y 10579y 10582y
                                     10595  10596  10598y 10601y 10604y
                                     10607  10609  10613y 10616y 11075
                                     11078  11169  11171  11188y 11191y
                                     11192  11193  11264y 11267y 13863y
                                     13875  13877  13881  13882  13884
                                     13900  13902  13908  13910
FAC1M3/FAC1M4                  $0061   515D  2447   2531y  2534y  2550
                                      2553   2560y  2565   2670   2671
                                      3306   3410   3540   3579y  3582y
                                      3654   3681   3715   3727   3732
                                      4158   4313   4332   4590   4666
                                      4857   4868y  4936   5158   5231
                                      5375   5399   5402   5424   5426
                                      5438   5458   5481   5483   5499
                                      5633   5817   5843   5881   5912
                                      5951   6058   6102   6135   6517
                                      6519   6820   6838   6840    516D
                                      2354   2450   2546   2554   2566
                                      2667   2668   3304   3407   3541
                                      3546   3591   3655   3679   3717
                                      3724   3729   4160   4315   4336
                                      4591   4667   4855   4937   5064
                                      5080   5082   5160   5232   5372
                                      5401   5404   5421   5423   5437
                                      5459   5484   5486   5497   5631
                                      5820   5840   5883   5913   5948
                                      6057   6108   6136   6166   6171
                                      6514   6516   6822   6833   6835
TXTPTR                         $0077   564D  1491   1492   1644   1671
                                      1712   1726   1728   1849   1852
                                      2009   2011   2054   2057   2061y
                                      2064y  2068y  2071y  2074   2075
                                      2077   2153   2154   2182   2183
                                      2204   2206   2231   2232   2242
                                      2245   2270   2272   2286   2287
                                      2289   2311y  2851   2852   2968
                                      2969   2974   2975   2991   2992
                                      3002   3017   3018   3041   3042
                                      3047   3048   3062y  3065y  3068y
                                      3071y  3150   3152   3202   3204
                                      3205   3260   3262   3263   3384
                                      3385   3453y  4480   4482   4529
                                      4531   4534   4537   4551   4553
                                      5170   5171   5175   5180   5201
                                      5202   6294y  6992   6994   8590
                                      8592   8593y 10444  10449  11054
                                     11056  11057x 11077  11080  11204
                                     11216  11256  12035  12821y 12842
                                     12843y 12853y 12929  12931y 12936
                                     12938  13805  13816
LINNUM                         $0011   331D  1571   1572   1749   1754
                                      1874   1875   1877   1900   1902
                                      2227   2374   2375   2377   2398
                                      2400   2402   2403   2404   2406
                                      2407   2408   2409   2411   2412
                                      2414   5233   5234   5241   5243
                                      5247y  5250   5252   5262y  5277y
                                      7030   7031   7036y  7039y  7040y
                                      7043y  7044y  7047y  7050   7052
                                      8147   8149   8788   8790   8793
                                      8800   8802   8804   8906   8909
                                      9772   9773   9775  10504  10506
                                     10602  10605  10959  10960  10977
                                     10981  10985  10988  11138  11140
                                     11410  11411  11546  11548  12603
                                     12811  13719  13721  13724
FAC1M1/FAC1M2                  $005f   513D  2023   2024   3310   3613
                                      3768   3794y  4426   4600   4619
                                      4661   5014y  5381   5395   5398
                                      5430   5432   5440   5456   5475
                                      5477   5503   5637   5811   5849
                                      5877   5899   5902   5910   5959
                                      6044   6048   6094   6133   6389
                                      6523   6525   6816   6834   6836
                                     11141    514D  2490   3308   3769
                                      4427   4601   4620   4663   5378
                                      5397   5400   5427   5429   5439
                                      5457   5478   5480   5501   5635
                                      5814   5846   5879   5911   5954
                                      6046   6098   6134   6390   6520
                                      6522   6818   6837   6839  11139
STRPTR/FROUND                  $006c   533D  2532   2535   2539   2543
                                      2562   2563   3347   4617   4618
                                      4623y  4634   4636   4640   4646
                                      4647   4862   4864   4866y  4878
                                      4879   4889y  4892y  4895y  5305
                                      5360   5705   5731   5760   5785
                                      6274   6742   6872    538D  4668
                                      4832   5323   5358   5369   5403
                                      5405   5420   5436   5460   5487
                                      5489   5490   5518   5539   5629
                                      5673   5861   5898   5964   5983
                                      6001   6010   6060   6106   6137
                                      6138   6146   6713   6735   6844
FAC1EX                         $005e   512D  2330   2468   2568   2569
                                      3312   3348   3767   3777   3781
                                      4117   4602   4632   4659   4825
                                      5227   5306   5345   5348   5355
                                      5362   5415   5443   5447   5454
                                      5587   5591   5712   5722   5729
                                      5762   5803   5804   5806   5894
                                      5903   5962   5980   5997   6008
                                      6025   6059   6090   6123   6160
                                      6165   6275   6434   6684   6719
                                      6729   6730   6843   6846   6949
STAL                           $00fb   863D  7210   7212   7344   7346
                                      7366   7368   7440   7442   7591
                                      7593   7626   8933   8935   8942
                                      8947   9925y  9944y 10969  10971
                                     11016y 12614  12616  12642  12643
                                     12649  12654y 12660  13223  13285
                                     13287  13314  13318  13340  13341
                                     13343  13455  13474  13476  13488
                                     13490  13494  13496  13511  13513
                                     13514  13779  13784
TMPPTD                         $006e   542D  1668   1688   2470   2473
                                      2474   2482   3555   4231   4243
                                      4265   4266   4283   4284   4290
                                      4308   4309   4326   4327   4337
                                      4340   4390   4391   4635   4639
                                      5172   5173   5199   5200   6428
                                      6496   6505   6542   6552   6565
                                      6753   6754   6767   6768   6775y
                                      6777   6781   6782   6783   6785
                                      6786   6791   6792
FUNCPT                         $004b   476D  4496   4497   4511   4513
                                      4515y  4519y  4533y  4536y  4544
                                      4546   4556y  4559y  4562y  4565y
                                      4568y  4741   4744   4747   4749
                                      4752   4754   4756   4759y  4763
                                      4764y  4765   4767   4771y  4774
                                      4776   4778   4794   4797   4802y
                                      4806y  6656   6657   6662   6663
                                      6672   6673   6905   6906   6915
                                      6916
TMPPTA                         $0055   500D  1378   1380   1382   1385y
                                      1389y  1391   1564   1569   3961
                                      3962   3964   3965   3969   3970
                                      3975   3976   3991   3992   3995
                                      3996   4011   4013   4086   4087
                                      4270   4272   4275   4287y  4289
                                      4292   4353   4356  13888  13893
                                     13909  13912  13918  13921  13925y
                                     13930  13932  13934  13937
FAC1SI                         $0063   517D  2021   2036   2469   2663
                                      3134   3301   3346   3783   3789
                                      4110   5225   5301   5303   5350
                                      5416   5467   5469   5704   5732
                                      5734   5900   5957   5977   6027
                                      6061   6068   6088   6110   6141
                                      6167   6273   6423   6427   6686
                                      6688   6842   6877   6881   6912
                                      6945   6948   6965
CHRGET                         $0070   562D  1493   1869   2033   2112
                                      2358   2381   2777   2862   2996
                                      3161   3227   3359   3369   3455
                                      3483   3670   3850   3855   3875
                                      4102   5145   6200   6206   6217
                                      7022   8550   8600   8621   8629
                                      8696   8753   8798   8809   9770
                                     11132  11224  11239  12803  12902
                                     13803
RENNEW                         $0023   373D  8781   8784   8789   8794
                                      8814   8817   8845   8848   8854
                                      8856   8857   8859   8928   8940
                                     11240  11243  11257  11262  11266
                                     13804  13809  13811  13817  13821
                                     13827  13828  13831  13837  13851
                                     13852  13853  13857  13859  13866
                                     13887  13914  13915  13916  13919
                                     13939
CHRGOT                         $0076   563D  1865   2030   2122   2214
                                      2325   2339   2699   2976   3035
                                      3049   3158   3215   3486   3816
                                      3825   3838   4163   4547   5065
                                      5161   5189   5272   7674   7691
                                      7701   8509   8616   8663   8785
                                      8795   8806   9760   9767  10450
                                     11156  12310  12326  12926  13799
VARTAB                         $002a   381D  1520   1528   1529   1531
                                      1533   1538   1561   1565   1577
                                      1578   1784   1787   1815   1816
                                      2547   2551   3884   3885   6366
                                      6368   8950   8951   9779  12135
                                     12138  12156  12158  12609  12611
                                     13885  13889  13896  13898  13933
                                     13936  13940  13944
SA                             $00d3   832D  6354   7524   7560   7868
                                      7993   8051   8145   9804   9921
                                      9941  11472  11497  11506  11531
                                     11538  11587  11605  11962  12049
                                     12102  12105  12142  12201  12211
                                     12232  12274  12286  12353  12355
                                     12635  12640  12669  12748  12788
                                     13372
STATUS                         $0096   610D  2922   3495   3624   6360
                                      7878   7888   8392   9800  11282
                                     11292  11475  11480  11499  11511
                                     11552  11589  11607  11862  11887
                                     12055  12068  12088  12198  12240
                                     12261  12275  12347  12739  12750
                                     12778  12790  12918  13421  13422
FNADR                          $00da   839D  6347   6349   7505   7507
                                      7536y  8232   8234   8449   8451
                                      9819y 11326  11328  11331y 11335y
                                     11338y 11341y 11350y 11365y 11420y
                                     11427y 11432y 11442  11562y 11567y
                                     11574y 11592y 11610y 12245y 12301
                                     12303  12937  12939
EAL                            $00c9   801D  6357   6358   6365   6367
                                      7564  11279  11281  11284  11289
                                     11291y 12053  12054  12061  12063
                                     12073y 12078y 12079y 12080y 12082
                                     12084  12137  12140  12155  12157
                                     12168  12170  12214  12215  12610
                                     12612  12650  12652
TXTTAB                         $0028   377D  1598   1599   1735   1736
                                      1778y  1780y  1781   1785   1847
                                      1850   2132   2134   2236   2237
                                      6355   6356   7029   7035   7062
                                      7065  10148y 10150y 10530  10533
                                     10591  10592  11168  11170  12212
                                     12213  12613  12615
TMPPTB                         $0057   501D  1361   1365   1371   1374
                                      1376   1384y  1388y  1390   1562
                                      1566   3955   3956   4021   4026
                                      4034y  4037y  8813y  8816y 10535
                                     10537  10593  10594  10608  10610
                                     13886  13890  13920  13923  13926y
                                     13927  13929
CursorCol                      $00c6   798D  2750   2769   4435   9012
                                      9090   9119   9149   9166   9219
                                      9245   9264   9300   9303   9317
                                      9319   9355   9407   9490   9581
                                      9582   9609   9655   9740   9833
                                      9836  10490  10510  10524  10544
                                     11876
FA                             $00d4   833D  7553   8045   8048   8115
                                      8207   8508   8709  11386  11389
                                     11437  11469  11495  11529  11536
                                     11585  11603  11674  11964  12043
                                     12203  12208  12283  12357  12630
                                     12752  12792  12916  12941  13613
FORPNT                         $0046   460D  1329   1332   1334   1337
                                      2039   2041   2254   2424   2425
                                      2448y  2451y  2461   2580   2583
                                      2588   2590   2604y  2966   2967
                                      3116   3117   3135   3136   5270
                                      5275   5278   5279   5937   5938
FRETOP                         $0030   393D  1422   1425   1434   1437
                                      1808   1809   2540   2544   2631
                                      2634   4027   4030   4414   4417
                                      4693   4696   4721   4722   4746
                                      4748   4816   4818   4960   4962
                                      4967   4970   7055   7056  11286
STREND                         $002e   389D  1358   1359   1575   1576
                                      1819   1820   3953   3954   3977
                                      3979   4178   4180   4280   4281
                                      4294   4298   4415   4418   4706
                                      4709  11277  11399  11478y 11509y
                                     13895  13897  13941  13945
BPTR                           $00f9   862D  7441   7443   8916   8926
                                      8929   9855   9866   9868  11037y
                                     11178  11180  13286  13288  13358
                                     13359  13361  13435  13450  13473
                                     13475  13501  13503  13504  13506
                                     13515  13517  13518
TMPVAR                         $005a   507D  3553   3557   4380   4401
                                      6191   6223   6230   6232   6233
                                      6238   6243   6255   6280   6290
                                      6297   6417   6449   6458   6464
                                      6480   6491   6492   6547   6574
                                      6579
FNLEN                          $00d1   830D  6351   7547   8230   8447
                                      8503   8605   9817  11347  11414
                                     11446  11449  11450  11461  11462
                                     11576  12047  12199  12229  12248
                                     12276  12299  12636  12935  13408
FRESPC                         $0032   397D  4711   4712   4719   4720
                                      4740   4743   4780   4782   4783
                                      4786y  4788   4790   4792   4796
                                      4803y  4807y  4809   4812   4815
                                      4817   4915y  4920   4921   4923
CURLIN                         $0036   407D  1473   1497   2014   2016
                                      2069   2072   2155   2160   2161
                                      2186   2187   2208   2210   2226
                                      2266   2268   2839   2840   3146
                                      3148   4448   6382   6383
FAC2M3/FAC2M4                  $0069   527D  3341   3770   3773   3793y
                                      5425   5661   5697   5816   5832
                                      5842   5844    528D  3343   3771
                                      3774   5422   5658   5694   5819
                                      5831   5839   5841
VARNAM                         $0042   449D  3542   3543   3837   3870
                                      3871   3876   3892   3895   3930
                                      3931   4047   4050   4142   4144
                                      4148   4150   4185   4187   4233
                                      4238   4342   4345
ScrPtr                         $00c4   797D  9091y  9107y  9150y  9206y
                                      9253y  9320y  9322y  9329y  9448y
                                      9486y  9491y  9494y  9498y  9611y
                                      9674y  9742y  9747y 10085  10089
                                     10496y 10546
MEMUSS                         $00fd   864D  7365   7367   7398   7399
                                      7406   8233   8235   8246y  8659
                                      8660   9858   9865   9867  13432
                                     13487  13489  13491  13493  13495
                                     13497
TopMargin                      $00e0   844D  8993   9004   9239   9273
                                      9290   9436   9454   9457   9592
                                      9621   9624   9627   9687   9700
                                     10463  10474  10542  10550  10553
                                     10556
CursorRow                      $00d8   837D  9005   9018   9116   9240
                                      9243   9435   9456   9572   9593
                                      9595   9623   9638   9643  10488
                                     10501  10512  10522  10541  10564
                                     11878
QUOTE                          $0022   245D  1937   1946   2316   2905
                                      3010   3377   4609   4629   7530
                                      7534   8529   8636   9189   9193
                                     11087  11093  11319  11342  13800
INDEXB                         $0021   356D  1523   1530   1542   1549y
                                      1553   3128   5178   5183   5185y
                                      5188y  5193y  6075   6081   6083y
                                      6087y  6092y  6097y  6101y  6107
CR                             $000d   233D  1630   2740   7227   7900
                                      7930   8337   8367   8375   8377
                                      9102   9172   9360   9517  11533
                                     11766  11889  12379  13307  13711
IOPMPT                         $0010   323D  1455   1459   2693   2733
                                      2807   2842   2866   2873   2886
                                      2893   2896   2920   2939   2987
                                      3087   3492   7025
VALTYP                         $0007   270D  2430   2717   2997   3187
                                      3235   3257   3358   3544   3764
                                      3848   3862   4137   4169   4409
                                      4425   4670   5123
RigMargin                      $00d5   835D  9104   9209   9242   9254
                                      9283   9301   9324   9406   9449
                                      9485   9501   9574   9675  10499
                                     10547  11884
COUNT                          $0005   257D  1514   1563   1579   1670
                                      1687   1713   4079   4166   4220
                                      4244   4268   4306   4338  11202
                                     11217  11225
DESCPT                         $004d   480D  2573   2574   2603y  4592
                                      4593   4874   4875   5024y  5027y
                                      5034   5035   5055y  5077y  5099
                                      5101
VARPTR                         $0044   455D  4069   4070   4354   4357
                                      4359   4476   4478   4516   4521
                                      4523y  4527   4538   4540   6541
                                      6553
FAC2EX                         $0066   524D  3335   3758   3759   5325
                                      5326   5363   5365   5711   5719
                                      5979   5998   6653   6728   6731
LefMargin                      $00e2   846D  9011   9218   9238   9263
                                      9274   9291   9316   9437   9580
                                      9608   9654  10074  10443
Mon_Lo                         $00c2   791D 13137  13222  13226  13243
                                     13675  13679  13680  13689  13690
                                     13704  13718  13723  13780
CHARAC                         $0003   255D  2304   2308   2309   3004
                                      3009   3013   3713   3722   4610
                                      4625   6172   6667   6724
DOS_RL                         $00b9   783D  9808   9812   9814  11409
                                     11424  11447  11459  11483  11488
                                     11500  11519  11593
RENINC                         $0021   360D  8780   8783   8801   8805
                                      8855   8858   9764   9766   9782y
                                      9785   9789   9790
LA                             $00d2   831D  7680   7870   8107   8131
                                      8499   8543  11960  11972  12280
                                     12335  12351
Mon_A                          $00bf   788D 12682  12688  13119  13134
                                     13139  13454  13458  13492  13498
                                     13502  13505
VERCK                          $009d   651D  7522   7542   7567   8308
                                     12071  12125  12132  12149  12186
                                     12259  12820
JIFFY_CLOCK                    $008d   578D  2491   3608   3609   9964
                                     12706  12708  12710  12711  12714
                                     12718  12719
MONCNT                         $00b5   775D  7173   7182   7185   7201
                                      7333   7336   7439   7453  13551
                                     13562
CharsInBuffer                  $009e   655D  9067   9069   9079   9096
                                     10346  10353  11865  12012  12892
                                     13325
FAC2SI                         $006b   529D  3345   3754   5304   5349
                                      5703   5706   5971   6272   6659
                                      6867
FAC2M1                         $0067   525D  3337   3756   3757   5431
                                      5667   5708   5810   5834   5848
                                      5850
FUNJMP                         $0052   494D  3695   3697   5093   5102
                                      5324   5354   5368   5419   6717
                                      6734
INDEXC                         $004f   484D  2581y  2584y  2595y  2598y
                                      2642   2645   4954y  4957y  4965
                                      4968
ARYTAB                         $002c   385D  1817   1818   3888   3890
                                      3949   3950   3967   3968   4174
                                      4175
FAC3M4                         $0026   367D  4378   4398   5517   5520
                                      5628   5657   5659   5672   5825
                                      5882
FAC3M3                         $0025   366D  4349   4370   4395   5519
                                      5522   5627   5660   5662   5671
                                      5880
GARBFL                         $0009   291D  1646   1658   1699   3638
                                      3641   3642   3645   4688   4725
                                      4729
ENDCHR                         $0004   256D  1655   1703   1706   2306
                                      2307   2310   2313   3016   4611
                                      4627
BSOS_KBD                       $0001    15D 10637  10650  10661  10720
                                     10733  10751  10764  10775  10834
                                     10847
BotMargin                      $00e1   845D  8996   9282   9573   9639
                                      9685   9702  10462  10475  10492
LDTND                          $00ae   753D  7987   8116  11914  11943
                                     11989  11990  11992  12345  12350
CINV                           $0090   586D  7120   7122   7471   7473
                                      9727   9971   9973  13639  13641
INPPTR                         $0040   439D  2960   2961   2972   2973
                                      3043   3044   3079   3080   3085
OLDTXT                         $003a   419D  1838   2058   2059   2158
                                      2159   2178   2181   2849   2850
QTSW                           $00cd   824D  9114   9162   9191   9192
                                      9368   9519   9665  10584
Mon_Hi                         $00c3   792D 13132  13219  13244  13676
                                     13685  13700  13720  13725
DosPtr                         $00bb   785D 11309  11311  11313  11318y
                                     11325  11327  11398  11402
W_Bank                         $00b7   781D  7128   7316   7429   7922
                                      8828   8884  11033  13452
R_Bank                         $00b6   780D  7126   7314   7427   7914
                                      8827   8924  10972  11013
Source_Unit                    $009c   646D  8205   8506   8567   8570
                                     11388  11468  11535  11584
FAC2M2                         $0068   526D  3339   5428   5664   5700
                                      5813   5833   5845   5847
ACCSYM                         $004a   470D  3214   3223   3224   3226
                                      3230   3265   3280   3765
MEMSIZ                         $0034   401D  1806   1807   4739   4742
                                      7053   7054   7060   7064
INSRT                          $00dc   840D  9203   9205   9364   9500
                                      9503   9523   9663
DATAX                          $00d9   838D  9155   9157   9158   9177
                                      9182   9341   9356
Mon_Op                         $00c1   790D 12411  12440  13242  13263
                                     13276  13290  13293
Dis_Line                       $00ba   784D  7354   7356   7358   7396
                                      7409   9899  13284
Wedge_Unit                     $00ab   739D  7033  12805  12812  12915
                                     12940  13626  13628
Key_Flags                      $0098   624D  6344   9967  10253  10255
                                     10295  10296  10370
FACTPA                         $0054   499D  5929   5930   6756   6759
                                      6760   6908   6909
FAC3M2                         $0024   365D  5521   5524   5626   5663
                                      5665   5670   5878
FAC3M1                         $0023   364D  5523   5526   5625   5666
                                      5668   5669   5876
SUBFLG                         $000a   297D  1839   1995   3866   3878
                                      3883   4469   4494
INTFLG                         $0008   276D  2428   3030   3576   3849
                                      3869   4135   4171
Mon_Tmp                        $00cb   803D  7447   7450   7656   7661
                                     13682  13713
SAL                            $00c7   800D  9029   9030   9031y  9673y
                                     10059  10063
Dis_Length                     $00be   787D 12417  12427  12485  13121
                                     13129  13289
PC_Adjust                      $00b3   773D  7103   7115   7131   7341
                                     12400  12402
DFLTO                          $00b0   761D  9174   9977  11900  11920
                                     11934  12793
YSAVE                          $0048   466D  2970   2971   3045   3046
                                      3251   3330
TANSGN                         $000c   311D  3333   3802   6883   6885
                                      6903   6913
DIMFLG                         $0006   264D  3831   4134   4173   4217
                                      4251   4302
DFLTN                          $00af   757D 11863  11874  11924  11936
                                     12753
Target_Unit                    $00ad   746D 11387  11436  11494  11528
                                     11602
CRSW                           $00ac   744D  9105   9142   9171   9354
                                     11883
BLNCT                          $00a8   718D  9088   9208   9736   9739
                                      9994
BSOUR                          $00a5   678D 11675  11691  11715  11786
                                     11802
Power_Flag                     $0099   629D  9653  10427  10429  10486
                                     10520
LASTPT                         $0014   341D  4671   4993   4995   4999
                                      7026
INPFLG                         $000b   301D  2832   2959   2978   2999
                                      3081
DELAY                          $00e6   850D  9996  10325  10327  10342
DOS_FC                         $00b1   771D 11355  11416  11486  11514
BLNON                          $00aa   734D  9083   9086   9741   9744
LastInputCol                   $00a1   665D  9112   9120   9168  11885
C3PO                           $00a0   663D 11664  11670  11795  11797
ReverseFlag                    $009f   659D  9200   9415   9563   9664
CBINV                          $0092   594D  9726  13588  13590  13658
RNDX                           $0088   569D  6824   6825   6848   6849
BITS                           $0065   520D  4827   4833   4834   6130
SGNFLG                         $0064   518D  6199   6246   6776   6796
DATPTR                         $003e   433D  2137   2138   2949   2950
DATLIN                         $003c   427D  2837   2838   3066   3070
OLDLIN                         $0038   412D  2162   2163   2184   2185
TEMPPT                         $0013   336D  1828   4654   4675   4997
SCROV                          $00eb   860D  9346  10013  10014
SCRIV                          $00e9   859D  9136  10009  10010
PrevChar                       $00e8   857D  9230   9461   9963
CHIME                          $00e7   851D 10016  10029  10038
KOUNT                          $00e5   849D  9997  10329  10335
LSTX                           $00e4   848D 10318  10323  10340
ScreenRows                     $00df   843D  9046   9275  10000
Mon_ZP                         $00cc   804D 13278  13280  13701
BLNSW                          $00a7   711D  9080   9734   9995
InputRow                       $00a3   666D  9115   9637  11879
Default_Bank                   $009a   636D  9969  11018  11039
Key_Index                      $0097   615D 10257  10290  10316
NMINV                          $0094   599D 13584  13586  13606
FACTPB                         $0059   506D  5922   6794   6795
RIGHT                          $001d   244D  2811   9370   9525
JIFFY6                         $00f8   861D 12720  12723
XMAX                           $00e3   847D  9975  10347
Mon_B                          $00c0   789D 12684  12687
Mon_Format                     $00bd   786D 12483  13118
DOS_EOF                        $00b2   772D 11481  11517
GDBLN                          $00a9   727D  9089   9745
SFDX                           $00a6   704D 10258  10362
InputCol                       $00a4   667D  9118  11877
Stop_Flag                      $009b   641D 10361  12007
JUMPER                         $0051   489D  3698   7014
CTRLY                          $0019   242D  9386   9539
TEMPST                         $0016   348D  1827   4655
CTRLV                          $0016   241D  9388   9535
CTRLU                          $0015   240D  9390   9545
DEL                            $0014   239D  9366   9521
HOME                           $0013   238D  9394   9531
RVS                            $0012   237D  9374   9529
DOWN                           $0011   236D  9372   9527
CTRLO                          $000f   235D  9382   9541
CTRLN                          $000e   234D  9378   9543
TAB                            $0009   232D  9384   9533
CTRLD                          $0004   230D  9392   9547
CTRLB                          $0002   229D  9380   9537
USRVEC                         $0001   253D  7018   7019
Basic_USR                      $0000   252D  1107   7015
ISNUM                          $007d   565D  2502
ESC                            $001b   243D  9362
BELL                           $0007   231D  9376
CTRLA                          $0001   228D  9396
FSBLK                          $00de   842
ROPRTY                         $00dd   841
TAPE1                          $00d6   836
ZD0                            $00d0   828
EOT                            $00cf   827
BITTS                          $00ce   826
ZP_b8                          $00b8   782
SCROLLING                      $00b4   774
FAC3M5                         $0027   369
DS_Ptr                         $000e   316
DS_Len                         $000d   315
INDEXA                         $001f   352D  1363   1373   1379   1519
                                      1521   1544   1546   1548y  1552
                                      1604y  1608   1611y  1613   1615y
                                      1616   1617   1618y  1673   1675
                                      1678   1680   1683y  1714y  1716
                                      1718   1721y  1964   1966   1970
                                      1972   1973y  1977y  2501y  2575
                                      2576   2589   2591   2622y  2626y
                                      2629y  2636   2637   2641   2643
                                      2794y  3240   3242   3297   3299
                                      3314   3316   3981   3982   3984y
                                      3987y  3990y  3994y  4002y  4006
                                      4007   4009   4010   4016y  4020y
                                      4024y  4033   4036   4040   4041
                                      4043   4267   4335   4368   4695
                                      4698   4703   4715y  4718y  4770
                                      4772   4775y  4785   4789y  4800y
                                      4810y  4813y  4903   4904   4914y
                                      4947   4948   4958   4959   4974y
                                      4977y  4980y  4982   4983   5041
                                      5042   5044   5134y  5174   5177
                                      5179   5690   5691   5693y  5696y
                                      5699y  5702y  5710y  5890   5891
                                      5893y  5945   5946   5949y  5952y
                                      5955y  5960y  5963y  8609y  8725y
                                      8731   8733   8743   8744  10153
                                     10156  12300  12302
TMPPTC                         $005c   508D  1362   1366   1518y  1522
                                      1524   1526y  1534   1537   1582y
                                      1743   1744   1745y  1750y  1755y
                                      1759y  1885y  1893y  1896y  1914y
                                      1917y  1918   1919   1943y  1952y
                                      2240   2243   3886   3887   3893y
                                      3897y  3902   3951   3952   4048y
                                      4051y  4054y  4056y  4058y  4060y
                                      4062y  4063   4066   4082   4083
                                      4176   4177   4183y  4188y  4191y
                                      4193   4196y  4197   4222y  4234y
                                      4239y  4248y  4260y  4263y  4295
                                      4297y  4300   4301y  4305y  4316y
                                      4321y  4369y  4372y  6216   6219
                                      6226   6227   6253   6284   8833y
                                      8839y  8842y  8890y  8893y  8900y
                                      8903y  8939y  8946   8949   9763
                                      9765   9781y  9786   9787  10529
                                     10532  10536  10538  10558y 10561y
                                     10562  10563  10576y 10579y 10582y
                                     10595  10596  10598y 10601y 10604y
                                     10607  10609  10613y 10616y 11075
                                     11078  11169  11171  11188y 11191y
                                     11192  11193  11264y 11267y 13863y
                                     13875  13877  13881  13882  13884
                                     13900  13902  13908  13910
FAC1M3/FAC1M4                  $0061   515D  2447   2531y  2534y  2550
                                      2553   2560y  2565   2670   2671
                                      3306   3410   3540   3579y  3582y
                                      3654   3681   3715   3727   3732
                                      4158   4313   4332   4590   4666
                                      4857   4868y  4936   5158   5231
                                      5375   5399   5402   5424   5426
                                      5438   5458   5481   5483   5499
                                      5633   5817   5843   5881   5912
                                      5951   6058   6102   6135   6517
                                      6519   6820   6838   6840    516D
                                      2354   2450   2546   2554   2566
                                      2667   2668   3304   3407   3541
                                      3546   3591   3655   3679   3717
                                      3724   3729   4160   4315   4336
                                      4591   4667   4855   4937   5064
                                      5080   5082   5160   5232   5372
                                      5401   5404   5421   5423   5437
                                      5459   5484   5486   5497   5631
                                      5820   5840   5883   5913   5948
                                      6057   6108   6136   6166   6171
                                      6514   6516   6822   6833   6835
TXTPTR                         $0077   564D  1491   1492   1644   1671
                                      1712   1726   1728   1849   1852
                                      2009   2011   2054   2057   2061y
                                      2064y  2068y  2071y  2074   2075
                                      2077   2153   2154   2182   2183
                                      2204   2206   2231   2232   2242
                                      2245   2270   2272   2286   2287
                                      2289   2311y  2851   2852   2968
                                      2969   2974   2975   2991   2992
                                      3002   3017   3018   3041   3042
                                      3047   3048   3062y  3065y  3068y
                                      3071y  3150   3152   3202   3204
                                      3205   3260   3262   3263   3384
                                      3385   3453y  4480   4482   4529
                                      4531   4534   4537   4551   4553
                                      5170   5171   5175   5180   5201
                                      5202   6294y  6992   6994   8590
                                      8592   8593y 10444  10449  11054
                                     11056  11057x 11077  11080  11204
                                     11216  11256  12035  12821y 12842
                                     12843y 12853y 12929  12931y 12936
                                     12938  13805  13816
LINNUM                         $0011   331D  1571   1572   1749   1754
                                      1874   1875   1877   1900   1902
                                      2227   2374   2375   2377   2398
                                      2400   2402   2403   2404   2406
                                      2407   2408   2409   2411   2412
                                      2414   5233   5234   5241   5243
                                      5247y  5250   5252   5262y  5277y
                                      7030   7031   7036y  7039y  7040y
                                      7043y  7044y  7047y  7050   7052
                                      8147   8149   8788   8790   8793
                                      8800   8802   8804   8906   8909
                                      9772   9773   9775  10504  10506
                                     10602  10605  10959  10960  10977
                                     10981  10985  10988  11138  11140
                                     11410  11411  11546  11548  12603
                                     12811  13719  13721  13724
FAC1M1/FAC1M2                  $005f   513D  2023   2024   3310   3613
                                      3768   3794y  4426   4600   4619
                                      4661   5014y  5381   5395   5398
                                      5430   5432   5440   5456   5475
                                      5477   5503   5637   5811   5849
                                      5877   5899   5902   5910   5959
                                      6044   6048   6094   6133   6389
                                      6523   6525   6816   6834   6836
                                     11141    514D  2490   3308   3769
                                      4427   4601   4620   4663   5378
                                      5397   5400   5427   5429   5439
                                      5457   5478   5480   5501   5635
                                      5814   5846   5879   5911   5954
                                      6046   6098   6134   6390   6520
                                      6522   6818   6837   6839  11139
STRPTR/FROUND                  $006c   533D  2532   2535   2539   2543
                                      2562   2563   3347   4617   4618
                                      4623y  4634   4636   4640   4646
                                      4647   4862   4864   4866y  4878
                                      4879   4889y  4892y  4895y  5305
                                      5360   5705   5731   5760   5785
                                      6274   6742   6872    538D  4668
                                      4832   5323   5358   5369   5403
                                      5405   5420   5436   5460   5487
                                      5489   5490   5518   5539   5629
                                      5673   5861   5898   5964   5983
                                      6001   6010   6060   6106   6137
                                      6138   6146   6713   6735   6844
FAC1EX                         $005e   512D  2330   2468   2568   2569
                                      3312   3348   3767   3777   3781
                                      4117   4602   4632   4659   4825
                                      5227   5306   5345   5348   5355
                                      5362   5415   5443   5447   5454
                                      5587   5591   5712   5722   5729
                                      5762   5803   5804   5806   5894
                                      5903   5962   5980   5997   6008
                                      6025   6059   6090   6123   6160
                                      6165   6275   6434   6684   6719
                                      6729   6730   6843   6846   6949
STAL                           $00fb   863D  7210   7212   7344   7346
                                      7366   7368   7440   7442   7591
                                      7593   7626   8933   8935   8942
                                      8947   9925y  9944y 10969  10971
                                     11016y 12614  12616  12642  12643
                                     12649  12654y 12660  13223  13285
                                     13287  13314  13318  13340  13341
                                     13343  13455  13474  13476  13488
                                     13490  13494  13496  13511  13513
                                     13514  13779  13784
TMPPTD                         $006e   542D  1668   1688   2470   2473
                                      2474   2482   3555   4231   4243
                                      4265   4266   4283   4284   4290
                                      4308   4309   4326   4327   4337
                                      4340   4390   4391   4635   4639
                                      5172   5173   5199   5200   6428
                                      6496   6505   6542   6552   6565
                                      6753   6754   6767   6768   6775y
                                      6777   6781   6782   6783   6785
                                      6786   6791   6792
FUNCPT                         $004b   476D  4496   4497   4511   4513
                                      4515y  4519y  4533y  4536y  4544
                                      4546   4556y  4559y  4562y  4565y
                                      4568y  4741   4744   4747   4749
                                      4752   4754   4756   4759y  4763
                                      4764y  4765   4767   4771y  4774
                                      4776   4778   4794   4797   4802y
                                      4806y  6656   6657   6662   6663
                                      6672   6673   6905   6906   6915
                                      6916
TMPPTA                         $0055   500D  1378   1380   1382   1385y
                                      1389y  1391   1564   1569   3961
                                      3962   3964   3965   3969   3970
                                      3975   3976   3991   3992   3995
                                      3996   4011   4013   4086   4087
                                      4270   4272   4275   4287y  4289
                                      4292   4353   4356  13888  13893
                                     13909  13912  13918  13921  13925y
                                     13930  13932  13934  13937
FAC1SI                         $0063   517D  2021   2036   2469   2663
                                      3134   3301   3346   3783   3789
                                      4110   5225   5301   5303   5350
                                      5416   5467   5469   5704   5732
                                      5734   5900   5957   5977   6027
                                      6061   6068   6088   6110   6141
                                      6167   6273   6423   6427   6686
                                      6688   6842   6877   6881   6912
                                      6945   6948   6965
CHRGET                         $0070   562D  1493   1869   2033   2112
                                      2358   2381   2777   2862   2996
                                      3161   3227   3359   3369   3455
                                      3483   3670   3850   3855   3875
                                      4102   5145   6200   6206   6217
                                      7022   8550   8600   8621   8629
                                      8696   8753   8798   8809   9770
                                     11132  11224  11239  12803  12902
                                     13803
RENNEW                         $0023   373D  8781   8784   8789   8794
                                      8814   8817   8845   8848   8854
                                      8856   8857   8859   8928   8940
                                     11240  11243  11257  11262  11266
                                     13804  13809  13811  13817  13821
                                     13827  13828  13831  13837  13851
                                     13852  13853  13857  13859  13866
                                     13887  13914  13915  13916  13919
                                     13939
CHRGOT                         $0076   563D  1865   2030   2122   2214
                                      2325   2339   2699   2976   3035
                                      3049   3158   3215   3486   3816
                                      3825   3838   4163   4547   5065
                                      5161   5189   5272   7674   7691
                                      7701   8509   8616   8663   8785
                                      8795   8806   9760   9767  10450
                                     11156  12310  12326  12926  13799
Mon_Register                   $02a0   882D  7106   7108   7110   7112
                                      7116   7119   7121   7123   7125
                                      7127   7129   7209   7211   7315
                                      7317   7321   7323   7326   7328
                                      7332   7343   7345   7422   7426
                                      7428   7466   7468   7470   7472
                                      7479   7481   7483   7485   7487
                                      7488   7489   7496
VARTAB                         $002a   381D  1520   1528   1529   1531
                                      1533   1538   1561   1565   1577
                                      1578   1784   1787   1815   1816
                                      2547   2551   3884   3885   6366
                                      6368   8950   8951   9779  12135
                                     12138  12156  12158  12609  12611
                                     13885  13889  13896  13898  13933
                                     13936  13940  13944
SA                             $00d3   832D  6354   7524   7560   7868
                                      7993   8051   8145   9804   9921
                                      9941  11472  11497  11506  11531
                                     11538  11587  11605  11962  12049
                                     12102  12105  12142  12201  12211
                                     12232  12274  12286  12353  12355
                                     12635  12640  12669  12748  12788
                                     13372
STACK                          $0100   865D  1326   1331   1333   1335
                                      1338   3130   3133   3139   3143
                                      3145   3147   3149   3151   4154
                                      4156   4159   4161   4582   4583
                                      6426   6499   6504   6546   6551
                                      6566   6582   6584   6592   6594
                                      6596   6599   6601   9723  11149
STATUS                         $0096   610D  2922   3495   3624   6360
                                      7878   7888   8392   9800  11282
                                     11292  11475  11480  11499  11511
                                     11552  11589  11607  11862  11887
                                     12055  12068  12088  12198  12240
                                     12261  12275  12347  12739  12750
                                     12778  12790  12918  13421  13422
FNADR                          $00da   839D  6347   6349   7505   7507
                                      7536y  8232   8234   8449   8451
                                      9819y 11326  11328  11331y 11335y
                                     11338y 11341y 11350y 11365y 11420y
                                     11427y 11432y 11442  11562y 11567y
                                     11574y 11592y 11610y 12245y 12301
                                     12303  12937  12939
EAL                            $00c9   801D  6357   6358   6365   6367
                                      7564  11279  11281  11284  11289
                                     11291y 12053  12054  12061  12063
                                     12073y 12078y 12079y 12080y 12082
                                     12084  12137  12140  12155  12157
                                     12168  12170  12214  12215  12610
                                     12612  12650  12652
TXTTAB                         $0028   377D  1598   1599   1735   1736
                                      1778y  1780y  1781   1785   1847
                                      1850   2132   2134   2236   2237
                                      6355   6356   7029   7035   7062
                                      7065  10148y 10150y 10530  10533
                                     10591  10592  11168  11170  12212
                                     12213  12613  12615
BUF                            $0200   866D  1558   1573   1574   1581
                                      1632   1647   1681   1691   1692
                                      1704   1709   1723   1725   2730
                                      2731   2732   2867   2868   2870
                                      2918   2927   2981   2982   2983
                                     11208  11260  13807  13813  13819
                                     13824  13861
TMPPTB                         $0057   501D  1361   1365   1371   1374
                                      1376   1384y  1388y  1390   1562
                                      1566   3955   3956   4021   4026
                                      4034y  4037y  8813y  8816y 10535
                                     10537  10593  10594  10608  10610
                                     13886  13890  13920  13923  13926y
                                     13927  13929
CursorCol                      $00c6   798D  2750   2769   4435   9012
                                      9090   9119   9149   9166   9219
                                      9245   9264   9300   9303   9317
                                      9319   9355   9407   9490   9581
                                      9582   9609   9655   9740   9833
                                      9836  10490  10510  10524  10544
                                     11876
FA                             $00d4   833D  7553   8045   8048   8115
                                      8207   8508   8709  11386  11389
                                     11437  11469  11495  11529  11536
                                     11585  11603  11674  11964  12043
                                     12203  12208  12283  12357  12630
                                     12752  12792  12916  12941  13613
FORPNT                         $0046   460D  1329   1332   1334   1337
                                      2039   2041   2254   2424   2425
                                      2448y  2451y  2461   2580   2583
                                      2588   2590   2604y  2966   2967
                                      3116   3117   3135   3136   5270
                                      5275   5278   5279   5937   5938
FRETOP                         $0030   393D  1422   1425   1434   1437
                                      1808   1809   2540   2544   2631
                                      2634   4027   4030   4414   4417
                                      4693   4696   4721   4722   4746
                                      4748   4816   4818   4960   4962
                                      4967   4970   7055   7056  11286
STREND                         $002e   389D  1358   1359   1575   1576
                                      1819   1820   3953   3954   3977
                                      3979   4178   4180   4280   4281
                                      4294   4298   4415   4418   4706
                                      4709  11277  11399  11478y 11509y
                                     13895  13897  13941  13945
BPTR                           $00f9   862D  7441   7443   8916   8926
                                      8929   9855   9866   9868  11037y
                                     11178  11180  13286  13288  13358
                                     13359  13361  13435  13450  13473
                                     13475  13501  13503  13504  13506
                                     13515  13517  13518
TMPVAR                         $005a   507D  3553   3557   4380   4401
                                      6191   6223   6230   6232   6233
                                      6238   6243   6255   6280   6290
                                      6297   6417   6449   6458   6464
                                      6480   6491   6492   6547   6574
                                      6579
FNLEN                          $00d1   830D  6351   7547   8230   8447
                                      8503   8605   9817  11347  11414
                                     11446  11449  11450  11461  11462
                                     11576  12047  12199  12229  12248
                                     12276  12299  12636  12935  13408
FRESPC                         $0032   397D  4711   4712   4719   4720
                                      4740   4743   4780   4782   4783
                                      4786y  4788   4790   4792   4796
                                      4803y  4807y  4809   4812   4815
                                      4817   4915y  4920   4921   4923
CURLIN                         $0036   407D  1473   1497   2014   2016
                                      2069   2072   2155   2160   2161
                                      2186   2187   2208   2210   2226
                                      2266   2268   2839   2840   3146
                                      3148   4448   6382   6383
FAC2M3/FAC2M4                  $0069   527D  3341   3770   3773   3793y
                                      5425   5661   5697   5816   5832
                                      5842   5844    528D  3343   3771
                                      3774   5422   5658   5694   5819
                                      5831   5839   5841
VARNAM                         $0042   449D  3542   3543   3837   3870
                                      3871   3876   3892   3895   3930
                                      3931   4047   4050   4142   4144
                                      4148   4150   4185   4187   4233
                                      4238   4342   4345
DOS_Flags                      $033e   911D  7723   7727   7744   7753
                                      7763   7856   8007   8166   8182
                                      8282   8498   8537   8548   8572
                                      8602   8641   8655   8672   8679
                                      8680   8728
ScrPtr                         $00c4   797D  9091y  9107y  9150y  9206y
                                      9253y  9320y  9322y  9329y  9448y
                                      9486y  9491y  9494y  9498y  9611y
                                      9674y  9742y  9747y 10085  10089
                                     10496y 10546
Bank_Store                     $028b   880D  7448   8840   8843   8846
                                      8849   8877   8891   8894   8907
                                      8910   9871  11085  11091  11100
                                     11116  11151  11157  13291  13479
                                     13508
MEMUSS                         $00fd   864D  7365   7367   7398   7399
                                      7406   8233   8235   8246y  8659
                                      8660   9858   9865   9867  13432
                                     13487  13489  13491  13493  13495
                                     13497
TopMargin                      $00e0   844D  8993   9004   9239   9273
                                      9290   9436   9454   9457   9592
                                      9621   9624   9627   9687   9700
                                     10463  10474  10542  10550  10553
                                     10556
CursorRow                      $00d8   837D  9005   9018   9116   9240
                                      9243   9435   9456   9572   9593
                                      9595   9623   9638   9643  10488
                                     10501  10512  10522  10541  10564
                                     11878
DOS_Command_Buffer             $0353   915D  8014   8144   8146   8148
                                      8150   8152   8247   8264   8267
                                      8286   8439   8448   8450   9886
                                      9891   9915  10208  10219  11391
Bank_Fetch                     $027a   881D   880   7176   7189   7449
                                      8938  10974  10980  10984  10987
                                     11003  12439  13292  13451  13453
                                     13456  13457  13478  13507  13558
QUOTE                          $0022   245D  1937   1946   2316   2905
                                      3010   3377   4609   4629   7530
                                      7534   8529   8636   9189   9193
                                     11087  11093  11319  11342  13800
INDEXB                         $0021   356D  1523   1530   1542   1549y
                                      1553   3128   5178   5183   5185y
                                      5188y  5193y  6075   6081   6083y
                                      6087y  6092y  6097y  6101y  6107
CR                             $000d   233D  1630   2740   7227   7900
                                      7930   8337   8367   8375   8377
                                      9102   9172   9360   9517  11533
                                     11766  11889  12379  13307  13711
IOPMPT                         $0010   323D  1455   1459   2693   2733
                                      2807   2842   2866   2873   2886
                                      2893   2896   2920   2939   2987
                                      3087   3492   7025
VALTYP                         $0007   270D  2430   2717   2997   3187
                                      3235   3257   3358   3544   3764
                                      3848   3862   4137   4169   4409
                                      4425   4670   5123
RigMargin                      $00d5   835D  9104   9209   9242   9254
                                      9283   9301   9324   9406   9449
                                      9485   9501   9574   9675  10499
                                     10547  11884
COUNT                          $0005   257D  1514   1563   1579   1670
                                      1687   1713   4079   4166   4220
                                      4244   4268   4306   4338  11202
                                     11217  11225
DESCPT                         $004d   480D  2573   2574   2603y  4592
                                      4593   4874   4875   5024y  5027y
                                      5034   5035   5055y  5077y  5099
                                      5101
VARPTR                         $0044   455D  4069   4070   4354   4357
                                      4359   4476   4478   4516   4521
                                      4523y  4527   4538   4540   6541
                                      6553
FAC2EX                         $0066   524D  3335   3758   3759   5325
                                      5326   5363   5365   5711   5719
                                      5979   5998   6653   6728   6731
KEYD                           $026f   870D  9062   9064   9065   9098
                                     10352  12894  13311  13313  13316
                                     13317  13320  13321  13323
LefMargin                      $00e2   846D  9011   9218   9238   9263
                                      9274   9291   9316   9437   9580
                                      9608   9654  10074  10443
Mon_Lo                         $00c2   791D 13137  13222  13226  13243
                                     13675  13679  13680  13689  13690
                                     13704  13718  13723  13780
CHARAC                         $0003   255D  2304   2308   2309   3004
                                      3009   3013   3713   3722   4610
                                      4625   6172   6667   6724
Ass_Buf                        $02c1   886D 13207  13211  13214  13251
                                     13259  13273  13694  13737  13740
                                     13744  13745  13762
DOS_RL                         $00b9   783D  9808   9812   9814  11409
                                     11424  11447  11459  11483  11488
                                     11500  11519  11593
RENINC                         $0021   360D  8780   8783   8801   8805
                                      8855   8858   9764   9766   9782y
                                      9785   9789   9790
LA                             $00d2   831D  7680   7870   8107   8131
                                      8499   8543  11960  11972  12280
                                     12335  12351
Mon_A                          $00bf   788D 12682  12688  13119  13134
                                     13139  13454  13458  13492  13498
                                     13502  13505
VERCK                          $009d   651D  7522   7542   7567   8308
                                     12071  12125  12132  12149  12186
                                     12259  12820
JIFFY_CLOCK                    $008d   578D  2491   3608   3609   9964
                                     12706  12708  12710  12711  12714
                                     12718  12719
MONCNT                         $00b5   775D  7173   7182   7185   7201
                                      7333   7336   7439   7453  13551
                                     13562
CharsInBuffer                  $009e   655D  9067   9069   9079   9096
                                     10346  10353  11865  12012  12892
                                     13325
FAC2SI                         $006b   529D  3345   3754   5304   5349
                                      5703   5706   5971   6272   6659
                                      6867
FAC2M1                         $0067   525D  3337   3756   3757   5431
                                      5667   5708   5810   5834   5848
                                      5850
FUNJMP                         $0052   494D  3695   3697   5093   5102
                                      5324   5354   5368   5419   6717
                                      6734
INDEXC                         $004f   484D  2581y  2584y  2595y  2598y
                                      2642   2645   4954y  4957y  4965
                                      4968
ARYTAB                         $002c   385D  1817   1818   3888   3890
                                      3949   3950   3967   3968   4174
                                      4175
FAC3M4                         $0026   367D  4378   4398   5517   5520
                                      5628   5657   5659   5672   5825
                                      5882
FAC3M3                         $0025   366D  4349   4370   4395   5519
                                      5522   5627   5660   5662   5671
                                      5880
GARBFL                         $0009   291D  1646   1658   1699   3638
                                      3641   3642   3645   4688   4725
                                      4729
ENDCHR                         $0004   256D  1655   1703   1706   2306
                                      2307   2310   2313   3016   4611
                                      4627
BSOS_KBD                       $0001    15D 10637  10650  10661  10720
                                     10733  10751  10764  10775  10834
                                     10847
DOS_Tmp                        $033a   895D  7673   7700   8151   8231
                                      8243   8250   8504   8658  11413
BotMargin                      $00e1   845D  8996   9282   9573   9639
                                      9685   9702  10462  10475  10492
LDTND                          $00ae   753D  7987   8116  11914  11943
                                     11989  11990  11992  12345  12350
CINV                           $0090   586D  7120   7122   7471   7473
                                      9727   9971   9973  13639  13641
INPPTR                         $0040   439D  2960   2961   2972   2973
                                      3043   3044   3079   3080   3085
OLDTXT                         $003a   419D  1838   2058   2059   2158
                                      2159   2178   2181   2849   2850
DOS_Status                     $03ad   916D  3567   3568   3643   8055
                                      8062   8064   8345   9805
Dis_Buf                        $02b1   884D 12693  13124  13142  13146
                                     13175  13180  13190  13274
QTSW                           $00cd   824D  9114   9162   9191   9192
                                      9368   9519   9665  10584
Mon_Hi                         $00c3   792D 13132  13219  13244  13676
                                     13685  13700  13720  13725
DosPtr                         $00bb   785D 11309  11311  11313  11318y
                                     11325  11327  11398  11402
W_Bank                         $00b7   781D  7128   7316   7429   7922
                                      8828   8884  11033  13452
R_Bank                         $00b6   780D  7126   7314   7427   7914
                                      8827   8924  10972  11013
Source_Unit                    $009c   646D  8205   8506   8567   8570
                                     11388  11468  11535  11584
FAC2M2                         $0068   526D  3339   5428   5664   5700
                                      5813   5833   5845   5847
ACCSYM                         $004a   470D  3214   3223   3224   3226
                                      3230   3265   3280   3765
MEMSIZ                         $0034   401D  1806   1807   4739   4742
                                      7053   7054   7060   7064
DOS_Filename                   $0342   914D  7504   7506   8610  13404
                                     13538  13547  13559
DOS_Attr                       $033d   898D  8422   8458   8463   8500
                                      8558   8584   8599
INSRT                          $00dc   840D  9203   9205   9364   9500
                                      9503   9523   9663
DATAX                          $00d9   838D  9155   9157   9158   9177
                                      9182   9341   9356
Mon_Op                         $00c1   790D 12411  12440  13242  13263
                                     13276  13290  13293
Dis_Line                       $00ba   784D  7354   7356   7358   7396
                                      7409   9899  13284
Wedge_Unit                     $00ab   739D  7033  12805  12812  12915
                                     12940  13626  13628
Key_Flags                      $0098   624D  6344   9967  10253  10255
                                     10295  10296  10370
FACTPA                         $0054   499D  5929   5930   6756   6759
                                      6760   6908   6909
FAC3M2                         $0024   365D  5521   5524   5626   5663
                                      5665   5670   5878
FAC3M1                         $0023   364D  5523   5526   5625   5666
                                      5668   5669   5876
SUBFLG                         $000a   297D  1839   1995   3866   3878
                                      3883   4469   4494
INTFLG                         $0008   276D  2428   3030   3576   3849
                                      3869   4135   4171
DOS_Drive_2                    $033c   897D  8437   8502   8579   8647
                                     11333  11608
LAT                            $0251   867D  8121  11946  11959  11993
                                     11994  12352
Mon_Tmp                        $00cb   803D  7447   7450   7656   7661
                                     13682  13713
SAL                            $00c7   800D  9029   9030   9031y  9673y
                                     10059  10063
Dis_Length                     $00be   787D 12417  12427  12485  13121
                                     13129  13289
PC_Adjust                      $00b3   773D  7103   7115   7131   7341
                                     12400  12402
DFLTO                          $00b0   761D  9174   9977  11900  11920
                                     11934  12793
YSAVE                          $0048   466D  2970   2971   3045   3046
                                      3251   3330
TANSGN                         $000c   311D  3333   3802   6883   6885
                                      6903   6913
DIMFLG                         $0006   264D  3831   4134   4173   4217
                                      4251   4302
DOS_Id                         $033f   912D  8083   8263   8266   8505
                                      8594
Ass_Buf_Length                 $02c0   885D 13262  13268  13736  13746
                                     13747
SAT                            $0265   869D  7990  11961  11997  11998
                                     12356
FAT                            $025b   868D  8119  11963  11995  11996
                                     12358
DFLTN                          $00af   757D 11863  11874  11924  11936
                                     12753
Target_Unit                    $00ad   746D 11387  11436  11494  11528
                                     11602
CRSW                           $00ac   744D  9105   9142   9171   9354
                                     11883
BLNCT                          $00a8   718D  9088   9208   9736   9739
                                      9994
BSOUR                          $00a5   678D 11675  11691  11715  11786
                                     11802
Power_Flag                     $0099   629D  9653  10427  10429  10486
                                     10520
LASTPT                         $0014   341D  4671   4993   4995   4999
                                      7026
INPFLG                         $000b   301D  2832   2959   2978   2999
                                      3081
TABS_SET                       $03ee   917D  9587   9589   9842  10004
DOS_Command_Length             $0341   913D  8407   8409   8606   8612
DOS_Drive_1                    $033b   896D  8433   8501   8578  11590
DELAY                          $00e6   850D  9996  10325  10327  10342
DOS_FC                         $00b1   771D 11355  11416  11486  11514
BLNON                          $00aa   734D  9083   9086   9741   9744
LastInputCol                   $00a1   665D  9112   9120   9168  11885
C3PO                           $00a0   663D 11664  11670  11795  11797
ReverseFlag                    $009f   659D  9200   9415   9563   9664
CBINV                          $0092   594D  9726  13588  13590  13658
RNDX                           $0088   569D  6824   6825   6848   6849
BITS                           $0065   520D  4827   4833   4834   6130
SGNFLG                         $0064   518D  6199   6246   6776   6796
DATPTR                         $003e   433D  2137   2138   2949   2950
DATLIN                         $003c   427D  2837   2838   3066   3070
OLDLIN                         $0038   412D  2162   2163   2184   2185
TEMPPT                         $0013   336D  1828   4654   4675   4997
Ignore_Timeout                 $03fc   919D 11731  11740  13596
Dis_Buf_Length                 $02b0   883D 13153  13193  13269
SCROV                          $00eb   860D  9346  10013  10014
SCRIV                          $00e9   859D  9136  10009  10010
PrevChar                       $00e8   857D  9230   9461   9963
CHIME                          $00e7   851D 10016  10029  10038
KOUNT                          $00e5   849D  9997  10329  10335
LSTX                           $00e4   848D 10318  10323  10340
ScreenRows                     $00df   843D  9046   9275  10000
Mon_ZP                         $00cc   804D 13278  13280  13701
BLNSW                          $00a7   711D  9080   9734   9995
InputRow                       $00a3   666D  9115   9637  11879
Default_Bank                   $009a   636D  9969  11018  11039
Key_Index                      $0097   615D 10257  10290  10316
NMINV                          $0094   599D 13584  13586  13606
FACTPB                         $0059   506D  5922   6794   6795
RIGHT                          $001d   244D  2811   9370   9525
Reset_Vector                   $03fa   918D 13592  13594
Ass_Index                      $02d0   887D 13265  13305
JIFFY6                         $00f8   861D 12720  12723
XMAX                           $00e3   847D  9975  10347
Mon_B                          $00c0   789D 12684  12687
Mon_Format                     $00bd   786D 12483  13118
DOS_EOF                        $00b2   772D 11481  11517
GDBLN                          $00a9   727D  9089   9745
SFDX                           $00a6   704D 10258  10362
InputCol                       $00a4   667D  9118  11877
Stop_Flag                      $009b   641D 10361  12007
JUMPER                         $0051   489D  3698   7014
CTRLY                          $0019   242D  9386   9539
TEMPST                         $0016   348D  1827   4655
CTRLV                          $0016   241D  9388   9535
CTRLU                          $0015   240D  9390   9545
DEL                            $0014   239D  9366   9521
HOME                           $0013   238D  9394   9531
RVS                            $0012   237D  9374   9529
DOWN                           $0011   236D  9372   9527
CTRLO                          $000f   235D  9382   9541
CTRLN                          $000e   234D  9378   9543
TAB                            $0009   232D  9384   9533
CTRLD                          $0004   230D  9392   9547
CTRLB                          $0002   229D  9380   9537
USRVEC                         $0001   253D  7018   7019
Basic_USR                      $0000   252D  1107   7015
Ass_Length                     $02d2   889D 13246
Ass_Dollar                     $02d1   888D 13245
ISNUM                          $007d   565D  2502
ESC                            $001b   243D  9362
BELL                           $0007   231D  9376
CTRLA                          $0001   228D  9396
FSBLK                          $00de   842
ROPRTY                         $00dd   841
TAPE1                          $00d6   836
ZD0                            $00d0   828
EOT                            $00cf   827
BITTS                          $00ce   826
ZP_b8                          $00b8   782
SCROLLING                      $00b4   774
FAC3M5                         $0027   369
DS_Ptr                         $000e   316
DS_Len                         $000d   315
