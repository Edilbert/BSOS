              ; ****************************************************
              ; * Complete Commodore 8296 Operating System & BASIC *
              ; ****************************************************

              ; Use the Bit Shift Assembler "bsa" for assembly of this source

b000          * = $b000   ; *** b000 ***  Commodore 8296

              .STORE $B000, $1000, "b000.basic"
              .STORE $C000, $1000, "c000.basic"
              .STORE $D000, $1000, "d000.basic"
              .STORE $E000, $1000, "e000.edit"
              .STORE $F000, $1000, "f000.kernal"

0001          BSOS_KBD = 1

              ; revision 1.12 10-Jan-2020
              ; -------------------------
              ; implement vector table for extension interception

              ; revision 1.11 08-Jan-2020
              ; -------------------------
              ; enhance DELETE commnd
              ; implement OLD command

              ; revision 1.10 09-Oct-2015
              ; -------------------------
              ; optimize garbage collection
              ; implement REPLACE command
              ; implement 26 rows mode

              ; revision 1.09 10-Sep-2015
              ; -------------------------
              ; optimize BASIC routines Scan_Linenumber and Basic_LIST
              ; in order to make parts of them callable subroutines
              ; These routines are used in the assembler and power scrolling

              ; revision 1.08 04-Aug-2015
              ; -------------------------
              ; Implement conditional code for original keyboard layout
              ; or BSOS keyboard layout (BSOS_KBD)

              ; revision 1.07 04-Aug-2015
              ; -------------------------
              ; Implement ML Disassembler

              ; revision 1.06 29-Jul-2015
              ; -------------------------
              ; Check disk error after trying to boot from disk

              ; revision 1.05 19-Jan-2015
              ; -------------------------
              ; Detect and activate option ROM's
              ; Detect and run "BSOS BOOT" during boot
              ; Non desctructive RAM test
              ; Optimization of BSM LOAD/SAVE

              ; revision 1.03 29-Dec-2014
              ; -------------------------
              ; Add unit to unit capability to the COPY command

              ; revision 1.02 23-Dec-2014
              ; -------------------------
              ; Fix bug in DSAVE/DOPEN (Save and Replace bug)
              ; Optimize DOS Parameter Parser

              ; revision 1.01 14-Dec-2014
              ; -------------------------
              ; Add support for Nils Eilers' SoftROM
              ; The LOAD and DLOAD routines may be used to load data files
              ; directly into the address range $9000 - $AFFF. This works well
              ; for RAM or SoftROM (which in fact is flashed) installed there.

              ; revision 1.00 30-Nov-2014
              ; -------------------------
              ; First public release

              ; The operating system and BASIC interpreter is stored on two chips:

              ; The editor is stored on a 2332 (4KB) ROM (or 2532 EPROM) for the
              ; address range $E000 - $EFFF. The range $E800 - $E8FF is reserved
              ; for I/O and is not accessible

              ; The remaining code is stored on a 23128 (16KB) ROM (or 27128 EPROM):
              ; The address ranges are: $C000 $D000 $B000 $F000

              ; So after assembling you can prepare the EPROM images by using
              ; 1) e000.edit for a 2532 EPROM
              ; 2) cat c000.basic d000.basic b000.basic f000.kernal >os8296.rom
              ;    and use os8296.rom then for a 27128 EPROM

              ; PATCHES APPLIED
              ; ===============

              ; DOS parameter parser accepts 0-9 for drive value (original 0-1)
              ; This allows BASIC4 to work with all 10 possible drives of petSD

              ; The BSM memory display and modifier uses 16 bytes per line

              ; DELETED FEATURES
              ; ================

              ; All tape related code is removed
              ; The entry of diacritic characters is removed (accented letters etc.)

              ; NEW FEATURES
              ; ============

              ; The COPY command accepts different units for source and target
              ; The full syntax is (s = source, t = target):
              ; COPY Ds,"filepattern",Us TO Dt,Ut
              ; The D(rive) parameter defaults to D0 if not specified
              ; The U(nit)  parameter defaults to U8 if not specified
              ; Examples:
              ;
              ; COPY U8 TO U9           copies all files from D0,U8 to D0,U9
              ; COPY D1,U8 TO D2,U10    copies all files from D1,U8 to D2,U10
              ; COPY "*" TO U11         copies all files from D0,U8 to D0,U11
              ; COPY D1,"A*" TO U10     copies all files beginning with A

              ; restrictions:
              ; Currently REL files are not supported.
              ; It is is not possible to give a different name for the target file,
              ; use the RENAME command if necessary

              ; The machine language monitor BSM can now display memory from other banks.
              ; The new command ".b" (set Bank) stores a byte for the bank register.
              ; This affects the memory display for the asddress range $8000 - $ffff.
              ; Common values for the bank register are:

              ; .b 00    : system bank (screen RAM, ROM, I/O)
              ; .b 80    ; RAM bank 0/2 in $8000 - $ffff
              ; .b 8c    ; RAM bank 1/3 in $8000 - $ffff

              ; BSM includes a disassembler:

              ; .d f5c2 f5ef     disassemble the given range
              ; .d f5c2          disassemble 10 statements starting with $f5c2
              ; .d               Disassemble next 10 statements

              ; EDITING
              ; =======

              ; The editor scrolls the BASIC listing upwards or downwards if the
              ; cursor is moved up on the top line or down on the bottom line
              ; The idea (not the code) is taken from Brad Templeton's POWER ROM
              ; The character set is expanded with the missing ASCII characters {|}~ 
              ; These can be used by pressing the CONTROL key together with:
              ; CONTROL 7/      |
              ; CONTROL 8(      {
              ; CONTROL 9)      }
              ; CONTROL .Pi     ~ 

              ; LOAD, SAVE and VERIFY use now unit 8 as default device

              ; LOAD "filename",8,0 forces the file to load to $0401
              ; this enables the loading of C64 and other BASIC programs, which use
              ; different start addresses for BASIC programs.

              ; The Disk-Wedge is integrated, loosely based on Nils Eilers' code.

              ; @                          read drive status
              ; @command                   send dos command
              ; @$                         directory
              ; $                          directory
              ; $0                         directory of drive 0
              ; $0:pat*                    directory of files starting with "pat"
              ; /prog                      load program prog
              ; ^prog                      load and run program prog
              ; #9                         switch to unit 9
              ; #                          display current unit

              ; New commands added:

              ; DELETE from-to       ; Deletes a line range
              ;   DELETE 500-700 deletes all lines in this range
              ; FIND "text"          ; lists all lines with strings containing <text>
              ; FIND /text/          ; lists all lines with BASIC   containing <text>
              ;                      ; any character may be used as delimiter
              ; MONITOR              ; Calls BSM
              ; RENUMBER new,inc,old ; Renumbers a BASIC program
              ;    The default values for new,inc,old are: 10,10,first line
              ;    RENUMBER 1000,10  renumbers the whole program to linenumbers
              ;       1000,1010,1020 etc.

              ; BSOS uses a vector table for important functions like C64, C128.
              ; This enables the interception for BASIC language extensions
              ; The names and addresses are the same as in the C128 BASIC.

0300            IERROR  = $0300     ; DEF_ERROR   BASIC error handler
0302            IMAIN   = $0302     ; DEF_MAIN    BASIC main loop
0304            ICRNCH  = $0304     ; DEF_CRUNCH  BASIC tokenizer
0306            IQPLOP  = $0306     ; DEF_QPLOP   BASIC statement lister
0308            IGONE   = $0308     ; DEF_GONE    BASIC interpret statement
030a            IEVAL   = $030a     ; DEF_EVAL    BASIC evaluate expression

              ; **********************
              ; BASIC scalar variables
              ; **********************

              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Type     | Exa.|  0  |  1  |  2  |  3  |  4  |  5  |  6
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Float    | AB  |  A  |  B  | EXP | MSB | MAN | MAN | LSB
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Integer  | AB% |  A^ |  B^ | MSB | LSB |  0  |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Function | AB( |  A^ |  B  | LFP | MFP | LBP | MBP | ARG
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; String   | AB$ |  A  |  B^ | LEN | LSP | MSP |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----

              ; ************
              ; BASIC arrays
              ; ************

              ; ---------+-----+-----+-----+---------------+
              ; Type     | Exa.|  0  |  1  |  Element Size |
              ; ---------+-----+-----+-----+---------------+
              ; Float    | AB  |  A  |  B  |       5       |
              ; ---------+-----+-----+-----+---------------+
              ; Integer  | AB% |  A^ |  B^ |       2       |
              ; ---------+-----+-----+-----+---------------+
              ; String   | AB$ |  A  |  B^ |       3       |
              ; ---------+-----+-----+-----+---------------+

              ; The circumflex ^ indicates characters OR'ed with $80

              ; Array header:

              ; Byte  0   : 1st. character of name
              ; Byte  1   : 2nd, character of name
              ; Byte  2-3 : length of array including header in bytes
              ; Byte  4   : dimension count
              ; Byte  5-6 : Hi/Lo elements of 1st. dimension, (e.g. 11 for dim a(10)
              ; Byte  7-8 : Hi/Lo elements of 2nd. dimension if dimension count > 1
              ; Byte  x-x : Two bytes for each dimension

              ; *******
              ; Equates
              ; *******

0001          CTRLA     = $01 ; scroll window down
0002          CTRLB     = $02 ; switch character ROM
0004          CTRLD     = $04 ; toggle display size between 25 or 26 rows
0007          BELL      = $07 ; chime
0009          TAB       = $09
000d          CR        = $0d
000e          CTRLN     = $0e ; switch to text mode
000f          CTRLO     = $0f ; set top left window corner
0011          DOWN      = $11
0012          RVS       = $12
0013          HOME      = $13
0014          DEL       = $14
0015          CTRLU     = $15
0016          CTRLV     = $16
0019          CTRLY     = $19
001b          ESC       = $1b
001d          RIGHT     = $1d
0022          QUOTE     = $22

              ; These locations contain the JMP instruction and target address of the
              ; USR command. They are initialised so that if you try to execute a USR
              ; call without changing them you will receive an ILLEGAL QUANTITY error
              ; message.

0000          Basic_USR = $00               ; initialized to $4c the code for JMP
0001          USRVEC    = $01               ; initialized to $c373 (Illegal_Quantity)

0003          CHARAC    = $03               ; search character
0004          ENDCHR    = $04               ; scan quotes flag
0005          COUNT     = $05               ; line crunch/array access/logic operators

              ; This is used as a flag by the routines that build an array or
              ; reference an existing array. It is used to determine whether a
              ; variable is in an array, whether the array has already been
              ; DIMensioned, and whether a new array should assume default size.

0006          DIMFLG    = $06               ; DIM flag

              ; This flag is used to indicate whether data being operated upon is
              ; string or numeric. A value of $FF in this location indicates string
              ; data while a $00 indicates numeric data.

0007          VALTYP    = $07               ; data type, $FF = string, $00 = numeric

              ; If the above flag indicates numeric then a $80 in this location
              ; identifies the number as an integer, and a $00 indicates a floating
              ; point number.

0008          INTFLG    = $08     ; data type flag, $80 = integer, $00 = floating pt.

              ; The garbage collection routine uses this location as a flag to
              ; indicate that garbage collection has already been tried before adding
              ; a new string. If there is still not enough memory, an OUT OF MEMORY
              ; error message will result.

              ; LIST uses this byte as a flag to let it know when it has come to a
              ; character string in quotes. It will then print the string,rather than
              ; search it for BASIC keyword tokens.

              ; This location is also used during the process of converting a line of
              ; text in the BASIC input buffer into a linked program line of BASIC
              ; keyword tokens to flag a DATA line is being processed.

0009          GARBFL    = $09     ; garbage collected/open quote/DATA flag

              ; This flag is set from the routines handling FOR, DEF and FN
              ; statements. Names for loop indices and function names must not be
              ; integer. Only identifiers of type real are allowed.

000a          SUBFLG    = $0a     ; subscript/FNx flag

              ; input mode, $00 = INPUT, $40 = GET, $80 = READ

000b          INPFLG    = $0b     ; input mode, $00 = INPUT, $40 = GET, $98 = READ

              ; This location is used to determine whether the sign of the value
              ; returned by the functions SIN, COS, ATN or TAN is positive or negative
              ; Also the comparison routines use this location to indicate the outcome
              ; of the compare. For A <=> B the value here will be $01 if A > B,
              ; $02 if A = B, and $04 if A < B. If more than one comparison operator
              ; was used to compare the two variables then the value here will be a
              ; combination of the above values.

000c          TANSGN    = $0c     ; ATN sign/comparison evaluation flag

              ; Disk status or temporary string descriptor

000d          DS_Len    = $0d     ; unused
000e          DS_Ptr    = $0e     ; unused

              ; When the default input or output device is used the value here will
              ; be a zero, and the format of prompting and output will be the standard
              ; screen output format. The location $B8 is used to decide what device
              ; actually to put input from or output to.

0010          IOPMPT    = $10     ; current I/O channel

              ; Used whenever a 16 bit integer is used e.g. the target line number for
              ; GOTO, LIST, ON, and GOSUB also the number of a BASIC line that is to
              ; be added or replaced. additionally PEEK, POKE, WAIT, and SYS use this
              ; location as a pointer to the address which is the subject of the
              ; command.

0011          LINNUM = $11        ; line number

              ; This location points to the next available slot in the temporary
              ; string descriptor stack located at TEMPST ($16-$1e).

0013          TEMPPT = $13        ; descriptor stack pointer, next free

              ; This contains information about temporary strings which have not yet
              ; been assigned to a string variable.

0014          LASTPT = $14        ; current descriptor stack item pointer

              ; Stack for temporary string descriptors
              ; String 1: $16-$18
              ; String 2: $19-$1b
              ; String 3: $1c-$1e

0016          TEMPST = $16        ; temporary descriptor stack

              ; miscellaneous pointer / word used in many BASIC routines

001f          INDEXA = $1f        ; miscellaneous pointer

              ; miscellaneous pointer / word used in many BASIC routines

0021          INDEXB = $21

              ; above address shared with RENUMBER as increment value

0021          RENINC = $21        ; RENUMBER increment value

              ; Floating point accumulator #3 (mantissa only)

0023          FAC3M1 = $23        ; mantissa byte 1 MSB
0024          FAC3M2 = $24        ; mantissa byte 2
0025          FAC3M3 = $25        ; mantissa byte 3
0026          FAC3M4 = $26        ; mantissa byte 4 LSB

0027          FAC3M5 = $27        ; unused

              ; FAC3 addresses shared with RENUMBER as start value for line numbers

0023          RENNEW = $23        ; RENUMBER new line number start

              ; Start of BASIC program - initialized to $0401

0028          TXTTAB = $28        ; Text Table

              ; Two byte pointer to the start of the BASIC variable storage area.

002a          VARTAB = $2a        ; Variable table

              ; Two byte pointer to the start of the BASIC array storage area.

002c          ARYTAB = $2c        ; Array table

              ; Two byte pointer to end of the start of free RAM.

002e          STREND = $2e        ; String end

              ; Two byte pointer to the highest address used by BASIC +1.

0030          FRETOP = $30        ; top of BASIC memory

              ; Two byte pointer to the bottom of the string text storage area.

0032          FRESPC = $32        ; bottom of string space

              ; Two byte pointer to the highest RAM address

0034          MEMSIZ = $34        ; top of RAM

              ; These locations contain the line number of the BASIC statement which
              ; is currently being executed. A value of $FF in location $3A means that
              ; BASIC is in immediate mode.

0036          CURLIN = $36        ; current line number

              ; When program execution ends or stops the last line number executed is
              ; stored here.

0038          OLDLIN = $38        ; break line number

              ; These locations contain the address of the start of the text of the
              ; BASIC statement that is being executed.  The value of the pointer to
              ; the address of the BASIC text character currently being scanned is
              ; stored here each time a new BASIC statement begins execution.

003a          OLDTXT = $3a        ; continue pointer

              ; These locations hold the line number of the current DATA statement
              ; being READ. If an error concerning the DATA occurs this number will
              ; be moved to $39/$3A so that the error message will show the line that
              ; contains the DATA statement rather than in the line that contains the
              ; READ statement.

003c          DATLIN = $3c        ; current DATA line number

              ; These locations point to the address where the next DATA will be READ
              ; from. RESTORE sets this pointer back to the address indicated by the
              ; start of BASIC pointer.

003e          DATPTR = $3e        ; DATA pointer

              ; READ, INPUT and GET all use this as a pointer to the address of the
              ; source of incoming data, such as DATA statements, or the text input
              ; buffer.

0040          INPPTR = $40        ; READ pointer

              ; Two bytes storing the name of a BASIC variable as ASCII values
              ; The combination of the two bits 7 determines the type
              ; ---------------------------------------------
              ; Real    : AB      = $41 $42 = 'A'     'B'
              ; Function: FNAB()  = $c1 $42 = 'A'+$80 'B'
              ; String  : AB$     = $41 $c2 = 'A'     'B'+$80
              ; Integer : AB%     = $c1 $c2 = 'A'+$80 'B'+$80

0042          VARNAM = $42        ; current variable name

              ; These locations point to the value of the current BASIC variable.
              ; Specifically they point to the byte just after the two-character
              ; variable name.

0044          VARPTR = $44        ; current variable address

              ; The address of the BASIC variable which is the subject of a FOR/NEXT
              ; loop is first stored here before being pushed onto the stack.

0046          FORPNT = $46        ; FOR/NEXT variable pointer

              ; The expression evaluation routine creates this to let it know whether
              ; the current comparison operation is a < $01, = $02 or > $04 comparison
              ; or combination.

0048          YSAVE  = $48        ; BASIC execute pointer temporary/precedence flag

              ; used to compare the variable type on both sides of an operator

004a          ACCSYM = $4a        ; comparison evaluation flag

              ; These locations are used as a pointer to the function that is created
              ; during function definition. During function execution it points to
              ; where the evaluation results should be saved.

004b          FUNCPT = $4b        ; FAC temp store/function/variable/garbage pointer

              ; Temporary Pointer to the current string descriptor.

004d          DESCPT = $4d        ; FAC temp store/descriptor pointer

              ; Temporary pointer used in subroutines

004f          INDEXC = $4f

              ; The first byte is the 6502 JMP instruction $4C, followed by the
              ; address of the required function taken from the table at $B000.

0051          JUMPER = $51         ; JMP opcode for functions

              ; Used as jump address for previous opcode
              ; Several uses as temporary storage in BASIC routines

0052          FUNJMP = $52         ; functions jump vector

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary pointer (block pointer, array pointer)

0054          FACTPA = $54         ; FAC temp store ($54 - $58)
0055          TMPPTA = $55         ; temp pointer A
0057          TMPPTB = $57         ; temp pointer B

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary variables

0059          FACTPB = $59         ; FAC temp store ($59 - $5d)
005a          TMPVAR = $5a         ; temporary variable
005c          TMPPTC = $5c         ; temporary pointer

              ; Floating point accumulator 1

005e          FAC1EX = $5e         ; FAC1 exponent
005f          FAC1M1 = $5f         ; FAC1 mantissa 1
0060          FAC1M2 = $60         ; FAC1 mantissa 2
0061          FAC1M3 = $61         ; FAC1 mantissa 3
0062          FAC1M4 = $62         ; FAC1 mantissa 4
0063          FAC1SI = $63         ; FAC1 sign
0064          SGNFLG = $64         ; constant count/negative flag

0065          BITS   = $65         ; unused

              ; Floating point accumulator 2

0066          FAC2EX = $66         ; FAC2 exponent
0067          FAC2M1 = $67         ; FAC2 mantissa 1
0068          FAC2M2 = $68         ; FAC2 mantissa 2
0069          FAC2M3 = $69         ; FAC2 mantissa 3
006a          FAC2M4 = $6a         ; FAC2 mantissa 4
006b          FAC2SI = $6b         ; FAC2 sign

              ; String pointer and FAC sign comparison and FAC rounding

006c          STRPTR = $6c         ; string pointer & FAC variables

              ; this address is sometimes used as high btye for the STRPTR
              ; and as rounding byte (5th. byte of mantissa) for FAC1

006d          FROUND = $6d         ; FAC1 mantissa 5 = rounding byte

              ; Temporary pointer and index used in many BASIC routines

006e          TMPPTD = $6e         ; temp BASIC execute/array pointer low byte/index

              ; Basic CHRGET (with increment) and CHRGOT (no increment) routine
              ; Also ISNUM for check if character is numeric
              ; Copied to this location from CHRGET_ROM at $d399
              ;
              ; 0070 e6 77     CHRGET    INC TXTPTR
              ; 0072 d0 02               BNE CHRGOT
              ; 0074 e6 78               INC TXTPTR+1
              ; 0076 ad 60 ea  CHRGOT    LDA $ffff       ; modified by previous code
              ; 0079 c9 3a               CMP #':'        ; check of end of statement
              ; 007b b0 0a               BCS CHRRET
              ; 007d c9 20     ISNUM     CMP #' '        ; skip blanks
              ; 007f f0 ef               BEQ CHRGET
              ; 0081 38                  SEC
              ; 0082 e9 30               SBC #'0'
              ; 0084 38                  SEC
              ; 0085 e9 d0               SBC #$d0
              ; 0087 60        CHRRET    RTS

0070          CHRGET = $70        ; Get program byte with pointer pre increment
0076          CHRGOT = $76        ; Get program byte
0077          TXTPTR = $77        ; Pointer to current program byte
007d          ISNUM  = $7d        ; Check for numeric digit

              ; Random seed, five bytes ($88 - $8c)

0088          RNDX   = $88        ; Random seed

              ; These three locations form a counter which is updated 60 times a
              ; second, and serves as a software clock which counts the number of
              ; jiffies that have elapsed since the computer was turned on.
              ; European computers running at 50 Hz add an additional count every
              ; 5th. jiffy in order to compensate the lower interrupt frequency.
              ; After 24 hours and one jiffy these locations are set back to $000000.

008d          JIFFY_CLOCK = $8d   ; Count jiffies (1/60 seconds)

              ; Vector, which may be used to redirect the interrupt routine.
              ; It is initialized to IRQ_NORMAL ($e455), which handles updating
              ; the jiffy clock, blinking the cursor and scanning the keyboard
              ; ROM's with tape routines switch this vector during tape activities
              ; to routines handling write to tape or read from tape.

0090          CINV   = $90        ; IRQ vector (IRQ_NORMAL)

              ; Vector, which may be used to redirect the break routine.
              ; The break routine is called after executing the BRK ($00) command
              ; either by intention or accidentally due to an error.
              ; It is initialized to MONITOR_BREAK ($d467), which saves the contents
              ; of all registers and starts BSM, the Bit Shifter Monitor.

0092          CBINV  = $92        ; BRK vector (MONITOR_BREAK)

              ; Vector, which may be used to redirect the Non Maskable Interrupt.
              ; It is intialized to Basic_Reday ($b3ff).

0094          NMINV  = $94        ; NMI vector (Basic_Reday)

              ; The STATUS byte is used to flag I/O errors or End-Of-Information
              ; A bit set to 1 indicates foloowing conditions:

              ; bit 0 : time out write
              ; bit 1 : time out read
              ; bit 4 : verify error
              ; bit 6 : EOI (End Of Information)
              ; bit 7 : device not present

0096          STATUS = $96        ; Status byte for I/O operations

              ; Key_Index is used in the subroutine EDIT_KEY_SCAN
              ; It holds the index for the character tables or -1 ($ff) for no key

0097          Key_Index = $97     ; Key index for character lookup

              ; The keyflags are used to select the character lookup table for
              ; NORMAL, SHIFTED or CONTROL.
              ; Flags are set by setting the corresponding bit to 0

              ; bit 7:  0 = <shift>
              ; bit 6:  0 = <control>

0098          Key_Flags = $98

              ; The power flag activates power scrolling (continuous scrolling)
              ; when set. It is active in direct mode and inactive in run mode.

0099          Power_Flag = $99    ; $ff power scrolling on, $00 off


              ; The default bank holds the configuration for the bank register $FFF0
              ; If the operating system runs from ROM its value is $00
              ; Loadable BSOS runs for configuration $ec

009a          Default_Bank = $9a  ; $00 = OS running in ROM

              ; The Stop_Flag is set by the keyboard scan routine
              ; $ff = no STOP key pressed, $ef = STOP key pressed

009b          Stop_Flag = $9b     ; $ef = 1110 1111 flags STOP key pressed

              ; Originally used as variable SVXT for tape routines
              ; Mow used by Parse_DOS_Parameter

009c          Source_Unit = $9c   ; Source unit for COPY command

              ; VERCK flags LOAD (0) or VERIFY ($80) mode for the load routines
              ; MERGE uses the value $40

009d          VERCK         = $9d ; LOAD or VERIFY flag

              ; Counter for the number of keys in keyboard buffer

009e          CharsInBuffer = $9e ; number of keys buffered

              ; Flag indicating reverse mode for screen output

009f          ReverseFlag  = $9f  ; 0 = normal   non zero = reverse

              ; IEEE-488 output: deferred character flag

00a0          C3PO         = $a0  ; 0 = no character waiting, $ff = character waiting

00a1          LastInputCol = $a1  ; screen input stops reading at LastInputVol
00a3          InputRow     = $a3  ; store screen input row number (0-24)
00a4          InputCol     = $a4  ; store screen input column (0-79)

              ; The IEEE-488 output routine CIOUT delays the output by one character,
              ; which is stored in BSOUR. CIOUT checks on each call, if a character
              ; is stored in BSOUR for transmisson, by testing the flag C3PO.
              ; If C3PO is negative, the character in BSOUR is sent and the actual
              ; character is stored in BSOUR. If BSOUR is empty (C3PO == 0), the only
              ; action is storing the actual character in BSOUR and making C3PO
              ; negative. The delay in sending makes it possible  to send the
              ; EOI (End Of Information) along with the last character to transmit.

00a5          BSOUR  = $a5        ; IEEE-488  output: deferred character (buffer)

              ; The keyscan interrupt routine uses this location to indicate which key
              ; is currently being pressed. The value here is then used as an index
              ; into the appropriate keyboard table to determine which character to
              ; print when a key is struck.
              ; The correspondence between the key pressed and the number stored here
              ; is as follows:

              ; $00          $10   2      $20   4      $30   6       $40   9
              ; $01          $11  [DOWN]  $21   UE     $31   AE      $41
              ; $02   sz     $12          $22   O      $32   L       $42  [HOME]
              ; $03  [DEL]   $13   0      $23   [      $33  [RETURN] $43   7
              ; $04   9      $14   ,      $24   U      $34   J       $44   0
              ; $05   6      $15   N      $25   T      $35   G       $45   7
              ; $06   3      $16   V      $26   E      $36   D       $46   4
              ; $07   <   ]  $17   Y      $27   Q      $37   A       $47   1
              ; $08   1      $18   3      $28   ]      $38   5       $48
              ; $09          $19  [SHIFT] $29   P      $39   OE      $49
              ; $0A          $1A          $2A   I      $3A   K       $4a  [STOP]
              ; $0B  [RIGHT] $1B   .      $2B   +      $3B   #       $4b   8
              ; $0C   M      $1C   .      $2C   Z      $3C   H       $4c   ´
              ; $0D  [SPACE] $1D   B      $2D   R      $3D   F       $4d   9
              ; $0E   X      $1E   C      $2E   W      $3E   S       $4e   6
              ; $0F  [CTRL]  $1F  [SHIFT] $2F  [TAB]   $3F  [ESC]    $4f   3

00a6          SFDX   = $a6         ; which key

              ; When this flag is set to a nonzero value, it indicates to the routine
              ; that normally flashes the cursor not to do so. The cursor blink is
              ; turned off when there are characters in the keyboard buffer, or when
              ; the program is running.

00a7          BLNSW   = $a7        ; cursor enable, $00 = flash cursor

              ; The routine that blinks the cursor uses this location to tell when
              ; it's time for a blink. The number 20 is put here and decremented every
              ; jiffy until it reaches zero. Then the cursor state is changed, the
              ; number 20 is put back here, and the cycle starts all over again.

00a8          BLNCT   = $a8

              ; The cursor is formed by printing the inverse of the character that
              ; occupies the cursor position. If that characters is the letter A, for
              ; example, the flashing cursor merely alternates between printing an A
              ; and a reverse-A. This location keeps track of the normal screen code
              ; of the character that is located at the cursor position, so that it
              ; may be restored when the cursor moves on.

00a9          GDBLN  = $a9         ; character under cursor

              ; This location keeps track of whether, during the current cursor blink,
              ; the character under the cursor was reversed, or was restored to
              ; normal. This location will contain 0 if the character is reversed, and
              ; 1 if the character is not reversed.

00aa          BLNON  = $aa         ; cursor blink phase

              ; The current unit number for wedge commands is held in Wedge_Unit
              ; It is initialized to 8 and can be changed with #<unit>

00ab          Wedge_Unit = $ab     ; current device for DOS wedge commands

              ; input from keyboard or screen, $xx = input is available from the
              ; screen, $00 = input should be obtained from the keyboard

00ac          CRSW   = $ac         ; input from keyboard or screen

00ad          Target_Unit = $ad    ; used by DOS Copy

              ; The number of currently open I/O files is stored here. The maximum
              ; number that can be open at one time is ten. The number stored here is
              ; used as the index to the end of the tables that hold the file numbers,
              ; device numbers, and secondary addresses.

00ae          LDTND  = $ae         ; open file count

              ; The default value of this location is 0.

00af          DFLTN  = $af         ; input device number

              ; The default value of this location is 3.

00b0          DFLTO  = $b0         ; output device number

                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard    - input only
                                   ;  1      cassette #1 - disabled in BSOS
                                   ;  2      cassette #2 - disabled in BSOS
                                   ;  3      screen      - input / output
                                   ;  4-31   IEEE-488 bus

00b1          DOS_FC     = $b1     ; used for DOS_Copy
00b2          DOS_EOF    = $b2     ; used for DOS_Copy
00b3          PC_Adjust  = $b3     ; used in monitor
00b4          SCROLLING  = $b4     ; unused
00b5          MONCNT     = $b5     ; BSM counter variable

              ; Theses variables are used to store the value for the bank switching
              ; register while performing the RENUMBER command.

00b6          R_Bank     = $b6     ; Read  Bank value for bank switching
00b7          W_Bank     = $b7     ; Write Bank value for bank switching
00b8          ZP_b8      = $b8     ; unused
00b9          DOS_RL     = $b9     ; used for DOS_Copy
00ba          Dis_Line   = $ba     ; Disassembler
00bb          DosPtr     = $bb     ; used for DS$
00bd          Mon_Format = $bd     ; Disassembler
00be          Dis_Length = $be     ; Disassembler
00bf          Mon_A      = $bf     ; Disassembler
00c0          Mon_B      = $c0     ; Disassembler
00c1          Mon_Op     = $c1     ; Disassembler
00c2          Mon_Lo     = $c2     ; Disassembler
00c3          Mon_Hi     = $c3     ; Disassembler

              ; The Screen Pointer ScrPtr contains the screen memory address
              ; of the current cursor position

00c4          ScrPtr     = $c4      ; screen pointer ($8000 - $87cf)
00c6          CursorCol  = $c6      ; cursor column (0 - 79)

00c7          SAL        = $c7      ; used for windows scrolling
00c9          EAL        = $c9      ; used for LOAD, SAVE and BSM

00cb          Mon_Tmp    = $cb      ; Monitor temporary
00cc          Mon_ZP     = $cc      ; Monitor ZP flag

              ; A nonzero value in this location indicates that the editor is in quote
              ; mode. Quote mode is toggled every time that you type in a quotation
              ; mark on a given line, the first quote mark turns it on, the second
              ; turns it off, the third turns it on, etc.

              ; If the editor is in this mode when a cursor control character or other
              ; nonprinting character is entered, a printed equivalent will appear on
              ; the screen instead of the cursor movement or other control operation
              ; taking place. Instead, that action is deferred until the string is
              ; sent to the string by a PRINT statement, at which time the cursor
              ; movement or other control operation will take place.

              ; The exception to this rule is the DELETE key, which will function
              ; normally within quote mode. The only way to print a character which is
              ; equivalent to the DELETE key is by entering insert mode. Quote mode
              ; may be exited by printing a closing quote or by hitting the RETURN or
              ; SHIFT-RETURN or ESC keys.

00cd          QTSW   = $cd        ; quote switch non zero:inside quotes

00ce          BITTS  = $ce        ; unused (transmitter byte buffer)
00cf          EOT    = $cf        ; unused (end of tape)
00d0          ZD0    = $d0        ; unused

00d1          FNLEN  = $d1        ; Length of filename - for file open and DOS
00d2          LA     = $d2        ; Local     Address
00d3          SA     = $d3        ; Secondary Address
00d4          FA     = $d4        ; First     Address

00d5          RigMargin  = $d5    ; right margin of window (0 - 79)
00d6          TAPE1      = $d6    ; unused
00d8          CursorRow  = $d8    ; current corsor row
00d9          DATAX      = $d9    ; temprary storage
00da          FNADR      = $da    ; file name address
00dc          INSRT      = $dc    ; # of inserts outstanding
00dd          ROPRTY     = $dd    ; unused
00de          FSBLK      = $de    ; unused
00df          ScreenRows = $df    ; current screen rows - 1 (24 or 29)
00e0          TopMargin  = $e0    ; bottom margin of window (0 - screenrows-1)
00e1          BotMargin  = $e1    ; top margin of window
00e2          LefMargin  = $e2    ; left margin of window
00e3          XMAX       = $e3    ; length of keyboard buffer-1 = 9
00e4          LSTX       = $e4    ; last key pressed
00e5          KOUNT      = $e5    ; repeat speed counter
00e6          DELAY      = $e6    ; repeat delay
00e7          CHIME      = $e7    ; chime counter

              ; save the last character processed by Edit_CHROUT in PrevChar
              ; this is used to identify the seuence <HOME><HOME>, which resets
              ; the window to full screen

00e8          PrevChar   = $e8    ; used for key press repetion
00e9          SCRIV      = $e9    ; EDIT_CHRIN vector
00eb          SCROV      = $eb    ; EDIT_CHROUT vector
00f8          JIFFY6     = $f8    ; 50Hz jiffy clock compensation counter
00f9          BPTR       = $f9    ; multi purpose
00fb          STAL       = $fb    ; start address
00fd          MEMUSS     = $fd    ; end   address

              ; the bottom of the stack is used from the BASIC formatting routine
              ; which converts numbers to strings.
              ; The 4 top addresses $01fc-$01ff are used by the BASIC tokenizer
              ; for storing link and line number of an entered BASIC line,
              ; so the usable stack range is limited to $0110 - $01fb.
              ; BASIC initializes the stack pointer to $fa

0100          STACK      = $0100

              ; The input buffer accepts input lines with a maximum of 80 characters
              ; It is also used as workspace for the BASIC tokenizer.

0200          BUF        = $0200

0251          LAT        = $0251  ; Logical Address Table
025b          FAT        = $025b  ; First   Address Table (unit / device)
0265          SAT        = $0265  ; Second  Address Table
026f          KEYD       = $026f  ; keyboard buffer (10 byte)

              ; Commodore BASIC 4 used the area $027a - $0339
              ; as buffer for tape operations (TAPE1 buffer)
              ; BSOS has no TAPE routine and uses it for storing routines
              ; for accessing memory at different banks. These routines must
              ; be located at low RAM, because the ROM area is switched off
              ; while accessing High RAM.
              ; The area is used by the Monitor and RENUMBER command only.

028b          Bank_Store = Bank_Fetch + Bank_Store_Start - Bank_Fetch_Start
027a          Bank_Fetch     = $027a
02a0          Mon_Register   = $02a0
02b0          Dis_Buf_Length = $02b0
02b1          Dis_Buf        = $02b1
02c0          Ass_Buf_Length = $02c0
02c1          Ass_Buf        = $02c1
02d0          Ass_Index      = $02d0

              ; jump vector table for interception of BASIC routines
              ; position and named like the C128 table

0300          IERROR  = $0300     ; DEF_ERROR   BASIC error handler
0302          IMAIN   = $0302     ; DEF_MAIN    BASIC main loop
0304          ICRNCH  = $0304     ; DEF_CRUNCH  BASIC tokenizer
0306          IQPLOP  = $0306     ; DEF_QPLOP   BASIC statement lister
0308          IGONE   = $0308     ; DEF_GONE    BASIC interpret statement
030a          IEVAL   = $030a     ; DEF_EVAL    BASIC evaluate expression

              ; The area $033a - $03c9 was the tape buffer 2 on BASIC 2
              ; BASIC 4 uses this area for variables and buffers related to the
              ; BASIC 4 disk commands, like DOPEN, DCLOSE, DIRECTORY, etc.

033a          DOS_Tmp     = $033a
033b          DOS_Drive_1 = $033b
033c          DOS_Drive_2 = $033c
033d          DOS_Attr    = $033d

              ; DOS_flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

033e          DOS_Flags          = $033e
033f          DOS_Id             = $033f
0341          DOS_Command_Length = $0341
0342          DOS_Filename       = $0342
0353          DOS_Command_Buffer = $0353
03ad          DOS_Status         = $03ad
03ee          TABS_SET           = $03ee    ; 80 bits TAB table
03fa          Reset_Vector       = $03fa    ; set but unused
03fc          Ignore_Timeout     = $03fc

8000          SCREEN_RAM         = $8000

              ; *****************************
              ; MCS 6520 Peripheral Adapter 1
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E810 |CASR| EOI|    |    |Select Keyboard Row| PIA1_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E811 |  0 |  0 |  1 |  1 |  1 |  x |  0 |  0 | PIA1_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E812 |          Keyboard Row (8 keys)        | PIA1_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E813 |  0 |  0 |  1 |  1 |  1 |  1 |  0 |  1 | PIA1_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e810          PIA1_Port_A = $e810
e811          PIA1_Cont_A = $e811
e812          PIA1_Port_B = $e812
e813          PIA1_Cont_B = $e813

              ; *****************************
              ; MCS 6520 Peripheral Adapter 2
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E820 |             IEEE-488 DATA IN          | PIA2_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E821 |    |    |    |    |NDAC|    |    |    | PIA2_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E822 |             IEEE-488 DATA OUT         | PIA2_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E823 | SRQ|    |    |    | DAV|    |    |    | PIA2_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e820          PIA2_Port_A = $e820
e821          PIA2_Cont_A = $e821
e822          PIA2_Port_B = $e822
e823          PIA2_Cont_B = $e823

              ; ************************************
              ; MCS 6522 Versatile Interface Adapter
              ; ************************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  0| E840 | DAV|NRFD|    |    |    | ATN|NRFD|NDAC| Port_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  1| E841 |              User-Port                | Port_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  2| E842 |  0 |  0 |  0 |  1 |  1 |  1 |  1 |  0 | DDR_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  3| E843 |       User-Port Data Direction        | DDR_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  4| E844 |    |    |    |    |    |    |    |    | Timer 1 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  5| E845 |    |    |    |    |    |    |    |    | Timer 1 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  6| E846 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  7| E847 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  8| E848 |    |    |    |    |    |    |    |    | Timer 2 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  9| E849 |    |    |    |    |    |    |    |    | Timer 2 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 10| E84A |    Shift Register                     | Shift
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 11| E84B |    Auxiliary Control Register         | ACR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 12| E84C |    |    |    |    |    |    |    |    | PCR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 13| E84D |    Interrupt Flag Register            | IFR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 14| E84E |    Interrupt Enable Register          | IER
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 15| E84F |    No Handshake Register              | no_HS
              ; --+------+----+----+----+----+----+----+----+----+--------------

e840          VIA_Port_B           = $e840
e841          VIA_Port_A           = $e841  ; unused
e842          VIA_DDR_B            = $e842
e843          VIA_DDR_A            = $e843  ; unused
e844          VIA_Timer_1_Lo       = $e844
e845          VIA_Timer_1_Hi       = $e845
e846          VIA_Timer_1_Latch_Lo = $e846  ; unused
e847          VIA_Timer_1_Latch_Hi = $e847  ; unused
e848          VIA_Timer_2_Lo       = $e848
e849          VIA_Timer_2_Hi       = $e849
e84a          VIA_Shift            = $e84a

e84b          VIA_ACR              = $e84b  ; Auxiliary Control Register
              ; bit 7: Timer 1 : Output Enable    1 = continuous 0 = single
              ; bit 6: Timer 1 : Free-Run Enable  1 = PB7 pulse  0 = IRQ
              ; bit 5: Timer 2 : Control          1 = pulse      0 = single

e84c          VIA_PCR              = $e84c

e84d          VIA_IFR              = $e84d  ; Interrupt Flag Register
              ; 7        IRQ
              ;  6       T1
              ;   5      T2
              ;    4     CB1
              ;     3    CB2
              ;      2   SR
              ;       1  CA1
              ;        0 CA2

e84e          VIA_IER              = $e84e  ; Interrupt Enable Register
e84f          VIA_Port_A_no_HS     = $e84f  ; unused




e880          CRT_Address          = $e880
e881          CRT_Value            = $e881

b000          * = $b000   ; *** b000 ***  Commodore 8296


              ; *********************
b000            Basic_Statement_Table
              ; *********************

b000 c7 b7              .WORD Basic_END       - 1
b002 dd b6              .WORD Basic_FOR       - 1
b004 18 bd              .WORD Basic_NEXT      - 1
b006 82 b8              .WORD Basic_DATA      - 1
b008 a3 bb              .WORD Basic_INPUTN    - 1
b00a bd bb              .WORD Basic_INPUT     - 1
b00c 20 c1              .WORD Basic_DIM       - 1
b00e 01 bc              .WORD Basic_READ      - 1
b010 2f b9              .WORD Basic_LET       - 1
b012 2f b8              .WORD Basic_GOTO      - 1
b014 07 b8              .WORD Basic_RUN       - 1
b016 b2 b8              .WORD Basic_IF        - 1
b018 b6 b7              .WORD Basic_RESTORE   - 1
b01a 12 b8              .WORD Basic_GOSUB     - 1
b01c 5c b8              .WORD Basic_RETURN    - 1
b01e c5 b8              .WORD Basic_REM       - 1
b020 c5 b7              .WORD Basic_STOP      - 1
b022 d5 b8              .WORD Basic_ON        - 1
b024 62 c9              .WORD Basic_WAIT      - 1
b026 d4 ff              .WORD Basic_LOAD      - 1
b028 d7 ff              .WORD Basic_SAVE      - 1
b02a da ff              .WORD Basic_VERIFY    - 1
b02c db c4              .WORD Basic_DEF       - 1
b02e 59 c9              .WORD Basic_POKE      - 1
b030 87 ba              .WORD Basic_PRINTN    - 1
b032 a7 ba              .WORD Basic_PRINT     - 1
b034 ed b7              .WORD Basic_CONT      - 1
b036 2f b6              .WORD Basic_LIST      - 1
b038 ed b5              .WORD Basic_CLR       - 1
b03a 8d ba              .WORD Basic_CMD       - 1
b03c dd ff              .WORD Basic_SYS       - 1
b03e bf ff              .WORD OPEN            - 1
b040 c2 ff              .WORD CLOSE           - 1
b042 79 bb              .WORD Basic_GET       - 1
b044 d1 b5              .WORD Basic_NEW       - 1
b046 ab b7              .WORD Basic_GO        - 1
b048 92 ff              .WORD Basic_CONCAT    - 1
b04a 95 ff              .WORD Basic_DOPEN     - 1
b04c 98 ff              .WORD Basic_DCLOSE    - 1
b04e 9b ff              .WORD Basic_RECORD    - 1
b050 9e ff              .WORD Basic_HEADER    - 1
b052 a1 ff              .WORD Basic_COLLECT   - 1
b054 a4 ff              .WORD Basic_BACKUP    - 1
b056 a7 ff              .WORD Basic_COPY      - 1
b058 aa ff              .WORD Basic_APPEND    - 1
b05a ad ff              .WORD Basic_DSAVE     - 1
b05c b0 ff              .WORD Basic_DLOAD     - 1
b05e b3 ff              .WORD Basic_DIRECTORY - 1
b060 b6 ff              .WORD Basic_RENAME    - 1
b062 b9 ff              .WORD Basic_SCRATCH   - 1
b064 b3 ff              .WORD Basic_DIRECTORY - 1

b066                    .SIZE ;  102 [Basic_Statement_Table]

              ; ********************
b066            Basic_Function_Table
              ; ********************

b066 6f cd              .WORD Basic_SGN
b068 02 ce              .WORD Basic_INT
b06a 8e cd              .WORD Basic_ABS
b06c 00 00              .WORD Basic_USR
b06e a8 c4              .WORD Basic_FRE
b070 c9 c4              .WORD Basic_POS
b072 08 d1              .WORD Basic_SQR
b074 29 d2              .WORD Basic_RND
b076 20 cb              .WORD Basic_LOG
b078 84 d1              .WORD Basic_EXP
b07a 82 d2              .WORD Basic_COS
b07c 89 d2              .WORD Basic_SIN
b07e d2 d2              .WORD Basic_TAN
b080 2c d3              .WORD Basic_ATN
b082 43 c9              .WORD Basic_PEEK
b084 b2 c8              .WORD Basic_LEN
b086 8e c5              .WORD Basic_STR
b088 e3 c8              .WORD Basic_VAL
b08a c1 c8              .WORD Basic_ASC
b08c 22 c8              .WORD Basic_CHR
b08e 36 c8              .WORD Basic_LEFT
b090 62 c8              .WORD Basic_RIGHT
b092 6d c8              .WORD Basic_MID

b094                    .SIZE ;   46 [Basic_Function_Table]

              ; ********************
b094            Basic_Operator_Table
              ; ********************

b094 79 9f c9           .BYTE $79, Op_PLUS     - 1
b097 79 88 c9           .BYTE $79, Op_MINUS    - 1
b09a 7b 60 cb           .BYTE $7b, Op_MULTIPLY - 1
b09d 7b 47 cc           .BYTE $7b, Op_DIVIDE   - 1
b0a0 7f 11 d1           .BYTE $7f, Op_POWER    - 1
b0a3 50 87 c0           .BYTE $50, Op_AND      - 1
b0a6 46 85 c0           .BYTE $46, Op_OR       - 1
b0a9 7d 4a d1           .BYTE $7d, Op_NEGATE   - 1
b0ac 5a cb be           .BYTE $5a, Op_NOT      - 1
b0af 64 b5 c0           .BYTE $64, Op_COMPARE  - 1

b0b2                    .SIZE ;   30 [Basic_Operator_Table]

              ; *******************
b0b2            Basic_Keyword_Table
              ; *******************

b0b2 45 4e c4           .BYTE "END"^        ; 80
b0b5 46 4f d2           .BYTE "FOR"^        ; 81
b0b8 4e 45 58           .BYTE "NEXT"^       ; 82
b0bc 44 41 54           .BYTE "DATA"^       ; 83
b0c0 49 4e 50           .BYTE "INPUT#"^     ; 84
b0c6 49 4e 50           .BYTE "INPUT"^      ; 85
b0cb 44 49 cd           .BYTE "DIM"^        ; 86
b0ce 52 45 41           .BYTE "READ"^       ; 87
b0d2 4c 45 d4           .BYTE "LET"^        ; 88
b0d5 47 4f 54           .BYTE "GOTO"^       ; 89
b0d9 52 55 ce           .BYTE "RUN"^        ; 8a
b0dc 49 c6              .BYTE "IF"^         ; 8b
b0de 52 45 53           .BYTE "RESTORE"^    ; 8c
b0e5 47 4f 53           .BYTE "GOSUB"^      ; 8d
b0ea 52 45 54           .BYTE "RETURN"^     ; 8e
b0f0 52 45 cd           .BYTE "REM"^        ; 8f
b0f3 53 54 4f           .BYTE "STOP"^       ; 90
b0f7 4f ce              .BYTE "ON"^         ; 91
b0f9 57 41 49           .BYTE "WAIT"^       ; 92
b0fd 4c 4f 41           .BYTE "LOAD"^       ; 93
b101 53 41 56           .BYTE "SAVE"^       ; 94
b105 56 45 52           .BYTE "VERIFY"^     ; 95
b10b 44 45 c6           .BYTE "DEF"^        ; 96
b10e 50 4f 4b           .BYTE "POKE"^       ; 97
b112 50 52 49           .BYTE "PRINT#"^     ; 98
b118 50 52 49           .BYTE "PRINT"^      ; 99
b11d 43 4f 4e           .BYTE "CONT"^       ; 9a
b121 4c 49 53           .BYTE "LIST"^       ; 9b
b125 43 4c d2           .BYTE "CLR"^        ; 9c
b128 43 4d c4           .BYTE "CMD"^        ; 9d
b12b 53 59 d3           .BYTE "SYS"^        ; 9e
b12e 4f 50 45           .BYTE "OPEN"^       ; 9f
b132 43 4c 4f           .BYTE "CLOSE"^      ; a0
b137 47 45 d4           .BYTE "GET"^        ; a1
b13a 4e 45 d7           .BYTE "NEW"^        ; a2
b13d 54 41 42           .BYTE "TAB("^       ; a3
b141 54 cf              .BYTE "TO"^         ; a4
b143 46 ce              .BYTE "FN"^         ; a5
b145 53 50 43           .BYTE "SPC("^       ; a6
b149 54 48 45           .BYTE "THEN"^       ; a7
b14d 4e 4f d4           .BYTE "NOT"^        ; a8
b150 53 54 45           .BYTE "STEP"^       ; a9
b154 ab                 .BYTE "+"^          ; aa
b155 ad                 .BYTE "-"^          ; ab
b156 aa                 .BYTE "*"^          ; ac
b157 af                 .BYTE "/"^          ; ad
b158 de                 .BYTE "^"^          ; ae
b159 41 4e c4           .BYTE "AND"^        ; af
b15c 4f d2              .BYTE "OR"^         ; b0
b15e be                 .BYTE ">"^          ; b1
b15f bd                 .BYTE "="^          ; b2
b160 bc                 .BYTE "<"^          ; b3
b161 53 47 ce           .BYTE "SGN"^        ; b4
b164 49 4e d4           .BYTE "INT"^        ; b5
b167 41 42 d3           .BYTE "ABS"^        ; b6
b16a 55 53 d2           .BYTE "USR"^        ; b7
b16d 46 52 c5           .BYTE "FRE"^        ; b8
b170 50 4f d3           .BYTE "POS"^        ; b9
b173 53 51 d2           .BYTE "SQR"^        ; ba
b176 52 4e c4           .BYTE "RND"^        ; bb
b179 4c 4f c7           .BYTE "LOG"^        ; bc
b17c 45 58 d0           .BYTE "EXP"^        ; bd
b17f 43 4f d3           .BYTE "COS"^        ; be
b182 53 49 ce           .BYTE "SIN"^        ; bf
b185 54 41 ce           .BYTE "TAN"^        ; c0
b188 41 54 ce           .BYTE "ATN"^        ; c1
b18b 50 45 45           .BYTE "PEEK"^       ; c2
b18f 4c 45 ce           .BYTE "LEN"^        ; c3
b192 53 54 52           .BYTE "STR$"^       ; c4
b196 56 41 cc           .BYTE "VAL"^        ; c5
b199 41 53 c3           .BYTE "ASC"^        ; c6
b19c 43 48 52           .BYTE "CHR$"^       ; c7
b1a0 4c 45 46           .BYTE "LEFT$"^      ; c8
b1a5 52 49 47           .BYTE "RIGHT$"^     ; c9
b1ab 4d 49 44           .BYTE "MID$"^       ; ca
b1af 47 cf              .BYTE "GO"^         ; cb
b1b1 43 4f 4e           .BYTE "CONCAT"^     ; cc
b1b7 44 4f 50           .BYTE "DOPEN"^      ; cd
b1bc 44 43 4c           .BYTE "DCLOSE"^     ; ce
b1c2 52 45 43           .BYTE "RECORD"^     ; cf
b1c8 48 45 41           .BYTE "HEADER"^     ; d0
b1ce 43 4f 4c           .BYTE "COLLECT"^    ; d1
b1d5 42 41 43           .BYTE "BACKUP"^     ; d2
b1db 43 4f 50           .BYTE "COPY"^       ; d3
b1df 41 50 50           .BYTE "APPEND"^     ; d4
b1e5 44 53 41           .BYTE "DSAVE"^      ; d5
b1ea 44 4c 4f           .BYTE "DLOAD"^      ; d6
b1ef 43 41 54           .BYTE "CATALOG"^    ; d7
b1f6 52 45 4e           .BYTE "RENAME"^     ; d8
b1fc 53 43 52           .BYTE "SCRATCH"^    ; d9
b203 44 49 52           .BYTE "DIRECTORY"^  ; da
b20c 00                 .BYTE $00           ; db

b20d                    .SIZE ;  347 [Basic_Keyword_Table]

              ; *********
b20d            Msg_Start
              ; *********

b20d 4e 45 58           .BYTE "NEXT WITHOUT FOR"^
b21d 53 59 4e Msg_SYNTA .BYTE "SYNTAX"^
b223 52 45 54 Msg_GOSUB .BYTE "RETURN WITHOUT GOSUB"^
b237 4f 55 54           .BYTE "OUT OF DATA"^
b242 49 4c 4c Msg_QUANT .BYTE "ILLEGAL QUANTITY"^
b252 4f 56 45 Msg_FLOW  .BYTE "OVERFLOW"^
b25a 4f 55 54 Msg_OOM   .BYTE "OUT OF MEMORY"^
b267 55 4e 44 Msg_UNDEF .BYTE "UNDEF'D STATEMENT"^
b278 42 41 44 Msg_SUBSC .BYTE "BAD SUBSCRIPT"^
b285 52 45 44 Msg_REDIM .BYTE "REDIM'D ARRAY"^
b292 44 49 56 Msg_DIV   .BYTE "DIVISION BY ZERO"^
b2a2 49 4c 4c Msg_DIREC .BYTE "ILLEGAL DIRECT"^
b2b0 54 59 50 Msg_TYPE  .BYTE "TYPE MISMATCH"^
b2bd 53 54 52 Msg_LONG  .BYTE "STRING TOO LONG"^
b2cc 46 49 4c Msg_DATA  .BYTE "FILE DATA"^
b2d5 46 4f 52 Msg_COMPL .BYTE "FORMULA TOO COMPLEX"^
b2e8 43 41 4e           .BYTE "CAN'T CONTINUE"^
b2f6 55 4e 44 Msg_FUNC  .BYTE "UNDEF'D FUNCTION"^
b306 20 45 52 Msg_ERR   .BYTE " ERROR",0
b30d 20 49 4e Msg_IN    .BYTE " IN ",0

b312                    .SIZE ;  261 [Msg_Start]

              ; *********
b312            Msg_READY
              ; *********

b312 0d 52 45           .BYTE "\rREADY.\r",0

              ; *********
b31b            Msg_BREAK
              ; *********

b31b 0d 42 52           .BYTE "\rBREAK",0


              ; FOR TO STEP NEXT data structure on stack
              ; ========================================

              ; 00 : TXTPTR
              ; 01 : TXTPTR+1  address of loop body

              ; 02 : CURLIN+1
              ; 03 : CURLIN    line #  of loop body

              ; 04 : FAC M4
              ; 05 : FAC M3
              ; 06 : FAC M2    value after TO
              ; 07 : FAC M1
              ; 08 : FAC EX

              ; 09 : sign
              ; 0a : FAC M4
              ; 0b : FAC M3
              ; 0c : FAC M2    value after STEP
              ; 0d : FAC M1
              ; 0e : FAC EX

              ; 0f : FORPNT+1
              ; 10 : FORPNT    address of index variable

              ; 11 : 81        loop marker

              ; ***********************
b322            Find_Active_FOR ; $b322
              ; ***********************

              ; Output: X = stackpointer to loop structure
              ;         Z = found flag
              ;         FORPNT = address of index variable

b322 ba                 TSX                 ; X = stack pointer
b323 e8                 INX
b324 e8                 INX                 ; skip return address of current subroutine
b325 e8                 INX
b326 e8                 INX                 ; skip return address of calling subroutine
b327 bd 01 01 FAF_10    LDA STACK+1,X
b32a c9 81              CMP #$81            ; loop marker ?
b32c d0 21              BNE FAF_Ret
b32e a5 47              LDA FORPNT+1        ; index variable given ?
b330 d0 0a              BNE FAF_20
b332 bd 02 01           LDA STACK+2,X       ; index variable low
b335 85 46              STA FORPNT
b337 bd 03 01           LDA STACK+3,X       ; index variable high
b33a 85 47              STA FORPNT+1
b33c dd 03 01 FAF_20    CMP STACK+3,X       ; index address high match ?
b33f d0 07              BNE FAF_30
b341 a5 46              LDA FORPNT
b343 dd 02 01           CMP STACK+2,X       ; index address low  match ?
b346 f0 07              BEQ FAF_Ret         ; OK found correct data structure
b348 8a       FAF_30    TXA
b349 18                 CLC
b34a 69 12              ADC #$12            ; try outer loop
b34c aa                 TAX
b34d d0 d8              BNE FAF_10
b34f 60       FAF_Ret   RTS ;Size   46 [Find_Active_FOR]

              ; *********************
b350            Open_Up_Space ; $b350
              ; *********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ;         TMPPTA = target pointer (upper boundary)
              ;         TMPPTB = source pointer (upper boundary)
              ;         TMPPTC = source pointer (lower boundary)

b350 20 a0 b3           JSR Check_Mem_Avail ; may trigger a garbage collection
b353 85 2e              STA STREND
b355 84 2f              STY STREND+1        ; save new top of variables
b357 38                 SEC
b358 a5 57              LDA TMPPTB
b35a e5 5c              SBC TMPPTC
b35c 85 1f              STA INDEXA
b35e a8                 TAY
b35f a5 58              LDA TMPPTB+1
b361 e5 5d              SBC TMPPTC+1
b363 aa                 TAX                 ; Y/X = bytes to move
b364 e8                 INX                 ; pages + 1
b365 98                 TYA
b366 f0 23              BEQ OUS_40          ; no partial page
b368 a5 57              LDA TMPPTB
b36a 38                 SEC
b36b e5 1f              SBC INDEXA
b36d 85 57              STA TMPPTB
b36f b0 03              BCS OUS_10
b371 c6 58              DEC TMPPTB+1        ; TMPPTB = source ptr
b373 38                 SEC
b374 a5 55    OUS_10    LDA TMPPTA
b376 e5 1f              SBC INDEXA
b378 85 55              STA TMPPTA
b37a b0 08              BCS OUS_30
b37c c6 56              DEC TMPPTA+1        ; TMPPTA = target ptr
b37e 90 04              BCC OUS_30          ; branch always
b380 b1 57    OUS_20    LDA (TMPPTB),Y
b382 91 55              STA (TMPPTA),Y
b384 88       OUS_30    DEY
b385 d0 f9              BNE OUS_20
b387 b1 57              LDA (TMPPTB),Y
b389 91 55              STA (TMPPTA),Y
b38b c6 58    OUS_40    DEC TMPPTB+1
b38d c6 56              DEC TMPPTA+1
b38f ca                 DEX
b390 d0 f2              BNE OUS_30
b392 60                 RTS ;Size   67 [Open_Up_Space]

              ; *************************
b393            Check_Stack_Avail ; $b393
              ; *************************

b393 ba                 TSX
b394 e0 20              CPX #$20
b396 90 35              BCC Error_Out_Of_Memory
b398 60                 RTS ;Size    6 [Check_Stack_Avail]

              ; **************
b399            BSOS_Bank_Init
              ; **************

b399 00                 .BYTE 0             ; changed by BSOS loader

b39a 00 00 00           .FILL $b3a0-* (0) ; 6 bytes

              ; ***********************
b3a0            Check_Mem_Avail ; $b3a0
              ; ***********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ; Return if OK
              ; Jump to OOM error if not

b3a0 c4 31              CPY FRETOP+1
b3a2 90 19              BCC CMA_Ret
b3a4 d0 04              BNE CMA_10
b3a6 c5 30              CMP FRETOP
b3a8 90 13              BCC CMA_Ret
b3aa 48       CMA_10    PHA                 ; not enough space
b3ab 98                 TYA                 ; call garbage collectiom
b3ac 48                 PHA
b3ad 20 6a c6           JSR Garbage_Collection
b3b0 68                 PLA
b3b1 a8                 TAY                 ; restore new top high
b3b2 68                 PLA                 ; restore new to low
b3b3 c4 31              CPY FRETOP+1        ; compare again
b3b5 90 06              BCC CMA_Ret
b3b7 d0 14              BNE Error_Out_Of_Memory
b3b9 c5 30              CMP FRETOP
b3bb b0 10              BCS Error_Out_Of_Memory
b3bd 60       CMA_Ret   RTS ;Size   30 [Check_Mem_Avail]

b3be 00 00 00           .FILL $b3cd-* (0) ; 15 bytes

              ; ***************************
b3cd            Error_Out_Of_Memory ; $b3cd
              ; ***************************

b3cd a2 4d              LDX #[Msg_OOM - Msg_Start] ; $4d

              ; *******************
b3cf            Basic_Error ; $b3cf
              ; *******************

              ; Input:  X = Offset from Msg_Start for message

b3cf 6c 00 03           JMP (IERROR)

              ; *********
b3d2            DEF_ERROR
              ; *********

b3d2 20 cc ff           JSR CLRCHN          ; close open channels
b3d5 85 10              STA IOPMPT          ; A = 0 from CLRCHN
b3d7 20 df ba           JSR Print_CR
b3da 20 44 bb           JSR Print_Question_Mark
b3dd bd 0d b2 Berr_20   LDA Msg_Start,X
b3e0 48                 PHA
b3e1 29 7f              AND #$7f
b3e3 20 d2 ff           JSR CHROUT
b3e6 e8                 INX
b3e7 68                 PLA
b3e8 10 f3              BPL Berr_20
b3ea 20 0e b6 Berr_30   JSR Flush_BASIC_Stack
b3ed a9 06              LDA #<Msg_ERR
b3ef a0 b3              LDY #>Msg_ERR
b3f1 20 1d bb Berr_40   JSR Print_String
b3f4 a4 37              LDY CURLIN+1
b3f6 c8                 INY
b3f7 f0 06              BEQ Basic_Ready
b3f9 20 78 cf           JSR Print_IN

b3fc ea ea ea           .FILL $b3ff-* ($ea) ; 3 bytes

              ; ********************
b3ff            Basic_Ready ; $ b3ff
              ; ********************

b3ff a9 12              LDA #<Msg_READY
b401 a0 b3              LDY #>Msg_READY
b403 20 1d bb           JSR Print_String

              ; ***************************
b406            Get_Basic_Statement ; $b406
              ; ***************************

b406 6c 02 03           JMP (IMAIN)

              ; ********
b409            DEF_MAIN
              ; ********

b409 20 f2 e9           JSR Read_Power_String
b40c 86 77              STX TXTPTR
b40e 84 78              STY TXTPTR+1
b410 20 70 00           JSR CHRGET
b413 aa                 TAX
b414 f0 f0              BEQ Get_Basic_Statement; empty line
b416 a2 ff              LDX #$ff
b418 86 37              STX CURLIN+1        ; invalidate CURLIN
b41a 90 03              BCC New_Basic_Line  ; started with a line number
b41c 4c 42 f8           JMP Wedge_Parser    ; direct command

              ; **********************
b41f            New_Basic_Line ; $b41f
              ; **********************

              ; This routine uses the addresses $01fc-$01ff for constructing
              ; the link and line number for the line stored in the buffer at $0200
              ; So these bytes are not available for stack operations.
              ; That's why the Flush_Stack routine initializes the stack pointer to $fa.

b41f 20 f6 b8           JSR Scan_Linenumber ; Line number
b422 20 fb b4           JSR Tokenize_Line   ; Crunch line
b425 84 05              STY COUNT           ; new line length (incl. link & number)
b427 20 a6 b5           JSR Find_BASIC_Line ; does this line exist?
b42a 90 44              BCC NBL_30          ; if not -> create a new line
b42c a0 01              LDY #1              ; Y = 1
b42e b1 5c              LDA (TMPPTC),Y      ; link high
b430 85 20              STA INDEXA+1        ; source pointer INDEXA high
b432 a5 2a              LDA VARTAB
b434 85 1f              STA INDEXA          ; source pointer INDEXA low
b436 a5 5d              LDA TMPPTC+1
b438 85 22              STA INDEXB+1        ; target pointer INDEXB high
b43a a5 5c              LDA TMPPTC
b43c 88                 DEY                 ; Y = 0
b43d f1 5c              SBC (TMPPTC),Y      ; negative length of line
b43f 18                 CLC
b440 65 2a              ADC VARTAB          ; subtract line length from VARTAB
b442 85 2a              STA VARTAB          ; by adding the negative length to VARTAB
b444 85 21              STA INDEXB          ; move target pointer INDEXB low
b446 a5 2b              LDA VARTAB+1
b448 69 ff              ADC #$ff
b44a 85 2b              STA VARTAB+1        ; VARTAB -= length of current line
b44c e5 5d              SBC TMPPTC+1
b44e aa                 TAX                 ; pages to move
b44f 38                 SEC
b450 a5 5c              LDA TMPPTC
b452 e5 2a              SBC VARTAB          ; bytes to move
b454 a8                 TAY
b455 b0 03              BCS NBL_10
b457 e8                 INX                 ; increment pages to move
b458 c6 22              DEC INDEXB+1
b45a 18       NBL_10    CLC
b45b 65 1f              ADC INDEXA
b45d 90 03              BCC NBL_20
b45f c6 20              DEC INDEXA+1
b461 18                 CLC
b462 b1 1f    NBL_20    LDA (INDEXA),Y      ; move program code above deleted line
b464 91 21              STA (INDEXB),Y      ; downwards
b466 c8                 INY
b467 d0 f9              BNE NBL_20          ; inner loop moves 1 page
b469 e6 20              INC INDEXA+1
b46b e6 22              INC INDEXB+1
b46d ca                 DEX                 ; pages to move
b46e d0 f2              BNE NBL_20
b470 20 e9 b5 NBL_30    JSR Reset_BASIC_Execution
b473 20 b6 b4           JSR Rechain
b476 ad 00 02           LDA BUF
b479 f0 8b              BEQ Get_Basic_Statement
b47b 18                 CLC
b47c a5 2a              LDA VARTAB
b47e 85 57              STA TMPPTB
b480 65 05              ADC COUNT
b482 85 55              STA TMPPTA
b484 a4 2b              LDY VARTAB+1
b486 84 58              STY TMPPTB+1
b488 90 01              BCC NBL_40
b48a c8                 INY
b48b 84 56    NBL_40    STY TMPPTA+1
b48d 20 50 b3           JSR Open_Up_Space
b490 a5 11              LDA LINNUM
b492 a4 12              LDY LINNUM+1
b494 8d fe 01           STA BUF-2
b497 8c ff 01           STY BUF-1
b49a a5 2e              LDA STREND
b49c a4 2f              LDY STREND+1
b49e 85 2a              STA VARTAB
b4a0 84 2b              STY VARTAB+1
b4a2 a4 05              LDY COUNT
b4a4 88                 DEY
b4a5 b9 fc 01 NBL_50    LDA BUF-4,Y         ; copy buffer to program
b4a8 91 5c              STA (TMPPTC),Y
b4aa 88                 DEY
b4ab 10 f8              BPL NBL_50

              ; *************************
b4ad            Reset_And_Rechain ; $b4ad
              ; *************************

b4ad 20 e9 b5           JSR Reset_BASIC_Execution
b4b0 20 b6 b4           JSR Rechain
b4b3 4c 06 b4           JMP Get_Basic_Statement

              ; ***************
b4b6            Rechain ; $b4b6
              ; ***************

b4b6 a6 28              LDX TXTTAB
b4b8 a5 29              LDA TXTTAB+1
b4ba a0 01              LDY #1
b4bc d0 16              BNE Rech_30
b4be a0 04    Rech_10   LDY #4
b4c0 c8       Rech_20   INY
b4c1 b1 1f              LDA (INDEXA),Y
b4c3 d0 fb              BNE Rech_20         ; scan for 0
b4c5 98                 TYA
b4c6 38                 SEC                 ; + 1
b4c7 65 1f              ADC INDEXA
b4c9 aa                 TAX                 ; X = new address low
b4ca a0 00              LDY #0
b4cc 91 1f              STA (INDEXA),Y      ; store link low
b4ce 98                 TYA                 ; A = 0
b4cf 65 20              ADC INDEXA+1        ; A = new address high
b4d1 c8                 INY                 ; Y = 1
b4d2 91 1f              STA (INDEXA),Y      ; store link high
b4d4 86 1f    Rech_30   STX INDEXA
b4d6 85 20              STA INDEXA+1
b4d8 b1 1f              LDA (INDEXA),Y      ; link high
b4da d0 e2              BNE Rech_10         ; more lines
b4dc 60                 RTS ;Size   39 [Rechain]

b4dd 00 00 00           .FILL $b4e2-* (0) ; 5 bytes

              ; *******************
b4e2            Read_String ; $b4e2
              ; *******************

b4e2 a2 00              LDX #0
b4e4 20 cf ff ReaS_10   JSR CHRIN
b4e7 c9 0d              CMP #CR
b4e9 f0 0d              BEQ ReaS_20
b4eb 9d 00 02           STA BUF,X
b4ee e8                 INX
b4ef e0 51              CPX #81
b4f1 90 f1              BCC ReaS_10
b4f3 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
b4f5 4c cf b3           JMP Basic_Error
b4f8 4c d2 ba ReaS_20   JMP Terminate_BUF

              ; *********************
b4fb            Tokenize_Line ; $b4fb
              ; *********************

b4fb 6c 04 03           JMP (ICRNCH)

              ; **********
b4fe            DEF_CRUNCH
              ; **********

b4fe a6 77              LDX TXTPTR
b500 a0 04              LDY #4
b502 84 09              STY GARBFL          ; clear bits 7-4
b504 bd 00 02 ToLi_01   LDA BUF,X           ; get next char
b507 10 07              BPL ToLi_02         ; normal char
b509 c9 ff              CMP #$ff            ; Pi ?
b50b f0 4a              BEQ ToLi_08         ; treat Pi as normal char
b50d e8                 INX                 ; no action on this char
b50e d0 f4              BNE ToLi_01         ; next one
b510 c9 20    ToLi_02   CMP #' '            ; no action on blank
b512 f0 43              BEQ ToLi_08
b514 85 04              STA ENDCHR          ; save char
b516 c9 22              CMP #$22            ; quote ?
b518 f0 62              BEQ ToLi_12         ; handle string
b51a 24 09              BIT GARBFL
b51c 70 39              BVS ToLi_08
b51e c9 3f              CMP #'?'            ; short for print
b520 d0 04              BNE ToLi_03
b522 a9 99              LDA #$99            ; PRINT token
b524 d0 31              BNE ToLi_08
b526 c9 30    ToLi_03   CMP #'0'
b528 90 04              BCC ToLi_04         ; is symbol
b52a c9 3c              CMP #$3c            ; '<'
b52c 90 29              BCC ToLi_08
b52e 84 6e    ToLi_04   STY TMPPTD          ; save Y
b530 a0 00              LDY #0
b532 84 05              STY COUNT           ; keyword count
b534 86 77              STX TXTPTR          ; update pointer
b536 a9 b0              LDA #>Basic_Keyword_Table
b538 85 20              STA INDEXA+1
b53a a9 b2              LDA #<Basic_Keyword_Table
b53c 85 1f              STA INDEXA
b53e d0 07              BNE ToLi_06         ; branch always
b540 e8       ToLi_05   INX                 ; inc buffer  pointer X
b541 e6 1f              INC INDEXA          ; inc keyword pointer INDEXA
b543 d0 02              BNE ToLi_06
b545 e6 20              INC INDEXA+1
b547 bd 00 02 ToLi_06   LDA BUF,X           ; char - keyword char
b54a 38                 SEC
b54b f1 1f              SBC (INDEXA),Y
b54d f0 f1              BEQ ToLi_05         ; match, continue with next char
b54f c9 80              CMP #$80            ; match with difference $80 -> found
b551 d0 30              BNE ToLi_13
b553 05 05              ORA COUNT           ; token = $80 | count
b555 a4 6e    ToLi_07   LDY TMPPTD          ; restore Y (started with 4)
b557 e8       ToLi_08   INX                 ; point to char after parsed word
b558 c8                 INY                 ; point to token insert position - 5
b559 99 fb 01           STA BUF-5,Y         ; insert token at start of word
b55c b9 fb 01           LDA BUF-5,Y         ; reload to set flags
b55f f0 3b              BEQ ToLi_16         ; zero -> end of line
b561 38                 SEC
b562 e9 3a              SBC #':'            ; colon ?
b564 f0 04              BEQ ToLi_09         ; branch on colon
b566 c9 49              CMP #$49            ; DATA token ? ($83 = $3a + $49)
b568 d0 02              BNE ToLi_10
b56a 85 09    ToLi_09   STA GARBFL          ; store colon or $49 for DATA
b56c 38       ToLi_10   SEC
b56d e9 55              SBC #$55            ; REM token ? ($8f = $3a + $55)
b56f d0 93              BNE ToLi_01         ; no special tokens -> continue parse
b571 85 04              STA ENDCHR          ; store REM marker in ENDCHR
b573 bd 00 02 ToLi_11   LDA BUF,X
b576 f0 df              BEQ ToLi_08         ; end of parsed text
b578 c5 04              CMP ENDCHR
b57a f0 db              BEQ ToLi_08         ; end of copied text
b57c c8       ToLi_12   INY                 ; copy text in quotes or after REM or DATA
b57d 99 fb 01           STA BUF-5,Y
b580 e8                 INX
b581 d0 f0              BNE ToLi_11         ; continue copy
b583 a6 77    ToLi_13   LDX TXTPTR          ; found keyword match
b585 e6 05              INC COUNT           ; set count to next token
b587 b1 1f    ToLi_14   LDA (INDEXA),Y      ;
b589 08                 PHP                 ; save flags
b58a e6 1f              INC INDEXA          ; let INDEXA point to next token
b58c d0 02              BNE ToLi_15
b58e e6 20              INC INDEXA+1
b590 28       ToLi_15   PLP                 ; restore flags
b591 10 f4              BPL ToLi_14         ; true if not single character keyword
b593 b1 1f              LDA (INDEXA),Y      ; load 1st. char of next token keyword
b595 d0 b0              BNE ToLi_06         ; jump if not at end of table
b597 bd 00 02           LDA BUF,X           ; reread parse char
b59a 10 b9              BPL ToLi_07         ; start searching from start of table
b59c 99 fd 01 ToLi_16   STA BUF-3,Y         ; end of parse, store zeroes at end of line
b59f c6 78              DEC TXTPTR+1        ; set TXTPTR to BUF-1
b5a1 a9 ff              LDA #$ff
b5a3 85 77              STA TXTPTR
b5a5 60                 RTS ;Size  168 [DEF_CRUNCH]

              ; ***********************
b5a6            Find_BASIC_Line ; $b5a3
              ; ***********************

b5a6 a5 28              LDA TXTTAB
b5a8 a6 29              LDX TXTTAB+1

              ; **************************
b5aa            Find_BASIC_Line_AX ; $b5a7
              ; **************************

b5aa a0 01              LDY #1
b5ac 85 5c              STA TMPPTC
b5ae 86 5d              STX TMPPTC+1
b5b0 b1 5c              LDA (TMPPTC),Y      ; link high
b5b2 f0 1a              BEQ FBL_30          ; branch on EOP
b5b4 aa                 TAX                 ; X = link high
b5b5 a0 03              LDY #3
b5b7 a5 12              LDA LINNUM+1
b5b9 d1 5c              CMP (TMPPTC),Y
b5bb 90 12              BCC FBL_Ret         ; branch if beyond
b5bd d0 09              BNE FBL_10
b5bf 88                 DEY                 ; Y = 2
b5c0 a5 11              LDA LINNUM
b5c2 d1 5c              CMP (TMPPTC),Y
b5c4 f0 09              BEQ FBL_Ret         ; (C=1) found
b5c6 90 07              BCC FBL_Ret         ; (C=0) not found
b5c8 a0 00    FBL_10    LDY #0
b5ca b1 5c              LDA (TMPPTC),Y      ; Link low
b5cc b0 dc              BCS Find_BASIC_Line_AX  ; branch always
b5ce 18       FBL_30    CLC                 ; Carry clear = not found
b5cf 60       FBL_Ret   RTS ;Size   38 [Find_BASIC_Line_AX]

b5d0 00 00              .FILL $b5d2-* (0) ; 2 bytes

              ; *****************
b5d2            Basic_NEW ; $b5d2
              ; *****************

b5d2 d0 fb              BNE FBL_Ret         ; return if NEW is not a single statement

              ; ***********
b5d4            Perform_NEW
              ; ***********

b5d4 a9 00              LDA #0
b5d6 a8                 TAY
b5d7 91 28              STA (TXTTAB),Y      ; zero link
b5d9 c8                 INY
b5da 91 28              STA (TXTTAB),Y
b5dc a5 28              LDA TXTTAB
b5de 18                 CLC
b5df 69 02              ADC #2
b5e1 85 2a              STA VARTAB          ; VARTAB = TXTTAB + 2
b5e3 a5 29              LDA TXTTAB+1
b5e5 69 00              ADC #0
b5e7 85 2b              STA VARTAB+1

              ; *********************
b5e9            Reset_BASIC_Execution
              ; *********************

b5e9 20 22 b6           JSR Reset_BASIC_Exec_Pointer
b5ec a9 00              LDA #0              ; set for next condition

              ; *********
b5ee            Basic_CLR
              ; *********

b5ee d0 31              BNE FBS_Ret         ; return if not single statement

              ; **********************
b5f0            Reset_Variable_Pointer
              ; **********************

b5f0 a5 34              LDA MEMSIZ
b5f2 a4 35              LDY MEMSIZ+1
b5f4 85 30              STA FRETOP
b5f6 84 31              STY FRETOP+1
b5f8 ea                 NOP
b5f9 ea                 NOP
b5fa ea                 NOP
b5fb ea                 NOP
b5fc 20 e7 ff           JSR CLALL
b5ff a5 2a              LDA VARTAB
b601 a4 2b              LDY VARTAB+1
b603 85 2c              STA ARYTAB
b605 84 2d              STY ARYTAB+1
b607 85 2e              STA STREND
b609 84 2f              STY STREND+1
b60b 20 b7 b7 RVP_10    JSR Basic_RESTORE

              ; *************************
b60e            Flush_BASIC_Stack ; $b60e
              ; *************************

b60e a2 16              LDX #TEMPST         ; clear string descriptor stack
b610 86 13              STX TEMPPT
b612 68                 PLA
b613 a8                 TAY
b614 68                 PLA
b615 a2 fa              LDX #$fa            ; reset stackpointer
b617 9a                 TXS
b618 48                 PHA
b619 98                 TYA
b61a 48                 PHA
b61b a9 00              LDA #0
b61d 85 3b              STA OLDTXT+1
b61f 85 0a              STA SUBFLG
b621 60       FBS_Ret   RTS ;Size   20 [Flush_BASIC_Stack]

              ; ************************
b622            Reset_BASIC_Exec_Pointer
              ; ************************

b622 18                 CLC                 ; TXTPTR = TXTTAB - 1
b623 a5 28              LDA TXTTAB
b625 69 ff              ADC #$ff
b627 85 77              STA TXTPTR
b629 a5 29              LDA TXTTAB+1
b62b 69 ff              ADC #$ff
b62d 85 78              STA TXTPTR+1
b62f 60       RBEP_Ret  RTS ;Size   14 [Reset_BASIC_Exec_Pointer]

              ; **********
b630            Basic_LIST
              ; **********

b630 90 06              BCC LIST_10         ; C=0 : number after LIST
b632 f0 04              BEQ LIST_10         ; Z=1 : end of statement
b634 c9 ab              CMP #$ab            ; '-' token
b636 d0 f7              BNE RBEP_Ret        ; -> RTS
b638 20 f6 b8 LIST_10   JSR Scan_Linenumber ; starting line or 0 for non numeric
b63b 20 a6 b5           JSR Find_BASIC_Line ; setup TMPPTC
b63e 20 76 00           JSR CHRGOT          ; last character read
b641 f0 0c              BEQ LIST_15         ; no end line
b643 c9 ab              CMP #$ab            ; '-' token
b645 d0 e8              BNE RBEP_Ret        ; -> RTS
b647 20 70 00           JSR CHRGET
b64a 20 f6 b8           JSR Scan_Linenumber ; read end line
b64d d0 e0              BNE RBEP_Ret        ; more chars after end line -> RTS
b64f 68       LIST_15   PLA                 ; remove return address
b650 68                 PLA
b651 a5 11              LDA LINNUM
b653 05 12              ORA LINNUM+1
b655 d0 02              BNE LIST_20         ; end line != 0 ?
b657 c6 12              DEC LINNUM+1        ; end line  = $ff00 = 65280

              ; loop for line listing

b659 a0 01    LIST_20   LDY #1

              ; check for EOP and STOP

b65b b1 5c              LDA (TMPPTC),Y      ; link address high
b65d f0 27              BEQ LIST_50         ; -> end of program
b65f 20 e1 ff           JSR STOP            ; check STOP key
b662 20 df ba           JSR Print_CR        ; start listing with newline

              ; get line #

b665 c8                 INY                 ; Y=2
b666 b1 5c              LDA (TMPPTC),Y      ; line # lo
b668 aa                 TAX
b669 c8                 INY                 ; Y=3
b66a b1 5c              LDA (TMPPTC),Y      ; line # hi

              ; check for last line to list

b66c c5 12              CMP LINNUM+1        ; compare with end line hi
b66e d0 04              BNE LIST_25         ; not equal
b670 e4 11              CPX LINNUM          ; compare with end line lo
b672 f0 02              BEQ LIST_30         ; match -> print it
b674 b0 10    LIST_25   BCS LIST_50         ; line # > end line


              ; loop for printing characters

b676 20 89 b6 LIST_30   JSR List_Line

              ; follow link

b679 a8       LIST_60   TAY                 ; Y=0
b67a b1 5c              LDA (TMPPTC),Y      ; link low
b67c aa                 TAX
b67d c8                 INY
b67e b1 5c              LDA (TMPPTC),Y      ; link high
b680 86 5c              STX TMPPTC          ; TMPPTC = link
b682 85 5d              STA TMPPTC+1
b684 d0 d3              BNE LIST_20         ; continue with next line

              ; next line if not EOP

b686 4c ff b3 LIST_50   JMP Basic_Ready     ; LIST finished

b689                    .SIZE ;   89 [Basic_LIST]

              ; *****************
b689            List_Line ; $b689
              ; *****************

b689 20 83 cf           JSR Print_Integer_XA; print line #
b68c a9 20              LDA #' '            ; print blank after line #
b68e a0 03              LDY #3              ; before basic text

b690 20 46 bb LiLi_08   JSR Print_Char
b693 c9 22              CMP #QUOTE
b695 d0 0c              BNE LiLi_20

              ; print quoted string

b697 c8       LiLi_10   INY
b698 b1 5c              LDA (TMPPTC),Y
b69a f0 41              BEQ LiLi_Ret
b69c 20 46 bb           JSR Print_Char      ; print it
b69f c9 22              CMP #QUOTE
b6a1 d0 f4              BNE LiLi_10

              ; get next char

b6a3 c8       LiLi_20   INY                 ; Y++
b6a4 b1 5c              LDA (TMPPTC),Y      ; next character
b6a6 f0 35              BEQ LiLi_Ret
b6a8 6c 06 03           JMP (IQPLOP)        ; hook for extensions

              ; *********
b6ab            DEF_QPLOP
              ; *********

b6ab 10 e3              BPL LiLi_08         ; continue printing if not a token
b6ad c9 ff              CMP #$ff            ; is it the special char PI ?
b6af f0 df              BEQ LiLi_08         ; yes, print it

              ; print keyword from token

b6b1 aa                 TAX
b6b2 98                 TYA
b6b3 48                 PHA                 ; save Y
b6b4 a0 b0              LDY #>[Basic_Keyword_Table-1]
b6b6 84 20              STY INDEXA+1
b6b8 a0 b1              LDY #<[Basic_Keyword_Table-1]
b6ba 84 1f              STY INDEXA
b6bc a0 00              LDY #0
b6be ca       LiLi_30   DEX                 ; token--
b6bf 10 0c              BPL LiLi_60         ; count down finished
b6c1 e6 1f    LiLi_40   INC INDEXA          ; increment address to keyword table
b6c3 d0 02              BNE LiLi_50
b6c5 e6 20              INC INDEXA+1
b6c7 b1 1f    LiLi_50   LDA (INDEXA),Y      ; load next keyword char
b6c9 10 f6              BPL LiLi_40         ; -> inside keyword
b6cb 30 f1              BMI LiLi_30         ; -> end of keyword
b6cd c8       LiLi_60   INY
b6ce b1 1f              LDA (INDEXA),Y      ; next char from keyword table
b6d0 48                 PHA
b6d1 29 7f              AND #$7f
b6d3 20 46 bb           JSR Print_Char      ; print it
b6d6 68                 PLA
b6d7 10 f4              BPL LiLi_60
b6d9 68                 PLA
b6da a8                 TAY
b6db d0 c6              BNE LiLi_20
b6dd 60       LiLi_Ret  RTS ;Size   51 [DEF_QPLOP]

b6de                    .FILL $b6de-* (0) ; 0 bytes

              ; *****************
b6de            Basic_FOR ; $b6de
              ; *****************

b6de a9 80              LDA #$80
b6e0 85 0a              STA SUBFLG          ; Inhibit integer index
b6e2 20 30 b9           JSR Basic_LET       ; define index variable
b6e5 20 22 b3           JSR Find_Active_FOR
b6e8 d0 05              BNE FOR_10          ; branch if none
b6ea 8a                 TXA
b6eb 69 0f              ADC #15             ; add 16 (C=1 from Find_Active_FOR)
b6ed aa                 TAX
b6ee 9a                 TXS
b6ef 68       FOR_10    PLA                 ; remove return address
b6f0 68                 PLA                 ; now there is space for 18 bytes
b6f1 20 93 b3           JSR Check_Stack_Avail
b6f4 20 91 b8           JSR Skip_To_EOS     ; search start of loop body
b6f7 18                 CLC
b6f8 98                 TYA                 ; Y = position of delimiter (0 or ':')
b6f9 65 77              ADC TXTPTR          ; loop body low
b6fb 48                 PHA
b6fc a5 78              LDA TXTPTR+1        ; loop body high
b6fe 69 00              ADC #0
b700 48                 PHA
b701 a5 37              LDA CURLIN+1        ; line # high for body
b703 48                 PHA
b704 a5 36              LDA CURLIN          ; line # low  for body
b706 48                 PHA
b707 a9 a4              LDA #$a4            ; TO token
b709 20 f7 be           JSR Need_A
b70c 20 84 bd           JSR Eval_Numeric    ; read end value
b70f a5 63              LDA FAC1SI
b711 09 7f              ORA #$7f
b713 25 5f              AND FAC1M1
b715 85 5f              STA FAC1M1
b717 18                 CLC                 ; push without sign
b718 20 2e be           JSR Push_FAC1       ; push TO value
b71b a9 f2              LDA #<REAL_1
b71d a0 ca              LDY #>REAL_1
b71f 20 d8 cc           JSR Load_FAC1_AY    ; default 1.0 for STEP value
b722 20 76 00           JSR CHRGOT
b725 c9 a9              CMP #$a9            ; STEP token
b727 d0 06              BNE FOR_30
b729 20 70 00           JSR CHRGET
b72c 20 84 bd           JSR Eval_Numeric
b72f 20 61 cd FOR_30    JSR Get_FAC1_Sign
b732 85 63              STA FAC1SI
b734 38                 SEC                 ; push with sign
b735 20 2e be           JSR Push_FAC1       ; push STEP value
b738 a5 47              LDA FORPNT+1
b73a 48                 PHA
b73b a5 46              LDA FORPNT
b73d 48                 PHA
b73e a9 81              LDA #$81
b740 48                 PHA
b741 d0 07              BNE Execute         ; always

b743 00 00 00           .FILL $b74a-* (0) ; 7 bytes

              ; ***************
b74a            Execute ; $b74a
              ; ***************

b74a 20 43 f3           JSR Kernal_STOP
b74d a4 78              LDY TXTPTR+1
b74f c0 02              CPY #2
b751 f0 06              BEQ Exec_10
b753 a5 77              LDA TXTPTR
b755 85 3a              STA OLDTXT          ; save pointer if not direct
b757 84 3b              STY OLDTXT+1
b759 a0 00    Exec_10   LDY #0
b75b b1 77              LDA (TXTPTR),Y
b75d d0 46              BNE Inpr_40         ; branch if not at line end
b75f a0 02              LDY #2
b761 b1 77              LDA (TXTPTR),Y      ; link high
b763 18                 CLC                 ; C=0 : normal end
b764 f0 7c              BEQ END_40          ; end of program -> READY.
b766 c8                 INY                 ; Y = 3
b767 b1 77              LDA (TXTPTR),Y      ; new line # to CURLIN
b769 85 36              STA CURLIN
b76b c8                 INY
b76c b1 77              LDA (TXTPTR),Y
b76e 85 37              STA CURLIN+1
b770 98                 TYA
b771 65 77              ADC TXTPTR          ; TXTPTR = next statement
b773 85 77              STA TXTPTR
b775 90 02              BCC Start_Program
b777 e6 78              INC TXTPTR+1

              ; *************
b779            Start_Program
              ; *************

b779 6c 08 03           JMP (IGONE)

              ; ********
b77c            DEF_GONE
              ; ********

b77c 20 0f bf           JSR Any_Except_Pi   ; Pi must not start a statement
b77f 20 85 b7           JSR Interpret
b782 4c 4a b7           JMP Execute

              ; *****************
b785            Interpret ; $b785
              ; *****************

              ; Input:  A = first character of new statement
              ;         Flags set from GETCHR

b785 f0 3e              BEQ REST_Ret        ; branch on empty statement
b787 e9 80    Inpr_10   SBC #$80            ; token -> number
b789 90 17              BCC Inpr_30         ; branch to LET if not token
b78b c9 23              CMP #$23            ; $80-$a2 may start a statement
b78d 90 06              BCC Inpr_20         ; use jump table
b78f c9 4b              CMP #$4b            ; $a3-$cb are functions or operators
b791 90 16              BCC Inpr_50
b793 e9 28              SBC #$28            ; BASIC-4 token
b795 0a       Inpr_20   ASL A
b796 a8                 TAY
b797 b9 01 b0           LDA Basic_Statement_Table+1,Y
b79a 48                 PHA
b79b b9 00 b0           LDA Basic_Statement_Table,Y
b79e 48                 PHA
b79f 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
b7a2 4c 30 b9 Inpr_30   JMP Basic_LET       ; start with variable name
b7a5 c9 3a    Inpr_40   CMP #':'
b7a7 f0 d0              BEQ Start_Program
b7a9 4c 00 bf Inpr_50   JMP Syntax_Error

              ; ****************
b7ac            Basic_GO ; $b7ac
              ; ****************

b7ac 20 76 00           JSR CHRGOT          ; execute GO TO command
b7af a9 a4              LDA #$a4            ; TO token
b7b1 20 f7 be           JSR Need_A
b7b4 4c 30 b8           JMP Basic_GOTO

              ; *********************
b7b7            Basic_RESTORE ; $b7b7
              ; *********************

b7b7 38                 SEC                 ; DATPTR = TXTTAB - 1
b7b8 a5 28              LDA TXTTAB
b7ba e9 01              SBC #1
b7bc a4 29              LDY TXTTAB+1
b7be b0 01              BCS REST_10
b7c0 88                 DEY
b7c1 85 3e    REST_10   STA DATPTR
b7c3 84 3f              STY DATPTR+1
b7c5 60       REST_Ret  RTS ;Size   15 [Basic_RESTORE]

              ; ******************
b7c6            Basic_STOP ; $b7c6
              ; ******************

b7c6 b0 01              BCS END_10          ; C=1 : BREAK

              ; ****************
b7c8            Basic_END ; b7c8
              ; ****************

b7c8 18                 CLC                 ; C=0 : READY
b7c9 d0 3c    END_10    BNE CONT_Ret
b7cb a5 77              LDA TXTPTR
b7cd a4 78              LDY TXTPTR+1
b7cf a6 37              LDX CURLIN+1
b7d1 e8                 INX                 ; CURLIN+1 = $ff : undefined
b7d2 f0 0c              BEQ END_30
b7d4 85 3a              STA OLDTXT
b7d6 84 3b              STY OLDTXT+1
b7d8 a5 36    END_20    LDA CURLIN
b7da a4 37              LDY CURLIN+1
b7dc 85 38              STA OLDLIN
b7de 84 39              STY OLDLIN+1
b7e0 68       END_30    PLA
b7e1 68                 PLA
b7e2 a9 1b    END_40    LDA #<Msg_BREAK     ; $b31b
b7e4 a0 b3              LDY #>Msg_BREAK
b7e6 90 03              BCC END_50
b7e8 4c f1 b3           JMP Berr_40
b7eb 4c ff b3 END_50    JMP Basic_Ready

              ; ******************
b7ee            Basic_CONT ; $b7ee
              ; ******************

b7ee d0 17              BNE CONT_Ret
b7f0 a2 db              LDX #$db
b7f2 a4 3b              LDY OLDTXT+1
b7f4 d0 03              BNE CONT_10
b7f6 4c cf b3           JMP Basic_Error
b7f9 a5 3a    CONT_10   LDA OLDTXT
b7fb 85 77              STA TXTPTR
b7fd 84 78              STY TXTPTR+1
b7ff a5 38              LDA OLDLIN
b801 a4 39              LDY OLDLIN+1
b803 85 36              STA CURLIN
b805 84 37              STY CURLIN+1
b807 60       CONT_Ret  RTS ;Size   26 [Basic_CONT]

              ; *****************
b808            Basic_RUN ; $b808
              ; *****************

b808 d0 03              BNE RUN_20          ; branch onheck_Stack_Avail
b80a 4c e9 b5 RUN_10    JMP Reset_BASIC_Execution
b80d 20 f0 b5 RUN_20    JSR Reset_Variable_Pointer
b810 4c 25 b8           JMP GOSUB_10

              ; *******************
b813            Basic_GOSUB ; $b813
              ; *******************

b813 20 93 b3           JSR Check_Stack_Avail
b816 a5 78              LDA TXTPTR+1
b818 48                 PHA
b819 a5 77              LDA TXTPTR
b81b 48                 PHA
b81c a5 37              LDA CURLIN+1
b81e 48                 PHA
b81f a5 36              LDA CURLIN
b821 48                 PHA
b822 a9 8d              LDA #$8d            ; GOSUB token marker
b824 48                 PHA
b825 20 76 00 GOSUB_10  JSR CHRGOT
b828 20 30 b8           JSR Basic_GOTO
b82b 4c 4a b7           JMP Execute

b82e 00 00              .FILL $b830-* (0) ; 2 bytes

              ; ******************
b830            Basic_GOTO ; $b830
              ; ******************

b830 20 f6 b8           JSR Scan_Linenumber ; read LINNUM
b833 20 94 b8           JSR Skip_To_EOL     ; skip to end of line
b836 a5 37              LDA CURLIN+1
b838 c5 12              CMP LINNUM+1        ; CURLIN >= LINNUM ?
b83a b0 0b              BCS GOTO_10         ; search from start
b83c 98                 TYA                 ; EOL index
b83d 38                 SEC
b83e 65 77              ADC TXTPTR          ; (A/X) = TXTPTR + length + 1 (carry)
b840 a6 78              LDX TXTPTR+1
b842 90 07              BCC GOTO_20
b844 e8                 INX
b845 b0 04              BCS GOTO_20         ; start search from current link
b847 a5 28    GOTO_10   LDA TXTTAB
b849 a6 29              LDX TXTTAB+1
b84b 20 aa b5 GOTO_20   JSR Find_BASIC_Line_AX
b84e 90 1e              BCC RET_10          ; undefined statement
b850 a5 5c              LDA TMPPTC
b852 e9 01              SBC #1
b854 85 77              STA TXTPTR          ; TXTPTR = TMPPTC - 1
b856 a5 5d              LDA TMPPTC+1
b858 e9 00              SBC #0
b85a 85 78              STA TXTPTR+1
b85c 60       GOTO_Ret  RTS ;Size   45 [Basic_GOTO]

              ; ********************
b85d            Basic_RETURN ; $b85d
              ; ********************

b85d d0 fd              BNE GOTO_Ret        ; no raguments allowed
b85f a9 ff              LDA #$ff
b861 85 47              STA FORPNT+1        ; invalidate FORPNT
b863 20 22 b3           JSR Find_Active_FOR ; remove open loops
b866 9a                 TXS
b867 c9 8d              CMP #$8d            ; GOSUB token marker ?
b869 f0 0b              BEQ RET_30           ; yes -> perform return
b86b a2 16              LDX #[Msg_GOSUB - Msg_Start] ; $16
b86d 2c                 .BYTE $2c           ; skip next instruction
b86e a2 5a    RET_10    LDX #[Msg_UNDEF - Msg_Start] ; $5a
b870 4c cf b3           JMP Basic_Error
b873 4c 00 bf RET_20    JMP Syntax_Error
b876 68       RET_30    PLA                 ; marker
b877 68                 PLA
b878 85 36              STA CURLIN
b87a 68                 PLA
b87b 85 37              STA CURLIN+1
b87d 68                 PLA
b87e 85 77              STA TXTPTR
b880 68                 PLA
b881 85 78              STA TXTPTR+1

              ; ******************
b883            Basic_DATA ; $b883
              ; ******************

b883 20 91 b8           JSR Skip_To_EOS

              ; **********************************
b886            Add_Y_To_Execution_Pointer ; $b886
              ; **********************************

b886 98                 TYA
b887 18                 CLC
b888 65 77              ADC TXTPTR
b88a 85 77              STA TXTPTR
b88c 90 02              BCC AYEP_Ret
b88e e6 78              INC TXTPTR+1
b890 60       AYEP_Ret  RTS ;Size   11 [Add_Y_To_Execution_Pointer]

              ; *******************
b891            Skip_To_EOS ; $b891
              ; *******************

b891 a2 3a              LDX #':'            ; scan for ':' or zero
b893 2c                 .BYTE $2c

              ; *******************
b894            Skip_To_EOL ; $b894
              ; *******************

b894 a2 00              LDX #0
b896 86 03              STX CHARAC
b898 a0 00              LDY #0
b89a 84 04              STY ENDCHR
b89c a5 04    NeSt_10   LDA ENDCHR
b89e a6 03              LDX CHARAC
b8a0 85 03              STA CHARAC
b8a2 86 04              STX ENDCHR
b8a4 b1 77    NeSt_20   LDA (TXTPTR),Y
b8a6 f0 e8              BEQ AYEP_Ret
b8a8 c5 04              CMP ENDCHR
b8aa f0 e4              BEQ AYEP_Ret
b8ac c8                 INY
b8ad c9 22              CMP #QUOTE
b8af d0 f3              BNE NeSt_20
b8b1 f0 e9              BEQ NeSt_10

              ; ****************
b8b3            Basic_IF ; $b8b3
              ; ****************

b8b3 20 98 bd           JSR Eval_Expression
b8b6 20 76 00           JSR CHRGOT
b8b9 c9 89              CMP #$89            ; GOTO token
b8bb f0 05              BEQ IF_10
b8bd a9 a7              LDA #$a7            ; THEN token
b8bf 20 f7 be           JSR Need_A
b8c2 a5 5e    IF_10     LDA FAC1EX          ; IF clause != 0 (true) or 0 (false)
b8c4 d0 05              BNE REM_10          ; branch if true

              ; *****************
b8c6            Basic_REM ; $b8c6
              ; *****************

b8c6 20 94 b8           JSR Skip_To_EOL
b8c9 f0 bb              BEQ Add_Y_To_Execution_Pointer
b8cb 20 76 00 REM_10    JSR CHRGOT
b8ce b0 03              BCS REM_20
b8d0 4c 30 b8           JMP Basic_GOTO
b8d3 4c 85 b7 REM_20    JMP Interpret

              ; ********
b8d6            Basic_ON
              ; ********

b8d6 20 d4 c8           JSR Get_Byte_Value
b8d9 48                 PHA
b8da c9 8d              CMP #$8d            ; GOSUB token
b8dc f0 04              BEQ ON_20
b8de c9 89    ON_10     CMP #$89            ; GOTO token
b8e0 d0 91              BNE RET_20          ; -> syntax error
b8e2 c6 62    ON_20     DEC FAC1M4          ; ON - counter
b8e4 d0 04              BNE ON_30
b8e6 68                 PLA
b8e7 4c 87 b7           JMP Inpr_10
b8ea 20 70 00 ON_30     JSR CHRGET
b8ed 20 f6 b8           JSR Scan_Linenumber
b8f0 c9 2c              CMP #','
b8f2 f0 ee              BEQ ON_20
b8f4 68                 PLA
b8f5 60                 RTS ;Size   32 [Basic_ON]

              ; ***************
b8f6            Scan_Linenumber
              ; ***************

              ; Input:  A = 1st. character
              ; Output: LINNUM decoded (0-63999) valid range
              ;         LINNUM = 0 if (A) is not numeric (C=1)

b8f6 a2 00              LDX #0
b8f8 86 11              STX LINNUM
b8fa 86 12              STX LINNUM+1
b8fc b0 0e              BCS ScLi_Ret        ; return if (A) is not numeric
b8fe a6 12    ScLi_10   LDX LINNUM+1
b900 e0 19              CPX #25             ; $fa00 after multiplication
b902 b0 da              BCS ON_10           ; value >= 64000 -> Syntax Error
b904 20 0d b9           JSR Dec_Char
b907 20 70 00           JSR CHRGET
b90a 90 f2              BCC ScLi_10         ; next char if numeric
b90c 60       ScLi_Ret  RTS ;Size   23 [Scan_Linenumber]

              ; ********
b90d            Dec_Char
              ; ********

              ; Input:  LINNUM = 16 bit unsigned integer
              ;         A      = new value to add
              ;         X      = LINNUM+1
              ; Output: LINNUM = LINNUM * 10 + (A)

              ; check on integer overflow is done on calling routine

b90d 29 0f              AND #15             ; char -> bin
b90f 48                 PHA                 ; save value to add
b910 a5 11              LDA LINNUM
b912 0a                 ASL A               ; * 2
b913 26 12              ROL LINNUM+1
b915 0a                 ASL A               ; * 4
b916 26 12              ROL LINNUM+1
b918 65 11              ADC LINNUM          ; * 5
b91a 85 11              STA LINNUM
b91c 8a                 TXA                 ; old high byte of LINNUM
b91d 65 12              ADC LINNUM+1
b91f 85 12              STA LINNUM+1
b921 06 11              ASL LINNUM          ; * 10
b923 26 12              ROL LINNUM+1
b925 68                 PLA                 ; value to add
b926 65 11              ADC LINNUM
b928 85 11              STA LINNUM
b92a 90 02              BCC LIM_10
b92c e6 12              INC LINNUM+1
b92e 60       LIM_10    RTS ;Size   34 [Dec_Char]

b92f 00                 .FILL $b930-* (0) ; 1 bytes

              ; *****************
b930            Basic_LET ; $b930
              ; *****************

b930 20 2b c1           JSR Parse_Name
b933 85 46              STA FORPNT
b935 84 47              STY FORPNT+1
b937 a9 b2              LDA #$b2            ; '=' token
b939 20 f7 be           JSR Need_A
b93c a5 08              LDA INTFLG          ; save attributes
b93e 48                 PHA                 ; of variable
b93f a5 07              LDA VALTYP
b941 48                 PHA
b942 20 98 bd           JSR Eval_Expression ; FAC1 = value or pointer
b945 68                 PLA                 ; VALTYP
b946 2a                 ROL A               ; C=1 : string   C=0 : numeric
b947 20 8a bd           JSR Check_Var_Type
b94a d0 18              BNE LET_20          ; branch for string
b94c 68                 PLA                 ; INTFLG

              ; ***********************
b94d            Assign_Numeric_variable
              ; ***********************

b94d 10 12              BPL LET_10          ; branch for real
b94f 20 51 cd           JSR Round_FAC1
b952 20 ea c2           JSR Real_To_Integer
b955 a0 00              LDY #0
b957 a5 61              LDA FAC1M3
b959 91 46              STA (FORPNT),Y      ; integer high byte
b95b c8                 INY
b95c a5 62              LDA FAC1M4
b95e 91 46              STA (FORPNT),Y      ; integer low  byte
b960 60                 RTS ;Size   20 [Assign_Numeric_variable]
b961 4c 06 cd LET_10    JMP FAC1_To_FORPNT

b964 68       LET_20    PLA                 ; INTFLG

              ; ******************************
b965            Assign_String_Variable ; $b965
              ; ******************************

b965 a4 47              LDY FORPNT+1
b967 c0 d0              CPY #>[Float_0_5 + 2]; void string descriptor for TI$
b969 d0 4f              BNE Assign_Normal_String
b96b 20 b8 c7           JSR Free_String_FAC1
b96e c9 06              CMP #6              ; setting TI$ requires 6 digits
b970 d0 40              BNE ATSD_10
b972 a0 00              LDY #0              ; FAC1 = 0.0
b974 84 5e              STY FAC1EX
b976 84 63              STY FAC1SI
b978 84 6e    CLOCK_10  STY TMPPTD
b97a 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b97d 20 18 cc           JSR Multiply_FAC1_BY_10
b980 e6 6e              INC TMPPTD
b982 a4 6e              LDY TMPPTD
b984 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b987 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
b98a aa                 TAX                 ; number is zero ?
b98b f0 05              BEQ CLOCK_20
b98d e8                 INX
b98e 8a                 TXA                 ; FAC2 *= 2
b98f 20 23 cc           JSR Add_And_Double  ; FAC1 = (FAC1 + FAC2) * 2
b992 a4 6e    CLOCK_20  LDY TMPPTD
b994 c8                 INY
b995 c0 06              CPY #6
b997 d0 df              BNE CLOCK_10
b999 20 18 cc           JSR Multiply_FAC1_BY_10
b99c 20 d1 cd           JSR FAC1_LSR
b99f a2 02              LDX #2
b9a1 78                 SEI                 ; set jiffy clock
b9a2 b5 60    CLOCK_30  LDA FAC1M2,X
b9a4 95 8d              STA JIFFY_CLOCK,X
b9a6 ca                 DEX
b9a7 10 f9              BPL CLOCK_30
b9a9 58                 CLI
b9aa 60                 RTS ;Size   70 [Assign_String_Variable]

              ; ***************************
b9ab            Add_TI_String_Digit_To_FAC1
              ; ***************************

b9ab b1 1f              LDA (INDEXA),Y
b9ad 20 7d 00           JSR ISNUM
b9b0 90 03              BCC ATSD_20
b9b2 4c 73 c3 ATSD_10   JMP Jump_To_Illegal_Quantity
b9b5 e9 2f    ATSD_20   SBC #$2f            ; '0'-1
b9b7 4c b4 ce           JMP Add_A_To_FAC1

              ; ****************************
b9ba            Assign_Normal_String ; $b9ba
              ; ****************************

              ; 100 a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to static string in code
              ;     STRPTR = $0409
              ;     -> ANS_60 branch

              ; a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to dynamic string
              ;     STRPTR = $7ffa
              ;     -> ANS_60 branch

              ; a$ = ds$ (disk status)
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 12, pointer to dynamic string
              ;     STRPTR = $7fd6
              ;     -> ANS_50 branch

b9ba a0 01              LDY #1
b9bc b1 61              LDA (FAC1M3),Y
b9be 85 6c              STA STRPTR          ; STRPTR = string pointer
b9c0 c8                 INY
b9c1 b1 61              LDA (FAC1M3),Y
b9c3 85 6d              STA STRPTR+1        ; STRPTR = DS$ (Disk Status) ?
b9c5 c9 04              CMP #4
b9c7 90 23              BCC ANS_50          ; string is in system area (DS$)

b9c9 a5 6d    ANS_10    LDA STRPTR+1        ; STRPTR < FRETOP ?
b9cb c5 31    ANS_20    CMP FRETOP+1
b9cd 90 16              BCC ANS_40          ; branch if static
b9cf d0 06              BNE ANS_30          ; branch if higher
b9d1 a5 6c              LDA STRPTR
b9d3 c5 30              CMP FRETOP
b9d5 90 0e              BCC ANS_40          ; branch if static
b9d7 a4 62    ANS_30    LDY FAC1M4
b9d9 c4 2b              CPY VARTAB+1
b9db 90 08              BCC ANS_40          ; branch if not variable
b9dd d0 0d              BNE ANS_50
b9df a5 61              LDA FAC1M3
b9e1 c5 2a              CMP VARTAB
b9e3 b0 07              BCS ANS_50
b9e5 a5 61    ANS_40    LDA FAC1M3          ; static string
b9e7 a4 62              LDY FAC1M4
b9e9 4c 05 ba           JMP ANS_60

              ; assign string from string variable

b9ec a0 00    ANS_50    LDY #0              ; allocate & copy string
b9ee b1 61              LDA (FAC1M3),Y      ; length
b9f0 20 a6 c5           JSR Allocate_String_A
b9f3 a6 6c              LDX STRPTR
b9f5 a4 6d              LDY STRPTR+1
b9f7 20 9a c7           JSR Store_String_XY
b9fa a5 61              LDA FAC1M3
b9fc a4 62              LDY FAC1M4
b9fe 20 11 c8           JSR Pop_Descriptor_Stack
ba01 a9 5e              LDA #<FAC1EX        ; allocated descriptor
ba03 a0 00              LDY #>FAC1EX

              ; assign static string and create back reference

ba05 85 4d    ANS_60    STA DESCPT
ba07 84 4e              STY DESCPT+1
ba09 85 1f              STA INDEXA
ba0b 84 20              STY INDEXA+1
ba0d 20 11 c8           JSR Pop_Descriptor_Stack
ba10 20 3d ba           JSR Back_Reference_Position   ; from INDEXA
ba13 90 09              BCC ANS_70          ; -> no back reference
ba15 a5 47              LDA FORPNT+1
ba17 91 4f              STA (INDEXC),Y      ; Y = 1
ba19 88                 DEY
ba1a a5 46              LDA FORPNT          ; store back reference
ba1c 91 4f              STA (INDEXC),Y      ; for garbage collection

              ; invalidate old string

ba1e a5 46    ANS_70    LDA FORPNT
ba20 85 1f              STA INDEXA
ba22 a5 47              LDA FORPNT+1
ba24 85 20              STA INDEXA+1
ba26 20 3d ba           JSR Back_Reference_Position
ba29 90 08              BCC ANS_80
ba2b a9 ff              LDA #$ff            ; mark old string as obsolete
ba2d 91 4f              STA (INDEXC),Y      ; Y = 1
ba2f 88                 DEY                 ; Y = 0
ba30 8a                 TXA                 ; length
ba31 91 4f              STA (INDEXC),Y

              ; copy new value to variable

ba33 a0 02    ANS_80    LDY #2
ba35 b1 4d    ANS_90    LDA (DESCPT),Y
ba37 91 46              STA (FORPNT),Y
ba39 88                 DEY
ba3a 10 f9              BPL ANS_90
ba3c 60                 RTS ;Size  131 [Assign_Normal_String]

              ; ***********************
ba3d            Back_Reference_Position
              ; ***********************

              ; Input:  INDEXA = pointer to string descriptor
              ; Output: INDEXA = points to start of string
              ;         INDEXC = points to the end of string + 1
              ;         X = length of string
              ;         Y = 1
              ;         C = 1 : INDEXA and INDEXC set
              ;         C = 0 : nothing changed

ba3d a0 00              LDY #0
ba3f b1 1f              LDA (INDEXA),Y      ; A = length
ba41 48                 PHA                 ; push length
ba42 f0 28              BEQ BRP_no
ba44 c8                 INY
ba45 b1 1f              LDA (INDEXA),Y
ba47 aa                 TAX                 ; X = pointer low
ba48 c8                 INY
ba49 b1 1f              LDA (INDEXA),Y      ; A = pointer high
ba4b 30 1f              BMI BRP_no          ; return if not in lower RAM
ba4d c5 31              CMP FRETOP+1
ba4f 90 1b              BCC BRP_no          ; return if not dynamic string
ba51 d0 04              BNE BRP_10
ba53 e4 30              CPX FRETOP
ba55 90 15              BCC BRP_no          ; return if not dynamic string
ba57 86 1f    BRP_10    STX INDEXA          ; INDEXA = string pointer
ba59 85 20              STA INDEXA+1
ba5b 68                 PLA                 ; length
ba5c aa                 TAX                 ; return length in X
ba5d 18                 CLC
ba5e 65 1f              ADC INDEXA
ba60 85 4f              STA INDEXC
ba62 a5 20              LDA INDEXA+1
ba64 69 00              ADC #0
ba66 85 50              STA INDEXC+1        ; INDEXC = INDEXA + length
ba68 a0 01              LDY #1              ; expected by callers
ba6a 38                 SEC
ba6b 60                 RTS ;Size   47 [Back_Reference_Position]
ba6c 68       BRP_no    PLA
ba6d 18                 CLC
ba6e 60                 RTS ;Size   50 [Back_Reference_Position]

              ; This subroutines converts a real value to a 16 bit integer.
              ; There is no sign or range check in this routine. So it may
              ; be used for signed integers (-32768 to 32767) or unsigned
              ; integers (0 to 65535).

              ; ********
ba6f            FAC1_INT
              ; ********

ba6f 20 d1 cd           JSR FAC1_LSR
ba72 24 63              BIT FAC1SI
ba74 10 0b              BPL FACI_Ret
ba76 38                 SEC
ba77 98                 TYA
ba78 e5 62              SBC FAC1M4
ba7a 85 62              STA FAC1M4
ba7c 98                 TYA
ba7d e5 61              SBC FAC1M3
ba7f 85 61              STA FAC1M3
ba81 60       FACI_Ret  RTS ;Size   19 [FAC1_INT]

ba82 00 00 00           .FILL $ba88-* (0) ; 6 bytes

              ; ********************
ba88            Basic_PRINTN ; $ba88
              ; ********************

ba88 20 8e ba           JSR Basic_CMD
ba8b 4c b2 bb           JMP Set_Default_Channels

              ; *********
ba8e            Basic_CMD
              ; *********

ba8e 20 d4 c8           JSR Get_Byte_Value  ; X = value
ba91 f0 05              BEQ CMD_10          ; -> no more parameter
ba93 a9 2c              LDA #','
ba95 20 f7 be           JSR Need_A
ba98 08       CMD_10    PHP
ba99 20 c9 ff           JSR CHKOUT          ; set channel
ba9c 86 10              STX IOPMPT          ; mark output redirected
ba9e 28                 PLP
ba9f 4c a8 ba           JMP Basic_PRINT     ; do the printing


baa2 20 20 bb PRINT_10  JSR Print_String_From_Descriptor
baa5 20 76 00 PRINT_20  JSR CHRGOT

              ; ***********
baa8            Basic_PRINT
              ; ***********

baa8 f0 35              BEQ Print_CR
baaa f0 38    PRINT_30  BEQ PRINT_Ret
baac c9 a3              CMP #$a3            ; TAB(   token
baae f0 4d              BEQ Tab_Spc
bab0 c9 a6              CMP #$a6            ; SPC(   token
bab2 18                 CLC
bab3 f0 48              BEQ Tab_Spc
bab5 c9 2c              CMP #','
bab7 f0 37              BEQ Comma_Tab
bab9 c9 3b              CMP #';'
babb f0 5a              BEQ TaSp_50
babd 20 98 bd           JSR Eval_Expression
bac0 24 07              BIT VALTYP
bac2 30 de              BMI PRINT_10
bac4 20 93 cf           JSR Format_FAC1
bac7 20 b0 c5           JSR Create_String_Descriptor
baca 20 20 bb           JSR Print_String_From_Descriptor
bacd 20 3a bb           JSR Cursor_Right_Or_Space
bad0 d0 d3              BNE PRINT_20           ; always

              ; *************
bad2            Terminate_BUF
              ; *************

bad2 a9 00              LDA #0
bad4 9d 00 02           STA BUF,X
bad7 a2 ff              LDX #<[BUF-1]
bad9 a0 01              LDY #>[BUF-1]
badb a5 10              LDA IOPMPT
badd d0 05              BNE PRINT_Ret

              ; ****************
badf            Print_CR ; $badf
              ; ****************

badf a9 0d              LDA #CR
bae1 4c d2 ff           JMP CHROUT
bae4 60       PRINT_Ret RTS ;Size    6 [Print_CR]

bae5 00 00 00           .FILL $baf0-* (0) ; 11 bytes

              ; *****************
baf0            Comma_Tab ; $baf0
              ; *****************

baf0 a5 c6              LDA CursorCol
baf2 38                 SEC
baf3 e9 0a    CoTa_10   SBC #10
baf5 b0 fc              BCS CoTa_10
baf7 49 ff              EOR #$ff
baf9 69 01              ADC #1
bafb d0 10              BNE TaSp_10           ; always

              ; *******
bafd            Tab_Spc
              ; *******

bafd 08                 PHP                 ; C=1 TAB, C=0 SPC
bafe 20 d1 c8           JSR Get_Next_Byte_Value
bb01 c9 29              CMP #')'
bb03 d0 59              BNE SynErr
bb05 28                 PLP
bb06 90 06              BCC TaSp_20         ; SPC -> use X
bb08 8a                 TXA
bb09 e5 c6              SBC CursorCol       ; TAB -> use X - Col
bb0b 90 0a              BCC TaSp_50         ; branch if TAB < Col
bb0d aa       TaSp_10   TAX
bb0e e8       TaSp_20   INX
bb0f d0 03              BNE TaSp_40         ; always
bb11 20 3a bb TaSp_30   JSR Cursor_Right_Or_Space
bb14 ca       TaSp_40   DEX
bb15 d0 fa              BNE TaSp_30
bb17 20 70 00 TaSp_50   JSR CHRGET
bb1a 4c aa ba           JMP PRINT_30

              ; ********************
bb1d            Print_String ; $bb1d
              ; ********************

bb1d 20 b0 c5           JSR Create_String_Descriptor

              ; ************************************
bb20            Print_String_From_Descriptor ; $bb20
              ; ************************************

bb20 20 b8 c7           JSR Free_String_FAC1
bb23 aa                 TAX
bb24 f0 0b              BEQ PSFD_Ret        ; zero length ?
bb26 a0 00              LDY #0
bb28 b1 1f    PSFD_10   LDA (INDEXA),Y
bb2a 20 d2 ff           JSR CHROUT
bb2d c8                 INY
bb2e ca                 DEX
bb2f d0 f7              BNE PSFD_10
bb31 60       PSFD_Ret  RTS ;Size   18 [Print_String_From_Descriptor]

bb32 00 00 00           .FILL $bb3a-* (0) ; 8 bytes

              ; *****************************
bb3a            Cursor_Right_Or_Space ; $bb3a
              ; *****************************

bb3a a5 10              LDA IOPMPT
bb3c f0 03              BEQ CROS_10
bb3e a9 20              LDA #' '
bb40 2c                 .BYTE $2c
bb41 a9 1d    CROS_10   LDA #RIGHT
bb43 2c                 .BYTE $2c

              ; *******************
bb44            Print_Question_Mark
              ; *******************

bb44 a9 3f              LDA #'?'

              ; **********
bb46            Print_Char
              ; **********

bb46 4c d2 ff           JMP CHROUT

bb49 00 00 00           .FILL $bb4c-* (0) ; 3 bytes

              ; *****************
bb4c            Bad_Input ; $bb4c
              ; *****************

bb4c a5 0b              LDA INPFLG
bb4e f0 11              BEQ BaIn_30
bb50 30 04              BMI BaIn_10
bb52 a0 ff              LDY #$ff            ; invalidate CURLIN
bb54 d0 04              BNE BaIn_20
bb56 a5 3c    BaIn_10   LDA DATLIN
bb58 a4 3d              LDY DATLIN+1
bb5a 85 36    BaIn_20   STA CURLIN
bb5c 84 37              STY CURLIN+1
bb5e 4c 00 bf SynErr    JMP Syntax_Error
bb61 a5 10    BaIn_30   LDA IOPMPT
bb63 f0 05              BEQ BaIn_40
bb65 a2 bf              LDX #[Msg_DATA - Msg_Start] ; $bf
bb67 4c cf b3           JMP Basic_Error
bb6a a9 07    BaIn_40   LDA #<Msg_Redo_From_Start
bb6c a0 bd              LDY #>Msg_Redo_From_Start
bb6e 20 1d bb           JSR Print_String
bb71 a5 3a              LDA OLDTXT
bb73 a4 3b              LDY OLDTXT+1
bb75 85 77              STA TXTPTR
bb77 84 78              STY TXTPTR+1
bb79 60                 RTS ;Size   46 [Bad_Input]

              ; *****************
bb7a            Basic_GET ; $bb7a
              ; *****************

bb7a 20 cf c4           JSR Assert_Non_Direct
bb7d c9 23              CMP #'#'
bb7f d0 0e              BNE GET_10
bb81 20 70 00           JSR CHRGET
bb84 20 d4 c8           JSR Get_Byte_Value  ; channel #
bb87 20 f5 be           JSR Need_Comma
bb8a 20 c6 ff           JSR CHKIN
bb8d 86 10              STX IOPMPT
bb8f a2 01    GET_10    LDX #<[BUF+1]
bb91 a0 02              LDY #>[BUF+1]
bb93 a9 00              LDA #0
bb95 8d 01 02           STA BUF+1
bb98 a9 40              LDA #$40            ; no prompt
bb9a 20 0b bc           JSR Read_Get
bb9d a6 10              LDX IOPMPT
bb9f d0 13              BNE SDC_10
bba1 60                 RTS ;Size   40 [Basic_GET]

bba2 00 00              .FILL $bba4-* (0) ; 2 bytes

              ; ********************
bba4            Basic_INPUTN ; $bba4
              ; ********************

bba4 20 d4 c8           JSR Get_Byte_Value
bba7 20 f5 be           JSR Need_Comma
bbaa 20 c6 ff           JSR CHKIN
bbad 86 10              STX IOPMPT
bbaf 20 cd bb           JSR Input_String

              ; ********************
bbb2            Set_Default_Channels
              ; ********************

bbb2 a5 10              LDA IOPMPT
bbb4 20 cc ff SDC_10    JSR CLRCHN
bbb7 a2 00              LDX #0
bbb9 86 10              STX IOPMPT
bbbb 60                 RTS ;Size   10 [Set_Default_Channels]

bbbc 00 00              .FILL $bbbe-* (0) ; 2 bytes

              ; *******************
bbbe            Basic_INPUT ; $bbbe
              ; *******************

bbbe c9 22              CMP #QUOTE
bbc0 d0 0b              BNE Input_String
bbc2 20 b5 be           JSR Make_String_Descriptor_From_Code
bbc5 a9 3b              LDA #';'
bbc7 20 f7 be           JSR Need_A          ; prompt delimiter
bbca 20 20 bb           JSR Print_String_From_Descriptor

              ; ************
bbcd            Input_String
              ; ************

bbcd 20 cf c4           JSR Assert_Non_Direct
bbd0 a9 2c              LDA #','
bbd2 8d ff 01           STA BUF-1
bbd5 20 f5 bb InSt_10   JSR Prompt_And_Input
bbd8 a5 10              LDA IOPMPT
bbda f0 0c              BEQ InSt_20
bbdc a5 96              LDA STATUS
bbde 29 03              AND #3              ; check time out bits
bbe0 f0 06              BEQ InSt_20
bbe2 20 b2 bb           JSR Set_Default_Channels
bbe5 4c 83 b8           JMP Basic_DATA
bbe8 ad 00 02 InSt_20   LDA BUF
bbeb d0 1c              BNE READ_10
bbed 4c 19 bf           JMP Input_String_Patch
bbf0 18       InSt_30   CLC
bbf1 4c d8 b7           JMP END_20

bbf4 00                 .FILL $bbf5-* (0) ; 1 bytes

              ; ************************
bbf5            Prompt_And_Input ; $bbf5
              ; ************************

bbf5 a5 10              LDA IOPMPT
bbf7 d0 06              BNE PAI_10
bbf9 20 44 bb           JSR Print_Question_Mark
bbfc 20 3a bb           JSR Cursor_Right_Or_Space
bbff 4c e2 b4 PAI_10    JMP Read_String

              ; ******************
bc02            Basic_READ ; $bc02
              ; ******************

bc02 a6 3e              LDX DATPTR
bc04 a4 3f              LDY DATPTR+1
bc06 a9 98              LDA #$98            ; flag for READ
bc08 2c                 .BYTE $2c
bc09 a9 00    READ_10    LDA #0

              ; ********
bc0b            Read_Get
              ; ********

bc0b 85 0b              STA INPFLG
bc0d 86 40              STX INPPTR
bc0f 84 41              STY INPPTR+1

              ; loop reading variables

bc11 20 2b c1 READ_15   JSR Parse_Name      ; address of variable
bc14 85 46              STA FORPNT
bc16 84 47              STY FORPNT+1        ; FORPNT = variable pointer
bc18 a5 77              LDA TXTPTR
bc1a a4 78              LDY TXTPTR+1        ; save TXTPTR
bc1c 85 48              STA YSAVE
bc1e 84 49              STY YSAVE+1
bc20 a6 40              LDX INPPTR          ; TXTPTR = INPPTR
bc22 a4 41              LDY INPPTR+1
bc24 86 77              STX TXTPTR
bc26 84 78              STY TXTPTR+1
bc28 20 76 00           JSR CHRGOT
bc2b d0 20              BNE READ_35
bc2d 24 0b              BIT INPFLG
bc2f 50 0c              BVC READ_20         ; bit 6 set: GETIN
bc31 20 e4 ff           JSR GETIN
bc34 8d 00 02           STA BUF
bc37 a2 ff              LDX #<[BUF-1]
bc39 a0 01              LDY #>[BUF-1]
bc3b d0 0c              BNE READ_30         ; always

bc3d 30 75    READ_20   BMI READ_75         ; bit 7 set: READ
bc3f a5 10              LDA IOPMPT          ; else: INPUT
bc41 d0 03              BNE READ_25
bc43 20 44 bb           JSR Print_Question_Mark
bc46 20 f5 bb READ_25   JSR Prompt_And_Input
bc49 86 77    READ_30   STX TXTPTR
bc4b 84 78              STY TXTPTR+1

              ; loop reading character

bc4d 20 70 00 READ_35   JSR CHRGET
bc50 24 07              BIT VALTYP
bc52 10 31              BPL READ_60         ; -> numeric
bc54 24 0b              BIT INPFLG
bc56 50 09              BVC READ_40         ; -> not GET
bc58 e8                 INX
bc59 86 77              STX TXTPTR          ; GET A$
bc5b a9 00              LDA #0
bc5d 85 03              STA CHARAC
bc5f f0 0c              BEQ READ_45         ; always

              ; input or read string

bc61 85 03    READ_40   STA CHARAC
bc63 c9 22              CMP #QUOTE
bc65 f0 07              BEQ READ_50
bc67 a9 3a              LDA #':'
bc69 85 03              STA CHARAC
bc6b a9 2c              LDA #','
bc6d 18       READ_45   CLC
bc6e 85 04    READ_50   STA ENDCHR
bc70 a5 77              LDA TXTPTR
bc72 a4 78              LDY TXTPTR+1
bc74 69 00              ADC #0
bc76 90 01              BCC READ_55
bc78 c8                 INY
bc79 20 b6 c5 READ_55   JSR Create_String_Descriptor_AY
bc7c 20 18 c9           JSR Restore_Execution_Pointer
bc7f 20 65 b9           JSR Assign_String_Variable
bc82 4c 8d bc           JMP READ_65

              ; input or read number

bc85 20 29 ce READ_60   JSR Read_Real_To_FAC1
bc88 a5 08              LDA INTFLG
bc8a 20 4d b9           JSR Assign_Numeric_variable

              ; more to read ?

bc8d 20 76 00 READ_65   JSR CHRGOT
bc90 f0 07              BEQ READ_70         ; -> nothing left
bc92 c9 2c              CMP #','
bc94 f0 03              BEQ READ_70         ; comma or error
bc96 4c 4c bb           JMP Bad_Input

bc99 a5 77    READ_70   LDA TXTPTR
bc9b a4 78              LDY TXTPTR+1
bc9d 85 40              STA INPPTR          ; advance input pointer
bc9f 84 41              STY INPPTR+1
bca1 a5 48              LDA YSAVE
bca3 a4 49              LDY YSAVE+1
bca5 85 77              STA TXTPTR          ; restore text pointer
bca7 84 78              STY TXTPTR+1
bca9 20 76 00           JSR CHRGOT
bcac f0 2c              BEQ READ_85         ; -> goto loop end
bcae 20 f5 be           JSR Need_Comma
bcb1 4c 11 bc           JMP READ_15         ; -> next item

              ; READ from DATA statements

bcb4 20 91 b8 READ_75   JSR Skip_To_EOS
bcb7 c8                 INY
bcb8 aa                 TAX
bcb9 d0 12              BNE READ_80
bcbb a2 2a              LDX #$2a
bcbd c8                 INY
bcbe b1 77              LDA (TXTPTR),Y
bcc0 f0 6b              BEQ NEXT_30
bcc2 c8                 INY
bcc3 b1 77              LDA (TXTPTR),Y
bcc5 85 3c              STA DATLIN
bcc7 c8                 INY
bcc8 b1 77              LDA (TXTPTR),Y
bcca c8                 INY
bccb 85 3d              STA DATLIN+1
bccd b1 77    READ_80   LDA (TXTPTR),Y
bccf aa                 TAX
bcd0 20 86 b8           JSR Add_Y_To_Execution_Pointer
bcd3 e0 83              CPX #$83            ; DATA token
bcd5 d0 dd              BNE READ_75
bcd7 4c 4d bc           JMP READ_35
              ;

bcda a5 40    READ_85   LDA INPPTR
bcdc a4 41              LDY INPPTR+1
bcde a6 0b              LDX INPFLG
bce0 10 03              BPL READ_90
bce2 4c c1 b7           JMP REST_10
bce5 a0 00    READ_90   LDY #0
bce7 b1 40              LDA (INPPTR),Y
bce9 f0 0b              BEQ READ_Ret
bceb a5 10              LDA IOPMPT
bced d0 07              BNE READ_Ret
bcef a9 f7              LDA #<Msg_Extra_Ignored
bcf1 a0 bc              LDY #>Msg_Extra_Ignored
bcf3 4c 1d bb           JMP Print_String
bcf6 60       READ_Ret  RTS ;Size  236 [Read_Get]

bcf7                    .FILL $bcf7-* (0) ; 0 bytes

              ; *************************
bcf7            Msg_Extra_Ignored ; $bcf7
              ; *************************

bcf7 3f 45 58           .BYTE "?EXTRA IGNORED\r",0

              ; *******************
bd07            Msg_Redo_From_Start
              ; *******************

bd07 3f 52 45           .BYTE "?REDO FROM START\r",0

              ; ******************
bd19            Basic_NEXT ; $bd19
              ; ******************

bd19 d0 04              BNE NEXT_10         ; branch if index after NEXT
bd1b a0 00              LDY #0
bd1d f0 05              BEQ NEXT_20
bd1f 20 2b c1 NEXT_10   JSR Parse_Name      ; address of index
bd22 85 46              STA FORPNT
bd24 84 47    NEXT_20   STY FORPNT+1        ; address or zero if no index
bd26 20 22 b3           JSR Find_Active_FOR
bd29 f0 04              BEQ NEXT_40         ; branch if found
bd2b a2 00              LDX #0              ; index for next without for error
bd2d f0 66    NEXT_30   BEQ CVT_40           ; -> basic error
bd2f 9a       NEXT_40   TXS                 ; set stack pointer
bd30 8a                 TXA                 ; A = SP
bd31 18                 CLC
bd32 69 04              ADC #4              ; A = SP + 4 (STEP value)
bd34 48                 PHA
bd35 69 06              ADC #6
bd37 85 21              STA INDEXB          ; address TO   value low
bd39 68                 PLA                 ; address STEP value low
bd3a a0 01              LDY #>[STACK]       ; address STEP value high
bd3c 20 d8 cc           JSR Load_FAC1_AY
bd3f ba                 TSX                 ; X = SP    <-- DELETE obsolete
bd40 bd 09 01           LDA STACK+9,X       ; sign of STEP
bd43 85 63              STA FAC1SI
bd45 a5 46              LDA FORPNT
bd47 a4 47              LDY FORPNT+1           ; address of index
bd49 20 9d c9           JSR Add_Var_AY_To_FAC1 ; FAC1 = index + STEP
bd4c 20 06 cd           JSR FAC1_To_FORPNT
bd4f a0 01              LDY #>[STACK]          ; address TO value high
bd51 20 93 cd           JSR Compare_FAC1_INDEXB_Y
bd54 ba                 TSX
bd55 38                 SEC
bd56 fd 09 01           SBC STACK+9,X          ; STEP sign
bd59 f0 17              BEQ NEXT_60            ; loop finished
bd5b bd 0f 01           LDA STACK+15,X
bd5e 85 36              STA CURLIN
bd60 bd 10 01           LDA STACK+16,X
bd63 85 37              STA CURLIN+1           ; line # of loop body
bd65 bd 12 01           LDA STACK+18,X
bd68 85 77              STA TXTPTR
bd6a bd 11 01           LDA STACK+17,X
bd6d 85 78              STA TXTPTR+1           ; address of loop body
bd6f 4c 4a b7 NEXT_50   JMP Execute            ; next iteration
bd72 8a       NEXT_60   TXA
bd73 69 11              ADC #$11               ; carry was set
bd75 aa                 TAX
bd76 9a                 TXS                    ; remove loop structure from stack
bd77 20 76 00           JSR CHRGOT             ; character after NEXT
bd7a c9 2c              CMP #','               ; comma ?
bd7c d0 f1              BNE NEXT_50            ; continue with follow up statement
bd7e 20 70 00           JSR CHRGET             ; get another index
bd81 20 1f bd           JSR NEXT_10            ; perform NEXT again

              ; ********************
bd84            Eval_Numeric ; $bd84
              ; ********************

bd84 20 98 bd           JSR Eval_Expression

              ; ******************
bd87            Is_Numeric ; $bd87
              ; ******************

bd87 18                 CLC
bd88 24                 .BYTE $24

              ; *****************
bd89            Is_String ; $bd89
              ; *****************

bd89 38                 SEC

              ; **********************
bd8a            Check_Var_Type ; $bd8a
              ; **********************

bd8a 24 07              BIT VALTYP          ; $FF = string   $00 = numeric
bd8c 30 03              BMI CVT_20          ; branch on string type
bd8e b0 03              BCS CVT_30          ; string assert -> TYPE MISMATCH
bd90 60       CVT_10    RTS ;Size    7 [Check_Var_Type]
bd91 b0 fd    CVT_20    BCS CVT_10          ; looking for string, found string
bd93 a2 a3    CVT_30    LDX #[Msg_TYPE - Msg_Start] ; $a3
bd95 4c cf b3 CVT_40    JMP Basic_Error     ; want string got numeric or vice versa

              ; called from $b947 Basic_LET
              ;             $c06b Op_COMPARE

              ; ***********************
bd98            Eval_Expression ; $bd98
              ; ***********************

bd98 a6 77              LDX TXTPTR          ; TXTPTR--
bd9a d0 02              BNE EvEx_05
bd9c c6 78              DEC TXTPTR+1
bd9e c6 77    EvEx_05   DEC TXTPTR
bda0 a2 00              LDX #0
bda2 24                 .BYTE $24           ; skip next PHA
bda3 48       EvEx_10   PHA                 ; push ACCSYM (comparison op + type)
bda4 8a                 TXA
bda5 48                 PHA                 ; push X
bda6 20 93 b3           JSR Check_Stack_Avail
bda9 20 7e be           JSR Evaluate
bdac a9 00              LDA #0
bdae 85 4a              STA ACCSYM          ;clear type comparison flag
bdb0 20 76 00 EvEx_15   JSR CHRGOT
bdb3 38       EvEx_20   SEC
bdb4 e9 b1              SBC #$b1            ; > token ( start of comparison ops)
bdb6 90 16              BCC EvEx_25         ; -> binary operators
bdb8 c9 03              CMP #3              ; ( 3 comparison operators > = < )
bdba b0 12              BCS EvEx_25         ; -> function
bdbc c9 02              CMP #2              ; '>'  A = 1
bdbe 69 01              ADC #1              ; '='  A = 2
bdc0 45 4a              EOR ACCSYM          ; '<'  A = 4
bdc2 c5 4a              CMP ACCSYM
bdc4 90 61              BCC SynErr1           ; -> syntax error
bdc6 85 4a              STA ACCSYM          ; rememer comparison operator
bdc8 20 70 00           JSR CHRGET
bdcb 4c b3 bd           JMP EvEx_20         ; loop (maybe <= or >= or <>)

bdce a6 4a    EvEx_25   LDX ACCSYM
bdd0 d0 2c              BNE EvEx_50
bdd2 b0 7e              BCS Pop_FAC2        ; function ( SGN INT ... MID$ )
bdd4 69 07              ADC #7
bdd6 90 7a              BCC Pop_FAC2        ; ->
bdd8 65 07              ADC VALTYP          ; C=1               0 1 2 3 4  5  6
bdda d0 03              BNE EvEx_30         ; binary operator ( + - * / ^ AND OR )
bddc 4c 4f c7           JMP Concatenate     ; '+' with strings

bddf 69 ff    EvEx_30   ADC #$ff
bde1 85 1f              STA INDEXA          ; op code (0-9 for '+' to '<')
bde3 0a                 ASL A               ; op code * 2
bde4 65 1f              ADC INDEXA          ; op code * 3
bde6 a8                 TAY                 ; Y = index
bde7 68       EvEx_35   PLA                 ; precedence
bde8 d9 94 b0           CMP Basic_Operator_Table,Y
bdeb b0 6a              BCS PoFA_20         ; previous op has higher precedence
bded 20 87 bd           JSR Is_Numeric
bdf0 48       EvEx_40   PHA                 ; save precedence
bdf1 20 17 be EvEx_45   JSR Use_Operator
bdf4 68                 PLA                 ; restore precedence
bdf5 a4 48              LDY YSAVE           ; restore index
bdf7 10 17              BPL EvEx_60
bdf9 aa                 TAX
bdfa f0 59              BEQ PoFA_10
bdfc d0 62              BNE PoFA_40         ; always

bdfe 46 07    EvEx_50   LSR VALTYP          ; clear type
be00 8a                 TXA                 ; comparison operator
be01 2a                 ROL A               ; com op * 2
be02 a6 77              LDX TXTPTR          ; TXTPTR--
be04 d0 02              BNE EvEx_55
be06 c6 78              DEC TXTPTR+1
be08 c6 77    EvEx_55   DEC TXTPTR
be0a a0 1b              LDY #27             ; index to Op_COMPARE
be0c 85 4a              STA ACCSYM          ; com op * 2
be0e d0 d7              BNE EvEx_35
be10 d9 94 b0 EvEx_60   CMP Basic_Operator_Table,Y
be13 b0 4b              BCS PoFA_40         ; higher precedence
be15 90 d9              BCC EvEx_40         ; lower  precedence

              ; ************
be17            Use_Operator
              ; ************

be17 b9 96 b0           LDA Basic_Operator_Table+2,Y
be1a 48                 PHA
be1b b9 95 b0           LDA Basic_Operator_Table+1,Y
be1e 48                 PHA
be1f 20 2a be           JSR Push_Operand
be22 a5 4a              LDA ACCSYM
be24 4c a3 bd           JMP EvEx_10

be27 4c 00 bf SynErr1   JMP Syntax_Error

              ; ************
be2a            Push_Operand
              ; ************

be2a be 94 b0           LDX Basic_Operator_Table,Y ; operator priority
be2d 38                 SEC                        ; push with sign

              ; *********
be2e            Push_FAC1
              ; *********

be2e 68                 PLA                 ; return address-1 low
be2f 85 1f              STA INDEXA
be31 68                 PLA                 ; return address-1 high
be32 85 20              STA INDEXA+1
be34 90 03              BCC PuFA_10
be36 a5 63              LDA FAC1SI          ; sign of operand
be38 48                 PHA
be39 20 51 cd PuFA_10   JSR Round_FAC1
be3c a5 62              LDA FAC1M4
be3e 48                 PHA
be3f a5 61              LDA FAC1M3
be41 48                 PHA
be42 a5 60              LDA FAC1M2
be44 48                 PHA
be45 a5 5f              LDA FAC1M1
be47 48                 PHA
be48 a5 5e              LDA FAC1EX
be4a 48                 PHA
be4b a5 20              LDA INDEXA+1
be4d 48                 PHA
be4e a5 1f              LDA INDEXA
be50 48                 PHA
be51 60                 RTS ;Size   36 [Push_FAC1]

              ; ********
be52            Pop_FAC2
              ; ********

be52 a0 ff              LDY #$ff
be54 68                 PLA
be55 f0 23    PoFA_10   BEQ PoFA_50
be57 c9 64    PoFA_20   CMP #$64            ; precedence of Op_COMPARE
be59 f0 03              BEQ PoFA_30         ; strings may be comapred too
be5b 20 87 bd           JSR Is_Numeric
be5e 84 48    PoFA_30   STY YSAVE
be60 68       PoFA_40   PLA
be61 4a                 LSR A               ; C = VALTYPE
be62 85 0c              STA TANSGN          ; comparison operator
be64 68                 PLA
be65 85 66              STA FAC2EX
be67 68                 PLA
be68 85 67              STA FAC2M1
be6a 68                 PLA
be6b 85 68              STA FAC2M2
be6d 68                 PLA
be6e 85 69              STA FAC2M3
be70 68                 PLA
be71 85 6a              STA FAC2M4
be73 68                 PLA
be74 85 6b              STA FAC2SI
be76 45 63              EOR FAC1SI
be78 85 6c              STA STRPTR
be7a a5 5e    PoFA_50   LDA FAC1EX
be7c 60                 RTS                 ; -> use operator ;Size   43 [Pop_FAC2]

be7d 00                 .FILL $be7e-* (0) ; 1 bytes

              ; ****************
be7e            Evaluate ; $be7e
              ; ****************

be7e 6c 0a 03           JMP (IEVAL)

              ; ****************
be81            DEF_EVAL ; $be81
              ; ****************

be81 a9 00              LDA #0
be83 85 07              STA VALTYP          ; default numeric
be85 20 70 00 Eva_10    JSR CHRGET
be88 b0 03              BCS Eva_30          ; branch if not numeric
be8a 4c 29 ce Eva_20    JMP Read_Real_To_FAC1
be8d 20 b6 c1 Eva_30    JSR Is_Alpha
be90 b0 7a              BCS JMP_Get_Var     ; branch to Get_Var
be92 c9 ff              CMP #$ff            ; Pi token
be94 d0 0f              BNE Eva_40
be96 a9 a0              LDA #<Float_PI
be98 a0 be              LDY #>Float_PI
be9a 20 d8 cc           JSR Load_FAC1_AY
be9d 4c 70 00           JMP CHRGET
bea0 82 49 0f Float_PI  .REAL $82490fdaa1   ; 3.14159265254
bea5 c9 2e    Eva_40    CMP # '.'
bea7 f0 e1              BEQ Eva_20          ; real number starting with '.'
bea9 c9 ab              CMP #$ab            ; '-' token sign
beab f0 58              BEQ Negate
bead c9 aa              CMP #$aa            ; '+' token sign
beaf f0 d4              BEQ Eva_10
beb1 c9 22              CMP #QUOTE
beb3 d0 0f              BNE Eva_50

              ; ********************************
beb5            Make_String_Descriptor_From_Code
              ; ********************************

beb5 a5 77              LDA TXTPTR
beb7 a4 78              LDY TXTPTR+1
beb9 69 00              ADC #0              ; INC (A,Y)
bebb 90 01              BCC MSDF_10
bebd c8                 INY
bebe 20 b0 c5 MSDF_10   JSR Create_String_Descriptor
bec1 4c 18 c9           JMP Restore_Execution_Pointer

bec4 c9 a8    Eva_50    CMP #$a8            ; NOT token
bec6 d0 13              BNE Eva_60
bec8 a0 18              LDY #24             ; NOT index to Op Table
beca d0 3b              BNE Nega_10         ; always

              ; ******
becc            Op_NOT
              ; ******

              ; convert real in FAC1 to integer
              ; do a bitwise EOR (negate)
              ; convert result back to FAC1
              ; 0 : false, <> 0 : true

becc 20 ea c2           JSR Real_To_Integer
becf a5 62              LDA FAC1M4
bed1 49 ff              EOR #$ff
bed3 a8                 TAY
bed4 a5 61              LDA FAC1M3
bed6 49 ff              EOR #$ff
bed8 4c bc c4           JMP AY_To_Real

bedb c9 a5    Eva_60    CMP #$a5            ; FN(  token
bedd d0 03              BNE Eva_70
bedf 4c 1d c5           JMP Eval_FNX
bee2 c9 b4    Eva_70    CMP #$b4            ; SGN( token
bee4 90 03              BCC Eval_In_Parenthesis
bee6 4c 47 c0           JMP Function_Call

              ; *******************
bee9            Eval_In_Parenthesis
              ; *******************

bee9 20 f2 be           JSR Need_Left_Parenthesis
beec 20 98 bd           JSR Eval_Expression

              ; **********************
beef            Need_Right_Parenthesis
              ; **********************

beef a9 29              LDA #')'
bef1 2c                 .BYTE $2c

              ; *********************
bef2            Need_Left_Parenthesis
              ; *********************

bef2 a9 28              LDA #'('
bef4 2c                 .BYTE $2c

              ; **********
bef5            Need_Comma
              ; **********

bef5 a9 2c              LDA #','

              ; ******
bef7            Need_A
              ; ******

bef7 a0 00              LDY #0
bef9 d1 77              CMP (TXTPTR),Y
befb d0 03              BNE Syntax_Error
befd 4c 70 00           JMP CHRGET

              ; ************
bf00            Syntax_Error
              ; ************

bf00 a2 10              LDX #[Msg_SYNTA - Msg_Start]
bf02 4c cf b3           JMP Basic_Error

              ; ******
bf05            Negate
              ; ******

bf05 a0 15              LDY #21             ; index to Op_NEGATE
bf07 68       Nega_10   PLA
bf08 68                 PLA
bf09 4c f1 bd           JMP EvEx_45

              ; ***********
bf0c            JMP_Get_Var
              ; ***********

bf0c 4c 8c bf           JMP Get_Var

              ; *************
bf0f            Any_Except_Pi
              ; *************

bf0f 20 70 00           JSR CHRGET
bf12 c9 ff              CMP #$ff            ; Pi token
bf14 f0 ea              BEQ Syntax_Error
bf16 4c 76 00           JMP CHRGOT

              ; ******************
bf19            Input_String_Patch
              ; ******************

bf19 a5 10              LDA IOPMPT
bf1b d0 03              BNE InSt_40
bf1d 4c f0 bb           JMP InSt_30
bf20 a5 96    InSt_40   LDA STATUS
bf22 29 40              AND #$40            ; check EOF
bf24 d0 03              BNE InSt_50
bf26 4c d5 bb           JMP InSt_10
bf29 4c 09 bc InSt_50   JMP READ_10

              ; ************************
bf2c            Extended_Statement_Table
              ; ************************

bf2c b0 de              .WORD Renumber         - 1
bf2e 44 d4              .WORD Monitor          - 1
bf30 7c e4              .WORD Delete           - 1
bf32 77 ed              .WORD Find_Text        - 1
bf34 59 fe              .WORD Replace          - 1
bf36 e5 f3              .WORD Merge            - 1
bf38 00 e7              .WORD OLD              - 1

              ; **********************
bf3a            Extended_Keyword_Table
              ; **********************

bf3a 52 45 4e           .BYTE "RENUMBER"^
bf42 4d 4f 4e           .BYTE "MONITOR"^
bf49 44 45 4c           .BYTE "DELETE"^
bf4f 46 49 4e           .BYTE "FIND"^
bf53 52 45 50           .BYTE "REPLACE"^
bf5a 4d 45 52           .BYTE "MERGE"^
bf5f 4f 4c c4           .BYTE "OLD"^
bf62 00                 .BYTE 0

bf63 00 00 00           .FILL $bf8c-* (0) ; 41 bytes

              ; *******
bf8c            Get_Var
              ; *******

              ; Parse_Name checks, whether the caller is Get_Var
              ; It does not create a so far unknown variable in this case

              ; Output: FAC1 a) integer value converted to real
              ;              b) real value
              ;              c) address of string (FAC1M3)

bf8c 20 2b c1           JSR Parse_Name      ; call address checked in Create_Var !
bf8f 85 61              STA FAC1M3          ; A = VARPTR
bf91 84 62              STY FAC1M4          ; Y = VARPTR+1
bf93 a5 42              LDA VARNAM
bf95 a4 43              LDY VARNAM+1
bf97 a6 07              LDX VALTYP
bf99 f0 33              BEQ Get_Numeric_Value
bf9b a6 62              LDX FAC1M4          ; VARPTR+1
bf9d 10 2e              BPL GeVa_Ret        ; is assigned: no special variables
bf9f c9 54              CMP #'T'            ; TI$ - 1st. char
bfa1 d0 18              BNE GeVa_10
bfa3 c0 c9              CPY #'I'+$80        ; TI$ - 2nd. char
bfa5 d0 14              BNE GeVa_10
bfa7 20 03 c0           JSR Load_Jiffyclock
bfaa 84 5b              STY TMPVAR+1        ; TMPVAR+1 = 0
bfac 88                 DEY
bfad 84 6e              STY TMPPTD          ; TMPPTD = $ff
bfaf a0 06              LDY #6
bfb1 84 5a              STY TMPVAR          ; # of digits
bfb3 a0 24              LDY #$24            ; index to Decimal_Conversion_Table
bfb5 20 1a d0           JSR Format_Jiffyclock
bfb8 4c 98 c5           JMP STR_10           ; create string and descriptor

bfbb c9 44    GeVa_10   CMP #'D'            ; DS$ - 1st. char
bfbd d0 0e              BNE GeVa_Ret
bfbf c0 d3              CPY #'S'+$80        ; DS$ - 2nd. char
bfc1 d0 0a              BNE GeVa_Ret
bfc3 20 91 d9           JSR Kernal_Read_DS
bfc6 a9 ad              LDA #<DOS_Status
bfc8 a0 03              LDY #>DOS_Status
bfca 4c b0 c5           JMP Create_String_Descriptor
bfcd 60       GeVa_Ret  RTS ;Size   66 [Get_Var]

              ; *****************
bfce            Get_Numeric_Value
              ; *****************

bfce a6 08              LDX INTFLG
bfd0 10 0d              BPL Load_Float
bfd2 a0 00              LDY #0
bfd4 b1 61              LDA (FAC1M3),Y
bfd6 aa                 TAX
bfd7 c8                 INY
bfd8 b1 61              LDA (FAC1M3),Y
bfda a8                 TAY
bfdb 8a                 TXA
bfdc 4c bc c4           JMP AY_To_Real

              ; **********
bfdf            Load_Float
              ; **********

bfdf a6 62              LDX FAC1M4
bfe1 10 5d              BPL Load_Float_Var
bfe3 c9 54              CMP #'T'            ; TI - 1st. char
bfe5 d0 28              BNE Check_ST_Var
bfe7 c0 49              CPY #'I'            ; TI - 2nd. char
bfe9 d0 55              BNE Load_Float_Var
bfeb 20 03 c0           JSR Load_Jiffyclock
bfee 98                 TYA                 ; FROUND := $00  FAC1SI := $00
bfef a2 a0              LDX #$a0            ; FAC1EX := $a0
bff1 4c 85 cd           JMP CITR_10           ; normalize FAC1

bff4 00 00 00           .FILL $c003-* (0) ; 15 bytes

              ; ***********************
c003            Load_Jiffyclock ; $c003
              ; ***********************

c003 a9 8b              LDA #<[JIFFY_CLOCK-2] ; load mixture of random seed
c005 a0 00              LDY #>[JIFFY_CLOCK-2] ; and jiffy clock
c007 78                 SEI
c008 20 d8 cc           JSR Load_FAC1_AY      ; FAC1M2/3/4 = Jiffy Clock
c00b 58                 CLI
c00c 84 5f              STY FAC1M1            ; FAC1M1 = 0
c00e 60                 RTS ;Size   12 [Load_Jiffyclock]

              ; ************
c00f            Check_ST_Var
              ; ************

c00f c9 53              CMP #'S'
c011 d0 09              BNE Check_DS_Var
c013 c0 54              CPY #'T'
c015 d0 05              BNE Check_DS_Var
c017 a5 96              LDA STATUS
c019 4c 72 cd           JMP A_To_FAC1

              ; ************
c01c            Check_DS_Var
              ; ************

c01c c9 44              CMP #'D'
c01e d0 20              BNE Load_Float_Var
c020 c0 53              CPY #'S'
c022 d0 1c              BNE Load_Float_Var
c024 20 91 d9           JSR Kernal_Read_DS
c027 29 0f              AND #15
c029 0a                 ASL A
c02a 85 09              STA GARBFL
c02c 0a                 ASL A
c02d 0a                 ASL A
c02e 65 09              ADC GARBFL
c030 85 09              STA GARBFL
c032 ad ae 03           LDA DOS_Status+1
c035 29 0f              AND #15
c037 65 09              ADC GARBFL
c039 4c 72 cd           JMP A_To_FAC1

c03c 00 00 00           .FILL $c040-* (0) ; 4 bytes

              ; **********************
c040            Load_Float_Var ; $c040
              ; **********************

c040 a5 61              LDA FAC1M3
c042 a4 62              LDY FAC1M4
c044 4c d8 cc           JMP Load_FAC1_AY

              ; *************
c047            Function_Call
              ; *************

              ; called from Evaluate
              ; Input:  A = function token
              ;         token  range = $b4 SGN - $ca MID$
              ;         scaled range = $68 SGN - $92 MID$

c047 0a                 ASL A               ; A = token * 2
c048 48                 PHA                 ; save
c049 aa                 TAX                 ; X = token * 2
c04a 20 70 00           JSR CHRGET
c04d e0 8f              CPX #$8f            ; limit of single numeric argument
c04f 90 20              BCC FuCa_10         ; branch if not LEFT$, RIGHT$, MID$
c051 20 f2 be           JSR Need_Left_Parenthesis
c054 20 98 bd           JSR Eval_Expression
c057 20 f5 be           JSR Need_Comma
c05a 20 89 bd           JSR Is_String       ; 1st. arg must be string
c05d 68                 PLA                 ; scaled token
c05e aa                 TAX                 ; X = $90 LEFT$, $92 RIGHT$, $94 MID$
c05f a5 62              LDA FAC1M4
c061 48                 PHA
c062 a5 61              LDA FAC1M3          ; push pointer to 1st. argUment
c064 48                 PHA
c065 8a                 TXA
c066 48                 PHA                 ; save scaled token
c067 20 d4 c8           JSR Get_Byte_Value  ; get 2nd. argument (byte value)
c06a 68                 PLA
c06b a8                 TAY                 ; Y = scaled token
c06c 8a                 TXA
c06d 48                 PHA                 ; push 2nd. argument
c06e 4c 76 c0           JMP FuCa_20
c071 20 e9 be FuCa_10   JSR Eval_In_Parenthesis
c074 68                 PLA                 ; scaled token
c075 a8                 TAY                 ; Y = index
c076 b9 fe af FuCa_20   LDA Basic_Function_Table-$68,Y
c079 85 52              STA FUNJMP
c07b b9 ff af           LDA Basic_Function_Table-$67,Y
c07e 85 53              STA FUNJMP+1
c080 20 51 00           JSR JUMPER
c083 4c 87 bd           JMP Is_Numeric

              ; *****
c086            Op_OR
              ; *****

c086 38                 SEC
c087 24                 .BYTE $24

              ; ******
c088            Op_AND
              ; ******

c088 18                 CLC
c089 66 03              ROR CHARAC          ; bit7=1:OR bit7=0:AND
c08b 20 ea c2           JSR Real_To_Integer
c08e a5 61              LDA FAC1M3
c090 48                 PHA
c091 a5 62              LDA FAC1M4
c093 48                 PHA
c094 20 32 cd           JSR FAC2_To_FAC1
c097 20 ea c2           JSR Real_To_Integer
c09a 68                 PLA
c09b 24 03              BIT CHARAC
c09d 10 09              BPL ANDOR_10
c09f 05 62              ORA FAC1M4
c0a1 a8                 TAY
c0a2 68                 PLA
c0a3 05 61              ORA FAC1M3
c0a5 4c bc c4           JMP AY_To_Real
c0a8 25 62    ANDOR_10  AND FAC1M4
c0aa a8                 TAY
c0ab 68                 PLA
c0ac 25 61              AND FAC1M3
c0ae 4c bc c4           JMP AY_To_Real

              ; ************
              ; Float_M32768
              ; ************

              ;         .REAL $9080000000   ; -32768

c0b1 00 00 00           .FILL $c0b6-* (0) ; 5 bytes

              ; ******************
c0b6            Op_COMPARE ; $c0b6
              ; ******************

              ; Input:  C = VALTYPE
              ;         TANSGN = comparison mask
              ;         FAC1 = right operand
              ;         FAC2 = left  operand

c0b6 20 8a bd           JSR Check_Var_Type
c0b9 b0 13              BCS OpCO_10         ; -> compare strings
c0bb a5 6b              LDA FAC2SI          ; transfer sign to FAC2M1
c0bd 09 7f              ORA #$7f
c0bf 25 67              AND FAC2M1
c0c1 85 67              STA FAC2M1
c0c3 a9 66              LDA #<FAC2EX
c0c5 a0 00              LDY #>FAC2EX
c0c7 20 91 cd           JSR Compare_FAC1_AY ; -1: FAC1 > FAC2  +1: FAC1 < FAC2
c0ca aa                 TAX                 ; set flags
c0cb 4c 01 c1           JMP OpCO_40
c0ce a9 00    OpCO_10   LDA #0
c0d0 85 07              STA VALTYP          ; result = numeric (-1:true, 0:false)
c0d2 c6 4a              DEC ACCSYM          ; OBSOLETE
c0d4 20 b8 c7           JSR Free_String_FAC1
c0d7 85 5e              STA FAC1EX
c0d9 86 5f              STX FAC1M1          ; 1st. string
c0db 84 60              STY FAC1M2
c0dd a5 69              LDA FAC2M3
c0df a4 6a              LDY FAC2M4
c0e1 20 bc c7           JSR Free_String_AY
c0e4 86 69              STX FAC2M3          ; 2nd. string
c0e6 84 6a              STY FAC2M4
c0e8 aa                 TAX                 ; X = length2
c0e9 38                 SEC
c0ea e5 5e              SBC FAC1EX          ; length difference
c0ec f0 08              BEQ OpCO_20         ; -> equal length
c0ee a9 01              LDA #1
c0f0 90 04              BCC OpCO_20
c0f2 a6 5e              LDX FAC1EX          ; X = length1 (shorter one)
c0f4 a9 ff              LDA #-1
c0f6 85 63    OpCO_20   STA FAC1SI          ; store length1 <=> length2 (-1,0,1)
c0f8 a0 ff              LDY #-1
c0fa e8                 INX
c0fb c8       OpCO_30   INY
c0fc ca                 DEX
c0fd d0 07              BNE OpCO_50
c0ff a6 63              LDX FAC1SI          ; equal so far
c101 30 0f    OpCO_40   BMI OpCO_60         ; left > right
c103 18                 CLC
c104 90 0c              BCC OpCO_60
c106 b1 69    OpCO_50   LDA (FAC2M3),Y
c108 d1 5f              CMP (FAC1M1),Y
c10a f0 ef              BEQ OpCO_30
c10c a2 ff              LDX #-1
c10e b0 02              BCS OpCO_60
c110 a2 01              LDX #1
c112 e8       OpCO_60   INX                 ; C=1 : string2 >= string1
c113 8a                 TXA                 ; C=0 : string2 <  string1
c114 2a                 ROL A
c115 25 0c              AND TANSGN          ; ACCSYM comparison mask
c117 f0 02              BEQ OpCO_70         ; > 1   = 2   < 4
c119 a9 ff              LDA #-1             ; true
c11b 4c 72 cd OpCO_70   JMP A_To_FAC1


c11e 20 f5 be DIM_10    JSR Need_Comma

              ; *********
c121            Basic_DIM
              ; *********

c121 aa                 TAX
c122 20 30 c1           JSR Get_Array_Address
c125 20 76 00           JSR CHRGOT
c128 d0 f4              BNE DIM_10
c12a 60                 RTS ;Size   10 [Basic_DIM]

              ; **********
c12b            Parse_Name
              ; **********

c12b a2 00              LDX #0
c12d 20 76 00           JSR CHRGOT

              ; *****************
c130            Get_Array_Address
              ; *****************

c130 86 06              STX DIMFLG

              ; **************
c132            Get_FN_Address
              ; **************

c132 85 42              STA VARNAM
c134 20 76 00           JSR CHRGOT
c137 20 b6 c1           JSR Is_Alpha
c13a b0 03              BCS Get_Address
c13c 4c 00 bf GFA_Err   JMP Syntax_Error

              ; *******************
c13f            Get_Address ; $c13f
              ; *******************

c13f a2 00              LDX #0              ; set defaults
c141 86 07              STX VALTYP          ; numeric
c143 86 08              STX INTFLG          ; real
c145 20 70 00           JSR CHRGET          ; 2nd. char of name
c148 90 05              BCC GeAd_05         ; -> branch if numeric
c14a 20 b6 c1           JSR Is_Alpha
c14d 90 0b              BCC GeAd_15         ; -> branch if not alpha
c14f aa       GeAd_05   TAX                 ; X = 2nd. char of name
c150 20 70 00 GeAd_10   JSR CHRGET          ; skip all alphanumeric characters
c153 90 fb              BCC GeAd_10         ; after the 2nd. one
c155 20 b6 c1           JSR Is_Alpha
c158 b0 f6              BCS GeAd_10
c15a c9 24    GeAd_15   CMP #'$'            ; string ?
c15c d0 06              BNE GeAd_20
c15e a9 ff              LDA #$ff            ; set string flag
c160 85 07              STA VALTYP          ; $ff = string  $00 = numeric
c162 d0 10              BNE GeAd_25         ; branch always
c164 c9 25    GeAd_20   CMP #'%'            ; integer ?
c166 d0 13              BNE GeAd_30
c168 a5 0a              LDA SUBFLG          ; integer allowed ?
c16a d0 d0              BNE GFA_Err         ; -> not in this context
c16c a9 80              LDA #$80
c16e 85 08              STA INTFLG          ; integer flag
c170 05 42              ORA VARNAM
c172 85 42              STA VARNAM          ; mark variable as integer
c174 8a       GeAd_25   TXA                 ; A = 2nd. char
c175 09 80              ORA #$80            ; set string/integer bit
c177 aa                 TAX                 ; X = 2nd. char OR $80
c178 20 70 00           JSR CHRGET          ; next char after '$' or '%'
c17b 86 43    GeAd_30   STX VARNAM+1        ; store 2nd. char of name
c17d 38                 SEC
c17e 05 0a              ORA SUBFLG          ; Or with FOR, FN flag
c180 e9 28              SBC #'('            ; array ?
c182 d0 03              BNE GeAd_35         ; -> no
c184 4c fc c2           JMP Find_Array      ; read subscripts
c187 a0 00    GeAd_35   LDY #0
c189 84 0a              STY SUBFLG          ; clear integer disable flag
c18b a5 2a              LDA VARTAB
c18d a6 2b              LDX VARTAB+1        ; (A/X) = VARTAB
c18f 86 5d    GeAd_40   STX TMPPTC+1        ; find variable in (VARTAB..ARYTAB)
c191 85 5c    GeAd_45   STA TMPPTC          ; TMPPTC = (A/X)
c193 e4 2d              CPX ARYTAB+1
c195 d0 04              BNE GeAd_50
c197 c5 2c              CMP ARYTAB
c199 f0 25              BEQ Create_Var      ; (A/X) == ARYTAB -> not found
c19b a5 42    GeAd_50   LDA VARNAM
c19d d1 5c              CMP (TMPPTC),Y      ; compare 1st. char
c19f d0 0b              BNE GeAd_60
c1a1 a5 43              LDA VARNAM+1
c1a3 c8                 INY                 ; Y = 1
c1a4 d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c1a6 d0 03              BNE GeAd_55
c1a8 4c b4 c2           JMP CrVa_80           ; -> found
c1ab 88       GeAd_55   DEY                 ; Y = 0
c1ac 18       GeAd_60   CLC
c1ad a5 5c              LDA TMPPTC
c1af 69 07              ADC #7              ; TMPPTC += 7
c1b1 90 de              BCC GeAd_45
c1b3 e8                 INX
c1b4 d0 d9              BNE GeAd_40         ; branch always

              ; ********
c1b6            Is_Alpha
              ; ********

c1b6 c9 41              CMP #'A'
c1b8 90 05              BCC IsAl_Ret
c1ba e9 5b              SBC #'Z'+1
c1bc 38                 SEC
c1bd e9 a5              SBC #$a5            ; restore original content
c1bf 60       IsAl_Ret  RTS                 ; C=1 if (A..Z) ;Size   10 [Is_Alpha]

              ; ******************
c1c0            Create_Var ; $c1c0
              ; ******************

c1c0 68                 PLA
c1c1 48                 PHA                 ; return address low
c1c2 c9 8e              CMP #<[Get_Var+2]   ; $8e called from Get_Var ?
c1c4 d0 05              BNE CrVa_10
c1c6 a9 c9    CrVa_05   LDA #<[Float_0_5 + 2]; void descriptor (0,0,0)
c1c8 a0 d0              LDY #>[Float_0_5 + 2]; or value in ROM
c1ca 60                 RTS ;Size   11 [Create_Var]
c1cb a5 42    CrVa_10   LDA VARNAM
c1cd a4 43              LDY VARNAM+1
c1cf c9 54              CMP #'T'            ; check reserved names
c1d1 d0 0b              BNE CrVa_20
c1d3 c0 c9              CPY #'I'+$80        ; TI$ = "hhmmss"  sets jiffy clock
c1d5 f0 ef              BEQ CrVa_05         ; create void descriptor
c1d7 c0 49              CPY #'I'            ; TI  (read only variable)
c1d9 d0 03              BNE CrVa_20
c1db 4c 00 bf CrVa_15   JMP Syntax_Error    ; tried to use reserved name
c1de c9 53    CrVa_20   CMP #'S'
c1e0 d0 04              BNE CrVa_25
c1e2 c0 54              CPY #'T'            ; ST  (read only variable)
c1e4 f0 f5              BEQ CrVa_15
c1e6 c9 44    CrVa_25   CMP #'D'
c1e8 d0 08              BNE CrVa_30
c1ea c0 53              CPY #'S'            ; DS  (read only variable)
c1ec f0 ed              BEQ CrVa_15
c1ee c0 d3              CPY #'S'+$80        ; DS$ (read only variable)
c1f0 f0 e9              BEQ CrVa_15
c1f2 a5 2c    CrVa_30   LDA ARYTAB
c1f4 a4 2d              LDY ARYTAB+1        ; (A/Y)  = ARYTAB
c1f6 85 5c              STA TMPPTC
c1f8 84 5d              STY TMPPTC+1        ; TMPPTC = ARYTAB
c1fa a5 2e              LDA STREND
c1fc a4 2f              LDY STREND+1        ; (A/Y)  = STREND
c1fe 85 57              STA TMPPTB
c200 84 58              STY TMPPTB+1        ; TMPPTB = STREND
c202 18                 CLC
c203 69 07              ADC #7              ; 7 bytes for a new variable
c205 90 01              BCC CrVa_35
c207 c8                 INY
c208 85 55    CrVa_35   STA TMPPTA
c20a 84 56              STY TMPPTA+1        ; TMPPTA = TMPPTB + 7
c20c 20 50 b3           JSR Open_Up_Space   ; move array space 7 bytes up
c20f a5 55              LDA TMPPTA
c211 a4 56              LDY TMPPTA+1
c213 c8                 INY
c214 85 2c              STA ARYTAB
c216 84 2d              STY ARYTAB+1        ; ARYTAB += 7
c218 85 55              STA TMPPTA
c21a 84 56              STY TMPPTA+1        ; TMPPTA = ARYTAB

              ; scan through array area and adjust all dynamic string
              ; back references to the new descriptor position

c21c a5 55    CrVa_40   LDA TMPPTA
c21e a6 56              LDX TMPPTA+1
c220 e4 2f    CrVa_45   CPX STREND+1        ; TMPPTA == STREND ?
c222 d0 04              BNE CrVa_50
c224 c5 2e              CMP STREND
c226 f0 70              BEQ CrVa_75         ; -> initialize variable
c228 85 1f    CrVa_50   STA INDEXA
c22a 86 20              STX INDEXA+1        ; INDEXA = TMPPTA
c22c a0 00              LDY #0
c22e b1 1f              LDA (INDEXA),Y
c230 aa                 TAX                 ; X = 1st. char
c231 c8                 INY                 ; Y = 1
c232 b1 1f              LDA (INDEXA),Y
c234 08                 PHP                 ; push flags of 2nd. char
c235 c8                 INY                 ; Y = 2
c236 b1 1f              LDA (INDEXA),Y      ; A = array length low
c238 65 55              ADC TMPPTA
c23a 85 55              STA TMPPTA
c23c c8                 INY                 ; Y = 3
c23d b1 1f              LDA (INDEXA),Y      ; A = array length high
c23f 65 56              ADC TMPPTA+1
c241 85 56              STA TMPPTA+1        ; TMPPTA += array length
c243 28                 PLP                 ; flags of 2nd. char
c244 10 d6              BPL CrVa_40         ; -> branch for real array
c246 8a                 TXA                 ; flags for 1st. char
c247 30 d3              BMI CrVa_40         ;-> branch for integer
c249 c8                 INY                 ; Y = 4
c24a b1 1f              LDA (INDEXA),Y      ; A = # of dimensions
c24c a0 00              LDY #0
c24e 0a                 ASL A               ; dimensions * 2
c24f 69 05              ADC #5              ; plus 5 bytes for header
c251 65 1f              ADC INDEXA
c253 85 1f              STA INDEXA
c255 90 02              BCC CrVa_55
c257 e6 20              INC INDEXA+1        ; INDEXA += header size
c259 a6 20    CrVa_55   LDX INDEXA+1
c25b e4 56              CPX TMPPTA+1        ; INDEXA == TMPPTA (end of array) ?
c25d d0 04              BNE CrVa_60
c25f c5 55              CMP TMPPTA
c261 f0 bd              BEQ CrVa_45         ; -> branch on end of array
c263 a0 00    CrVa_60   LDY #0
c265 b1 1f              LDA (INDEXA),Y      ; length
c267 f0 22              BEQ CrVa_70         ; -> next item
c269 c8                 INY                 ; Y = 1
c26a 18                 CLC
c26b 71 1f              ADC (INDEXA),Y      ; A = length + address low
c26d 85 57              STA TMPPTB
c26f aa                 TAX
c270 c8                 INY                 ; Y = 2
c271 b1 1f              LDA (INDEXA),Y      ; address high
c273 69 00              ADC #0
c275 85 58              STA TMPPTB+1        ; TMPPTB = back reference
c277 c5 31              CMP FRETOP+1
c279 90 10              BCC CrVa_70         ; -> branch if not in string area
c27b d0 04              BNE CrVa_65
c27d e4 30              CPX FRETOP
c27f 90 0a              BCC CrVa_70         ; -> branch if not in string area
c281 88       CrVa_65   DEY                 ; Y = 1
c282 a5 20              LDA INDEXA+1        ; back reference high
c284 91 57              STA (TMPPTB),Y      ; store
c286 88                 DEY                 ; Y = 0
c287 a5 1f              LDA INDEXA          ; back reference low
c289 91 57              STA (TMPPTB),Y      ; store
c28b a9 03    CrVa_70   LDA #3
c28d 18                 CLC
c28e 65 1f              ADC INDEXA
c290 85 1f              STA INDEXA
c292 90 c5              BCC CrVa_55
c294 e6 20              INC INDEXA+1        ; INDEXA += 3 (next descriptor)
c296 d0 c1              BNE CrVa_55         ; branch always

c298 a0 00    CrVa_75   LDY #0
c29a a5 42              LDA VARNAM
c29c 91 5c              STA (TMPPTC),Y      ; byte 0: 1st. char
c29e c8                 INY
c29f a5 43              LDA VARNAM+1
c2a1 91 5c              STA (TMPPTC),Y      ; byte 1: 2nd. char
c2a3 a9 00              LDA #0
c2a5 c8                 INY
c2a6 91 5c              STA (TMPPTC),Y      ; byte 2-6: 0
c2a8 c8                 INY
c2a9 91 5c              STA (TMPPTC),Y
c2ab c8                 INY
c2ac 91 5c              STA (TMPPTC),Y
c2ae c8                 INY
c2af 91 5c              STA (TMPPTC),Y
c2b1 c8                 INY
c2b2 91 5c              STA (TMPPTC),Y
c2b4 a5 5c    CrVa_80   LDA TMPPTC
c2b6 18                 CLC
c2b7 69 02              ADC #2
c2b9 a4 5d              LDY TMPPTC+1
c2bb 90 01              BCC CrVa_85
c2bd c8                 INY
c2be 85 44    CrVa_85   STA VARPTR          ; VARPTR = TMPPTC + 2
c2c0 84 45              STY VARPTR+1
c2c2 60                 RTS ;Size  259 [Create_Var]

c2c3 00 00 00           .FILL $c2c8-* (0) ; 5 bytes

              ; ******************************
c2c8            Array_Pointer_To_First ; $c2c8
              ; ******************************

c2c8 a5 05              LDA COUNT           ; # of dimensions
c2ca 0a                 ASL A               ; in bytes
c2cb 69 05              ADC #5              ; plus header size
c2cd 65 5c              ADC TMPPTC          ; plus start of array
c2cf a4 5d              LDY TMPPTC+1
c2d1 90 01              BCC APTF_10
c2d3 c8                 INY
c2d4 85 55    APTF_10   STA TMPPTA          ; pointer to first elemnt
c2d6 84 56              STY TMPPTA+1
c2d8 60                 RTS ;Size   17 [Array_Pointer_To_First]

              ; ************
c2d9            Float_M32768
              ; ************

c2d9 90 80 00           .QUAD $90800000  -1870659584

c2dd                    .FILL $c2dd-* (0) ; 0 bytes

              ; *****************************
c2dd            Eval_Positive_Integer ; $c2dd
              ; *****************************

c2dd 20 70 00           JSR CHRGET
c2e0 20 98 bd           JSR Eval_Expression

              ; ***************************
c2e3            Eval_Positive_Integer_Check
              ; ***************************

c2e3 20 87 bd           JSR Is_Numeric
c2e6 a5 63              LDA FAC1SI
c2e8 30 0d              BMI RIT_10

              ; ***********************
c2ea            Real_To_Integer ; $c2ea
              ; ***********************

c2ea a5 5e              LDA FAC1EX
c2ec c9 90              CMP #$90            ; check if -32767 >= value >= 32767
c2ee 90 09              BCC RIT_20
c2f0 a9 d9              LDA #<Float_M32768  ; check if value = -32768
c2f2 a0 c2              LDY #>Float_M32768
c2f4 20 91 cd           JSR Compare_FAC1_AY
c2f7 d0 7a    RIT_10    BNE Jump_To_Illegal_Quantity
c2f9 4c 6f ba RIT_20    JMP FAC1_INT

              ; ******************
c2fc            Find_Array ; $c2fc
              ; ******************

              ; This routine is jumped at from the Parse_Name routine
              ; after parsing the name of the array (VARNAM) and the
              ; left parenthesis '('

c2fc a5 06              LDA DIMFLG
c2fe 05 08              ORA INTFLG          ; push INTFLG (bit 7) and DIMFLG (6-0)
c300 48                 PHA
c301 a5 07              LDA VALTYP          ; push VALTYP
c303 48                 PHA
c304 a0 00              LDY #0
c306 98       FiAr_05   TYA                 ; start loop evaluating subscripts
c307 48                 PHA                 ; push Y
c308 a5 43              LDA VARNAM+1
c30a 48                 PHA
c30b a5 42              LDA VARNAM          ; push VARNAM
c30d 48                 PHA
c30e 20 dd c2           JSR Eval_Positive_Integer
c311 68                 PLA
c312 85 42              STA VARNAM
c314 68                 PLA
c315 85 43              STA VARNAM+1        ; pull VARNAM
c317 68                 PLA
c318 a8                 TAY                 ; pull Y
c319 ba                 TSX                 ; X = stack pointer
c31a bd 02 01           LDA STACK+2,X
c31d 48                 PHA                 ; push DIMFLG/INTFLG again
c31e bd 01 01           LDA STACK+1,X
c321 48                 PHA                 ; push VALTYP again
c322 a5 61              LDA FAC1M3
c324 9d 02 01           STA STACK+2,X
c327 a5 62              LDA FAC1M4          ; replace value above these flags
c329 9d 01 01           STA STACK+1,X       ; by the subscript pointer
c32c c8                 INY                 ; check next index
c32d 20 76 00           JSR CHRGOT
c330 c9 2c              CMP #','
c332 f0 d2              BEQ FiAr_05         ; evaluate next subscript
c334 84 05              STY COUNT           ; # of subscripts
c336 20 ef be           JSR Need_Right_Parenthesis
c339 68                 PLA
c33a 85 07              STA VALTYP
c33c 68                 PLA
c33d 85 08              STA INTFLG
c33f 29 7f              AND #$7f
c341 85 06              STA DIMFLG          ; restore array flags
c343 a6 2c              LDX ARYTAB
c345 a5 2d              LDA ARYTAB+1        ; start of search
c347 86 5c    FiAr_10   STX TMPPTC
c349 85 5d              STA TMPPTC+1
c34b c5 2f              CMP STREND+1
c34d d0 04              BNE FiAr_15
c34f e4 2e              CPX STREND
c351 f0 39              BEQ FiAr_30           ; not found -> create default size array
c353 a0 00    FiAr_15   LDY #0
c355 b1 5c              LDA (TMPPTC),Y
c357 c8                 INY                 ; Y = 1
c358 c5 42              CMP VARNAM          ; compare 1st. char
c35a d0 06              BNE FiAr_20
c35c a5 43              LDA VARNAM+1
c35e d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c360 f0 16              BEQ FiAr_25
c362 c8       FiAr_20   INY                 ; Y = 2
c363 b1 5c              LDA (TMPPTC),Y      ; length of header
c365 18                 CLC
c366 65 5c              ADC TMPPTC
c368 aa                 TAX
c369 c8                 INY
c36a b1 5c              LDA (TMPPTC),Y
c36c 65 5d              ADC TMPPTC+1        ; advance TMPPTC to next array
c36e 90 d7              BCC FiAr_10         ; branch always

              ; -------------
c370            Bad_Subscript
              ; -------------

c370 a2 6b              LDX #[Msg_SUBSC - Msg_Start] ; $6b
c372 2c                 .BYTE $2c

              ; ------------------------
c373            Jump_To_Illegal_Quantity
              ; ------------------------

c373 a2 35              LDX #[Msg_QUANT - Msg_Start] ; $35
c375 4c cf b3 FiAr_Err  JMP Basic_Error

              ; array already declared and dimensioned

c378 a2 78    FiAr_25   LDX #[Msg_REDIM - Msg_Start] ; $78
c37a a5 06              LDA DIMFLG          ; dimension statement ?
c37c d0 f7              BNE FiAr_Err        ; array already created
c37e 20 c8 c2           JSR Array_Pointer_To_First
c381 a5 05              LDA COUNT           ; # of subscripts
c383 a0 04              LDY #4
c385 d1 5c              CMP (TMPPTC),Y      ; compare with # of declared dimensions
c387 d0 e7              BNE Bad_Subscript   ; error if no match
c389 4c 15 c4           JMP FiAr_70

              ; create array

c38c 20 c8 c2 FiAr_30   JSR Array_Pointer_To_First
c38f 20 a0 b3           JSR Check_Mem_Avail
c392 a0 00              LDY #0
c394 84 6f              STY TMPPTD+1
c396 a2 05              LDX #5              ; # of bytes per element (default REAL)
c398 a5 42              LDA VARNAM
c39a 91 5c              STA (TMPPTC),Y      ; store 1st. char
c39c 10 01              BPL FiAr_35         ; branch if REAL or STRING
c39e ca                 DEX                 ; # of bytes = 4
c39f c8       FiAr_35   INY                 ; Y = 1
c3a0 a5 43              LDA VARNAM+1
c3a2 91 5c              STA (TMPPTC),Y      ; store 2nd. char
c3a4 10 02              BPL FiAr_40         ; branch if REAL
c3a6 ca                 DEX
c3a7 ca                 DEX                 ; # of bytes (2 INTEGER, 3 STRING)
c3a8 86 6e    FiAr_40   STX TMPPTD          ; store size of elemnts
c3aa a5 05              LDA COUNT           ; # of subscripts
c3ac c8                 INY                 ; Y = 2
c3ad c8                 INY                 ; Y = 3
c3ae c8                 INY                 ; Y = 4
c3af 91 5c              STA (TMPPTC),Y      ; store # of dimensions
c3b1 a2 0b    FiAr_45   LDX #11             ; default dimension (0..10)
c3b3 a9 00              LDA #0              ; high value
c3b5 24 06              BIT DIMFLG
c3b7 50 08              BVC FiAr_50         ; -> branch for default dimension
c3b9 68                 PLA
c3ba 18                 CLC
c3bb 69 01              ADC #1              ; add 1 because indices start at 0
c3bd aa                 TAX
c3be 68                 PLA
c3bf 69 00              ADC #0              ; (X/A) = (subscript + 1)
c3c1 c8       FiAr_50   INY                 ; Y = 5,7,...
c3c2 91 5c              STA (TMPPTC),Y      ; store dimension high
c3c4 c8                 INY                 ; Y = 6,8,...
c3c5 8a                 TXA
c3c6 91 5c              STA (TMPPTC),Y      ; store dimension low
c3c8 20 77 c4           JSR Mult_16x16
c3cb 86 6e              STX TMPPTD          ; size low
c3cd 85 6f              STA TMPPTD+1        ; size high
c3cf a4 1f              LDY INDEXA
c3d1 c6 05              DEC COUNT           ; decrement dimension counter
c3d3 d0 dc              BNE FiAr_45         ; loop for next dimension
c3d5 65 56              ADC TMPPTA+1
c3d7 b0 5d              BCS FiAr_76           ; -> out of memory
c3d9 85 56              STA TMPPTA+1
c3db a8                 TAY
c3dc 8a                 TXA
c3dd 65 55              ADC TMPPTA
c3df 90 03              BCC FiAr_55
c3e1 c8                 INY
c3e2 f0 52              BEQ FiAr_76           ; -> out of memory
c3e4 20 a0 b3 FiAr_55   JSR Check_Mem_Avail
c3e7 85 2e              STA STREND
c3e9 84 2f              STY STREND+1        ; new top of array area
c3eb a9 00              LDA #0              ; zero array content
c3ed e6 6f              INC TMPPTD+1        ; size high
c3ef a4 6e              LDY TMPPTD          ; Y = size low
c3f1 f0 05              BEQ FiAr_65
c3f3 88       FiAr_60   DEY
c3f4 91 55              STA (TMPPTA),Y      ; clear array
c3f6 d0 fb              BNE FiAr_60
c3f8 c6 56    FiAr_65   DEC TMPPTA+1
c3fa c6 6f              DEC TMPPTD+1
c3fc d0 f5              BNE FiAr_60
c3fe e6 56              INC TMPPTA+1
c400 38                 SEC
c401 a5 2e              LDA STREND
c403 e5 5c              SBC TMPPTC
c405 a0 02              LDY #2
c407 91 5c              STA (TMPPTC),Y      ; store array size low
c409 a5 2f              LDA STREND+1
c40b c8                 INY                 ; Y = 3
c40c e5 5d              SBC TMPPTC+1
c40e 91 5c              STA (TMPPTC),Y      ; store array size high
c410 a5 06              LDA DIMFLG
c412 d0 62              BNE FiAr_Ret
c414 c8                 INY                 ; Y = 4
c415 b1 5c    FiAr_70   LDA (TMPPTC),Y      ; # of dimensions
c417 85 05              STA COUNT
c419 a9 00              LDA #0
c41b 85 6e              STA TMPPTD          ; TMPPTD = 0
c41d 85 6f    FiAr_72   STA TMPPTD+1
c41f c8                 INY                 ; Y = 5,7,...
c420 68                 PLA
c421 aa                 TAX
c422 85 61              STA FAC1M3
c424 68                 PLA
c425 85 62              STA FAC1M4          ; FAC1M3/4 = subscript
c427 d1 5c              CMP (TMPPTC),Y      ; compare with dimension high
c429 90 0e              BCC FiAr_78         ; -> lower
c42b d0 06              BNE FiAr_74         ; greater -> out of range
c42d c8                 INY                 ; Y = 6,8,...
c42e 8a                 TXA
c42f d1 5c              CMP (TMPPTC),Y      ; compare with dimension low
c431 90 07              BCC FiAr_80         ; -> lower
c433 4c 70 c3 FiAr_74   JMP Bad_Subscript
c436 4c cd b3 FiAr_76   JMP Error_Out_Of_Memory
c439 c8       FiAr_78   INY                 ; Y = 6,8,...
c43a a5 6f    FiAr_80   LDA TMPPTD+1
c43c 05 6e              ORA TMPPTD
c43e 18                 CLC
c43f f0 0a              BEQ FiAr_82         ; TMPPTD == 0 ?
c441 20 77 c4           JSR Mult_16x16
c444 8a                 TXA
c445 65 61              ADC FAC1M3
c447 aa                 TAX
c448 98                 TYA
c449 a4 1f              LDY INDEXA
c44b 65 62    FiAr_82   ADC FAC1M4
c44d 86 6e              STX TMPPTD
c44f c6 05              DEC COUNT
c451 d0 ca              BNE FiAr_72         ; next subscript
c453 85 6f              STA TMPPTD+1
c455 a2 05              LDX #5              ; standard item size (REAL)
c457 a5 42              LDA VARNAM
c459 10 01              BPL FiAr_84         ; -> REAL or STRING
c45b ca                 DEX                 ; X = 4
c45c a5 43    FiAr_84   LDA VARNAM+1
c45e 10 02              BPL FiAr_86         ; -> REAL
c460 ca                 DEX
c461 ca                 DEX                 ; X = 2
c462 86 25    FiAr_86   STX FAC3M3          ; item size (I=2, S=3, R=5)
c464 a9 00              LDA #0
c466 20 80 c4           JSR Mult_16x16_A    ; # of items * item size
c469 8a                 TXA
c46a 65 55              ADC TMPPTA
c46c 85 44              STA VARPTR
c46e 98                 TYA
c46f 65 56              ADC TMPPTA+1
c471 85 45              STA VARPTR+1        ; VARPTR = array element
c473 a8                 TAY
c474 a5 44              LDA VARPTR          ; (A/Y) = VARPTR
c476 60       FiAr_Ret  RTS ;Size  379 [Find_Array]

c477                    .FILL $c477-* (0) ; 0 bytes

              ; ******************
c477            Mult_16x16 ; $c477
              ; ******************

c477 84 1f              STY INDEXA
c479 b1 5c              LDA (TMPPTC),Y
c47b 85 25              STA FAC3M3
c47d 88                 DEY
c47e b1 5c              LDA (TMPPTC),Y

              ; ************
c480            Mult_16x16_A
              ; ************

c480 85 26              STA FAC3M4          ; FAC3M3/3 = Dimension
c482 a9 10              LDA #16
c484 85 5a              STA TMPVAR          ; 16 bit multiplication
c486 a2 00              LDX #0
c488 a0 00              LDY #0
c48a 8a       Mu16_10   TXA                 ; (X/Y) = FAC3M3 * TMPPTD
c48b 0a                 ASL A
c48c aa                 TAX
c48d 98                 TYA
c48e 2a                 ROL A
c48f a8                 TAY
c490 b0 a4              BCS FiAr_76
c492 06 6e              ASL TMPPTD
c494 26 6f              ROL TMPPTD+1
c496 90 0b              BCC Mu16_20
c498 18                 CLC
c499 8a                 TXA
c49a 65 25              ADC FAC3M3
c49c aa                 TAX
c49d 98                 TYA
c49e 65 26              ADC FAC3M4
c4a0 a8                 TAY
c4a1 b0 93              BCS FiAr_76
c4a3 c6 5a    Mu16_20   DEC TMPVAR          ; next bit
c4a5 d0 e3              BNE Mu16_10
c4a7 60                 RTS ;Size   40 [Mult_16x16_A]

              ; *****************
c4a8            Basic_FRE ; $c4a8
              ; *****************

c4a8 a5 07              LDA VALTYP
c4aa f0 03              BEQ FRE_10          ; -> numeric argument
c4ac 20 b8 c7           JSR Free_String_FAC1
c4af 20 6a c6 FRE_10    JSR Garbage_Collection
c4b2 38                 SEC
c4b3 a5 30              LDA FRETOP
c4b5 e5 2e              SBC STREND
c4b7 a8                 TAY
c4b8 a5 31              LDA FRETOP+1
c4ba e5 2f              SBC STREND+1

              ; **********
c4bc            AY_To_Real
              ; **********

c4bc a2 00              LDX #0
c4be 86 07              STX VALTYP          ; numeric result
c4c0 85 5f              STA FAC1M1
c4c2 84 60              STY FAC1M2
c4c4 a2 90              LDX #$90            ; exponent
c4c6 4c 7a cd           JMP ATOF_10

              ; *****************
c4c9            Basic_POS ; $c4c9
              ; *****************

c4c9 a4 c6              LDY CursorCol

              ; **********
c4cb            Y_To_Float
              ; **********

c4cb a9 00              LDA #0
c4cd f0 ed              BEQ AY_To_Real      ; always

              ; *****************
c4cf            Assert_Non_Direct
              ; *****************

c4cf a6 37              LDX CURLIN+1
c4d1 e8                 INX
c4d2 d0 a2              BNE FiAr_Ret
c4d4 a2 95              LDX #[Msg_DIREC - Msg_Start] ; $95
c4d6 2c                 .BYTE $2c

              ; ******************
c4d7            Undefined_Function
              ; ******************

c4d7 a2 e9              LDX #[Msg_FUNC - Msg_Start] ; $e9
c4d9 4c cf b3           JMP Basic_Error

              ; *****************
c4dc            Basic_DEF ; $c4dc
              ; *****************

c4dc 20 0a c5           JSR Get_FN          ; read function name
c4df 20 cf c4           JSR Assert_Non_Direct
c4e2 20 f2 be           JSR Need_Left_Parenthesis
c4e5 a9 80              LDA #$80
c4e7 85 0a              STA SUBFLG          ; no integer function
c4e9 20 2b c1           JSR Parse_Name
c4ec 20 87 bd           JSR Is_Numeric      ; only numeric arguments
c4ef 20 ef be           JSR Need_Right_Parenthesis
c4f2 a9 b2              LDA #$b2            ; '=' token
c4f4 20 f7 be           JSR Need_A
c4f7 48                 PHA
c4f8 a5 45              LDA VARPTR+1
c4fa 48                 PHA
c4fb a5 44              LDA VARPTR          ; push function argument address
c4fd 48                 PHA
c4fe a5 78              LDA TXTPTR+1
c500 48                 PHA
c501 a5 77              LDA TXTPTR          ; push function address
c503 48                 PHA
c504 20 83 b8           JSR Basic_DATA      ; skip to next statement
c507 4c 75 c5           JMP FNX_30           ; pull and store attributes

              ; ******
c50a            Get_FN
              ; ******

c50a a9 a5              LDA #$a5            ; FN token
c50c 20 f7 be           JSR Need_A
c50f 09 80              ORA #$80
c511 85 0a              STA SUBFLG          ; no integer function
c513 20 32 c1           JSR Get_FN_Address
c516 85 4b              STA FUNCPT
c518 84 4c              STY FUNCPT+1
c51a 4c 87 bd           JMP Is_Numeric

              ; ********
c51d            Eval_FNX
              ; ********

c51d 20 0a c5           JSR Get_FN          ; address of function descriptor
c520 48                 PHA                 ; push FUNCPT
c521 98                 TYA
c522 48                 PHA                 ; push FUNCPT+1
c523 20 e9 be           JSR Eval_In_Parenthesis
c526 20 87 bd           JSR Is_Numeric      ; force numeric argument
c529 68                 PLA
c52a 85 4c              STA FUNCPT+1
c52c 68                 PLA
c52d 85 4b              STA FUNCPT          ; restore function descriptor
c52f a0 02              LDY #2
c531 b1 4b              LDA (FUNCPT),Y
c533 85 44              STA VARPTR
c535 aa                 TAX
c536 c8                 INY                 ; Y = 3
c537 b1 4b              LDA (FUNCPT),Y
c539 f0 9c              BEQ Undefined_Function
c53b 85 45              STA VARPTR+1        ; VARPTR = address of argument variable
c53d c8                 INY                 ; Y = 4
c53e b1 44    FNX_10    LDA (VARPTR),Y      ; push value of variable (5 bytes)
c540 48                 PHA
c541 88                 DEY
c542 10 fa              BPL FNX_10
c544 a4 45              LDY VARPTR+1
c546 20 0a cd           JSR FAC1_To_XY      ; (X/Y) = VARPTR - Y=0 on return
c549 a5 78              LDA TXTPTR+1
c54b 48                 PHA
c54c a5 77              LDA TXTPTR
c54e 48                 PHA                 ; push TXTPTR
c54f b1 4b              LDA (FUNCPT),Y
c551 85 77              STA TXTPTR
c553 c8                 INY                 ; Y = 1
c554 b1 4b              LDA (FUNCPT),Y
c556 85 78              STA TXTPTR+1        ; TXTPTR = function body
c558 a5 45              LDA VARPTR+1
c55a 48                 PHA
c55b a5 44              LDA VARPTR
c55d 48                 PHA                 ; push VARPTR
c55e 20 84 bd           JSR Eval_Numeric    ; execute function body
c561 68                 PLA
c562 85 4b              STA FUNCPT
c564 68                 PLA
c565 85 4c              STA FUNCPT+1        ; FUNCPT = VARPTR
c567 20 76 00           JSR CHRGOT
c56a f0 03              BEQ FNX_20
c56c 4c 00 bf           JMP Syntax_Error     ; function did not end properly
c56f 68       FNX_20    PLA
c570 85 77              STA TXTPTR
c572 68                 PLA
c573 85 78              STA TXTPTR+1         ; restore execution pointer
c575 a0 00    FNX_30    LDY #0               ; restore value of argument variable
c577 68                 PLA
c578 91 4b              STA (FUNCPT),Y
c57a 68                 PLA
c57b c8                 INY
c57c 91 4b              STA (FUNCPT),Y
c57e 68                 PLA
c57f c8                 INY
c580 91 4b              STA (FUNCPT),Y
c582 68                 PLA
c583 c8                 INY
c584 91 4b              STA (FUNCPT),Y
c586 68                 PLA
c587 c8                 INY
c588 91 4b              STA (FUNCPT),Y
c58a 60                 RTS ;Size  110 [Eval_FNX]

c58b 00 00 00           .FILL $c58e-* (0) ; 3 bytes

              ; *****************
c58e            Basic_STR ; $c58e
              ; *****************

c58e 20 87 bd           JSR Is_Numeric
c591 a0 00              LDY #0
c593 20 95 cf           JSR Format_FAC1_Y
c596 68                 PLA
c597 68                 PLA
c598 a9 ff    STR_10    LDA #<STACK-1
c59a a0 00              LDY #>STACK-1
c59c f0 12              BEQ Create_String_Descriptor

              ; ********************
c59e            Allocate_String_FAC1
              ; ********************

c59e a6 61              LDX FAC1M3
c5a0 a4 62              LDY FAC1M4
c5a2 86 4d              STX DESCPT
c5a4 84 4e              STY DESCPT+1

              ; *****************
c5a6            Allocate_String_A
              ; *****************

c5a6 20 1d c6           JSR Allocate_String_Space
c5a9 86 5f              STX FAC1M1          ; addres low
c5ab 84 60              STY FAC1M2          ; address high
c5ad 85 5e              STA FAC1EX          ; length
c5af 60                 RTS ;Size   10 [Allocate_String_A]

              ; ************************
c5b0            Create_String_Descriptor
              ; ************************

c5b0 a2 22              LDX #QUOTE          ; quote is the only valid delimiter
c5b2 86 03              STX CHARAC
c5b4 86 04              STX ENDCHR

              ; ***************************
c5b6            Create_String_Descriptor_AY
              ; ***************************

c5b6 85 6c              STA STRPTR
c5b8 84 6d              STY STRPTR+1        ; set STRPTR from (A/Y)
c5ba 85 5f              STA FAC1M1
c5bc 84 60              STY FAC1M2          ; set FAC1M1 from (A/Y)
c5be a0 ff              LDY #-1             ; start loop with 0
c5c0 c8       CSD_10    INY
c5c1 b1 6c              LDA (STRPTR),Y
c5c3 f0 0c              BEQ CSD_30          ; end of string
c5c5 c5 03              CMP CHARAC          ; closing delimiter
c5c7 f0 04              BEQ CSD_20
c5c9 c5 04              CMP ENDCHR
c5cb d0 f3              BNE CSD_10          ; loop
c5cd c9 22    CSD_20    CMP #QUOTE
c5cf f0 01              BEQ CSD_40
c5d1 18       CSD_30    CLC
c5d2 84 5e    CSD_40    STY FAC1EX          ; string length
c5d4 98                 TYA
c5d5 65 6c              ADC STRPTR          ; TMPPTD = STRPTR + strlen
c5d7 85 6e              STA TMPPTD
c5d9 a6 6d              LDX STRPTR+1
c5db 90 01              BCC CSD_50
c5dd e8                 INX
c5de 86 6f    CSD_50    STX TMPPTD+1
c5e0 a5 6d              LDA STRPTR+1
c5e2 f0 04              BEQ CSD_60          ; -> allocate if on ZP
c5e4 c9 02              CMP #2              ; -> allocate if in buffer
c5e6 d0 0b              BNE Push_String_Descriptor
c5e8 98       CSD_60    TYA                 ; A = length
c5e9 20 9e c5           JSR Allocate_String_FAC1
c5ec a6 6c              LDX STRPTR
c5ee a4 6d              LDY STRPTR+1
c5f0 20 9a c7           JSR Store_String_XY ; Copy string from (X/Y) to (FRESPC)

              ; **********************
c5f3            Push_String_Descriptor
              ; **********************

c5f3 a6 13              LDX TEMPPT
c5f5 e0 1f              CPX #TEMPST+9       ; top of temp string descriptors
c5f7 d0 05              BNE PuSD_10
c5f9 a2 c8              LDX #Msg_COMPL-Msg_Start ; $c8 FORMULA TOO COMPLEX
c5fb 4c cf b3 PuSD_Err  JMP Basic_Error
c5fe a5 5e    PuSD_10   LDA FAC1EX          ; push FAC1 descriptor
c600 95 00              STA 0,X
c602 a5 5f              LDA FAC1M1
c604 95 01              STA 1,X
c606 a5 60              LDA FAC1M2
c608 95 02              STA 2,X
c60a a0 00              LDY #0
c60c 86 61              STX FAC1M3          ; mark stack position
c60e 84 62              STY FAC1M4
c610 84 6d              STY FROUND
c612 88                 DEY                 ; Y = $ff
c613 84 07              STY VALTYP          ; type = string
c615 86 14              STX LASTPT          ; remember last used position
c617 e8                 INX
c618 e8                 INX
c619 e8                 INX
c61a 86 13              STX TEMPPT          ; increase string stack pointer
c61c 60                 RTS ;Size   42 [Push_String_Descriptor]

              ; *****************************
c61d            Allocate_String_Space ; $c61d
              ; *****************************

              ; Input:  A = length of string

              ; Output: A = length of string
              ;         X = address low
              ;         Y = address high

c61d 46 09              LSR GARBFL          ; clear bit 7 of GARBFL
c61f aa       ASS_10    TAX                 ; string length
c620 f0 38              BEQ ASS_50          ; 0 : nothing to do
c622 48                 PHA                 ; save length
c623 38                 SEC
c624 a5 30              LDA FRETOP
c626 e9 02              SBC #2
c628 85 1f              STA INDEXA
c62a a5 31              LDA FRETOP+1
c62c e9 00              SBC #0
c62e 85 20              STA INDEXA+1        ; INDEXA = FRETOP - 2
c630 a8                 TAY                 ; Y = INDEXA+1
c631 8a                 TXA                 ; A = length
c632 49 ff              EOR #$ff
c634 38                 SEC                 ; add -length
c635 65 1f              ADC INDEXA          ; (A/Y) = INDEXA - length
c637 b0 01              BCS ASS_30
c639 88                 DEY
c63a c4 2f    ASS_30    CPY STREND+1
c63c 90 1d              BCC ASS_60          ; OOM: try garbage collection
c63e d0 04              BNE ASS_40
c640 c5 2e              CMP STREND
c642 90 17              BCC ASS_60          ; OOM: try garbage collection
c644 85 32    ASS_40    STA FRESPC
c646 84 33              STY FRESPC+1        ; FRESPC = INDEXA - length
c648 a0 01              LDY #1
c64a a9 ff              LDA #$ff
c64c 91 1f              STA (INDEXA),Y      ; mark as unassigned
c64e 88                 DEY                 ; Y = 0
c64f 68                 PLA
c650 91 1f              STA (INDEXA),Y      ; store length
c652 a6 32              LDX FRESPC
c654 a4 33              LDY FRESPC+1
c656 86 30              STX FRETOP
c658 84 31              STY FRETOP+1        ; FRETOP = FRESPC
c65a 60       ASS_50    RTS ;Size   62 [Allocate_String_Space]
c65b a2 4d    ASS_60    LDX #[Msg_OOM - Msg_Start] ; $4d
c65d a5 09              LDA GARBFL
c65f 30 9a              BMI PuSD_Err           ; -> Out Of Memory
c661 20 6a c6           JSR Garbage_Collection
c664 38                 SEC
c665 66 09              ROR GARBFL          ; mark: collection done
c667 68                 PLA                 ; length
c668 d0 b5              BNE ASS_10          ; always

c66a                    .FILL $c66a-* (0) ; 0 bytes

              ; **************************
c66a            Garbage_Collection ; $c66a
              ; **************************

c66a a5 34              LDA MEMSIZ
c66c 85 32              STA FRESPC          ; new location of string
c66e 85 4b              STA FUNCPT          ; old location of string
c670 a5 35              LDA MEMSIZ+1
c672 85 33              STA FRESPC+1
c674 85 4c              STA FUNCPT+1

c676 a5 30    GaCo_05   LDA FRETOP          ; if (FRETOP >= FUNCPT)
c678 c5 4b              CMP FUNCPT
c67a a5 31              LDA FRETOP+1
c67c e5 4c              SBC FUNCPT+1
c67e b0 6b              BCS GaCo_45         ; finish

c680 a5 4b              LDA FUNCPT
c682 e9 01              SBC #1              ; subtract 2 (C=0)
c684 85 4b              STA FUNCPT
c686 b0 02              BCS GaCo_10
c688 c6 4c              DEC FUNCPT+1        ; FUNCPT -= 2

c68a a0 01    GaCo_10   LDY #1
c68c b1 4b              LDA (FUNCPT),Y      ; reference high
c68e 88                 DEY                 ; Y = 0
c68f c9 ff              CMP #$ff            ; obsolete flag
c691 d0 0c              BNE GaCo_15         ; branch to string copy
c693 a5 4b              LDA FUNCPT          ; C = 1 from CMP #$ff
c695 f1 4b              SBC (FUNCPT),Y      ; subtract length
c697 85 4b              STA FUNCPT
c699 b0 db              BCS GaCo_05         ; loop
c69b c6 4c              DEC FUNCPT+1
c69d d0 d7              BNE GaCo_05         ; loop always

c69f 85 20    GaCo_15   STA INDEXA+1        ; reference high
c6a1 b1 4b              LDA (FUNCPT),Y
c6a3 85 1f              STA INDEXA          ; reference low
c6a5 38                 SEC
c6a6 a5 4b              LDA FUNCPT
c6a8 f1 1f              SBC (INDEXA),Y      ; subtract length
c6aa 85 4b              STA FUNCPT
c6ac b0 02              BCS GaCo_20
c6ae c6 4c              DEC FUNCPT+1        ; FUNCPT -= length

c6b0 a5 32    GaCo_20   LDA FRESPC
c6b2 d0 02              BNE GaCo_25
c6b4 c6 33              DEC FRESPC+1
c6b6 c6 32    GaCo_25   DEC FRESPC          ; FRESPC--

c6b8 a5 20              LDA INDEXA+1        ; reference high
c6ba 91 32              STA (FRESPC),Y
c6bc 18                 CLC
c6bd a5 32              LDA FRESPC
c6bf f1 1f              SBC (INDEXA),Y      ; subtract length + borrow
c6c1 85 32              STA FRESPC
c6c3 b0 02              BCS GaCo_30
c6c5 c6 33              DEC FRESPC+1        ; FRESPC -= (length+1)

c6c7 c5 4b    GaCo_30   CMP FUNCPT          ; if (FRESPC == FUNCPT)
c6c9 d0 06              BNE GaCo_35         ; copy
c6cb a5 33              LDA FRESPC+1
c6cd c5 4c              CMP FUNCPT+1
c6cf f0 a5              BEQ GaCo_05         ; loop

c6d1 b1 1f    GaCo_35   LDA (INDEXA),Y      ; length
c6d3 a8                 TAY
c6d4 b1 4b    GaCo_40   LDA (FUNCPT),Y      ; copy string & low reference
c6d6 91 32              STA (FRESPC),Y
c6d8 88                 DEY
c6d9 d0 f9              BNE GaCo_40
c6db b1 4b              LDA (FUNCPT),Y
c6dd 91 32              STA (FRESPC),Y
c6df c8                 INY                 ; Y = 1
c6e0 a5 32              LDA FRESPC          ; store new reference
c6e2 91 1f              STA (INDEXA),Y
c6e4 c8                 INY
c6e5 a5 33              LDA FRESPC+1
c6e7 91 1f              STA (INDEXA),Y
c6e9 d0 8b              BNE GaCo_05         ; loop always
c6eb a5 32    GaCo_45   LDA FRESPC
c6ed 85 30              STA FRETOP
c6ef a5 33              LDA FRESPC+1
c6f1 85 31              STA FRETOP+1
c6f3 60                 RTS ;Size  138 [Garbage_Collection]

              ; ********
c6f4            FAC1_LSB
              ; ********

c6f4 a2 5e              LDX #FAC1EX
c6f6 a0 00    FACX_LSB  LDY #0
c6f8 84 65              STY BITS
c6fa c9 f9    FACB_10   CMP #-7
c6fc b0 1e              BCS FACB_Ret
c6fe a8                 TAY
c6ff b5 04              LDA 4,X
c701 85 6d              STA FROUND
c703 05 65              ORA BITS
c705 85 65              STA BITS
c707 b5 03              LDA 3,X
c709 95 04              STA 4,X
c70b b5 02              LDA 2,X
c70d 95 03              STA 3,X
c70f b5 01              LDA 1,X
c711 95 02              STA 2,X
c713 a9 00              LDA #0
c715 95 01              STA 1,X
c717 98                 TYA
c718 69 08              ADC #8
c71a d0 de              BNE FACB_10
c71c a8       FACB_Ret  TAY
c71d 60                 RTS ;Size   42 [FAC1_LSB]

c71e 00 00 00           .FILL $c74f-* (0) ; 49 bytes

              ; *******************
c74f            Concatenate ; $c74f
              ; *******************

c74f a5 62              LDA FAC1M4
c751 48                 PHA
c752 a5 61              LDA FAC1M3
c754 48                 PHA
c755 20 7e be           JSR Evaluate
c758 20 89 bd           JSR Is_String
c75b 68                 PLA
c75c 85 6c              STA STRPTR
c75e 68                 PLA
c75f 85 6d              STA STRPTR+1
c761 a0 00              LDY #0
c763 b1 6c              LDA (STRPTR),Y
c765 18                 CLC
c766 71 61              ADC (FAC1M3),Y
c768 90 05              BCC Conc_10
c76a a2 b0              LDX #Msg_LONG-Msg_Start ; $b0 STRING TOO LONG
c76c 4c cf b3           JMP Basic_Error
c76f 20 9e c5 Conc_10   JSR Allocate_String_FAC1
c772 20 8c c7           JSR Store_String_STRPTR ; store first part
c775 a5 4d              LDA DESCPT
c777 a4 4e              LDY DESCPT+1
c779 20 bc c7           JSR Free_String_AY
c77c 20 9e c7           JSR Store_String_INDEXA ; store second part
c77f a5 6c              LDA STRPTR
c781 a4 6d              LDY STRPTR+1
c783 20 bc c7           JSR Free_String_AY
c786 20 f3 c5           JSR Push_String_Descriptor
c789 4c b0 bd           JMP EvEx_15

              ; *******************
c78c            Store_String_STRPTR
              ; *******************

c78c a0 00              LDY #0
c78e b1 6c              LDA (STRPTR),Y      ; A = length
c790 48                 PHA
c791 c8                 INY
c792 b1 6c              LDA (STRPTR),Y      ; X = address low
c794 aa                 TAX
c795 c8                 INY
c796 b1 6c              LDA (STRPTR),Y      ; Y = address high
c798 a8                 TAY
c799 68                 PLA

              ; ***************
c79a            Store_String_XY
              ; ***************

c79a 86 1f              STX INDEXA
c79c 84 20              STY INDEXA+1

              ; ***************************
c79e            Store_String_INDEXA ; $c79e
              ; ***************************

c79e a8                 TAY
c79f f0 13              BEQ SSI_Ret
c7a1 48                 PHA
c7a2 88       SSI_10    DEY
c7a3 b1 1f              LDA (INDEXA),Y
c7a5 91 32              STA (FRESPC),Y
c7a7 98                 TYA
c7a8 d0 f8              BNE SSI_10
c7aa 68                 PLA
c7ab 18                 CLC
c7ac 65 32              ADC FRESPC          ; FRESPC += length
c7ae 85 32              STA FRESPC          ; (used by Concatenate)
c7b0 90 02              BCC SSI_Ret
c7b2 e6 33              INC FRESPC+1
c7b4 60       SSI_Ret   RTS ;Size   23 [Store_String_INDEXA]

              ; ****************************
c7b5            Eval_And_Free_String ; $c7b5
              ; ****************************

c7b5 20 89 bd           JSR Is_String

              ; ****************
c7b8            Free_String_FAC1
              ; ****************

c7b8 a5 61              LDA FAC1M3
c7ba a4 62              LDY FAC1M4

              ; **********************
c7bc            Free_String_AY ; $c7bc
              ; **********************

              ; Input:  (A/Y) = pointer to descriptor
              ; Output: (X/Y) = INDEXA = pointer to string
              ;         A     = length

c7bc 85 1f              STA INDEXA
c7be 84 20              STY INDEXA+1        ; INDEXA = pointer to descriptor
c7c0 20 11 c8           JSR Pop_Descriptor_Stack
c7c3 d0 28              BNE GSD_40          ; -> load if not temporary
c7c5 20 3d ba           JSR Back_Reference_Position
c7c8 90 23              BCC GSD_40          ; -> branch if not dynamic string
c7ca a9 ff              LDA #$ff
c7cc 91 4f              STA (INDEXC),Y      ; invalidate string
c7ce 88                 DEY                 ; Y = 0
c7cf 8a                 TXA
c7d0 91 4f              STA (INDEXC),Y      ; store length
c7d2 a6 1f              LDX INDEXA
c7d4 a4 20              LDY INDEXA+1
c7d6 c4 31              CPY FRETOP+1
c7d8 d0 25              BNE GSD_Ret
c7da e4 30              CPX FRETOP
c7dc d0 21              BNE GSD_Ret         ; return if INDEXA != FRETOP
c7de 48                 PHA                 ; push length
c7df a5 4f              LDA INDEXC
c7e1 69 01              ADC #1              ; add 2 (1 + carry)
c7e3 85 30              STA FRETOP
c7e5 a5 50              LDA INDEXC+1
c7e7 69 00              ADC #0
c7e9 85 31              STA FRETOP+1
c7eb 68                 PLA
c7ec 60                 RTS ;Size   49 [Free_String_AY]
c7ed a0 00    GSD_40    LDY #0              ; load descriptor from pointer
c7ef b1 1f              LDA (INDEXA),Y
c7f1 48                 PHA
c7f2 c8                 INY
c7f3 b1 1f              LDA (INDEXA),Y
c7f5 aa                 TAX
c7f6 c8                 INY
c7f7 b1 1f              LDA (INDEXA),Y
c7f9 a8                 TAY
c7fa 86 1f              STX INDEXA
c7fc 84 20              STY INDEXA+1
c7fe 68                 PLA
c7ff 60       GSD_Ret   RTS ;Size   68 [Free_String_AY]

c800 00 00 00           .FILL $c811-* (0) ; 17 bytes

              ; ****************************
c811            Pop_Descriptor_Stack ; $c811
              ; ****************************

c811 c4 15              CPY LASTPT+1
c813 d0 0c              BNE PDS_Ret
c815 c5 14              CMP LASTPT
c817 d0 08              BNE PDS_Ret
c819 85 13              STA TEMPPT
c81b e9 03              SBC #3
c81d 85 14              STA LASTPT
c81f a0 00              LDY #0
c821 60       PDS_Ret   RTS ;Size   17 [Pop_Descriptor_Stack]

              ; *********
c822            Basic_CHR
              ; *********

c822 20 d7 c8           JSR Eval_Byte       ; get byte in X
c825 8a                 TXA
c826 48                 PHA
c827 a9 01              LDA #1
c829 20 a6 c5           JSR Allocate_String_A
c82c 68                 PLA
c82d a0 00              LDY #0
c82f 91 5f              STA (FAC1M1),Y
c831 68                 PLA
c832 68                 PLA
c833 4c f3 c5           JMP Push_String_Descriptor

              ; **********
c836            Basic_LEFT
              ; **********

c836 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c839 d1 4d              CMP (DESCPT),Y      ; compare argument with length
c83b 98                 TYA                 ; A = 0
c83c 90 04    LEFT_10   BCC LEFT_20         ; branch if arg < length
c83e b1 4d              LDA (DESCPT),Y      ; get total length
c840 aa                 TAX                 ; string length
c841 98                 TYA                 ; A = 0
c842 48       LEFT_20   PHA                 ; push start index (0 for LEFT$)
c843 8a       LEFT_30   TXA                 ; A  = new length
c844 48       LEFT_40   PHA                 ; push new length
c845 20 a6 c5           JSR Allocate_String_A
c848 a5 4d              LDA DESCPT
c84a a4 4e              LDY DESCPT+1
c84c 20 bc c7           JSR Free_String_AY  ; free string argument
c84f 68                 PLA
c850 a8                 TAY                 ; Y = length
c851 68                 PLA                 ; A = start index
c852 18                 CLC
c853 65 1f              ADC INDEXA
c855 85 1f              STA INDEXA
c857 90 02              BCC LEFT_50
c859 e6 20              INC INDEXA+1        ; INDEX += start index
c85b 98       LEFT_50   TYA                 ; new length
c85c 20 9e c7           JSR Store_String_INDEXA
c85f 4c f3 c5           JMP Push_String_Descriptor

              ; ***********
c862            Basic_RIGHT
              ; ***********

c862 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c865 18                 CLC
c866 f1 4d              SBC (DESCPT),Y      ; argument - length
c868 49 ff              EOR #$ff            ; length - argument
c86a 4c 3c c8           JMP LEFT_10         ; share code with LEFT$

              ; *********
c86d            Basic_MID
              ; *********

c86d a9 ff              LDA #255            ; default value for 3rd. argument
c86f 85 62              STA FAC1M4
c871 20 76 00           JSR CHRGOT
c874 c9 29              CMP #')'
c876 f0 06              BEQ MID_10
c878 20 f5 be           JSR Need_Comma
c87b 20 d4 c8           JSR Get_Byte_Value  ; 3rd. argument to FAC1M4
c87e 20 97 c8 MID_10    JSR Pop_DESCPT      ; get string address and 2nd. argument
c881 f0 4b              BEQ ASC_Err         ; null string -> error
c883 ca                 DEX                 ; start index to offset
c884 8a                 TXA
c885 48                 PHA                 ; push offset
c886 18                 CLC
c887 a2 00              LDX #0
c889 f1 4d              SBC (DESCPT),Y      ; offset - length
c88b b0 b6              BCS LEFT_30
c88d 49 ff              EOR #$ff            ; length - offset
c88f c5 62              CMP FAC1M4
c891 90 b1              BCC LEFT_40         ; new length = rest of string
c893 a5 62              LDA FAC1M4          ; new length
c895 b0 ad              BCS LEFT_40         ; branch always

              ; **********
c897            Pop_DESCPT
              ; **********

c897 20 ef be           JSR Need_Right_Parenthesis
c89a 68                 PLA
c89b a8                 TAY                 ; return address low
c89c 68                 PLA
c89d 85 52              STA FUNJMP          ; return address high
c89f 68                 PLA
c8a0 68                 PLA
c8a1 68                 PLA
c8a2 aa                 TAX                 ; X = length
c8a3 68                 PLA
c8a4 85 4d              STA DESCPT
c8a6 68                 PLA
c8a7 85 4e              STA DESCPT+1        ; DESCPT = string address
c8a9 a5 52              LDA FUNJMP
c8ab 48                 PHA                 ; return address high
c8ac 98                 TYA
c8ad 48                 PHA                 ; return address low
c8ae a0 00              LDY #0
c8b0 8a                 TXA                 ; A = length
c8b1 60                 RTS ;Size   27 [Pop_DESCPT]

              ; *********
c8b2            Basic_LEN
              ; *********

c8b2 20 b8 c8           JSR Eval_String_Desc
c8b5 4c cb c4           JMP Y_To_Float

              ; ****************
c8b8            Eval_String_Desc
              ; ****************

c8b8 20 b5 c7           JSR Eval_And_Free_String
c8bb a2 00              LDX #0
c8bd 86 07              STX VALTYP
c8bf a8                 TAY
c8c0 60                 RTS ;Size    9 [Eval_String_Desc]

              ; *********
c8c1            Basic_ASC
              ; *********

c8c1 20 b8 c8           JSR Eval_String_Desc
c8c4 f0 05              BEQ ASC_10          ; ASC(""") was a syntax error in BASIC 4
c8c6 a0 00              LDY #0              ; here we return 0
c8c8 b1 1f              LDA (INDEXA),Y
c8ca a8                 TAY
c8cb 4c cb c4 ASC_10    JMP Y_To_Float
c8ce 4c 73 c3 ASC_Err   JMP Jump_To_Illegal_Quantity

c8d1                    .FILL $c8d1-* (0) ; 0 bytes

              ; ***************************
c8d1            Get_Next_Byte_Value ; $c8d1
              ; ***************************

c8d1 20 70 00           JSR CHRGET

              ; **************
c8d4            Get_Byte_Value
              ; **************

c8d4 20 84 bd           JSR Eval_Numeric

              ; *********
c8d7            Eval_Byte
              ; *********

c8d7 20 e3 c2           JSR Eval_Positive_Integer_Check
c8da a6 61              LDX FAC1M3
c8dc d0 f0              BNE ASC_Err
c8de a6 62              LDX FAC1M4
c8e0 4c 76 00           JMP CHRGOT

              ; *****************
c8e3            Basic_VAL ; $c8e3
              ; *****************

c8e3 20 b8 c8           JSR Eval_String_Desc
c8e6 d0 03              BNE VAL_10
c8e8 4c 2d ca           JMP Clear_FAC1
c8eb a6 77    VAL_10    LDX TXTPTR
c8ed a4 78              LDY TXTPTR+1
c8ef 86 6e              STX TMPPTD
c8f1 84 6f              STY TMPPTD+1        ; TMPPTD = TXTPTR
c8f3 a6 1f              LDX INDEXA
c8f5 86 77              STX TXTPTR
c8f7 18                 CLC
c8f8 65 1f              ADC INDEXA
c8fa 85 21              STA INDEXB
c8fc a6 20              LDX INDEXA+1
c8fe 86 78              STX TXTPTR+1        ; TXTPTR = INDEXA
c900 90 01              BCC VAL_20          ; INDEXB = INDEXA + length
c902 e8                 INX
c903 86 22    VAL_20    STX INDEXB+1
c905 a0 00              LDY #0
c907 b1 21              LDA (INDEXB),Y      ; back reference low
c909 48                 PHA
c90a 98                 TYA
c90b 91 21              STA (INDEXB),Y      ; add zero delimiter for CHRGET
c90d 20 76 00           JSR CHRGOT
c910 20 29 ce           JSR Read_Real_To_FAC1
c913 68                 PLA
c914 a0 00              LDY #0
c916 91 21              STA (INDEXB),Y      ; restore back reference low

              ; *************************
c918            Restore_Execution_Pointer
              ; *************************

c918 a6 6e              LDX TMPPTD
c91a a4 6f              LDY TMPPTD+1
c91c 86 77              STX TXTPTR
c91e 84 78              STY TXTPTR+1
c920 60                 RTS ;Size    9 [Restore_Execution_Pointer]

c921                    .FILL $c921-* (0) ; 0 bytes

              ; *************************
c921            Get_Word_And_Byte ; $c921
              ; *************************

c921 20 84 bd           JSR Eval_Numeric
c924 20 2d c9           JSR FAC1_To_LINNUM

              ; *******************
c927            Need_Comma_Get_Byte
              ; *******************

c927 20 f5 be           JSR Need_Comma
c92a 4c d4 c8           JMP Get_Byte_Value

              ; **************
c92d            FAC1_To_LINNUM
              ; **************

c92d a5 63              LDA FAC1SI
c92f 30 9d              BMI ASC_Err         ; only positive numbers
c931 a5 5e              LDA FAC1EX
c933 c9 91              CMP #$91
c935 b0 97              BCS ASC_Err         ; -> greater 65536
c937 20 d1 cd           JSR FAC1_LSR
c93a a5 61              LDA FAC1M3
c93c a4 62              LDY FAC1M4
c93e 84 11              STY LINNUM
c940 85 12              STA LINNUM+1
c942 60                 RTS ;Size   22 [FAC1_To_LINNUM]

              ; **********
c943            Basic_PEEK
              ; **********

c943 a5 12              LDA LINNUM+1
c945 48                 PHA
c946 a5 11              LDA LINNUM
c948 48                 PHA
c949 20 2d c9           JSR FAC1_To_LINNUM
c94c a0 00              LDY #0
c94e b1 11              LDA (LINNUM),Y
c950 a8                 TAY
c951 68                 PLA
c952 85 11              STA LINNUM
c954 68                 PLA
c955 85 12              STA LINNUM+1
c957 4c cb c4           JMP Y_To_Float

              ; **********
c95a            Basic_POKE
              ; **********

c95a 20 21 c9           JSR Get_Word_And_Byte
c95d 8a                 TXA
c95e a0 00              LDY #0
c960 91 11              STA (LINNUM),Y
c962 60                 RTS ;Size    9 [Basic_POKE]

              ; **********
c963            Basic_WAIT
              ; **********

c963 20 21 c9           JSR Get_Word_And_Byte
c966 86 46              STX FORPNT
c968 a2 00              LDX #0
c96a 20 76 00           JSR CHRGOT
c96d f0 03              BEQ WAIT_10
c96f 20 27 c9           JSR Need_Comma_Get_Byte
c972 86 47    WAIT_10   STX FORPNT+1
c974 a0 00              LDY #0
c976 b1 11    WAIT_20   LDA (LINNUM),Y
c978 45 47              EOR FORPNT+1
c97a 25 46              AND FORPNT
c97c f0 f8              BEQ WAIT_20
c97e 60       WAIT_Ret  RTS ;Size   28 [Basic_WAIT]

              ; ***************
c97f            Add_0_5_To_FAC1
              ; ***************

c97f a9 c7              LDA #<Float_0_5
c981 a0 d0              LDY #>Float_0_5
c983 4c 9d c9           JMP Add_Var_AY_To_FAC1

              ; *************
c986            AY_Minus_FAC1
              ; *************

c986 20 c2 cb           JSR Load_FAC2_From_AY

              ; ********
c989            Op_MINUS
              ; ********

c989 a5 63              LDA FAC1SI
c98b 49 ff              EOR #$ff
c98d 85 63              STA FAC1SI
c98f 45 6b              EOR FAC2SI
c991 85 6c              STA STRPTR          ; pos = ADD, neg = SUB
c993 a5 5e              LDA FAC1EX
c995 4c a0 c9           JMP Op_PLUS

c998 00 00 00           .FILL $c99d-* (0) ; 5 bytes

              ; ******************
c99d            Add_Var_AY_To_FAC1
              ; ******************

c99d 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***************
c9a0            Op_PLUS ; $c9a0
              ; ***************

c9a0 d0 03              BNE PLUS_10         ; -> branch if FAC1 is not 0
c9a2 4c 32 cd           JMP FAC2_To_FAC1    ; FAC1 = FAC2
c9a5 a6 6d    PLUS_10   LDX FROUND
c9a7 86 53              STX FUNJMP+1        ; copy rounding byte
c9a9 a2 66              LDX #FAC2EX         ; X points to FAC2
c9ab a5 66              LDA FAC2EX

              ; ***************************
c9ad            AddSub_FAC2_To_FAC1 ; $c9ad
              ; ***************************

              ; The mantissa of the FAC with the lower exponent is shifted
              ; right until both exponents become equal.

              ; Input:  A = exponent of FAC2
              ;         X = address  of FAC2
              ;         STRPTR ($00:Add, $80:Subtract)

              ; Output: FAC1 = FAC1 + FAC2 (for STRPTR == $00)
              ;         FAC1 = FAC1 - FAC2 (for STRPTR == $80)

c9ad a8                 TAY                 ; Y = exp 2
c9ae f0 ce              BEQ WAIT_Ret        ; return if FAC2 is zero
c9b0 38                 SEC
c9b1 e5 5e              SBC FAC1EX          ; A = exp 2 - exp 1
c9b3 f0 1b              BEQ AFTF_30         ; -> exponents are equal
c9b5 90 12              BCC AFTF_10         ; -> exp 2 < exp 1
c9b7 84 5e              STY FAC1EX          ; exp 1 = exp 2
c9b9 a4 6b              LDY FAC2SI
c9bb 84 63              STY FAC1SI          ; sign 1 = sign 2
c9bd 49 ff              EOR #$ff
c9bf 69 00              ADC #0              ; A = exp 1 - exp 2
c9c1 a0 00              LDY #0
c9c3 84 53              STY FUNJMP+1        ; clear FAC2 rounding byte
c9c5 a2 5e              LDX #FAC1EX         ; X points to FAC1
c9c7 d0 04              BNE AFTF_20         ; always
c9c9 a0 00    AFTF_10   LDY #0
c9cb 84 6d              STY FROUND          ; clear FAC1 rounding byte
c9cd 20 cf ca AFTF_20   JSR Shift_FACX_A
c9d0 24 6c    AFTF_30   BIT STRPTR          ; add or subtract ?
c9d2 10 60              BPL AFTF_60         ; -> add mantissa of FAC2 to FAC1
c9d4 a0 5e              LDY #FAC1EX
c9d6 e0 66              CPX #FAC2EX         ; if (X == FAC2) Y = FAC1
c9d8 f0 02              BEQ AFTF_40
c9da a0 66              LDY #FAC2EX         ; else           Y = FAC2
c9dc 38       AFTF_40   SEC
c9dd 49 ff              EOR #$ff            ; negate rounding byte
c9df 65 53              ADC FUNJMP+1
c9e1 85 6d              STA FROUND
c9e3 b9 04 00           LDA 4,Y
c9e6 f5 04              SBC 4,X
c9e8 85 62              STA FAC1M4
c9ea b9 03 00           LDA 3,Y
c9ed f5 03              SBC 3,X
c9ef 85 61              STA FAC1M3
c9f1 b9 02 00           LDA 2,Y
c9f4 f5 02              SBC 2,X
c9f6 85 60              STA FAC1M2
c9f8 b9 01 00           LDA 1,Y
c9fb f5 01              SBC 1,X
c9fd 85 5f              STA FAC1M1
c9ff b0 0c    AFTF_50   BCS Normalise_FAC1
ca01 20 7d ca           JSR Negate_FAC1
ca04 4c 0d ca           JMP Normalise_FAC1

ca07 00 00 00           .FILL $ca0d-* (0) ; 6 bytes

              ; **************
ca0d            Normalise_FAC1
              ; **************

ca0d a0 00              LDY #0              ; Y = 0
ca0f 98                 TYA                 ; A = 0
ca10 18                 CLC
ca11 a6 5f    NF1_10    LDX FAC1M1          ; MSB of mantissa
ca13 d0 4a              BNE AFTF_70         ; -> shift bitwise
ca15 a6 60              LDX FAC1M2          ; shift bytes
ca17 86 5f              STX FAC1M1
ca19 a6 61              LDX FAC1M3
ca1b 86 60              STX FAC1M2
ca1d a6 62              LDX FAC1M4
ca1f 86 61              STX FAC1M3
ca21 a6 6d              LDX FROUND
ca23 86 62              STX FAC1M4
ca25 84 6d              STY FROUND          ; = 0
ca27 69 08              ADC #8              ; A = shift count
ca29 c9 20              CMP #32             ; maximum shift = 32 bit
ca2b d0 e4              BNE NF1_10          ; loop

              ; **********
ca2d            Clear_FAC1
              ; **********

ca2d a9 00              LDA #0
ca2f 85 5e    CF1_10    STA FAC1EX
ca31 85 63              STA FAC1SI
ca33 60                 RTS ;Size    7 [Clear_FAC1]

ca34 65 53    AFTF_60   ADC FUNJMP+1        ; FAC1 rounding byte
ca36 85 6d              STA FROUND
ca38 a5 62              LDA FAC1M4          ; add FAC2 mantissa to FAC1
ca3a 65 6a              ADC FAC2M4
ca3c 85 62              STA FAC1M4
ca3e a5 61              LDA FAC1M3
ca40 65 69              ADC FAC2M3
ca42 85 61              STA FAC1M3
ca44 a5 60              LDA FAC1M2
ca46 65 68              ADC FAC2M2
ca48 85 60              STA FAC1M2
ca4a a5 5f              LDA FAC1M1
ca4c 65 67              ADC FAC2M1
ca4e 85 5f              STA FAC1M1
ca50 4c 6c ca           JMP Mantissa_Overflow

ca53 69 01    AFTF_65   ADC #1
ca55 06 6d              ASL FROUND
ca57 26 62              ROL FAC1M4
ca59 26 61              ROL FAC1M3
ca5b 26 60              ROL FAC1M2
ca5d 26 5f              ROL FAC1M1
ca5f 10 f2    AFTF_70   BPL AFTF_65
ca61 38                 SEC
ca62 e5 5e              SBC FAC1EX
ca64 b0 c7              BCS Clear_FAC1
ca66 49 ff              EOR #$ff
ca68 69 01              ADC #1
ca6a 85 5e              STA FAC1EX

              ; *****************
ca6c            Mantissa_Overflow
              ; *****************

ca6c 90 0e              BCC AFTF_Ret
ca6e e6 5e    AFTF_80   INC FAC1EX
ca70 f0 42              BEQ Overflow_Error
ca72 66 5f              ROR FAC1M1
ca74 66 60              ROR FAC1M2
ca76 66 61              ROR FAC1M3
ca78 66 62              ROR FAC1M4
ca7a 66 6d              ROR FROUND
ca7c 60       AFTF_Ret  RTS ;Size   17 [Mantissa_Overflow]

              ; ***********
ca7d            Negate_FAC1
              ; ***********

ca7d a5 63              LDA FAC1SI
ca7f 49 ff              EOR #$ff
ca81 85 63              STA FAC1SI

              ; ********************
ca83            Negate_FAC1_Mantissa
              ; ********************

ca83 a5 5f              LDA FAC1M1
ca85 49 ff              EOR #$ff
ca87 85 5f              STA FAC1M1
ca89 a5 60              LDA FAC1M2
ca8b 49 ff              EOR #$ff
ca8d 85 60              STA FAC1M2
ca8f a5 61              LDA FAC1M3
ca91 49 ff              EOR #$ff
ca93 85 61              STA FAC1M3
ca95 a5 62              LDA FAC1M4
ca97 49 ff              EOR #$ff
ca99 85 62              STA FAC1M4
ca9b a5 6d              LDA FROUND
ca9d 49 ff              EOR #$ff
ca9f 85 6d              STA FROUND
caa1 e6 6d              INC FROUND
caa3 d0 0e              BNE IFM_Ret

              ; *****************
caa5            Inc_FAC1_Mantissa
              ; *****************

caa5 e6 62              INC FAC1M4
caa7 d0 0a              BNE IFM_Ret
caa9 e6 61              INC FAC1M3
caab d0 06              BNE IFM_Ret
caad e6 60              INC FAC1M2
caaf d0 02              BNE IFM_Ret
cab1 e6 5f              INC FAC1M1
cab3 60       IFM_Ret   RTS ;Size   15 [Inc_FAC1_Mantissa]

              ; **************
cab4            Overflow_Error
              ; **************

cab4 a2 45              LDX #Msg_FLOW-Msg_Start ; $45 OVERFLOW
cab6 4c cf b3           JMP Basic_Error

              ; **********
cab9            Shift_FAC3
              ; **********

cab9 a5 26              LDA FAC3M4
cabb 85 6d              STA FROUND
cabd a5 25              LDA FAC3M3
cabf 85 26              STA FAC3M4
cac1 a5 24              LDA FAC3M2
cac3 85 25              STA FAC3M3
cac5 a5 23              LDA FAC3M1
cac7 85 24              STA FAC3M2
cac9 a9 00              LDA #0
cacb 85 23              STA FAC3M1
cacd 60                 RTS ;Size   21 [Shift_FAC3]

cace 00                 .FILL $cacf-* (0) ; 1 bytes

              ; perform a byte shift right on FAC X
              ; the LSB byte goes to FROUND

              ; ************
cacf            Shift_FACX_A
              ; ************

cacf 20 f6 c6           JSR FACX_LSB
cad2 a5 6d              LDA FROUND          ; byte shifted off
cad4 c0 00              CPY #0
cad6 10 0c              BPL SFA_40          ; return if done
cad8 56 01    SFA_10    LSR 1,X
cada 76 02              ROR 2,X
cadc 76 03              ROR 3,X
cade 76 04              ROR 4,X
cae0 6a                 ROR A               ; A gets bits shifted out
cae1 c8                 INY
cae2 d0 f4              BNE SFA_10
cae4 18       SFA_40    CLC
cae5 60                 RTS ;Size   23 [Shift_FACX_A]

cae6 00 00 00           .FILL $caf2-* (0) ; 12 bytes

              ; **************
caf2            REAL_1 ; $caf2
              ; **************

caf2 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000
caf7 03       VLOG_A    .BYTE $03
caf8 7f 5e 56 cb 79     .REAL $7f5e56cb79   ;    0.43425594189
cafd 80 13 9b 0b 64     .REAL $80139b0b64   ;    0.57658454124
cb02 80 76 38 93 16     .REAL $8076389316   ;    0.96180075919
cb07 82 38 aa 3b 20     .REAL $8238aa3b20   ;    2.88539007306

              ; ***********
cb0c            HALF_SQRT_2
              ; ***********

cb0c 80 35 04 f3 34     .REAL $803504f334   ;    0.70710678119
cb11 81 35 04 SQRT_2    .REAL $813504f334   ;    1.41421356238

              ; *********
cb16            MINUS_0_5
              ; *********

cb16 80 80 00 00 00     .REAL $8080000000   ;   -0.50000000000
cb1b 80 31 72 LN_2      .REAL $80317217f8   ;    0.69314718060

              ; *********
cb20            Basic_LOG
              ; *********

cb20 20 61 cd           JSR Get_FAC1_Sign
cb23 f0 02              BEQ LOG_10
cb25 10 03              BPL LOG_20
cb27 4c 73 c3 LOG_10    JMP Jump_To_Illegal_Quantity
cb2a a5 5e    LOG_20    LDA FAC1EX
cb2c e9 7f              SBC #$7f
cb2e 48                 PHA
cb2f a9 80              LDA #$80
cb31 85 5e              STA FAC1EX
cb33 a9 0c              LDA #<HALF_SQRT_2
cb35 a0 cb              LDY #>HALF_SQRT_2
cb37 20 9d c9           JSR Add_Var_AY_To_FAC1
cb3a a9 11              LDA #<SQRT_2
cb3c a0 cb              LDY #>SQRT_2
cb3e 20 45 cc           JSR AY_Divided_By_FAC1
cb41 a9 f2              LDA #<REAL_1
cb43 a0 ca              LDY #>REAL_1
cb45 20 86 c9           JSR AY_Minus_FAC1
cb48 a9 f7              LDA #<VLOG_A
cb4a a0 ca              LDY #>VLOG_A
cb4c 20 d7 d1           JSR Square_And_Series_Eval
cb4f a9 16              LDA #<MINUS_0_5
cb51 a0 cb              LDY #>MINUS_0_5
cb53 20 9d c9           JSR Add_Var_AY_To_FAC1
cb56 68                 PLA
cb57 20 b4 ce           JSR Add_A_To_FAC1
cb5a a9 1b              LDA #<LN_2
cb5c a0 cb              LDY #>LN_2

              ; *********************
cb5e            Multiply_FAC1_With_AY
              ; *********************

cb5e 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***********
cb61            Op_MULTIPLY
              ; ***********

cb61 f0 5b              BEQ MULT_Ret
cb63 20 ed cb           JSR Check_FAC
cb66 a9 00              LDA #0
cb68 85 23              STA FAC3M1
cb6a 85 24              STA FAC3M2
cb6c 85 25              STA FAC3M3
cb6e 85 26              STA FAC3M4
cb70 a5 6d              LDA FROUND
cb72 20 8c cb           JSR Mult_SubA
cb75 a5 62              LDA FAC1M4
cb77 20 8c cb           JSR Mult_SubA
cb7a a5 61              LDA FAC1M3
cb7c 20 8c cb           JSR Mult_SubA
cb7f a5 60              LDA FAC1M2
cb81 20 8c cb           JSR Mult_SubA
cb84 a5 5f              LDA FAC1M1
cb86 20 91 cb           JSR Mult_SubB
cb89 4c c5 cc           JMP FAC3_To_FAC1

              ; *********
cb8c            Mult_SubA
              ; *********

cb8c d0 03              BNE Mult_SubB       ; do multiply if A is not zero
cb8e 4c b9 ca           JMP Shift_FAC3      ; else shift FAC3 right 8 bits

              ; *********
cb91            Mult_SubB
              ; *********

cb91 4a                 LSR A
cb92 09 80              ORA #$80            ; make sure, that A remains not zero
cb94 a8       MULT_20   TAY                 ; until 8 shifts are done
cb95 90 19              BCC MULT_30
cb97 18                 CLC
cb98 a5 26              LDA FAC3M4
cb9a 65 6a              ADC FAC2M4
cb9c 85 26              STA FAC3M4
cb9e a5 25              LDA FAC3M3
cba0 65 69              ADC FAC2M3
cba2 85 25              STA FAC3M3
cba4 a5 24              LDA FAC3M2
cba6 65 68              ADC FAC2M2
cba8 85 24              STA FAC3M2
cbaa a5 23              LDA FAC3M1
cbac 65 67              ADC FAC2M1
cbae 85 23              STA FAC3M1
cbb0 66 23    MULT_30   ROR FAC3M1
cbb2 66 24              ROR FAC3M2
cbb4 66 25              ROR FAC3M3
cbb6 66 26              ROR FAC3M4
cbb8 66 6d              ROR FROUND
cbba 98                 TYA
cbbb 4a                 LSR A
cbbc d0 d6              BNE MULT_20
cbbe 60       MULT_Ret  RTS ;Size   46 [Mult_SubB]

cbbf 00 00 00           .FILL $cbc2-* (0) ; 3 bytes

              ; *************************
cbc2            Load_FAC2_From_AY ; $cbc2
              ; *************************

              ; Input:  (A/Y) = address of packed floating point value
              ; Output: FAC2  = read floating point value
              ;         A     = exponent of FAC1
              ;         Y     = 0

cbc2 85 1f              STA INDEXA
cbc4 84 20              STY INDEXA+1
cbc6 a0 04              LDY #4
cbc8 b1 1f              LDA (INDEXA),Y
cbca 85 6a              STA FAC2M4
cbcc 88                 DEY
cbcd b1 1f              LDA (INDEXA),Y
cbcf 85 69              STA FAC2M3
cbd1 88                 DEY
cbd2 b1 1f              LDA (INDEXA),Y
cbd4 85 68              STA FAC2M2
cbd6 88                 DEY
cbd7 b1 1f              LDA (INDEXA),Y      ; bit7 = sign
cbd9 85 6b              STA FAC2SI          ; transfer sign to FAC2SI bit7
cbdb 45 63              EOR FAC1SI          ; EOR with sign of FAC1
cbdd 85 6c              STA STRPTR          ; flag sign comparison
cbdf a5 6b              LDA FAC2SI          ; load sign/byte 1 of mantissa
cbe1 09 80              ORA #$80            ; replace sign with 1 (normalize)
cbe3 85 67              STA FAC2M1          ; M1 is now in unpacked mode
cbe5 88                 DEY
cbe6 b1 1f              LDA (INDEXA),Y      ; exponent
cbe8 85 66              STA FAC2EX
cbea a5 5e              LDA FAC1EX          ; return with FAC1 exp in A
cbec 60                 RTS ;Size   43 [Load_FAC2_From_AY]

              ; *********
cbed            Check_FAC
              ; *********

cbed a5 66              LDA FAC2EX
cbef f0 1c    ChFA_10   BEQ ChFA_50         ; -> set FAC1 = 0.0
cbf1 18                 CLC
cbf2 65 5e              ADC FAC1EX          ; (exp 1 + exp 2)
cbf4 90 04              BCC ChFA_20         ; -> no overflow
cbf6 30 1a              BMI ChFA_Err        ; -> overflow
cbf8 18                 CLC
cbf9 2c                 .BYTE $2c
cbfa 10 11    ChFA_20   BPL ChFA_50         ; -> underflow
cbfc 69 80              ADC #$80            ; correct bias
cbfe 85 5e              STA FAC1EX          ; exp 1 += exp 2
cc00 f0 02              BEQ ChFA_30
cc02 a5 6c              LDA STRPTR
cc04 85 63    ChFA_30   STA FAC1SI
cc06 60                 RTS ;Size   26 [Check_FAC]
cc07 a5 63    ChFA_40   LDA FAC1SI
cc09 49 ff              EOR #$ff
cc0b 30 05              BMI ChFA_Err
cc0d 68       ChFA_50   PLA
cc0e 68                 PLA
cc0f 4c 2d ca           JMP Clear_FAC1      ; underflow -> set FAC1 = 0.0
cc12 4c b4 ca ChFA_Err  JMP Overflow_Error  ; overflow  -> error

cc15 00 00 00           .FILL $cc18-* (0) ; 3 bytes

              ; ***************************
cc18            Multiply_FAC1_BY_10 ; $cc18
              ; ***************************

cc18 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2   ; FAC2 = FAC1
cc1b aa                 TAX                               ; A = Exponent
cc1c f0 10              BEQ Mul10_Ret
cc1e 18                 CLC
cc1f 69 02              ADC #2                            ; FAC2 *= 4
cc21 b0 ef              BCS ChFA_Err

              ; **************
cc23            Add_And_Double
              ; **************

cc23 a2 00              LDX #0
cc25 86 6c              STX STRPTR                        ; choose ADD
cc27 20 ad c9           JSR AddSub_FAC2_To_FAC1           ; FAC1 += FAC2   (*  5)
cc2a e6 5e              INC FAC1EX                        ; FAC1 *= 2      (* 10)
cc2c f0 e4              BEQ ChFA_Err
cc2e 60       Mul10_Ret RTS ;Size   12 [Add_And_Double]

              ; ********
cc2f            Float_10
              ; ********

cc2f 84 20 00 00 00     .REAL $8420000000   ;   10.00000000000

              ; *****************
cc34            Divide_FAC1_By_10
              ; *****************

cc34 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
cc37 a9 2f              LDA #<Float_10
cc39 a0 cc              LDY #>Float_10
cc3b a2 00              LDX #0

              ; *****************
cc3d            Divide_FAC2_By_AY
              ; *****************

cc3d 86 6c              STX STRPTR
cc3f 20 d8 cc           JSR Load_FAC1_AY
cc42 4c 48 cc           JMP Op_DIVIDE

              ; ******************
cc45            AY_Divided_By_FAC1
              ; ******************

cc45 20 c2 cb           JSR Load_FAC2_From_AY

              ; *********
cc48            Op_DIVIDE
              ; *********

cc48 f0 76              BEQ Divide_By_Zero
cc4a 20 51 cd           JSR Round_FAC1
cc4d a9 00              LDA #0
cc4f 38                 SEC
cc50 e5 5e              SBC FAC1EX
cc52 85 5e              STA FAC1EX
cc54 20 ed cb           JSR Check_FAC
cc57 e6 5e              INC FAC1EX
cc59 f0 b7              BEQ ChFA_Err
cc5b a2 fc              LDX #$fc            ; wrap around index
cc5d a9 01              LDA #1
cc5f a4 67    DIV_10    LDY FAC2M1
cc61 c4 5f              CPY FAC1M1
cc63 d0 10              BNE DIV_20
cc65 a4 68              LDY FAC2M2
cc67 c4 60              CPY FAC1M2
cc69 d0 0a              BNE DIV_20
cc6b a4 69              LDY FAC2M3
cc6d c4 61              CPY FAC1M3
cc6f d0 04              BNE DIV_20
cc71 a4 6a              LDY FAC2M4
cc73 c4 62              CPY FAC1M4
cc75 08       DIV_20    PHP
cc76 2a                 ROL A
cc77 90 09              BCC DIV_30
cc79 e8                 INX
cc7a 95 26              STA FAC3M4,X
cc7c f0 32              BEQ DIV_60
cc7e 10 34              BPL DIV_70
cc80 a9 01              LDA #1
cc82 28       DIV_30    PLP
cc83 b0 0e              BCS DIV_50
cc85 06 6a    DIV_40    ASL FAC2M4
cc87 26 69              ROL FAC2M3
cc89 26 68              ROL FAC2M2
cc8b 26 67              ROL FAC2M1
cc8d b0 e6              BCS DIV_20
cc8f 30 ce              BMI DIV_10
cc91 10 e2              BPL DIV_20
cc93 a8       DIV_50    TAY
cc94 a5 6a              LDA FAC2M4
cc96 e5 62              SBC FAC1M4
cc98 85 6a              STA FAC2M4
cc9a a5 69              LDA FAC2M3
cc9c e5 61              SBC FAC1M3
cc9e 85 69              STA FAC2M3
cca0 a5 68              LDA FAC2M2
cca2 e5 60              SBC FAC1M2
cca4 85 68              STA FAC2M2
cca6 a5 67              LDA FAC2M1
cca8 e5 5f              SBC FAC1M1
ccaa 85 67              STA FAC2M1
ccac 98                 TYA
ccad 4c 85 cc           JMP DIV_40
ccb0 a9 40    DIV_60    LDA #$40
ccb2 d0 ce              BNE DIV_30
ccb4 0a       DIV_70    ASL A
ccb5 0a                 ASL A
ccb6 0a                 ASL A
ccb7 0a                 ASL A
ccb8 0a                 ASL A
ccb9 0a                 ASL A
ccba 85 6d              STA FROUND
ccbc 28                 PLP
ccbd 4c c5 cc           JMP FAC3_To_FAC1

              ; **************
ccc0            Divide_By_Zero
              ; **************

ccc0 a2 85              LDX #Msg_DIV-Msg_Start ; $85
ccc2 4c cf b3           JMP Basic_Error

              ; ************
ccc5            FAC3_To_FAC1
              ; ************

ccc5 a5 23              LDA FAC3M1
ccc7 85 5f              STA FAC1M1
ccc9 a5 24              LDA FAC3M2
cccb 85 60              STA FAC1M2
cccd a5 25              LDA FAC3M3
cccf 85 61              STA FAC1M3
ccd1 a5 26              LDA FAC3M4
ccd3 85 62              STA FAC1M4
ccd5 4c 0d ca           JMP Normalise_FAC1

              ; ********************
ccd8            Load_FAC1_AY ; $ccd8
              ; ********************

ccd8 85 1f              STA INDEXA
ccda 84 20              STY INDEXA+1
ccdc a0 04              LDY #4
ccde b1 1f    LFAY_10   LDA (INDEXA),Y
cce0 99 5e 00           STA FAC1EX,Y
cce3 88                 DEY
cce4 10 f8              BPL LFAY_10
cce6 c8                 INY                 ; Y = 0
cce7 84 6d              STY FROUND          ; rounding byte
cce9 a5 5f              LDA FAC1M1
cceb 85 63              STA FAC1SI
cced 09 80              ORA #$80
ccef 85 5f              STA FAC1M1
ccf1 a5 5e              LDA FAC1EX
ccf3 60                 RTS ;Size   28 [Load_FAC1_AY]

              ; ********
ccf4            Set_FAC1
              ; ********

ccf4 85 5f              STA FAC1M1
ccf6 85 60              STA FAC1M2
ccf8 85 61              STA FAC1M3
ccfa 85 62              STA FAC1M4
ccfc 60                 RTS ;Size    9 [Set_FAC1]

ccfd                    .FILL $ccfd-* (0) ; 0 bytes

              ; **********************
ccfd            FAC1_To_FACTPB ; $ccfd
              ; **********************

ccfd a2 59              LDX #FACTPB ; $59
ccff 2c                 .BYTE $2c

              ; **************
cd00            FAC1_To_FACTPA
              ; **************

cd00 a2 54              LDX #<FACTPA
cd02 a0 00              LDY #>FACTPA
cd04 f0 04              BEQ FAC1_To_XY      ; always

              ; **************
cd06            FAC1_To_FORPNT
              ; **************

cd06 a6 46              LDX FORPNT
cd08 a4 47              LDY FORPNT+1

              ; **********
cd0a            FAC1_To_XY
              ; **********

cd0a 20 51 cd           JSR Round_FAC1
cd0d 86 1f              STX INDEXA
cd0f 84 20              STY INDEXA+1
cd11 a0 04              LDY #4
cd13 a5 62              LDA FAC1M4
cd15 91 1f              STA (INDEXA),Y
cd17 88                 DEY
cd18 a5 61              LDA FAC1M3
cd1a 91 1f              STA (INDEXA),Y
cd1c 88                 DEY
cd1d a5 60              LDA FAC1M2
cd1f 91 1f              STA (INDEXA),Y
cd21 88                 DEY
cd22 a5 63              LDA FAC1SI
cd24 09 7f              ORA #$7f
cd26 25 5f              AND FAC1M1
cd28 91 1f              STA (INDEXA),Y
cd2a 88                 DEY
cd2b a5 5e              LDA FAC1EX
cd2d 91 1f              STA (INDEXA),Y
cd2f 84 6d              STY FROUND
cd31 60                 RTS ;Size   40 [FAC1_To_XY]

              ; ************
cd32            FAC2_To_FAC1
              ; ************

cd32 a5 6b              LDA FAC2SI

              ; *********************
cd34            Copy_ABS_FAC2_To_FAC1
              ; *********************

cd34 85 63              STA FAC1SI
cd36 a2 05              LDX #5
cd38 b5 65    F1F2_10   LDA FAC2EX-1,X
cd3a 95 5d              STA FAC1EX-1,X
cd3c ca                 DEX
cd3d d0 f9              BNE F1F2_10
cd3f 86 6d              STX FROUND ; 0
cd41 60                 RTS ;Size   14 [Copy_ABS_FAC2_To_FAC1]

              ; ***************************
cd42            FAC1_Round_And_Copy_To_FAC2
              ; ***************************

cd42 20 51 cd           JSR Round_FAC1

              ; ************
cd45            FAC1_To_FAC2
              ; ************

cd45 a2 06              LDX #6
cd47 b5 5d    FA12_10   LDA FAC1EX-1,X
cd49 95 65              STA FAC2EX-1,X
cd4b ca                 DEX
cd4c d0 f9              BNE FA12_10
cd4e 86 6d              STX FROUND ; 0
cd50 60       FA12_Ret  RTS ;Size   12 [FAC1_To_FAC2]

              ; **********
cd51            Round_FAC1
              ; **********

cd51 a5 5e              LDA FAC1EX
cd53 f0 fb              BEQ FA12_Ret
cd55 06 6d              ASL FROUND
cd57 90 f7              BCC FA12_Ret

              ; ********
cd59            Inc_FAC1
              ; ********

cd59 20 a5 ca           JSR Inc_FAC1_Mantissa
cd5c d0 f2              BNE FA12_Ret
cd5e 4c 6e ca           JMP AFTF_80

              ; *************
cd61            Get_FAC1_Sign
              ; *************

cd61 a5 5e              LDA FAC1EX
cd63 f0 09              BEQ GFS_Ret
cd65 a5 63    GFS_10    LDA FAC1SI
cd67 2a       GFS_20    ROL A
cd68 a9 ff              LDA #$ff
cd6a b0 02              BCS GFS_Ret
cd6c a9 01              LDA #1
cd6e 60       GFS_Ret   RTS ;Size   14 [Get_FAC1_Sign]

              ; *********
cd6f            Basic_SGN
              ; *********

cd6f 20 61 cd           JSR Get_FAC1_Sign

              ; *********
cd72            A_To_FAC1
              ; *********

cd72 85 5f              STA FAC1M1
cd74 a9 00              LDA #0
cd76 85 60              STA FAC1M2
cd78 a2 88              LDX #$88
cd7a a5 5f    ATOF_10   LDA FAC1M1
cd7c 49 ff              EOR #$ff
cd7e 2a                 ROL A               ; clear carry for negative numbers

              ; ***********************
cd7f            Convert_Integer_To_Real
              ; ***********************

cd7f a9 00              LDA #0
cd81 85 62              STA FAC1M4
cd83 85 61              STA FAC1M3
cd85 86 5e    CITR_10   STX FAC1EX
cd87 85 6d              STA FROUND
cd89 85 63              STA FAC1SI
cd8b 4c ff c9           JMP AFTF_50

              ; *********
cd8e            Basic_ABS
              ; *********

cd8e 46 63              LSR FAC1SI          ; clear bit 7 (sign)
cd90 60                 RTS ;Size    3 [Basic_ABS]

              ; ***************
cd91            Compare_FAC1_AY
              ; ***************

cd91 85 21              STA INDEXB

              ; *********************
cd93            Compare_FAC1_INDEXB_Y
              ; *********************

cd93 84 22              STY INDEXB+1        ; (INDEXB) = operand 2
cd95 a0 00              LDY #0
cd97 b1 21              LDA (INDEXB),Y      ; exp 2
cd99 c8                 INY                 ; Y = 1
cd9a aa                 TAX
cd9b f0 c4              BEQ Get_FAC1_Sign   ; branch if operand 2 is zero
cd9d b1 21              LDA (INDEXB),Y      ; M1
cd9f 45 63              EOR FAC1SI          ; EOR both sign bits
cda1 30 c2              BMI GFS_10          ; branch on different signs
cda3 e4 5e              CPX FAC1EX          ; compare exponents
cda5 d0 21              BNE CFAY_10         ; branch if not equal
cda7 b1 21              LDA (INDEXB),Y      ; M1
cda9 09 80              ORA #$80            ; remove sign
cdab c5 5f              CMP FAC1M1          ; compare M1's
cdad d0 19              BNE CFAY_10
cdaf c8                 INY                 ; Y = 2
cdb0 b1 21              LDA (INDEXB),Y
cdb2 c5 60              CMP FAC1M2          ; compare M2's
cdb4 d0 12              BNE CFAY_10
cdb6 c8                 INY                 ; Y = 3
cdb7 b1 21              LDA (INDEXB),Y
cdb9 c5 61              CMP FAC1M3          ; compare M3's
cdbb d0 0b              BNE CFAY_10
cdbd c8                 INY                 ; Y = 4
cdbe a9 7f              LDA #$7f
cdc0 c5 6d              CMP FROUND          ; $7f >= FROUND ?
cdc2 b1 21              LDA (INDEXB),Y
cdc4 e5 62              SBC FAC1M4          ; compare M4's and FROUND
cdc6 f0 39              BEQ FLSR_Ret
cdc8 a5 63    CFAY_10   LDA FAC1SI
cdca 90 02              BCC CFAY_20
cdcc 49 ff              EOR #$ff
cdce 4c 67 cd CFAY_20   JMP GFS_20

              ; ********
cdd1            FAC1_LSR
              ; ********

              ; Shift FAC1 right until the exponent is at $a0.
              ; This is the value for which the four mantissa bytes
              ; represent a 32 bit integer value.

cdd1 a5 5e              LDA FAC1EX
cdd3 d0 03              BNE FLSR_20
cdd5 4c f4 cc FLSR_10   JMP Set_FAC1        ; clear mantissa for zero exp
cdd8 38       FLSR_20   SEC
cdd9 e9 a0              SBC #$a0
cddb 20 f4 c6           JSR FAC1_LSB        ; shift bytes
cdde f0 1f              BEQ FLSR_40         ; -> done
cde0 a5 65              LDA BITS            ; check integer status
cde2 f0 02              BEQ FLSR_30         ; branch on integer
cde4 a9 80              LDA #$80            ; real
cde6 46 5f    FLSR_30   LSR FAC1M1          ; do a bit shift
cde8 66 60              ROR FAC1M2
cdea 66 61              ROR FAC1M3
cdec 66 62              ROR FAC1M4
cdee 66 6d              ROR FROUND
cdf0 05 6d              ORA FROUND          ; remember bits shifted off
cdf2 c8                 INY
cdf3 d0 f1              BNE FLSR_30
cdf5 24 63              BIT FAC1SI
cdf7 10 06              BPL FLSR_40         ; positive: finished
cdf9 0a                 ASL A               ; any 1 bits shifted off ?
cdfa 90 03              BCC FLSR_40         ; -> number was exact integer
cdfc 20 a5 ca           JSR Inc_FAC1_Mantissa ; subtract 1 from negative number
cdff 84 6d    FLSR_40   STY FROUND          ; FROUND = 0
ce01 60       FLSR_Ret  RTS ;Size   49 [FAC1_LSR]

ce02                    .FILL $ce02-* (0) ; 0 bytes

              ; *****************
ce02            Basic_INT ; $ce02
              ; *****************

              ; The BASIC int function is not restricted to the 16 bit
              ; range of integer variables. Its range is 32 bit.
              ; INT does not round, it looks for the integer lower or
              ; equal to the given value. E.g: int(-1.1) results in -2.

ce02 a5 5e              LDA FAC1EX
ce04 c9 a0              CMP #$a0
ce06 b0 f9              BCS FLSR_Ret        ; -> no bits after decimal point
ce08 20 d1 cd           JSR FAC1_LSR        ; normalise to integer
ce0b a9 a0              LDA #$a0
ce0d 85 5e              STA FAC1EX          ; set exponent for integer mantissa
ce0f a5 62              LDA FAC1M4
ce11 24 63              BIT FAC1SI
ce13 10 05              BPL INT_10
ce15 38                 SEC
ce16 a9 00              LDA #0
ce18 e5 62              SBC FAC1M4
ce1a 85 03    INT_10    STA CHARAC          ; needed from Basic_EXP
ce1c 4c 0d ca           JMP Normalise_FAC1  ; normalise back to real

ce1f 00 00 00           .FILL $ce29-* (0) ; 10 bytes

              ; *************************
ce29            Read_Real_To_FAC1 ; $ce29
              ; *************************

              ; This subroutine parses a string via CHRGET and
              ; converts it into a floating point value in FAC1.

              ;         TMPVAR   = digits after decimal point
              ;         TMPVAR+1 = exponent
              ;         TMPPTC   = bit 7 : flag for '.' decimal point
              ;         TMPPTC+1 = bit 7 : flag for '-' sign

ce29 a0 00              LDY #0
ce2b a2 0a              LDX #10
ce2d 94 5a    RRTF_02   STY TMPVAR,X        ; clear TMPVAR, TMPPTC and FAC1
ce2f ca                 DEX
ce30 10 fb              BPL RRTF_02         ; X = $ff at end
ce32 90 68              BCC RRTF_34         ; -> numeric
ce34 c9 2b              CMP #'+'            ; positive sign ?
ce36 f0 06              BEQ RRTF_04         ; -> get next
ce38 c9 2d              CMP #'-'            ; negative sign ?
ce3a d0 07              BNE RRTF_06
ce3c 86 64              STX SGNFLG          ; sign flag = $ff
ce3e 20 70 00 RRTF_04   JSR CHRGET          ; next character after sign
ce41 90 59              BCC RRTF_34         ; -> numeric
ce43 c9 2e    RRTF_06   CMP #'.'            ; decimal point ?
ce45 f0 2c              BEQ RRTF_20         ; -> now the fractional part
ce47 c9 45              CMP #'E'            ; exponent ?
ce49 d0 2e              BNE RRTF_22
ce4b 20 70 00           JSR CHRGET          ; read character of exponent
ce4e 90 77              BCC RRTF_40         ; -> numeric
ce50 c9 aa              CMP #$aa            ; '+' token
ce52 f0 0e              BEQ RRTF_10
ce54 c9 2b              CMP #'+'            ; '+' sign of exponent
ce56 f0 0a              BEQ RRTF_10
ce58 c9 ab              CMP #$ab            ; '-' token
ce5a f0 04              BEQ RRTF_08
ce5c c9 2d              CMP #'-'            ; '-' sign of exponent
ce5e d0 07              BNE RRTF_12
ce60 66 5d    RRTF_08   ROR TMPPTC+1        ; flag negative sign
ce62 20 70 00 RRTF_10   JSR CHRGET          ; read character of exponent
ce65 90 60              BCC RRTF_40         ; -> numeric
ce67 24 5d    RRTF_12   BIT TMPPTC+1
ce69 10 0e              BPL RRTF_22         ; -> positive exponent
ce6b a9 00              LDA #0
ce6d 38                 SEC
ce6e e5 5b              SBC TMPVAR+1        ; -> negative exponent
ce70 4c 7b ce           JMP RRTF_24

ce73 66 5c    RRTF_20   ROR TMPPTC          ; bit 7 = flag for '.'
ce75 24 5c              BIT TMPPTC
ce77 50 c5              BVC RRTF_04         ; break if 2nd. dot read

ce79 a5 5b    RRTF_22   LDA TMPVAR+1        ; exponent read
ce7b 38       RRTF_24   SEC
ce7c e5 5a              SBC TMPVAR          ; minus # of digits after '.'
ce7e 85 5b              STA TMPVAR+1        ; effective exponent
ce80 f0 12              BEQ RRTF_30         ; -> zero exponent
ce82 10 09              BPL RRTF_28         ; -> pos. exponent

ce84 20 34 cc RRTF_26   JSR Divide_FAC1_By_10 ; neg. exponent
ce87 e6 5b              INC TMPVAR+1
ce89 d0 f9              BNE RRTF_26
ce8b f0 07              BEQ RRTF_30

ce8d 20 18 cc RRTF_28   JSR Multiply_FAC1_BY_10 ; apply positive exponent
ce90 c6 5b              DEC TMPVAR+1
ce92 d0 f9              BNE RRTF_28

ce94 a5 64    RRTF_30   LDA SGNFLG
ce96 30 01              BMI RRTF_32         ; -> negate result
ce98 60                 RTS ;Size  112 [Read_Real_To_FAC1]

ce99 4c 4b d1 RRTF_32   JMP Op_NEGATE

ce9c 48       RRTF_34   PHA                 ; result = result * 10 + digit
ce9d 24 5c              BIT TMPPTC
ce9f 10 02              BPL RRTF_36
cea1 e6 5a              INC TMPVAR          ; count digits after decimal point
cea3 20 18 cc RRTF_36   JSR Multiply_FAC1_BY_10
cea6 68                 PLA
cea7 29 0f              AND #15             ; PETSCII -> binary
cea9 20 b4 ce           JSR Add_A_To_FAC1
ceac 4c 3e ce           JMP RRTF_04

ceaf 00 00 00           .FILL $ceb4-* (0) ; 5 bytes

              ; *********************
ceb4            Add_A_To_FAC1 ; $ceb4
              ; *********************

ceb4 48                 PHA
ceb5 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
ceb8 68                 PLA
ceb9 20 72 cd           JSR A_To_FAC1
cebc a5 6b              LDA FAC2SI
cebe 45 63              EOR FAC1SI
cec0 85 6c              STA STRPTR
cec2 a6 5e              LDX FAC1EX
cec4 4c a0 c9           JMP Op_PLUS

              ; read digits for exponent

cec7 a5 5b    RRTF_40   LDA TMPVAR+1        ; exponent so far
cec9 c9 0a              CMP #10             ; alreay two digits ?
cecb 90 09              BCC RRTF_42         ; -> OK if less than 10
cecd a9 64              LDA #100            ; exponent = 100
cecf 24 5d              BIT TMPPTC+1
ced1 30 11              BMI RRTF_44         ; -> negative exponent
ced3 4c b4 ca           JMP Overflow_Error  ; max value = 37
ced6 0a       RRTF_42   ASL A               ; * 2
ced7 0a                 ASL A               ; * 4
ced8 18                 CLC
ced9 65 5b              ADC TMPVAR+1        ; * 5
cedb 0a                 ASL A               ; * 10
cedc 18                 CLC
cedd a0 00              LDY #0
cedf 71 77              ADC (TXTPTR),Y
cee1 38                 SEC
cee2 e9 30              SBC #'0'
cee4 85 5b    RRTF_44   STA TMPVAR+1        ; new value for exponent
cee6 4c 62 ce           JMP RRTF_10

              ; *********
cee9            REAL_1e8
              ; *********

cee9 9b 3e bc 20 00     .REAL $9b3ebc2000   ; 1e8

              ; *********
ceee            REAL_9x9
              ; *********

ceee 9e 6e 6b 27 fe     .REAL $9e6e6b27fe   ;  999999999.5

              ; *********
cef3            REAL_1e9
              ; *********

cef3 9e 6e 6b 28 00     .REAL $9e6e6b2800   ; 1e9

cef8 42 53 4f BSOS_TEXT .BYTE "BSOS BOOT"

              ; **********
cf01            Option_ROM
              ; **********

cf01 a2 03              LDX #3
cf03 bd 00 90 OpRO_10   LDA $9000,X         ; check $9000 ROM
cf06 dd f8 ce           CMP BSOS_TEXT,X
cf09 d0 06              BNE OpRO_20
cf0b ca                 DEX
cf0c 10 f5              BPL OpRO_10
cf0e 20 04 90           JSR $9004
cf11 a2 03    OpRO_20   LDX #3
cf13 bd 00 a0 OpRO_30   LDA $a000,X         ; check $a000 ROM
cf16 dd f8 ce           CMP BSOS_TEXT,X
cf19 d0 06              BNE OpRO_40
cf1b ca                 DEX
cf1c 10 f5              BPL OpRO_30
cf1e 4c 04 a0           JMP $a004
cf21 60       OpRO_40   RTS ;Size   33 [Option_ROM]

              ; *********
cf22            BOOT_File
              ; *********

cf22 24 98              BIT Key_Flags
cf24 10 fb              BPL OpRO_40         ; skip if SHIFT pressed
cf26 a9 f8              LDA #<BSOS_TEXT     ; look for boot file
cf28 85 da              STA FNADR
cf2a a9 ce              LDA #>BSOS_TEXT
cf2c 85 db              STA FNADR+1
cf2e a9 09              LDA #?BSOS_TEXT
cf30 85 d1              STA FNLEN
cf32 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
cf35 a9 00              LDA #0
cf37 85 d3              STA SA              ; enforce load to $0401
cf39 a5 28              LDA TXTTAB
cf3b a6 29              LDX TXTTAB+1
cf3d 85 c9              STA EAL             ; TXTTAB (normally $0401)
cf3f 86 ca              STX EAL+1
cf41 20 d0 f3           JSR Open_Load_File
cf44 a5 96              LDA STATUS
cf46 f0 06              BEQ BOFi_10
cf48 20 ae f1           JSR UNTLK           ; not there
cf4b 4c 91 d9           JMP Kernal_Read_DS  ; clear status and return
cf4e 20 8e f3 BOFi_10   JSR LoFi_30         ; load boot file
cf51 a5 c9              LDA EAL
cf53 85 2a              STA VARTAB
cf55 a5 ca              LDA EAL+1
cf57 85 2b              STA VARTAB+1
cf59 20 e9 b5           JSR Reset_BASIC_Execution
cf5c 20 b6 b4           JSR Rechain
cf5f 4c 4a b7           JMP Execute

cf62 00 00 00           .FILL $cf78-* (0) ; 22 bytes

              ; ********
cf78            Print_IN
              ; ********

cf78 a9 0d              LDA #<Msg_IN
cf7a a0 b3              LDY #>Msg_IN
cf7c 20 90 cf           JSR To_Print_String
cf7f a5 37              LDA CURLIN+1
cf81 a6 36              LDX CURLIN

              ; ****************
cf83            Print_Integer_XA
              ; ****************

cf83 85 5f              STA FAC1M1
cf85 86 60              STX FAC1M2
cf87 a2 90              LDX #$90
cf89 38                 SEC
cf8a 20 7f cd           JSR Convert_Integer_To_Real
cf8d 20 93 cf           JSR Format_FAC1

              ; ***************
cf90            To_Print_String
              ; ***************

cf90 4c 1d bb           JMP Print_String

              ; *******************
cf93            Format_FAC1 ; $cf93
              ; *******************

cf93 a0 01              LDY #1              ; start of string storage

              ; =====================
cf95            Format_FAC1_Y ; $cf95
              ; =====================

              ; Format floating point number in FAC1
              ; The string is stored starting at $ff for Y=0
              ; and extending into the bottom of the stack

cf95 a9 00              LDA #0
cf97 85 5a              STA TMPVAR          ; 10's exponent

              ; the first character is blank for positive or '-'
              ; for negative numbers

cf99 a9 20              LDA #' '
cf9b 24 63              BIT FAC1SI
cf9d 10 02              BPL FoFA_02
cf9f a9 2d              LDA #'-'
cfa1 99 ff 00 FoFA_02   STA STACK-1,Y       ; 1.st char ' ' or '-'
cfa4 85 63              STA FAC1SI          ; delete sign info from FAC1
cfa6 84 6e              STY TMPPTD          ; save Y
cfa8 c8                 INY                 ; next string position
cfa9 a9 30              LDA #'0'            ; default for value zero

              ; if the value is zero, store '0' and finish

cfab a6 5e              LDX FAC1EX
cfad d0 03              BNE FoFA_04         ; -> non zero
cfaf 4c b6 d0           JMP FoFA_94         ; store '0' and finish

              ; if the value is less than 1.0, scale it with 1.0e+9
              ; and store the scaled 10's exponent (-9) in TMPVAR
              ; this saves 9 iterations in loop FoFA_08

cfb2 a9 00    FoFA_04   LDA #0
cfb4 e0 81              CPX #$81            ; exponent for >= 1.0
cfb6 b0 09              BCS FoFA_06
cfb8 a9 f3              LDA #<REAL_1e9
cfba a0 ce              LDY #>REAL_1e9
cfbc 20 5e cb           JSR Multiply_FAC1_With_AY
cfbf a9 f7              LDA #-9
cfc1 85 5a    FoFA_06   STA TMPVAR          ; current 10's exponent

              ; scale FAC1 up until the number has more than 8 digits

cfc3 a9 e9    FoFA_08   LDA #<REAL_1e8
cfc5 a0 ce              LDY #>REAL_1e8
cfc7 20 91 cd           JSR Compare_FAC1_AY
cfca 10 0c              BPL FoFA_12         ; FAC1 >= REAL_1e8 ->
cfcc 20 18 cc           JSR Multiply_FAC1_BY_10
cfcf c6 5a              DEC TMPVAR          ; decrement 10's exponent
cfd1 d0 f0              BNE FoFA_08         ; always

              ; scale FAC1 down until the number has less than 10 digits

cfd3 20 34 cc FoFA_10   JSR Divide_FAC1_By_10
cfd6 e6 5a              INC TMPVAR          ; increment 10's exponent
cfd8 a9 ee    FoFA_12   LDA #<REAL_9x9
cfda a0 ce              LDY #>REAL_9x9      ; 999999999.5
cfdc 20 91 cd           JSR Compare_FAC1_AY
cfdf 10 f2              BPL FoFA_10         ; FAC1 > REAL_9x9 -> continue scaling

              ; scaling is done - now convert the digits before the decimal
              ; point into a 32 bit integer

cfe1 20 7f c9           JSR Add_0_5_To_FAC1 ; add 0.5 for rounding
cfe4 20 d1 cd           JSR FAC1_LSR        ; convert to integer

              ; choose fixed point format if -2 < exp < 10
              ; else format in exponential format

cfe7 a2 01              LDX #1
cfe9 a5 5a              LDA TMPVAR          ; current 10's exponent
cfeb 18                 CLC
cfec 69 0a              ADC #10             ; exp difference
cfee 30 09              BMI FoFA_14         ; value < 1.0
cff0 c9 0b              CMP #11
cff2 b0 06              BCS FoFA_16         ; value >= 1e9
cff4 69 ff              ADC #$ff
cff6 aa                 TAX                 ; X = exp + 9
cff7 a9 02              LDA #2              ; fixed point
cff9 38       FoFA_14   SEC
cffa e9 02    FoFA_16   SBC #2
cffc 85 5b              STA TMPVAR+1        ; exp print = 0 or exp+8
cffe 86 5a              STX TMPVAR          ; digits before decimal point
d000 8a                 TXA
d001 f0 02              BEQ FoFA_18         ; -> if no digits before point
d003 10 13              BPL FoFA_22
d005 a4 6e    FoFA_18   LDY TMPPTD
d007 a9 2e              LDA #'.'
d009 c8                 INY
d00a 99 ff 00           STA STACK-1,Y       ; insert decimal point
d00d 8a                 TXA
d00e f0 06              BEQ FoFA_20
d010 a9 30              LDA #'0'
d012 c8                 INY
d013 99 ff 00           STA STACK-1,Y       ; insert '0'
d016 84 6e    FoFA_20   STY TMPPTD
d018 a0 00    FoFA_22   LDY #0

              ; =================
d01a            Format_Jiffyclock
              ; =================

d01a a2 80              LDX #$80
d01c 18       FoFA_78   CLC
d01d a5 62              LDA FAC1M4
d01f 79 cf d0           ADC Decimal_Conversion_Table+3,Y
d022 85 62              STA FAC1M4
d024 a5 61              LDA FAC1M3
d026 79 ce d0           ADC Decimal_Conversion_Table+2,Y
d029 85 61              STA FAC1M3
d02b a5 60              LDA FAC1M2
d02d 79 cd d0           ADC Decimal_Conversion_Table+1,Y
d030 85 60              STA FAC1M2
d032 a5 5f              LDA FAC1M1
d034 79 cc d0           ADC Decimal_Conversion_Table,Y
d037 85 5f              STA FAC1M1
d039 e8                 INX
d03a b0 04              BCS FoFA_80
d03c 10 de              BPL FoFA_78
d03e 30 02              BMI FoFA_82

d040 30 da    FoFA_80   BMI FoFA_78
d042 8a       FoFA_82   TXA
d043 90 04              BCC FoFA_84
d045 49 ff              EOR #$ff
d047 69 0a              ADC #10
d049 69 2f    FoFA_84   ADC #'0'-1
d04b c8                 INY
d04c c8                 INY
d04d c8                 INY
d04e c8                 INY                 ; Y += 4
d04f 84 44              STY VARPTR          ; save index to table
d051 a4 6e              LDY TMPPTD          ; get index to string
d053 c8                 INY
d054 aa                 TAX
d055 29 7f              AND #$7f
d057 99 ff 00           STA STACK-1,Y       ; store digit
d05a c6 5a              DEC TMPVAR          ; # of digits
d05c d0 06              BNE FoFA_86         ; -> if not zero
d05e a9 2e              LDA #'.'
d060 c8                 INY
d061 99 ff 00           STA STACK-1,Y       ; store decimal point
d064 84 6e    FoFA_86   STY TMPPTD          ; save string index
d066 a4 44              LDY VARPTR          ; get table index
d068 8a                 TXA
d069 49 ff              EOR #$ff
d06b 29 80              AND #$80
d06d aa                 TAX
d06e c0 24              CPY #$24            ; end of decimal table ?
d070 f0 04              BEQ FoFA_88
d072 c0 3c              CPY #$3c            ; end of jiffy table ?
d074 d0 a6              BNE FoFA_78

              ; remove trailing zeroes

d076 a4 6e    FoFA_88   LDY TMPPTD          ; get string index
d078 b9 ff 00 FoFA_90   LDA STACK-1,Y
d07b 88                 DEY
d07c c9 30              CMP #'0'
d07e f0 f8              BEQ FoFA_90
d080 c9 2e              CMP #'.'
d082 f0 01              BEQ FoFA_91
d084 c8                 INY
d085 a9 2b    FoFA_91   LDA #'+'            ; default sign for exponent
d087 a6 5b              LDX TMPVAR+1
d089 f0 2e              BEQ FoFA_95         ; -> no exponent
d08b 10 08              BPL FoFA_92         ; -> positive exponent
d08d a9 00              LDA #0
d08f 38                 SEC
d090 e5 5b              SBC TMPVAR+1        ; negate exponent
d092 aa                 TAX
d093 a9 2d              LDA #'-'            ; negative sign for exponent
d095 99 01 01 FoFA_92   STA STACK+1,Y
d098 a9 45              LDA #'E'
d09a 99 00 01           STA STACK,Y
d09d 8a                 TXA
d09e a2 2f              LDX #'0'-1
d0a0 38                 SEC
d0a1 e8       FoFA_93   INX
d0a2 e9 0a              SBC #10
d0a4 b0 fb              BCS FoFA_93
d0a6 69 3a              ADC #'0'+10
d0a8 99 03 01           STA STACK+3,Y
d0ab 8a                 TXA
d0ac 99 02 01           STA STACK+2,Y
d0af a9 00              LDA #0
d0b1 99 04 01           STA STACK+4,Y
d0b4 f0 08              BEQ FoFA_96         ; always

d0b6 99 ff 00 FoFA_94   STA STACK-1,Y
d0b9 a9 00    FoFA_95   LDA #0
d0bb 99 00 01           STA STACK,Y
d0be a9 00    FoFA_96   LDA #0
d0c0 a0 01              LDY #1
d0c2 60                 RTS ;Size  304 [Format_FAC1]

d0c3 00 00 00           .FILL $d0c7-* (0) ; 4 bytes

              ; *****************
d0c7            Float_0_5 ; $d0c7
              ; *****************

d0c7 80 00 00 00 00     .REAL $8000000000   ;    0.50000000000

              ; ************************
d0cc            Decimal_Conversion_Table
              ; ************************

d0cc fa 0a 1f           .QUAD $fa0a1f00     ; -100000000
d0d0 00 98 96           .QUAD $00989680     ;   10000000
d0d4 ff f0 bd           .QUAD $fff0bdc0     ;   -1000000
d0d8 00 01 86           .QUAD $000186a0     ;     100000
d0dc ff ff d8           .QUAD $ffffd8f0     ;     -10000
d0e0 00 00 03           .QUAD $000003e8     ;       1000
d0e4 ff ff ff           .QUAD $ffffff9c     ;       -100
d0e8 00 00 00           .QUAD $0000000a     ;         10
d0ec ff ff ff           .QUAD $ffffffff     ;         -1

              ; **********************
d0f0            Jiffy_Conversion_Table
              ; **********************

d0f0 ff df 0a           .QUAD $ffdf0a80     ;   -2160000
d0f4 00 03 4b           .QUAD $00034bc0     ;     216000
d0f8 ff ff 73           .QUAD $ffff7360     ;     -36000
d0fc 00 00 0e           .QUAD $00000e10     ;       3600
d100 ff ff fd           .QUAD $fffffda8     ;       -600
d104 00 00 00           .QUAD $0000003c     ;         60

              ; *****************
d108            Basic_SQR ; $d108
              ; *****************

d108 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d10b a9 c7              LDA #<Float_0_5
d10d a0 d0              LDY #>Float_0_5
d10f 20 d8 cc           JSR Load_FAC1_AY    ; perform (arg)^0.5

              ; ********
d112            Op_POWER
              ; ********

d112 f0 70              BEQ Basic_EXP       ; -> FAC1 == 0
d114 a5 66              LDA FAC2EX
d116 d0 03              BNE PWR_10
d118 4c 2f ca           JMP CF1_10
d11b a2 4b    PWR_10    LDX #<FUNCPT
d11d a0 00              LDY #>FUNCPT
d11f 20 0a cd           JSR FAC1_To_XY
d122 a5 6b              LDA FAC2SI
d124 10 0f              BPL PWR_20
d126 20 02 ce           JSR Basic_INT
d129 a9 4b              LDA #<FUNCPT
d12b a0 00              LDY #>FUNCPT
d12d 20 91 cd           JSR Compare_FAC1_AY
d130 d0 03              BNE PWR_20
d132 98                 TYA
d133 a4 03              LDY CHARAC
d135 20 34 cd PWR_20    JSR Copy_ABS_FAC2_To_FAC1
d138 98                 TYA
d139 48                 PHA
d13a 20 20 cb           JSR Basic_LOG
d13d a9 4b              LDA #<FUNCPT
d13f a0 00              LDY #>FUNCPT
d141 20 5e cb           JSR Multiply_FAC1_With_AY
d144 20 84 d1           JSR Basic_EXP
d147 68                 PLA
d148 4a                 LSR A
d149 90 0a              BCC NEGA_Ret

              ; *********
d14b            Op_NEGATE
              ; *********

d14b a5 5e              LDA FAC1EX
d14d f0 06              BEQ NEGA_Ret
d14f a5 63              LDA FAC1SI
d151 49 ff              EOR #$ff            ; change sign
d153 85 63              STA FAC1SI
d155 60       NEGA_Ret  RTS ;Size   11 [Op_NEGATE]

              ; *********
d156            REV_LOG_2
              ; *********

d156 81 38 aa 3b 29     .REAL $8138aa3b29   ;    1.44269504072
d15b 07       VAR_EXP   .BYTE $07
d15c 71 34 58 3e 56     .REAL $7134583e56   ;    0.00002149876
d161 74 16 7e b3 1b     .REAL $74167eb31b   ;    0.00014352314
d166 77 2f ee e3 85     .REAL $772feee385   ;    0.00134226348
d16b 7a 1d 84 1c 2a     .REAL $7a1d841c2a   ;    0.00961401701
d170 7c 63 59 58 0a     .REAL $7c6359580a   ;    0.05550512686
d175 7e 75 fd e7 c6     .REAL $7e75fde7c6   ;    0.24022638460
d17a 80 31 72 18 10     .REAL $8031721810   ;    0.69314718619
d17f 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; *********
d184            Basic_EXP
              ; *********

d184 a9 56              LDA #<REV_LOG_2
d186 a0 d1              LDY #>REV_LOG_2
d188 20 5e cb           JSR Multiply_FAC1_With_AY
d18b a5 6d              LDA FROUND
d18d 69 50              ADC #$50
d18f 90 03              BCC EXP_10
d191 20 59 cd           JSR Inc_FAC1
d194 85 53    EXP_10    STA FUNJMP+1        ; FROUND + $50
d196 20 45 cd           JSR FAC1_To_FAC2
d199 a5 5e              LDA FAC1EX
d19b c9 88              CMP #$88
d19d 90 03              BCC EXP_30          ; -> value < 128
d19f 20 07 cc EXP_20    JSR ChFA_40         ; Floating Point Exception
d1a2 20 02 ce EXP_30    JSR Basic_INT       ; convert to integer
d1a5 a5 03              LDA CHARAC
d1a7 49 80              EOR #$80
d1a9 48                 PHA
d1aa a2 05              LDX #5
d1ac b5 66    EXP_40    LDA FAC2EX,X
d1ae b4 5e              LDY FAC1EX,X
d1b0 95 5e              STA FAC1EX,X
d1b2 94 66              STY FAC2EX,X
d1b4 ca                 DEX
d1b5 10 f5              BPL EXP_40
d1b7 a5 53              LDA FUNJMP+1
d1b9 85 6d              STA FROUND
d1bb 20 89 c9           JSR Op_MINUS
d1be 20 4b d1           JSR Op_NEGATE
d1c1 a9 5b              LDA #<VAR_EXP
d1c3 a0 d1              LDY #>VAR_EXP
d1c5 20 ed d1           JSR Eval_Series_AY
d1c8 a9 00              LDA #0
d1ca 85 6c              STA STRPTR
d1cc 68                 PLA
d1cd 20 ef cb           JSR ChFA_10
d1d0 60                 RTS ;Size   77 [Basic_EXP]

d1d1 00 00 00           .FILL $d1d7-* (0) ; 6 bytes

              ; ******************************
d1d7            Square_And_Series_Eval ; $d1d7
              ; ******************************

d1d7 85 6e              STA TMPPTD
d1d9 84 6f              STY TMPPTD+1
d1db 20 00 cd           JSR FAC1_To_FACTPA
d1de a9 54              LDA #<FACTPA        ; Y = 0
d1e0 20 5e cb           JSR Multiply_FAC1_With_AY
d1e3 20 f1 d1           JSR Eval_Series
d1e6 a9 54              LDA #<FACTPA
d1e8 a0 00              LDY #>FACTPA
d1ea 4c 5e cb           JMP Multiply_FAC1_With_AY

              ; **************
d1ed            Eval_Series_AY
              ; **************

d1ed 85 6e              STA TMPPTD
d1ef 84 6f              STY TMPPTD+1

              ; ***********
d1f1            Eval_Series
              ; ***********

d1f1 20 fd cc           JSR FAC1_To_FACTPB
d1f4 b1 6e              LDA (TMPPTD),Y
d1f6 85 64              STA SGNFLG          ; # of terms
d1f8 a4 6e              LDY TMPPTD
d1fa c8                 INY
d1fb 98                 TYA
d1fc d0 02              BNE EvSe_10
d1fe e6 6f              INC TMPPTD+1
d200 85 6e    EvSe_10   STA TMPPTD
d202 a4 6f              LDY TMPPTD+1
d204 20 5e cb EvSe_20   JSR Multiply_FAC1_With_AY
d207 a5 6e              LDA TMPPTD
d209 a4 6f              LDY TMPPTD+1
d20b 18                 CLC
d20c 69 05              ADC #5              ; advance polynomial pointer
d20e 90 01              BCC EvSe_30
d210 c8                 INY
d211 85 6e    EvSe_30   STA TMPPTD
d213 84 6f              STY TMPPTD+1
d215 20 9d c9           JSR Add_Var_AY_To_FAC1
d218 a9 59              LDA #<FACTPB
d21a a0 00              LDY #>FACTPB
d21c c6 64              DEC SGNFLG
d21e d0 e4              BNE EvSe_20         ; -> next polynomial
d220 60                 RTS ;Size   48 [Eval_Series]

d221 98 35 44 RND_VA    .QUAD $9835447a     ; -1741339526
d225 68 28 b1 RND_VB    .QUAD $6828b146     ;  1747497286

              ; *********
d229            Basic_RND
              ; *********

              ; The random factor argument from RND(arg) is interpreted:
              ; arg < 0 : use argument as random seed
              ; arg = 0 : use timer 1 and 2 for random seed
              ; arg > 0 : start with fixed random seed from ROM

d229 20 61 cd           JSR Get_FAC1_Sign
d22c 30 2e              BMI RND_20
d22e d0 17              BNE RND_10
d230 ad 44 e8           LDA VIA_Timer_1_Lo  ; timer seed
d233 85 5f              STA FAC1M1
d235 ad 48 e8           LDA VIA_Timer_2_Lo
d238 85 60              STA FAC1M2
d23a ad 45 e8           LDA VIA_Timer_1_Hi
d23d 85 61              STA FAC1M3
d23f ad 49 e8           LDA VIA_Timer_2_Hi
d242 85 62              STA FAC1M4
d244 4c 6c d2           JMP RND_30
d247 a9 88    RND_10    LDA #<RNDX          ; fixed seed
d249 a0 00              LDY #>RNDX
d24b 20 d8 cc           JSR Load_FAC1_AY
d24e a9 21              LDA #<RND_VA
d250 a0 d2              LDY #>RND_VA
d252 20 5e cb           JSR Multiply_FAC1_With_AY
d255 a9 25              LDA #<RND_VB
d257 a0 d2              LDY #>RND_VB
d259 20 9d c9           JSR Add_Var_AY_To_FAC1
d25c a6 62    RND_20    LDX FAC1M4          ; argument seed
d25e a5 5f              LDA FAC1M1
d260 85 62              STA FAC1M4
d262 86 5f              STX FAC1M1
d264 a6 60              LDX FAC1M2
d266 a5 61              LDA FAC1M3
d268 85 60              STA FAC1M2
d26a 86 61              STX FAC1M3
d26c a9 00    RND_30    LDA #0
d26e 85 63              STA FAC1SI
d270 a5 5e              LDA FAC1EX
d272 85 6d              STA FROUND
d274 a9 80              LDA #$80
d276 85 5e              STA FAC1EX
d278 20 0d ca           JSR Normalise_FAC1
d27b a2 88              LDX #<RNDX
d27d a0 00              LDY #>RNDX
d27f 4c 0a cd           JMP FAC1_To_XY

              ; *********
d282            Basic_COS
              ; *********

d282 a9 fe              LDA #<PI_Half
d284 a0 d2              LDY #>PI_Half
d286 20 9d c9           JSR Add_Var_AY_To_FAC1

              ; *****************
d289            Basic_SIN ; $d289
              ; *****************

d289 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d28c a9 03              LDA #<Two_PI
d28e a0 d3              LDY #>Two_PI
d290 a6 6b              LDX FAC2SI
d292 20 3d cc           JSR Divide_FAC2_By_AY ; arg / (2 pi)
d295 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d298 20 02 ce           JSR Basic_INT
d29b a9 00              LDA #0
d29d 85 6c              STA STRPTR
d29f 20 89 c9           JSR Op_MINUS
d2a2 a9 08              LDA #<Float_0_25
d2a4 a0 d3              LDY #>Float_0_25
d2a6 20 86 c9           JSR AY_Minus_FAC1
d2a9 a5 63              LDA FAC1SI
d2ab 48                 PHA
d2ac 10 0d              BPL SIN_10
d2ae 20 7f c9           JSR Add_0_5_To_FAC1
d2b1 a5 63              LDA FAC1SI
d2b3 30 09              BMI SIN_20
d2b5 a5 0c              LDA TANSGN
d2b7 49 ff              EOR #$ff
d2b9 85 0c              STA TANSGN
d2bb 20 4b d1 SIN_10    JSR Op_NEGATE
d2be a9 08    SIN_20    LDA #<Float_0_25
d2c0 a0 d3              LDY #>Float_0_25
d2c2 20 9d c9           JSR Add_Var_AY_To_FAC1
d2c5 68                 PLA
d2c6 10 03              BPL SIN_30
d2c8 20 4b d1           JSR Op_NEGATE
d2cb a9 0d    SIN_30    LDA #<VAR_SIN
d2cd a0 d3              LDY #>VAR_SIN
d2cf 4c d7 d1           JMP Square_And_Series_Eval

              ; *********
d2d2            Basic_TAN
              ; *********

d2d2 20 00 cd           JSR FAC1_To_FACTPA
d2d5 a9 00              LDA #0
d2d7 85 0c              STA TANSGN
d2d9 20 89 d2           JSR Basic_SIN
d2dc a2 4b              LDX #<FUNCPT
d2de a0 00              LDY #>FUNCPT
d2e0 20 0a cd           JSR FAC1_To_XY
d2e3 a9 54              LDA #<FACTPA
d2e5 a0 00              LDY #>FACTPA
d2e7 20 d8 cc           JSR Load_FAC1_AY
d2ea a9 00              LDA #0
d2ec 85 63              STA FAC1SI
d2ee a5 0c              LDA TANSGN
d2f0 20 fa d2           JSR TAN_10
d2f3 a9 4b              LDA #<FUNCPT
d2f5 a0 00              LDY #>FUNCPT
d2f7 4c 45 cc           JMP AY_Divided_By_FAC1

              ; ******
d2fa            TAN_10
              ; ******

d2fa 48                 PHA
d2fb 4c bb d2           JMP SIN_10
d2fe 81 49 0f PI_Half   .REAL $81490fdaa2   ;    1.57079632673
d303 83 49 0f Two_PI    .REAL $83490fdaa2   ;    6.28318530694

              ; **********
d308            Float_0_25
              ; **********

d308 7f 00 00 00 00     .REAL $7f00000000   ;    0.25000000000
d30d 05       VAR_SIN   .BYTE $05
d30e 84 e6 1a 2d 1b     .REAL $84e61a2d1b   ;  -14.38139067218
d313 86 28 07 fb f8     .REAL $862807fbf8   ;   42.00779712200
d318 87 99 68 89 01     .REAL $8799688901   ;  -76.70417025685
d31d 87 23 35 df e1     .REAL $872335dfe1   ;   81.60522368550
d322 86 a5 5d e7 28     .REAL $86a55de728   ;  -41.34170210361
d327 83 49 0f da a2     .REAL $83490fdaa2   ;    6.28318530694

              ; *****************
d32c            Basic_ATN ; $d32c
              ; *****************

d32c a5 63              LDA FAC1SI
d32e 48                 PHA                 ; save sign
d32f a9 00              LDA #0
d331 85 63              STA FAC1SI          ; use symmetry of arctangent
d333 a5 5e              LDA FAC1EX
d335 c9 81              CMP #$81
d337 08                 PHP                 ; save flags
d338 90 07              BCC ATN_20          ; -> arg < 1.0
d33a a9 f2              LDA #<REAL_1
d33c a0 ca              LDY #>REAL_1
d33e 20 45 cc           JSR AY_Divided_By_FAC1
d341 a9 5c    ATN_20    LDA #<VAR_ATN
d343 a0 d3              LDY #>VAR_ATN
d345 20 d7 d1           JSR Square_And_Series_Eval
d348 28                 PLP                 ; restore comparison flags
d349 90 07              BCC ATN_30          ; -> arg < 1.0
d34b a9 fe              LDA #<PI_Half
d34d a0 d2              LDY #>PI_Half
d34f 20 86 c9           JSR AY_Minus_FAC1
d352 68       ATN_30    PLA
d353 85 63              STA FAC1SI          ; use same sign as arguemnt
d355 60                 RTS ;Size   42 [Basic_ATN]

d356 00 00 00           .FILL $d35c-* (0) ; 6 bytes

              ; ***************
d35c            VAR_ATN ; $d35c
              ; ***************

d35c 0b                 .BYTE $0b
d35d 76 b3 83 bd d3     .REAL $76b383bdd3   ;   -0.00068479391
d362 79 1e f4 a6 f5     .REAL $791ef4a6f5   ;    0.00485094216
d367 7b 83 fc b0 10     .REAL $7b83fcb010   ;   -0.01611170184
d36c 7c 0c 1f 67 ca     .REAL $7c0c1f67ca   ;    0.03420963805
d371 7c de 53 cb c1     .REAL $7cde53cbc1   ;   -0.05427913276
d376 7d 14 64 70 4c     .REAL $7d1464704c   ;    0.07245719654
d37b 7d b7 ea 51 7a     .REAL $7db7ea517a   ;   -0.08980239538
d380 7d 63 30 88 7e     .REAL $7d6330887e   ;    0.11093241343
d385 7e 92 44 99 3a     .REAL $7e9244993a   ;   -0.14283980767
d38a 7e 4c cc 91 c7     .REAL $7e4ccc91c7   ;    0.19999912049
d38f 7f aa aa aa 13     .REAL $7faaaaaa13   ;   -0.33333331568
d394 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; **********
d399            CHRGET_ROM
              ; **********

d399 e6 77              INC TXTPTR
d39b d0 02              BNE CHRG_10
d39d e6 78              INC TXTPTR+1
d39f ad 60 ea CHRG_10   LDA $ea60           ; dummy address
d3a2 c9 3a              CMP #':'
d3a4 b0 0a              BCS CHRG_20
d3a6 c9 20              CMP #' '
d3a8 f0 ef              BEQ CHRGET_ROM
d3aa 38                 SEC
d3ab e9 30              SBC #'0'
d3ad 38                 SEC
d3ae e9 d0              SBC #$d0
d3b0 60       CHRG_20   RTS ;Size   24 [CHRGET_ROM]

d3b1 80 4f c7 52 58     .REAL $804fc75258   ;    0.81163515709

              ; **********************
d3b6            Init_BASIC_RAM_Vectors
              ; **********************

d3b6 20 0e b6           JSR Flush_BASIC_Stack
d3b9 a9 4c              LDA #$4c            ; JMP code
d3bb 85 51              STA JUMPER
d3bd 85 00              STA Basic_USR
d3bf a9 73              LDA #<Jump_To_Illegal_Quantity
d3c1 a0 c3              LDY #>Jump_To_Illegal_Quantity
d3c3 85 01              STA USRVEC
d3c5 84 02              STY USRVEC+1
d3c7 a2 1c              LDX #$1c
d3c9 bd 98 d3 IBRV_10   LDA CHRGET_ROM-1,X
d3cc 95 6f              STA CHRGET-1,X
d3ce ca                 DEX
d3cf d0 f8              BNE IBRV_10         ; X=0 on exit
d3d1 86 10              STX IOPMPT          ; 0
d3d3 86 15              STX LASTPT+1        ; 0
d3d5 8e 00 04           STX $0400           ; BASIC start
d3d8 a0 04              LDY #4              ; X=0  Y=4
d3da 84 29              STY TXTTAB+1        ; >$0401
d3dc 86 11              STX LINNUM
d3de 84 12              STY LINNUM+1        ; $0400
d3e0 a9 08              LDA #8
d3e2 85 ab              STA Wedge_Unit
d3e4 a0 01              LDY #1              ; start RAM test at $0401
d3e6 84 28              STY TXTTAB          ; (TXTTAB) = $0401
d3e8 b1 11    IBRV_20   LDA (LINNUM),Y
d3ea aa                 TAX                 ; save content
d3eb a9 55              LDA #$55            ; test pattern
d3ed 91 11              STA (LINNUM),Y
d3ef d1 11              CMP (LINNUM),Y
d3f1 d0 11              BNE IBRV_30         ; failed
d3f3 0a                 ASL A               ; shift pattern
d3f4 91 11              STA (LINNUM),Y
d3f6 d1 11              CMP (LINNUM),Y
d3f8 d0 0a              BNE IBRV_30         ; failed
d3fa 8a                 TXA                 ; restore content
d3fb 91 11              STA (LINNUM),Y
d3fd c8                 INY                 ; next address
d3fe d0 e8              BNE IBRV_20         ; loop
d400 e6 12              INC LINNUM+1
d402 10 e4              BPL IBRV_20         ; loop for LINNUM < $8000
d404 a5 12    IBRV_30   LDA LINNUM+1
d406 84 34              STY MEMSIZ
d408 85 35              STA MEMSIZ+1        ; top of RAM + 1
d40a 84 30              STY FRETOP
d40c 85 31              STA FRETOP+1
d40e 20 77 fb           JSR Init_RAM_Vectors
d411 a9 9d              LDA #<Start_Message
d413 a0 de              LDY #>Start_Message
d415 20 1d bb           JSR Print_String
d418 a5 34              LDA MEMSIZ
d41a 38                 SEC
d41b e5 28              SBC TXTTAB
d41d aa                 TAX
d41e a5 35              LDA MEMSIZ+1
d420 e5 29              SBC TXTTAB+1
d422 20 83 cf           JSR Print_Integer_XA
d425 a9 38              LDA #<Bytes_Free_Message
d427 a0 d4              LDY #>Bytes_Free_Message
d429 20 1d bb           JSR Print_String
d42c 20 d4 b5           JSR Perform_NEW
d42f 20 01 cf           JSR Option_ROM
d432 20 22 cf           JSR BOOT_File
d435 4c ff b3           JMP Basic_Ready

              ; ******************
d438            Bytes_Free_Message
              ; ******************

d438 20 42 59           .BYTE " BYTES FREE\r",0

              ; *******
d445            Monitor
              ; *******
d445 a9 b4              LDA #>[Basic_Ready+1]
d447 48                 PHA
d448 a9 00              LDA #<[Basic_Ready+1]
d44a 48                 PHA
d44b a9 00              LDA #0              ; clear if not already 0
d44d 48                 PHA                 ; Y
d44e 48                 PHA                 ; X
d44f 48                 PHA                 ; A
d450 48                 PHA                 ; SR

              ; *************
d451            MONITOR_BREAK
              ; *************

d451 d8                 CLD
d452 a2 01              LDX #1              ; 1 for BRK
d454 c9 20              CMP #$20            ; T2 single step IRQ
d456 d0 01              BNE MOBR_05
d458 ca                 DEX                 ; 0 for STEP IRQ
d459 86 b3    MOBR_05   STX PC_Adjust
d45b 20 a6 f2           JSR Kernal_CLRCHN
d45e 68                 PLA
d45f 8d a7 02           STA Mon_Register+7  ; Y
d462 68                 PLA
d463 8d a6 02           STA Mon_Register+6  ; X
d466 68                 PLA
d467 8d a5 02           STA Mon_Register+5  ; A
d46a 68                 PLA
d46b 8d a4 02           STA Mon_Register+4  ; SR
d46e 20 43 ec           JSR Install_Bank_Access ; Carry = 1
d471 68                 PLA
d472 e5 b3              SBC PC_Adjust
d474 8d a1 02           STA Mon_Register+1  ; PC lo
d477 68                 PLA
d478 e9 00              SBC #0
d47a 8d a0 02           STA Mon_Register    ; PC hi
d47d a5 90              LDA CINV
d47f 8d a3 02           STA Mon_Register+3  ; IRQ lo
d482 a5 91              LDA CINV+1
d484 8d a2 02           STA Mon_Register+2  ; IRQ hi
d487 ba                 TSX
d488 8e a8 02           STX Mon_Register+8  ; SP
d48b a5 b6              LDA R_Bank
d48d 8d a9 02           STA Mon_Register+9  ; RB
d490 a5 b7              LDA W_Bank
d492 8d aa 02           STA Mon_Register+10 ; WB
d495 58                 CLI
d496 a6 b3              LDX PC_Adjust
d498 f0 0e              BEQ MOBR_20         ; no greetings on single step mode
d49a a0 ff              LDY #-1
d49c c8       MOBR_10   INY
d49d b9 26 d5           LDA Mon_Start,Y
d4a0 f0 06              BEQ MOBR_20
d4a2 20 02 e2           JSR EDIT_CHROUT
d4a5 4c 9c d4           JMP MOBR_10
d4a8 a9 52    MOBR_20   LDA #'R'
d4aa d0 11              BNE Mon_20          ; always

              ; *********
d4ac            Mon_Error
              ; *********

d4ac a9 3f              LDA #'?'
d4ae 20 02 e2           JSR EDIT_CHROUT

              ; ********
d4b1            Mon_Main
              ; ********

d4b1 20 21 d5           JSR Mon_Print_CR
d4b4 20 f4 d8 Mon_10    JSR Mon_CHRIN
d4b7 f0 f8              BEQ Mon_Main
d4b9 c9 20              CMP #' '
d4bb f0 f7              BEQ Mon_10
d4bd a2 18    Mon_20    LDX #24
d4bf ca       Mon_30    DEX
d4c0 30 ea              BMI Mon_Error
d4c2 dd 31 d5           CMP Mon_Commands,X
d4c5 d0 f8              BNE Mon_30
d4c7 bd 49 d5           LDA Mon_Sub_Hi,X
d4ca 48                 PHA
d4cb bd 60 d5           LDA Mon_Sub_Lo,X
d4ce 48                 PHA
d4cf 60                 RTS ;Size   31 [Mon_Main]

              ; **********************
d4d0            Mon_Print_A_Hex_Values
              ; **********************

d4d0 85 b5              STA MONCNT
d4d2 a0 00              LDY #0
d4d4 20 1e d5 MPAH_10   JSR Mon_Print_Blank
d4d7 20 7a 02           JSR Bank_Fetch
d4da 20 57 d7           JSR Print_Hex_Byte
d4dd c8                 INY
d4de c0 08              CPY #8
d4e0 d0 03              BNE MPAH_12
d4e2 20 1e d5           JSR Mon_Print_Blank
d4e5 c4 b5    MPAH_12   CPY MONCNT
d4e7 90 eb              BCC MPAH_10
d4e9 20 1e d5           JSR Mon_Print_Blank
d4ec a5 b5              LDA MONCNT
d4ee c9 10              CMP #16
d4f0 d0 20              BNE MPAH_Ret
d4f2 a0 00              LDY #0
d4f4 20 7a 02 MPAH_20   JSR Bank_Fetch
d4f7 29 7f              AND #$7f
d4f9 c9 20              CMP #$20
d4fb 90 04              BCC MPAH_30
d4fd c9 60              CMP #$60
d4ff 90 02              BCC MPAH_40
d501 a9 2e    MPAH_30   LDA #'.'
d503 20 02 e2 MPAH_40   JSR EDIT_CHROUT
d506 c8                 INY
d507 c0 08              CPY #8
d509 d0 03              BNE MPAH_42
d50b 20 1e d5           JSR Mon_Print_Blank
d50e c4 b5    MPAH_42   CPY MONCNT
d510 90 e2              BCC MPAH_20
d512 60       MPAH_Ret  RTS ;Size   67 [Mon_Print_A_Hex_Values]

              ; *****************
d513            Mon_STAL_Register
              ; *****************

d513 a9 a4              LDA #<[Mon_Register+4]
d515 85 fb              STA STAL
d517 a9 02              LDA #>[Mon_Register+4]
d519 85 fc              STA STAL+1
d51b a9 07              LDA #7              ; 7 bytes to display
d51d 60                 RTS ;Size   11 [Mon_STAL_Register]

              ; ***************
d51e            Mon_Print_Blank
              ; ***************

d51e a9 20              LDA #$20            ; ' '
d520 2c                 .BYTE $2c

              ; ************
d521            Mon_Print_CR
              ; ************

d521 a9 0d              LDA #CR
d523 4c 02 e2           JMP EDIT_CHROUT


d526 42 53 20   Mon_Start .BYTE "BS MONITOR "

              ; ************
d531            Mon_Commands
              ; ************

d531 23 24 2e           .BYTE "#$./:;@ABCDFGHLMNRSTUWX",0

              ; **********
d549            Mon_Sub_Hi
              ; **********

d549 fd                 .BYTE >[Mon_Unit-1]           ; #
d54a fb                 .BYTE >[Mon_Dir-1]            ; $
d54b fa                 .BYTE >[Assemble-1]           ; .
d54c d6                 .BYTE >[Mon_Load-1]           ; /
d54d d6                 .BYTE >[Modify_Memory-1]      ; :
d54e d6                 .BYTE >[Modify_Register-1]    ; ;
d54f fb                 .BYTE >[Mon_Wedge-1]          ; @
d550 fa                 .BYTE >[Assemble-1]           ; A
d551 d8                 .BYTE >[Mon_Set_Bank-1]       ; B
d552 fb                 .BYTE >[Mon_Compare-1]        ; C
d553 f5                 .BYTE >[Disassemble-1]        ; D
d554 e5                 .BYTE >[Mon_Fill-1]           ; F
d555 d6                 .BYTE >[Mon_Go-1]             ; G
d556 fc                 .BYTE >[Mon_Hunt-1]           ; H
d557 d6                 .BYTE >[Mon_Load-1]           ; L
d558 d5                 .BYTE >[Display_Memory-1]     ; M
d559 fd                 .BYTE >[Mon_Next]             ; N
d55a d5                 .BYTE >[Display_Register-1]   ; R
d55b d6                 .BYTE >[Mon_Save-1]           ; S
d55c fc                 .BYTE >[Mon_Transfer-1]       ; T
d55d e5                 .BYTE >[Mon_Disk-1]           ; U
d55e d8                 .BYTE >[Mon_Write_Bank-1]     ; W
d55f d6                 .BYTE >[Mon_Exit-1]           ; X

              ; **********
d560            Mon_Sub_Lo
              ; **********

d560 50                 .BYTE <[Mon_Unit-1]           ; #
d561 58                 .BYTE <[Mon_Dir-1]            ; $
d562 41                 .BYTE <[Assemble-1]           ; .
d563 d0                 .BYTE <[Mon_Load-1]           ; /
d564 5b                 .BYTE <[Modify_Memory-1]      ; :
d565 41                 .BYTE <[Modify_Register-1]    ; ;
d566 37                 .BYTE <[Mon_Wedge-1]          ; @
d567 41                 .BYTE <[Assemble-1]           ; A
d568 e3                 .BYTE <[Mon_Set_Bank-1]       ; B
d569 e3                 .BYTE <[Mon_Compare-1]        ; C
d56a c1                 .BYTE <[Disassemble-1]        ; D
d56b 3e                 .BYTE <[Mon_Fill-1]           ; F
d56c 86                 .BYTE <[Mon_Go-1]             ; G
d56d 7f                 .BYTE <[Mon_Hunt-1]           ; H
d56e d0                 .BYTE <[Mon_Load-1]           ; L
d56f f6                 .BYTE <[Display_Memory-1]     ; M
d570 6e                 .BYTE <[Mon_Next]             ; N
d571 7e                 .BYTE <[Display_Register-1]   ; R
d572 d3                 .BYTE <[Mon_Save-1]           ; S
d573 15                 .BYTE <[Mon_Transfer-1]       ; T
d574 a6                 .BYTE <[Mon_Disk-1]           ; U
d575 eb                 .BYTE <[Mon_Write_Bank-1]     ; W
d576 c0                 .BYTE <[Mon_Exit-1]           ; X

              ; **********
d577            Mon_Prompt
              ; **********

d577 48                 PHA
d578 20 21 d5           JSR Mon_Print_CR
d57b 68                 PLA
d57c 4c 02 e2           JMP EDIT_CHROUT

              ; ****************
d57f            Display_Register
              ; ****************

d57f a2 00              LDX #0
d581 bd fb e4 DiRe_10   LDA Mon_Message,X
d584 20 02 e2           JSR EDIT_CHROUT
d587 e8                 INX
d588 e0 2a              CPX #42
d58a d0 f5              BNE DiRe_10
d58c a5 b6              LDA R_Bank
d58e 8d a9 02           STA Mon_Register+9
d591 a5 b7              LDA W_Bank
d593 8d aa 02           STA Mon_Register+10
d596 a9 3b              LDA #';'
d598 20 77 d5           JSR Mon_Prompt
d59b 20 1e d5           JSR Mon_Print_Blank
d59e ad a0 02           LDA Mon_Register    ; display PC
d5a1 20 57 d7           JSR Print_Hex_Byte
d5a4 ad a1 02           LDA Mon_Register+1
d5a7 20 57 d7           JSR Print_Hex_Byte
d5aa 20 1e d5           JSR Mon_Print_Blank
d5ad ad a2 02           LDA Mon_Register+2  ; display IRQ vector
d5b0 20 57 d7           JSR Print_Hex_Byte
d5b3 ad a3 02           LDA Mon_Register+3
d5b6 20 57 d7           JSR Print_Hex_Byte
d5b9 20 13 d5           JSR Mon_STAL_Register
d5bc 20 d0 d4           JSR Mon_Print_A_Hex_Values
d5bf ad a4 02           LDA Mon_Register+4  ; SR
d5c2 85 b5              STA MONCNT
d5c4 a2 08              LDX #8
d5c6 a9 30    DiRe_20   LDA #'0'
d5c8 06 b5              ASL MONCNT
d5ca 69 00              ADC #0
d5cc 20 02 e2           JSR EDIT_CHROUT
d5cf ca                 DEX
d5d0 d0 f4              BNE DiRe_20
d5d2 a5 b3              LDA PC_Adjust
d5d4 d0 42              BNE To_Mon_Main     ; branch if not stepping
d5d6 ad a1 02           LDA Mon_Register+1
d5d9 85 fb              STA STAL
d5db ad a0 02           LDA Mon_Register
d5de 85 fc              STA STAL+1
d5e0 4c cf f5           JMP Disa_15


              ; ************
d5e3            Mon_Cmp_Addr
              ; ************

d5e3 a5 ba              LDA Dis_Line        ; negative: compare addresses
d5e5 30 07              BMI Cmp_STAL_MEMUSS
d5e7 e6 ba              INC Dis_Line
d5e9 a9 10              LDA #16
d5eb c5 ba              CMP Dis_Line        ; line count > 16 ?
d5ed 60                 RTS ;Size   11 [Mon_Cmp_Addr]

              ; ***************
d5ee            Cmp_STAL_MEMUSS
              ; ***************

d5ee a5 fd              LDA MEMUSS          ; end addr >= start addr ?
d5f0 c5 fb              CMP STAL
d5f2 a5 fe              LDA MEMUSS+1
d5f4 e5 fc              SBC STAL+1
d5f6 60                 RTS ;Size    9 [Cmp_STAL_MEMUSS]

              ; **************
d5f7            Display_Memory
              ; **************

d5f7 20 1b d6           JSR Mon_Get_Addr
d5fa 20 35 f3 DiMe_10   JSR Check_STOP_Key  ; STOP key pressed?
d5fd f0 19              BEQ To_Mon_Main
d5ff 20 e3 d5           JSR Mon_Cmp_Addr
d602 90 14              BCC To_Mon_Main     ; STAL > MEMUSS ?
d604 a9 3a              LDA #':'
d606 20 77 d5           JSR Mon_Prompt
d609 20 50 d7           JSR Mon_Print_STAL
d60c a9 10              LDA #16             ; dump 16 bytes per line
d60e 20 d0 d4           JSR Mon_Print_A_Hex_Values
d611 a9 10              LDA #16
d613 20 15 fb           JSR Add_STAL
d616 d0 e2              BNE DiMe_10
d618          To_Mon_Main
d618 4c b1 d4           JMP Mon_Main

              ; ************
d61b            Mon_Get_Addr
              ; ************

d61b a0 00              LDY #0              ; reset line count
d61d 84 ba              STY Dis_Line
d61f 88                 DEY                 ; Y = $ff
d620 84 fd              STY MEMUSS
d622 84 fe              STY MEMUSS+1        ; default end address = $ffff
d624 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d627 f0 13              BEQ MGA_Ret         ; use last value for STAL
d629 20 6d d7           JSR Hex_To_STAL     ; read start address to STAL
d62c 90 0f              BCC MGA_Err
d62e 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d631 f0 09              BEQ MGA_Ret
d633 a2 fd              LDX #MEMUSS
d635 20 6f d7           JSR Read_Hex_Word  ; read end address
d638 90 03              BCC MGA_Err
d63a c6 ba              DEC Dis_Line        ; disable line count
d63c 60       MGA_Ret   RTS ;Size   34 [Mon_Get_Addr]
d63d 68       MGA_Err   PLA
d63e 68                 PLA
d63f          To_Mon_Err
d63f 4c ac d4           JMP Mon_Error

              ; ***************
d642            Modify_Register
              ; ***************

d642 a2 00              LDX #0
d644 20 7c d7 MoRe_10   JSR Read_Hex
d647 9d a0 02           STA Mon_Register,X
d64a e8                 INX
d64b e0 0b              CPX #11
d64d 90 f5              BCC MoRe_10
d64f ad a9 02           LDA Mon_Register+9
d652 85 b6              STA R_Bank
d654 ad aa 02           LDA Mon_Register+10
d657 85 b7              STA W_Bank
d659 4c b1 d4           JMP Mon_Main

              ; *************
d65c            Modify_Memory
              ; *************

d65c 20 6d d7           JSR Hex_To_STAL
d65f 90 de              BCC To_Mon_Err
d661 a9 10              LDA #16
d663 85 b5    MoMe_10   STA MONCNT
d665 a5 fb              LDA STAL
d667 85 f9              STA BPTR
d669 a5 fc              LDA STAL+1
d66b 85 fa              STA BPTR+1
d66d a0 00              LDY #0
d66f 20 7c d7 MoMe_20   JSR Read_Hex
d672 90 cb              BCC To_Mon_Err
d674 85 cb              STA Mon_Tmp
d676 20 8b 02           JSR Bank_Store
d679 20 7a 02           JSR Bank_Fetch
d67c c5 cb              CMP Mon_Tmp
d67e d0 bf              BNE To_Mon_Err      ; not RAM
d680 c8       MoMe_30   INY
d681 c4 b5              CPY MONCNT
d683 90 ea              BCC MoMe_20
d685 b0 91              BCS To_Mon_Main

              ; ******
d687            Mon_Go
              ; ******

d687 20 f4 d8           JSR Mon_CHRIN
d68a f0 10              BEQ MoGo_10
d68c c9 20              CMP #' '
d68e d0 af              BNE To_Mon_Err
d690 20 7c d7           JSR Read_Hex
d693 8d a0 02           STA Mon_Register
d696 20 7c d7           JSR Read_Hex
d699 8d a1 02           STA Mon_Register+1
d69c 78       MoGo_10   SEI
d69d ad a2 02           LDA Mon_Register+2  ; IRQ
d6a0 85 91              STA CINV+1
d6a2 ad a3 02           LDA Mon_Register+3
d6a5 85 90              STA CINV

              ; ********
d6a7            Mon_Step
              ; ********

d6a7 ae a8 02           LDX Mon_Register+8  ; SP
d6aa 9a                 TXS
d6ab ad a0 02           LDA Mon_Register    ; PC high
d6ae 48                 PHA
d6af ad a1 02           LDA Mon_Register+1  ; PC low
d6b2 48                 PHA
d6b3 ad a4 02           LDA Mon_Register+4  ; SR
d6b6 48                 PHA
d6b7 ad a5 02           LDA Mon_Register+5
d6ba ae a6 02           LDX Mon_Register+6
d6bd ac a7 02           LDY Mon_Register+7
d6c0 40                 RTI

              ; ********
d6c1            Mon_Exit
              ; ********

d6c1 ae a8 02           LDX Mon_Register+8  ; SP
d6c4 9a                 TXS
d6c5 4c ff b3           JMP Basic_Ready

              ; *************
d6c8            Set_DOS_FNADR
              ; *************

d6c8 a9 42              LDA #<DOS_Filename
d6ca 85 da              STA FNADR
d6cc a9 03              LDA #>DOS_Filename
d6ce 85 db              STA FNADR+1
d6d0 60                 RTS ;Size    9 [Set_DOS_FNADR]

              ; ********
d6d1            Mon_Load
              ; ********

d6d1 a9 00              LDA #0              ; load flag
d6d3 2c                 .BYTE $2c           ; skip 2 bytes

              ; ********
d6d4            Mon_Save
              ; ********

d6d4 a9 80              LDA #$80            ; save flag
d6d6 85 9d              STA VERCK           ; (0) LOAD, ($80) SAVE
d6d8 a0 01              LDY #1
d6da 84 d3              STY SA              ; use file load address
d6dc 88                 DEY                 ; Y = 0
d6dd 20 c8 d6           JSR Set_DOS_FNADR
d6e0 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
d6e3 20 f4 d8 MLS_10    JSR Mon_CHRIN
d6e6 f0 14              BEQ MLS_Err         ; filename required
d6e8 c9 22              CMP #QUOTE          ; filename must be quoted
d6ea d0 f7              BNE MLS_10          ; skip until leading quote
d6ec 20 f4 d8 MLS_20    JSR Mon_CHRIN       ; next char in string
d6ef f0 0b              BEQ MLS_Err         ; no ending quote
d6f1 c9 22              CMP #QUOTE          ; ending quote?
d6f3 f0 14              BEQ MLS_50
d6f5 91 da              STA (FNADR),Y       ; append to filename
d6f7 c8                 INY                 ; next
d6f8 c0 10              CPY #16
d6fa 90 f0              BCC MLS_20          ; loop
d6fc 4c ac d4 MLS_Err   JMP Mon_Error

d6ff 24 9d    MLS_30    BIT VERCK           ; LOAD or SAVE ?
d701 30 f9    MLS_35    BMI MLS_Err         ; SAVE needs range
d703 20 56 f3           JSR Load_File
d706 4c b1 d4           JMP Mon_Main        ; OK - done

d709 84 d1    MLS_50    STY FNLEN
d70b 20 f4 d8           JSR Mon_CHRIN       ; parameter after filename
d70e f0 ef              BEQ MLS_30
d710 c9 2c              CMP #','            ; comma needed
d712 d0 f5              BNE MLS_50
d714 20 7c d7           JSR Read_Hex        ; read device
d717 85 d4              STA FA
d719 20 f4 d8           JSR Mon_CHRIN
d71c f0 e1              BEQ MLS_30          ; no range -> LOAD
d71e c9 2c              CMP #','            ; comma needed
d720 d0 da              BNE MLS_Err
d722 20 6d d7           JSR Hex_To_STAL     ; STAL = start address
d725 a9 00              LDA #0
d727 85 d3              STA SA              ; relocate to EAL
d729 20 f4 d8           JSR Mon_CHRIN
d72c c9 2c              CMP #','
d72e d0 cc              BNE MLS_Err
d730 a2 c9              LDX #EAL
d732 20 6f d7           JSR Read_Hex_Word   ; EAL  = end address
d735 90 c5              BCC MLS_Err
d737 24 9d              BIT VERCK           ; (0) LOAD or ($80) SAVE
d739 10 c1              BPL MLS_Err
d73b 20 e3 f6           JSR Save_File
d73e 4c b1 d4           JMP Mon_Main

              ; *************
d741            Make_Hex_Byte
              ; *************

d741 48                 PHA
d742 4a                 LSR A
d743 4a                 LSR A
d744 4a                 LSR A
d745 4a                 LSR A
d746 20 63 d7           JSR Nibble_To_Hex
d749 aa                 TAX
d74a 68                 PLA
d74b 29 0f              AND #15
d74d 4c 63 d7           JMP Nibble_To_Hex

              ; **************
d750            Mon_Print_STAL
              ; **************

d750 a5 fc              LDA STAL+1
d752 20 57 d7           JSR Print_Hex_Byte
d755 a5 fb              LDA STAL

              ; **************
d757            Print_Hex_Byte
              ; **************

d757 20 41 d7           JSR Make_Hex_Byte

              ; ************
d75a            Mon_Print_XA
              ; ************

d75a 48                 PHA
d75b 8a                 TXA
d75c 20 02 e2           JSR EDIT_CHROUT
d75f 68                 PLA
d760 4c 02 e2           JMP EDIT_CHROUT

              ; *************
d763            Nibble_To_Hex
              ; *************

d763 18                 CLC
d764 69 f6              ADC #$f6
d766 90 02              BCC NTH_10
d768 69 06              ADC #6
d76a 69 3a    NTH_10    ADC #$3a
d76c 60                 RTS ;Size   10 [Nibble_To_Hex]

              ; ***********
d76d            Hex_To_STAL
              ; ***********

d76d a2 fb              LDX #STAL

              ; *************
d76f            Read_Hex_Word
              ; *************

d76f 20 7c d7           JSR Read_Hex        ; X points to word address
d772 90 07              BCC RHW_Ret
d774 95 01              STA 1,X             ; high byte
d776 20 7c d7           JSR Read_Hex
d779 95 00              STA 0,X             ; low  byte
d77b 60       RHW_Ret   RTS ;Size   13 [Read_Hex_Word]

              ; ********
d77c            Read_Hex
              ; ********

              ; read a two digit hex number, allow leading blanks

d77c 20 f4 d8           JSR Mon_CHRIN
d77f c9 20              CMP #' '
d781 f0 f9              BEQ Read_Hex
d783          Read_Hex_A
d783 20 11 d9           JSR Is_Hex
d786 90 17              BCC ReHe_Ret         ; error
d788 20 fa d8           JSR Hex_To_Bin
d78b 0a                 ASL A
d78c 0a                 ASL A
d78d 0a                 ASL A
d78e 0a                 ASL A
d78f 85 cb              STA Mon_Tmp
d791 20 f4 d8           JSR Mon_CHRIN
d794 20 11 d9           JSR Is_Hex
d797 90 06              BCC ReHe_Ret         ; error
d799 20 fa d8           JSR Hex_To_Bin
d79c 05 cb              ORA Mon_Tmp
d79e 38                 SEC
d79f 60       ReHe_Ret  RTS ;Size   36 [Read_Hex]


d7a0 00 00 00           .FILL $d7af - * (0) ; 15 bytes

              ; *************
d7af            Kernal_RECORD
              ; *************

d7af a9 01              LDA #1
d7b1 8d 3a 03           STA DOS_Tmp         ; default for position
d7b4 20 76 00           JSR CHRGOT
d7b7 a9 23              LDA #'#'
d7b9 20 f7 be           JSR Need_A
d7bc 20 8a de           JSR DOS_Get_Byte    ; get lfn
d7bf e0 00              CPX #0
d7c1 f0 3e              BEQ RECO_40
d7c3 86 d2              STX LA
d7c5 20 f5 be           JSR Need_Comma
d7c8 f0 3e              BEQ DOS_JMP_Syntax_Error
d7ca 90 0f              BCC RECO_10         ; -> numeric
d7cc 20 f2 be           JSR Need_Left_Parenthesis
d7cf 20 98 bd           JSR Eval_Expression
d7d2 20 2d c9           JSR FAC1_To_LINNUM
d7d5 20 ef be           JSR Need_Right_Parenthesis
d7d8 4c e1 d7           JMP RECO_20
d7db 20 98 bd RECO_10   JSR Eval_Expression ; get record #
d7de 20 2d c9           JSR FAC1_To_LINNUM
d7e1 20 76 00 RECO_20   JSR CHRGOT
d7e4 f0 18              BEQ RECO_30
d7e6 20 f5 be           JSR Need_Comma
d7e9 f0 1d              BEQ DOS_JMP_Syntax_Error
d7eb 20 8a de           JSR DOS_Get_Byte    ; get position
d7ee e0 00              CPX #0
d7f0 f0 0f              BEQ RECO_40
d7f2 e0 ff              CPX #$ff
d7f4 f0 0b              BEQ RECO_40
d7f6 8e 3a 03           STX DOS_Tmp
d7f9 20 76 00           JSR CHRGOT
d7fc d0 0a              BNE DOS_JMP_Syntax_Error
d7fe 4c 31 da RECO_30   JMP Build_Record_Command
d801 4c 27 de RECO_40   JMP DOS_JMP_Illegal_Quantity

              ; *************************
d804            Allow_Drive_Unit_Filename
              ; *************************

d804 29 e6              AND #$e6
d806 f0 03              BEQ Check_Filename_Given

              ; ********************
d808            DOS_JMP_Syntax_Error
              ; ********************

d808 4c 00 bf           JMP Syntax_Error

              ; ********************
d80b            Check_Filename_Given
              ; ********************

d80b ad 3e 03           LDA DOS_Flags
d80e 29 01              AND #1
d810 c9 01              CMP #1
d812 d0 f4              BNE DOS_JMP_Syntax_Error
d814 ad 3e 03           LDA DOS_Flags
d817 60                 RTS ;Size   13 [Check_Filename_Given]

              ; ********************
d818            Allow_Drive_And_Unit
              ; ********************

d818 29 e7              AND #$e7
d81a d0 ec              BNE DOS_JMP_Syntax_Error
d81c 60                 RTS ;Size    5 [Allow_Drive_And_Unit]

              ; ************
d81d            No_WL_Record
              ; ************

d81d 29 c4              AND #$c4
d81f d0 e7              BNE DOS_JMP_Syntax_Error
d821 ad 3e 03           LDA DOS_Flags

              ; *********************
d824            Check_Filename_Syntax
              ; *********************

d824 29 03              AND #3
d826 c9 03              CMP #3
d828 d0 de              BNE DOS_JMP_Syntax_Error
d82a ad 3e 03           LDA DOS_Flags
d82d 60                 RTS ;Size   10 [Check_Filename_Syntax]

              ; *******************
d82e            Check_Record_Syntax
              ; *******************

d82e 29 05              AND #5
d830 c9 05              CMP #5
d832 d0 d4              BNE DOS_JMP_Syntax_Error
d834 ad 3e 03           LDA DOS_Flags
d837 60                 RTS ;Size   10 [Check_Record_Syntax]

              ; ***************
d838            DOS_Build_Table
              ; ***************

d838 ff                 .BYTE $ff
                        ;-------------------- directory $00
d839 24                 .BYTE "$"
d83a d1                 .BYTE $d1           ; drive 1

                        ;-------------------- dopen     $02
d83b d1                 .BYTE $d1           ; drive 1
d83c 3a                 .BYTE ":"
d83d f1                 .BYTE $f1           ; file 1
d83e 2c                 .BYTE ","
d83f e1                 .BYTE $e1           ; L,S,W
d840 2c                 .BYTE ","
d841 e0                 .BYTE $e0           ; Record length

                        ;-------------------- append    $09
d842 d1                 .BYTE $d1           ; drive 1
d843 3a                 .BYTE ":"
d844 f1                 .BYTE $f1           ; file 1
d845 2c 41              .BYTE ",A"

                        ;-------------------- header    $0e
d847 4e                 .BYTE "N"
d848 d1                 .BYTE $d1           ; drive 1
d849 3a                 .BYTE ":"
d84a f1                 .BYTE $f1           ; file 1
d84b 2c                 .BYTE ","
d84c d0                 .BYTE $d0           ; ID

                        ;-------------------- collect   $14
d84d 56                 .BYTE "V"
d84e d1                 .BYTE $d1           ; drive 1

                        ;-------------------- backup    $16
d84f 44                 .BYTE "D"
d850 d2                 .BYTE $d2           ; drive 2
d851 3d                 .BYTE "="
d852 d1                 .BYTE $d1           ; drive 1

                        ;-------------------- copy      $1a
d853 43                 .BYTE "C"
d854 d2                 .BYTE $d2           ; drive 2
d855 3a                 .BYTE ":"
d856 f2                 .BYTE $f2           ; file 2
d857 3d                 .BYTE "="
d858 d1                 .BYTE $d1           ; drive 1
d859 3a                 .BYTE ":"
d85a f1                 .BYTE $f1           ; file 1

                        ;-------------------- concat    $22
d85b 43                 .BYTE "C"
d85c d2                 .BYTE $d2           ; drive 2
d85d 3a                 .BYTE ":"
d85e f2                 .BYTE $f2           ; file 2
d85f 3d                 .BYTE "="
d860 d2                 .BYTE $d2           ; drive 2
d861 3a                 .BYTE ":"
d862 f2                 .BYTE $f2           ; file 2
d863 2c                 .BYTE ","
d864 d1                 .BYTE $d1           ; drive 1
d865 3a                 .BYTE ":"
d866 f1                 .BYTE $f1           ; file 1

                        ;-------------------- rename    $2e
d867 52                 .BYTE "R"
d868 d1                 .BYTE $d1           ; drive 1
d869 3a                 .BYTE ":"
d86a f2                 .BYTE $f2           ; file 2
d86b 3d                 .BYTE "="
d86c d1                 .BYTE $d1           ; drive 1
d86d 3a                 .BYTE ":"
d86e f1                 .BYTE $f1           ; file 1

                        ;-------------------- scratch   $36
d86f 53                 .BYTE "S"
d870 d1                 .BYTE $d1           ; drive 1
d871 3a                 .BYTE ":"
d872 f1                 .BYTE $f1           ; file 1

              ; ****************
d873            Kernal_DIRECTORY
              ; ****************

d873 20 68 dc           JSR Parse_DOS_Parameter
d876 20 18 d8           JSR Allow_Drive_And_Unit
d879 a0 00              LDY #0
d87b a2 01              LDX #1
d87d ad 3e 03           LDA DOS_Flags
d880 29 10              AND #16
d882 f0 01              BEQ DIRE_10
d884 e8                 INX                 ; drive given
d885 8a       DIRE_10   TXA
d886 20 fa db           JSR Build_DOS_Command

              ; **************
d889            Wedge_Call_Dir
              ; **************

d889 a9 60              LDA #$60            ; secondary address 0 for LOAD
d88b 85 d3              STA SA
d88d a9 0e              LDA #14             ; logical address used for loading directory
d88f 85 d2              STA LA
d891 20 b9 f1           JSR UNLSN
d894 20 65 f5           JSR Open_File
d897 a2 0e              LDX #14
d899 20 af f7           JSR Kernal_CHKIN    ; input from floppy
d89c a0 03              LDY #3              ; 1st time: skip load address + next line link
d89e 20 c0 f1 WCD_10    JSR ACPTR           ; read until length in blocks read
d8a1 aa                 TAX                 ; file size low in X
d8a2 a5 96              LDA STATUS
d8a4 d0 36              BNE WCD_80          ; abort if status bad
d8a6 20 c0 f1           JSR ACPTR           ; file size high in A
d8a9 88                 DEY
d8aa d0 f2              BNE WCD_10          ; if not done
d8ac 20 83 cf           JSR Print_Integer_XA; output number of blocks
d8af a9 20              LDA #' '            ; output separator space
d8b1 20 02 e2           JSR EDIT_CHROUT
d8b4 20 c0 f1 WCD_20    JSR ACPTR           ; get char
d8b7 f0 1a              BEQ WCD_40          ; branch if end of line
d8b9 a6 96              LDX STATUS          ; get status
d8bb d0 1f              BNE WCD_80          ; abort if bad status
d8bd 20 02 e2           JSR EDIT_CHROUT
d8c0 20 35 f3           JSR Check_STOP_Key  ; abort if STOP key pressed
d8c3 f0 17              BEQ WCD_80
d8c5 20 0d f2           JSR GETIN_10        ; read keyboard
d8c8 c9 20              CMP #' '
d8ca d0 e8              BNE WCD_20          ; continue if not SPACE pressed
d8cc 20 0d f2 WCD_30    JSR GETIN_10        ; read keyboard
d8cf f0 fb              BEQ WCD_30          ; loop until any key pressed
d8d1 d0 e1              BNE WCD_20          ; branch always: continue reading dir characters

d8d3 a9 0d    WCD_40    LDA #CR             ; end of line: output CR
d8d5 20 02 e2           JSR EDIT_CHROUT
d8d8 a0 02              LDY #2              ; further passes: skip line link only
d8da d0 c2              BNE WCD_10          ; branch always

d8dc 20 a6 f2 WCD_80    JSR Kernal_CLRCHN   ; exit: clear channel
d8df a9 0e              LDA #14             ; close directory
d8e1 4c e2 f2           JMP Close_LA_in_A

              ; ************
d8e4            Mon_Set_Bank
              ; ************

d8e4 20 7c d7           JSR Read_Hex
d8e7 85 b6              STA R_Bank
d8e9 4c b1 d4           JMP Mon_Main

              ; **************
d8ec            Mon_Write_Bank
              ; **************

d8ec 20 7c d7           JSR Read_Hex
d8ef 85 b7              STA W_Bank
d8f1 4c b1 d4           JMP Mon_Main

              ; *********
d8f4            Mon_CHRIN
              ; *********

d8f4 20 15 f2           JSR Kernal_CHRIN
d8f7 c9 0d              CMP #CR
d8f9 60                 RTS ;Size    6 [Mon_CHRIN]

              ; **********
d8fa            Hex_To_Bin
              ; **********

d8fa c9 3a              CMP #$3a
d8fc 08                 PHP
d8fd 29 0f              AND #15
d8ff 28                 PLP
d900 90 02              BCC HTB_Ret
d902 69 08              ADC #8
d904 60       HTB_Ret   RTS ;Size   11 [Hex_To_Bin]

              ; ******
d905            Is_Int
              ; ******

d905 c9 24              CMP #'$'
d907 f0 18              BEQ IH_True
d909 c9 2b              CMP #'+'
d90b f0 14              BEQ IH_True
d90d c9 2d              CMP #'-'
d90f f0 10              BEQ IH_True

              ; ******
d911            Is_Hex
              ; ******

d911 c9 47              CMP #'F'+1
d913 b0 0e              BCS IH_False
d915 c9 41              CMP #'A'
d917 b0 08              BCS IH_True

              ; ******
d919            Is_Dec
              ; ******

d919 c9 30              CMP #'0'
d91b 90 06              BCC IH_False
d91d c9 3a              CMP #'9'+1
d91f b0 02              BCS IH_False
d921 38       IH_True   SEC
d922 60                 RTS                 ; carry 1 : true ;Size   10 [Is_Dec]
d923 18       IH_False  CLC
d924 60                 RTS                 ; carry 0 : false ;Size   12 [Is_Dec]

d925 00 00 00           .FILL $d92f - * (0) ; 10 bytes

              ; **************
d92f            Select_Free_SA
              ; **************

d92f a0 61              LDY #$61            ; start with SA = $62
d931 c8       SFSA_10   INY
d932 98                 TYA
d933 a6 ae              LDX LDTND           ; # of open files
d935 ca       SFSA_20   DEX
d936 30 07              BMI SFSA_30         ; -> not in use : take this SA
d938 dd 65 02           CMP SAT,X
d93b f0 f4              BEQ SFSA_10         ; -> in use: try next
d93d d0 f6              BNE SFSA_20
d93f 84 d3    SFSA_30   STY SA
d941 60                 RTS ;Size   19 [Select_Free_SA]

              ; ********************
d942            Kernal_DOPEN ; $d942
              ; ********************

d942 20 68 dc           JSR Parse_DOS_Parameter
d945 20 2e d8           JSR Check_Record_Syntax
d948 29 22              AND #$22            ; 2nd. filename or drive ?
d94a d0 20              BNE DOPEN_Err
d94c 20 2f d9           JSR Select_Free_SA  ; choose free secondary address
d94f a2 00              LDX #0              ; buffer index
d951 a9 03              LDA #3              ; length of build string (open read)
d953 2c 3e 03           BIT DOS_Flags
d956 50 04              BVC DOPEN_20        ; -> not a write file
d958 08                 PHP                 ; save flags
d959 a9 07              LDA #7              ; length of build string (open write)
d95b 28                 PLP                 ; restore flags
d95c 10 06    DOPEN_20  BPL DOPEN_30        ; -> not a replacement
d95e a0 40              LDY #'@'            ; insert save & replace command
d960 8c 53 03           STY DOS_Command_Buffer
d963 e8                 INX                 ; advance buffer index
d964 a0 02    DOPEN_30  LDY #2              ; start  of build string (open)
d966 20 fc db           JSR Build_DOS_Command_X
d969 4c 63 f5           JMP Mf563
d96c 4c 00 bf DOPEN_Err JMP Syntax_Error

d96f                    .SIZE ;   45 [Kernal_DOPEN]

d96f 00 00 00           .FILL $d977-* (0) ; 8 bytes

              ; *********************
d977            Kernal_APPEND ; $d977
              ; *********************

d977 20 68 dc           JSR Parse_DOS_Parameter
d97a 20 2e d8           JSR Check_Record_Syntax
d97d 29 e2              AND #$e2            ; @,W,L,drive 2 or file 2 ?
d97f d0 eb              BNE DOPEN_Err
d981 20 2f d9           JSR Select_Free_SA
d984 a0 09              LDY #9              ; start  of build string (append)
d986 a9 05              LDA #5              ; length of build string (append)
d988 20 fa db           JSR Build_DOS_Command
d98b 4c 63 f5           JMP Mf563

d98e 00 00 00           .FILL $d991-* (0) ; 3 bytes

              ; **********************
d991            Kernal_Read_DS ; $d991
              ; **********************

d991 a5 d4              LDA FA
d993 d0 04              BNE KRD_10
d995 a9 08              LDA #8              ; default 8 if not set
d997 85 d4              STA FA
d999 20 d2 f0 KRD_10    JSR TALK
d99c a9 6f              LDA #$6f
d99e 85 d3              STA SA
d9a0 20 93 f1           JSR TKSA
d9a3 a2 00              LDX #0
d9a5 20 c0 f1 KDR_20    JSR ACPTR
d9a8 9d ad 03           STA DOS_Status,X
d9ab e8                 INX
d9ac c9 20              CMP #' '
d9ae 90 04              BCC KDR_30          ; end (normally CR)
d9b0 e0 29              CPX #41             ; buffer length
d9b2 90 f1              BCC KDR_20
d9b4 a9 00    KDR_30    LDA #0
d9b6 9d ad 03           STA DOS_Status,X
d9b9 20 ae f1           JSR UNTLK
d9bc ad ad 03           LDA DOS_Status      ; load first character
d9bf 60                 RTS ;Size   47 [Kernal_Read_DS]

d9c0 00 00 00           .FILL $d9d2-* (0) ; 18 bytes

              ; *********************
d9d2            Kernal_HEADER ; $d9d2
              ; *********************

d9d2 20 68 dc           JSR Parse_DOS_Parameter
d9d5 20 04 d8           JSR Allow_Drive_Unit_Filename
d9d8 29 11              AND #$11
d9da c9 11              CMP #$11            ; name & drive set ?
d9dc d0 8e              BNE DOPEN_Err
d9de 20 1b da           JSR Close_All_Device_Files
d9e1 20 9e db           JSR Are_You_Sure
d9e4 b0 1f              BCS HEAD_20         ; cancel if not 'YES'
d9e6 a0 0e              LDY #14             ; start  of build string
d9e8 a9 04              LDA #4              ; length of build string
d9ea ae 3f 03           LDX DOS_Id          ; ID given ?
d9ed f0 02              BEQ HEAD_10
d9ef a9 06              LDA #6              ; command includes ID
d9f1 20 98 da HEAD_10   JSR Put_DOS_Command
d9f4 20 91 d9           JSR Kernal_Read_DS
d9f7 c9 32              CMP #'2'
d9f9 90 0a              BCC HEAD_20         ; status < 20 are warnings
d9fb 20 51 f3           JSR In_Direct_Mode
d9fe d0 05              BNE HEAD_20
da00 a0 c5              LDY #<MSG_BAD_DISK  ; $c5
da02 4c 85 f1           JMP Display_Kernal_Message
da05 60       HEAD_20   RTS ;Size   52 [Kernal_HEADER]

da06 00                 .FILL $da07-* (0) ; 1 bytes

              ; *********************
da07            Kernal_DCLOSE ; $da07
              ; *********************

da07 20 68 dc           JSR Parse_DOS_Parameter
da0a 29 f3              AND #$f3            ; allow lfn only
da0c f0 03              BEQ CLOSE_10
da0e 4c 00 bf           JMP Syntax_Error
da11 20 e1 db CLOSE_10  JSR Clear_Status
da14 a5 d2              LDA LA
da16 f0 03              BEQ Close_All_Device_Files
da18 4c e2 f2           JMP Close_LA_in_A

              ; ******************************
da1b            Close_All_Device_Files ; $da1b
              ; ******************************

da1b a5 d4              LDA FA              ; Close all open files on device FA
da1d a6 ae              LDX LDTND
da1f ca       CLOSE_20  DEX
da20 30 0e              BMI CLOSE_Ret
da22 dd 5b 02           CMP FAT,X
da25 d0 f8              BNE CLOSE_20
da27 bd 51 02           LDA LAT,X
da2a 20 e7 f2           JSR Close_File_A
da2d b8                 CLV
da2e 50 eb              BVC Close_All_Device_Files
da30 60       CLOSE_Ret RTS ;Size   22 [Close_All_Device_Files]

              ; ****************************
da31            Build_Record_Command ; $da31
              ; ****************************

da31 a5 d2              LDA LA
da33 20 c1 f2           JSR LOOKUP_LA
da36 f0 05              BEQ BRC_10
da38 a0 17              LDY #<MSG_FILE_NOT_O; $17
da3a 4c af f5           JMP Handle_IO_Error
da3d 20 cd f2 BRC_10    JSR Set_LFS_From_X
da40 20 e1 db           JSR Clear_Status

              ; *********************
da43            DOS_Record_No ; $da43
              ; *********************

da43 a9 50              LDA #'P'
da45 8d 53 03           STA DOS_Command_Buffer
da48 a5 d3              LDA SA
da4a 8d 54 03           STA DOS_Command_Buffer+1
da4d a5 11              LDA LINNUM
da4f 8d 55 03           STA DOS_Command_Buffer+2
da52 a5 12              LDA LINNUM+1
da54 8d 56 03           STA DOS_Command_Buffer+3
da57 ad 3a 03           LDA DOS_Tmp
da5a 8d 57 03           STA DOS_Command_Buffer+4
da5d a2 05              LDX #5
da5f 20 4c dc           JSR DOS_SETNAM
da62 4c 9b da           JMP PDC_10

              ; **********************
da65            Kernal_COLLECT ; $da65
              ; **********************

da65 20 68 dc           JSR Parse_DOS_Parameter
da68 20 18 d8           JSR Allow_Drive_And_Unit
da6b 20 1b da           JSR Close_All_Device_Files
da6e a0 14              LDY #$14
da70 a2 01              LDX #1
da72 ad 3e 03           LDA DOS_Flags
da75 29 10              AND #16             ; drive set ?
da77 f0 01              BEQ COLL_10
da79 e8                 INX
da7a 8a       COLL_10   TXA
da7b 4c 98 da           JMP Put_DOS_Command

              ; *************
da7e            Kernal_BACKUP
              ; *************

da7e 20 68 dc           JSR Parse_DOS_Parameter
da81 29 30              AND #$30
da83 c9 30              CMP #$30            ; two drives set ?
da85 f0 03              BEQ BACK_10
da87 4c 00 bf BACK_Err  JMP Syntax_Error
da8a ad 3e 03 BACK_10   LDA DOS_Flags
da8d 29 c7              AND #$c7
da8f d0 f6              BNE BACK_Err
da91 20 1b da           JSR Close_All_Device_Files
da94 a0 16              LDY #$16
da96 a9 04              LDA #4

              ; ***************
da98            Put_DOS_Command
              ; ***************

da98 20 fa db           JSR Build_DOS_Command
da9b 20 d5 f0 PDC_10    JSR LISTEN
da9e a9 6f              LDA #$6f            ; SA #15
daa0 4c ba f4           JMP Send_DOS_Command

daa3 00 00 00           .FILL $daa7-* (0) ; 4 bytes

              ; *******************
daa7            Kernal_COPY ; $daa7
              ; *******************

daa7 20 68 dc           JSR Parse_DOS_Parameter
daaa a5 9c              LDA Source_Unit     ; check source unit
daac f0 07              BEQ KECO_10         ; not specified
daae c5 d4              CMP FA              ; same as target ?
dab0 f0 03              BEQ KECO_10         ; yes, stay here
dab2 4c 3a ee           JMP DOS_Copy        ; -> extended COPY
dab5 a0 1a    KECO_10   LDY #$1a            ; offset
dab7 a9 08              LDA #8              ; command length
dab9 4c 98 da           JMP Put_DOS_Command

dabc 00 00 00           .FILL $dac7 - * (0) ; 11 bytes

              ; *********************
dac7            Kernal_CONCAT ; $dac7
              ; *********************

dac7 20 68 dc           JSR Parse_DOS_Parameter
daca 20 1d d8           JSR No_WL_Record
dacd a0 22              LDY #$22
dacf a9 0c              LDA #12
dad1 4c 98 da           JMP Put_DOS_Command

              ; ***************************
dad4            Copy_Filename_To_DOS_Buffer
              ; ***************************

dad4 a5 d1              LDA FNLEN
dad6 8d 3a 03           STA DOS_Tmp
dad9 a5 da              LDA FNADR
dadb 85 fd              STA MEMUSS
dadd a5 db              LDA FNADR+1
dadf 85 fe              STA MEMUSS+1

              ; *************************
dae1            Copy_MEMUSS_To_DOS_Buffer
              ; *************************

dae1 98                 TYA
dae2 48                 PHA
dae3 ac 3a 03           LDY DOS_Tmp
dae6 f0 10              BEQ CMDB_20
dae8 a0 00              LDY #0
daea b1 fd    CMDB_10   LDA (MEMUSS),Y
daec 9d 53 03           STA DOS_Command_Buffer,X
daef e8                 INX
daf0 c8                 INY
daf1 cc 3a 03           CPY DOS_Tmp
daf4 d0 f4              BNE CMDB_10
daf6 f0 01              BEQ CMDB_30
daf8 ca       CMDB_20   DEX
daf9 68       CMDB_30   PLA
dafa a8                 TAY
dafb 38                 SEC
dafc 60                 RTS ;Size   28 [Copy_MEMUSS_To_DOS_Buffer]

              ; *************
dafd            Insert_DOS_Id
              ; *************

dafd ad 3f 03           LDA DOS_Id
db00 9d 53 03           STA DOS_Command_Buffer,X
db03 e8                 INX
db04 ad 40 03           LDA DOS_Id+1
db07 9d 53 03           STA DOS_Command_Buffer,X
db0a e8                 INX
db0b 8a                 TXA
db0c 60                 RTS ;Size   16 [Insert_DOS_Id]

              ; ********************
db0d            Kernal_DSAVE ; $db0d
              ; ********************

db0d 20 68 dc           JSR Parse_DOS_Parameter
db10 20 0b d8           JSR Check_Filename_Given
db13 29 66              AND #$66            ; no 2nd. file ?
db15 f0 03              BEQ DSAVE_10
db17 4c 00 bf           JMP Syntax_Error
db1a a0 02    DSAVE_10  LDY #2
db1c ad 3e 03           LDA DOS_Flags
db1f 29 80              AND #$80
db21 f0 0f              BEQ DSAVE_20
db23 a9 40              LDA #'@'            ; save & replace
db25 8d 53 03           STA DOS_Command_Buffer
db28 a2 01              LDX #1
db2a a9 03              LDA #3
db2c 20 fc db           JSR Build_DOS_Command_X
db2f 4c e0 f6           JMP Mf6e0
db32 a9 03    DSAVE_20  LDA #3
db34 20 fa db           JSR Build_DOS_Command
db37 4c e0 f6           JMP Mf6e0

              ; ********************
db3a            Kernal_DLOAD ; $db3a
              ; ********************

db3a 20 68 dc           JSR Parse_DOS_Parameter
db3d 20 0b d8           JSR Check_Filename_Given
db40 29 e6              AND #$e6
db42 f0 03              BEQ DLOAD_20
db44 4c 00 bf DLOAD_10  JMP Syntax_Error
db47 a0 02    DLOAD_20  LDY #2
db49 a9 03              LDA #3
db4b 20 fa db           JSR Build_DOS_Command
db4e a9 00              LDA #0
db50 85 9d              STA VERCK
db52 4c 1d f4           JMP Load_Verify_Params_Set

              ; *********************
db55            Kernal_RENAME ; $db55
              ; *********************

db55 20 68 dc           JSR Parse_DOS_Parameter
db58 20 24 d8           JSR Check_Filename_Syntax
db5b 29 e4              AND #$e4
db5d d0 e5              BNE DLOAD_10
db5f a0 2e              LDY #$2e
db61 a9 08              LDA #8
db63 4c 98 da           JMP Put_DOS_Command

              ; **********************
db66            Kernal_SCRATCH ; $db66
              ; **********************

db66 20 68 dc           JSR Parse_DOS_Parameter
db69 20 04 d8           JSR Allow_Drive_Unit_Filename
db6c 20 9e db           JSR Are_You_Sure
db6f b0 21              BCS DiSt_Ret
db71 a0 36              LDY #$36
db73 a9 04              LDA #4
db75 20 98 da           JSR Put_DOS_Command
db78 20 51 f3           JSR In_Direct_Mode
db7b d0 15              BNE DiSt_Ret
db7d 20 91 d9           JSR Kernal_Read_DS
db80 a9 0d              LDA #CR
db82 20 02 e2           JSR EDIT_CHROUT

              ; **************
db85            Display_Status
              ; **************

db85 a0 00              LDY #0
db87 b9 ad 03 DiSt_10   LDA DOS_Status,Y
db8a c8                 INY
db8b 20 02 e2           JSR EDIT_CHROUT
db8e c9 20              CMP #' '            ; check for end
db90 b0 f5              BCS DiSt_10
db92 60       DiSt_Ret  RTS ;Size   14 [Display_Status]

db93 00 00 00           .FILL $db9e-* (0) ; 11 bytes

              ; ********************
db9e            Are_You_Sure ; $db9e
              ; ********************

db9e 20 51 f3           JSR In_Direct_Mode
dba1 d0 32              BNE AYS_20
dba3 a0 b6              LDY #<MSG_SURE      ; $b6
dba5 20 85 f1           JSR Display_Kernal_Message
dba8 20 a6 f2           JSR Kernal_CLRCHN
dbab 20 15 f2           JSR Kernal_CHRIN
dbae c9 59              CMP #'Y'
dbb0 d0 19              BNE AYS_10
dbb2 20 15 f2           JSR Kernal_CHRIN
dbb5 c9 0d              CMP #CR
dbb7 f0 1c              BEQ AYS_20
dbb9 c9 45              CMP #'E'
dbbb d0 0e              BNE AYS_10
dbbd 20 15 f2           JSR Kernal_CHRIN
dbc0 c9 53              CMP #'S'
dbc2 d0 07              BNE AYS_10
dbc4 20 15 f2           JSR Kernal_CHRIN
dbc7 c9 0d              CMP #CR
dbc9 f0 0a              BEQ AYS_20
dbcb c9 0d    AYS_10    CMP #CR
dbcd 38                 SEC
dbce f0 06              BEQ AYS_Ret
dbd0 20 15 f2           JSR Kernal_CHRIN
dbd3 d0 f6              BNE AYS_10
dbd5 18       AYS_20    CLC
dbd6 60       AYS_Ret   RTS ;Size   57 [Are_You_Sure]

dbd7 00 00 00           .FILL $dbe1-* (0) ; 10 bytes

              ; ********************
dbe1            Clear_Status ; $dbe1
              ; ********************

dbe1 a9 00              LDA #0
dbe3 85 96              STA STATUS          ; clear STATUS
dbe5 60                 RTS ;Size    5 [Clear_Status]

dbe6 00 00 00           .FILL $dbfa-* (0) ; 20 bytes

              ; *************************
dbfa            Build_DOS_Command ; $dbfa
              ; *************************

dbfa a2 00              LDX #0

              ; *******************
dbfc            Build_DOS_Command_X
              ; *******************

dbfc 8d 41 03           STA DOS_Command_Length
dbff 20 e1 db           JSR Clear_Status
dc02 ce 41 03 BDC_10    DEC DOS_Command_Length
dc05 30 45              BMI DOS_SETNAM      ; -> finished
dc07 c8                 INY
dc08 b9 38 d8           LDA DOS_Build_Table,Y
dc0b 10 39              BPL BDC_90          ; -> insert
dc0d c9 f1              CMP #$f1            ; insert file 1
dc0f d0 03              BNE BDC_20
dc11 20 d4 da           JSR Copy_Filename_To_DOS_Buffer
dc14 c9 f2    BDC_20    CMP #$f2            ; insert file 2
dc16 d0 03              BNE BDC_30
dc18 20 e1 da           JSR Copy_MEMUSS_To_DOS_Buffer
dc1b c9 e0    BDC_30    CMP #$e0            ; insert 2nd. attribute
dc1d d0 05              BNE BDC_40          ; W,S or R,record length
dc1f ad 3d 03           LDA DOS_Attr        ; record length
dc22 d0 22              BNE BDC_90          ; always
dc24 c9 d0    BDC_40    CMP #$d0            ; insert ID
dc26 d0 03              BNE BDC_50
dc28 20 fd da           JSR Insert_DOS_Id
dc2b c9 e1    BDC_50    CMP #$e1            ; insert 1st. attribute
dc2d d0 05              BNE BDC_60
dc2f 20 57 dc           JSR Write_Attribute
dc32 d0 12              BNE BDC_90
dc34 c9 d1    BDC_60    CMP #$d1            ; insert drive 1
dc36 d0 05              BNE BDC_70
dc38 ad 3b 03           LDA DOS_Drive_1
dc3b 10 07              BPL BDC_80
dc3d c9 d2    BDC_70    CMP #$d2            ; insert drive 2
dc3f d0 c1              BNE BDC_10
dc41 ad 3c 03           LDA DOS_Drive_2
dc44 09 30    BDC_80    ORA #'0'
dc46 9d 53 03 BDC_90    STA DOS_Command_Buffer,X
dc49 e8                 INX
dc4a d0 b6              BNE BDC_10

              ; **********
dc4c            DOS_SETNAM
              ; **********

dc4c 86 d1              STX FNLEN
dc4e a9 53              LDA #<DOS_Command_Buffer
dc50 85 da              STA FNADR
dc52 a9 03              LDA #>DOS_Command_Buffer
dc54 85 db              STA FNADR+1
dc56 60                 RTS ;Size   11 [DOS_SETNAM]

              ; ***************
dc57            Write_Attribute
              ; ***************

dc57 ad 3d 03           LDA DOS_Attr
dc5a f0 04              BEQ WrAt_10
dc5c a9 4c              LDA #'L'            ; L,record length
dc5e d0 07              BNE WrAt_Ret
dc60 a9 53    WrAt_10   LDA #'S'            ; W,S
dc62 8d 3d 03           STA DOS_Attr
dc65 a9 57              LDA #'W'
dc67 60       WrAt_Ret  RTS ;Size   17 [Write_Attribute]

              ; This is the universal DOS parser
              ; It is called by all BASIC 4 DOS commands and scans and stores

              ; LA              = logical address
              ; FA              = primary address (UNIT)
              ; DOS_Drive_1     = source drive
              ; DOS_Drive_2     = target drive
              ; FNADR, FNLEN    = source filename
              ; MEMUSS, DOS_Tmp = target filename
              ; Access  mode
              ; Replace mode

              ; DOS_Flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

              ; The routine returns with the flags stored in DOS_Flags
              ; and in the accumulator.

              ; ***************************
dc68            Parse_DOS_Parameter ; $dc68
              ; ***************************

dc68 a2 00              LDX #0              ; clear:
dc6a 8e 3e 03           STX DOS_Flags       ; all flags
dc6d 86 d2              STX LA              ; logical address
dc6f 8e 3d 03           STX DOS_Attr        ; attribute
dc72 8e 3b 03           STX DOS_Drive_1     ; source drive
dc75 8e 3c 03           STX DOS_Drive_2     ; target drive
dc78 86 d1              STX FNLEN           ; filename length
dc7a 8e 3a 03           STX DOS_Tmp         ; temporary storage
dc7d 8e 3f 03           STX DOS_Id          ; ID
dc80 86 9c              STX Source_Unit     ; for cross UNIT copy
dc82 a2 08              LDX #8              ; preset DOS device
dc84 86 d4              STX FA              ; with unit 8
dc86 20 76 00           JSR CHRGOT          ; start parsing
dc89 d0 03              BNE PDP_02          ; continue
dc8b 4c f9 dd           JMP PDP_68          ; finish

dc8e c9 23    PDP_02    CMP #'#'            ; logical address ?
dc90 f0 2a              BEQ PDP_10
dc92 c9 57              CMP #'W'            ; write mode ?
dc94 f0 3e              BEQ PDP_12
dc96 c9 4c              CMP #'L'            ; relative file ?
dc98 f0 45              BEQ PDP_14
dc9a c9 52              CMP #'R'            ; read mode ?
dc9c d0 03              BNE PDP_04
dc9e 4c 4a dd           JMP PDP_37

dca1 c9 44    PDP_04    CMP #'D'            ; Drive ?
dca3 f0 63              BEQ PDP_26          ; parse drive #
dca5 c9 91              CMP #$91            ; ON token
dca7 f0 4f              BEQ PDP_22          ; parse unit D(value)
dca9 c9 55              CMP #'U'            ; Unit ?
dcab f0 53              BEQ PDP_24          ; parse unit value
dcad c9 22              CMP #QUOTE
dcaf f0 44              BEQ PDP_20
dcb1 c9 49              CMP #'I'            ; ID parameter on HEADER ?
dcb3 f0 72              BEQ PDP_30
dcb5 c9 28              CMP #'('
dcb7 f0 3c              BEQ PDP_20
dcb9 4c 00 bf PDP_08    JMP Syntax_Error    ; parse error

dcbc ad 3e 03 PDP_10    LDA DOS_Flags       ; get logical address
dcbf 29 04              AND #4              ; test if set already
dcc1 d0 f6              BNE PDP_08          ; error if set
dcc3 20 87 de           JSR DOS_Parse_Value ; get logical address
dcc6 e0 00              CPX #0              ; is address equal zero ?
dcc8 f0 5a              BEQ PDP_28          ; -> illegal quantity
dcca 86 d2              STX LA              ; store logical address
dccc a9 04              LDA #4              ; logical address defined
dcce 20 fd dd           JSR Set_DOS_Flags
dcd1 4c 72 dd           JMP PDP_44

dcd4 2c 3e 03 PDP_12    BIT DOS_Flags       ; process W parameter
dcd7 70 e0              BVS PDP_08          ; bit 6 already set ?
dcd9 20 70 00           JSR CHRGET          ; skip 'W'
dcdc 4c ed dc           JMP PDP_16          ; continue

dcdf 20 87 de PDP_14    JSR DOS_Parse_Value ; get record length
dce2 e0 00              CPX #0              ; is it zero ?
dce4 f0 3e              BEQ PDP_28          ; -> illegal quantity
dce6 e0 ff              CPX #$ff            ; ist it 255 ?
dce8 f0 3a              BEQ PDP_28          ; -> illegal quantity
dcea 8e 3d 03           STX DOS_Attr        ; store record length

dced a9 40    PDP_16    LDA #$40            ; mark W or L set
dcef 20 fd dd           JSR Set_DOS_Flags
dcf2 4c 72 dd           JMP PDP_44

dcf5 4c 50 dd PDP_20    JMP PDP_38

dcf8 20 2c de PDP_22    JSR DOS_Parse_Unit
dcfb 86 9c              STX Source_Unit
dcfd 4c 72 dd           JMP PDP_44
dd00 20 33 de PDP_24    JSR Get_Unit_Value
dd03 86 9c              STX Source_Unit
dd05 4c 72 dd           JMP PDP_44
dd08 ad 3e 03 PDP_26    LDA DOS_Flags
dd0b 29 10              AND #16             ; drive # already set ?
dd0d d0 aa              BNE PDP_08          ; error if so
dd0f 20 87 de           JSR DOS_Parse_Value
dd12 e0 0a              CPX #10             ; original ROM had CPX #2 (D0 and D1 only)
dd14 b0 0e              BCS PDP_28          ; error for drive # > 9
dd16 8e 3b 03           STX DOS_Drive_1     ; store drive #
dd19 8e 3c 03           STX DOS_Drive_2     ; store drive #
dd1c a9 10              LDA #16             ; mark drive # set
dd1e 20 fd dd           JSR Set_DOS_Flags
dd21 4c 72 dd           JMP PDP_44
dd24 4c 27 de PDP_28    JMP DOS_JMP_Illegal_Quantity
dd27 ad 3d 03 PDP_30    LDA DOS_Attr        ; test DOS_Attr
dd2a 29 ff              AND #$ff            ; this is needless
dd2c f0 03              BEQ PDP_32          ; continue if zero
dd2e 4c 00 bf           JMP Syntax_Error    ; error if not zero
dd31 a0 00    PDP_32    LDY #0              ; parse ID string for HEADER
dd33 a2 00              LDX #0
dd35 e6 77    PDP_34    INC TXTPTR          ; advance TXTPTR
dd37 d0 02              BNE PDP_36
dd39 e6 78              INC TXTPTR+1
dd3b b1 77    PDP_36    LDA (TXTPTR),Y      ; get ID string
dd3d 9d 3f 03           STA DOS_Id,X
dd40 e8                 INX
dd41 e0 02              CPX #2              ; maximum 2 characters
dd43 90 f0              BCC PDP_34
dd45 a9 ff              LDA #$ff
dd47 8d 3d 03           STA DOS_Attr        ; mark ID defined
dd4a 20 70 00 PDP_37    JSR CHRGET          ; advance to next character
dd4d 4c 72 dd           JMP PDP_44
dd50 ad 3e 03 PDP_38    LDA DOS_Flags
dd53 29 01              AND #1              ; error if filename defined
dd55 20 49 de           JSR DOS_Parse_Filename
dd58 85 d1              STA FNLEN
dd5a 8d 41 03           STA DOS_Command_Length
dd5d 20 c8 d6           JSR Set_DOS_FNADR
dd60 a0 00              LDY #0
dd62 b1 1f    PDP_40    LDA (INDEXA),Y      ; copy string to filename
dd64 99 42 03           STA DOS_Filename,Y  ; store filename
dd67 c8                 INY
dd68 cc 41 03           CPY DOS_Command_Length
dd6b 90 f5              BCC PDP_40
dd6d a9 01              LDA #1              ; mark filename defined
dd6f 20 fd dd           JSR Set_DOS_Flags
dd72 20 76 00 PDP_44    JSR CHRGOT          ; next character to parse
dd75 d0 03              BNE PDP_46          ; there is more
dd77 4c f9 dd           JMP PDP_68          ; finish parsing
dd7a c9 2c    PDP_46    CMP #','            ; comma ?
dd7c d0 06              BNE PDP_48          ; look for tokens
dd7e 20 70 00           JSR CHRGET          ; next character after comma
dd81 4c 8e dc           JMP PDP_02          ; parse next sequence
dd84 c9 91    PDP_48    CMP #$91            ; ON token
dd86 d0 03              BNE PDP_50
dd88 4c f8 dc           JMP PDP_22          ; parse unit
dd8b c9 a4    PDP_50    CMP #$a4            ; TO token
dd8d f0 03              BEQ PDP_52
dd8f 4c 00 bf           JMP Syntax_Error
dd92 20 70 00 PDP_52    JSR CHRGET
dd95 c9 44              CMP #'D'
dd97 f0 13              BEQ PDP_56          ; parse target drive
dd99 c9 91              CMP #$91            ; ON token
dd9b f0 28              BEQ PDP_58          ; get UNIT
dd9d c9 55              CMP #'U'
dd9f f0 2a              BEQ PDP_60          ; get UNIT value
dda1 c9 22              CMP #QUOTE
dda3 f0 2c              BEQ PDP_62
dda5 c9 28              CMP #'('
dda7 f0 28              BEQ PDP_62
dda9 4c 00 bf PDP_54    JMP Syntax_Error
ddac ad 3e 03 PDP_56    LDA DOS_Flags
ddaf 29 20              AND #$20            ; Drive 2 defined ?
ddb1 d0 f6              BNE PDP_54          ; error if so
ddb3 20 87 de           JSR DOS_Parse_Value
ddb6 e0 0a              CPX #10             ; original ROM: CPX #2 (D0 and D1 only)
ddb8 b0 6d              BCS DOS_JMP_Illegal_Quantity
ddba 8e 3c 03           STX DOS_Drive_2
ddbd a9 20              LDA #$20            ; mark drive 2 defined
ddbf 20 fd dd           JSR Set_DOS_Flags
ddc2 4c e5 dd           JMP PDP_64
ddc5 20 2c de PDP_58    JSR DOS_Parse_Unit
ddc8 4c e5 dd           JMP PDP_64
ddcb 20 33 de PDP_60    JSR Get_Unit_Value
ddce 4c e5 dd           JMP PDP_64
ddd1 ad 3e 03 PDP_62    LDA DOS_Flags
ddd4 29 02              AND #2              ; error if target filename there
ddd6 20 49 de           JSR DOS_Parse_Filename
ddd9 8d 3a 03           STA DOS_Tmp         ; length of target filename
dddc 86 fd              STX MEMUSS          ; save descriptor in MEMUSS
ddde 84 fe              STY MEMUSS+1
dde0 a9 02              LDA #2              ; mark target filename parsed
dde2 20 fd dd           JSR Set_DOS_Flags
dde5 20 76 00 PDP_64    JSR CHRGOT          ; current character
dde8 f0 0f              BEQ PDP_68          ; finish
ddea c9 2c              CMP #','            ; another comma
ddec f0 a4              BEQ PDP_52          ; continue
ddee c9 91              CMP #$91            ; ON token
ddf0 f0 d3              BEQ PDP_58          ; continue
ddf2 c9 55              CMP #'U'
ddf4 f0 d5              BEQ PDP_60          ; get UNIT
ddf6 4c 00 bf PDP_66    JMP Syntax_Error
ddf9 ad 3e 03 PDP_68    LDA DOS_Flags
ddfc 60                 RTS ;Size  405 [Parse_DOS_Parameter]

              ; *************
ddfd            Set_DOS_Flags
              ; *************

ddfd 0d 3e 03           ORA DOS_Flags
de00 8d 3e 03           STA DOS_Flags
de03 60                 RTS ;Size    7 [Set_DOS_Flags]

de04 00 00 00           .FILL $de27 - * (0) ; 35 bytes

              ; ************************
de27            DOS_JMP_Illegal_Quantity
              ; ************************

de27 a2 35              LDX #Msg_QUANT-Msg_Start ; $35
de29 4c cf b3           JMP Basic_Error

              ; **************
de2c            DOS_Parse_Unit
              ; **************

de2c 20 70 00           JSR CHRGET
de2f c9 55              CMP #'U'
de31 d0 c3              BNE PDP_66

              ; **************
de33            Get_Unit_Value
              ; **************

de33 20 87 de           JSR DOS_Parse_Value
de36 e0 20              CPX #32
de38 b0 ed              BCS DOS_JMP_Illegal_Quantity
de3a e0 03              CPX #3
de3c 90 e9              BCC DOS_JMP_Illegal_Quantity
de3e 86 d4              STX FA
de40 a9 08              LDA #8
de42 4c fd dd           JMP Set_DOS_Flags

de45 00 00 00           .FILL $de49 - * (0) ; 4 bytes

              ; ******************
de49            DOS_Parse_Filename
              ; ******************

de49 d0 ab              BNE PDP_66
de4b 20 98 bd           JSR Eval_Expression
de4e 20 b5 c7           JSR Eval_And_Free_String
de51 aa                 TAX                 ; string length
de52 f0 d3              BEQ DOS_JMP_Illegal_Quantity
de54 a0 00              LDY #0
de56 b1 1f              LDA (INDEXA),Y
de58 c9 40              CMP #'@'            ; replace character
de5a d0 14              BNE DPF_30
de5c 2c 3e 03           BIT DOS_Flags       ; @ already used ?
de5f 10 03              BPL DPF_10
de61 4c 00 bf           JMP Syntax_Error
de64 e6 1f    DPF_10    INC INDEXA          ; skip @
de66 d0 02              BNE DPF_20
de68 e6 20              INC INDEXA+1
de6a ca       DPF_20    DEX                 ; length - @
de6b a9 80              LDA #$80
de6d 20 fd dd           JSR Set_DOS_Flags
de70 8a       DPF_30    TXA                 ; string length
de71 f0 b4              BEQ DOS_JMP_Illegal_Quantity
de73 c9 11              CMP #17
de75 90 05              BCC DPF_40
de77 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
de79 4c cf b3           JMP Basic_Error
de7c a6 1f    DPF_40    LDX INDEXA          ; string address low
de7e a4 20              LDY INDEXA+1        ; string address high
de80 60                 RTS ;Size   56 [DOS_Parse_Filename]

de81 00 00 00           .FILL $de87 - * (0) ; 6 bytes

              ; ***************
de87            DOS_Parse_Value
              ; ***************

de87 20 70 00           JSR CHRGET

              ; ************
de8a            DOS_Get_Byte
              ; ************

de8a d0 03              BNE DGB_10
de8c 4c 00 bf           JMP Syntax_Error
de8f 90 09    DGB_10    BCC DGB_20
de91 20 f2 be           JSR Need_Left_Parenthesis
de94 20 d4 c8           JSR Get_Byte_Value
de97 4c ef be           JMP Need_Right_Parenthesis
de9a 4c d4 c8 DGB_20    JMP Get_Byte_Value

              ; *************
de9d            Start_Message
              ; *************

de9d 2a 2a 2a           .PET '*** BSOS 8296 ***\r\r',0

              ; ********
deb1            Renumber
              ; ********

              ; check for arguments: RENUMBER new start, increment, old start

deb1 a9 0a              LDA #10
deb3 85 21              STA RENINC          ; preset increment low
deb5 85 23              STA RENNEW          ; preset start low
deb7 a9 00              LDA #0
deb9 85 22              STA RENINC+1
debb 85 24              STA RENNEW+1
debd 20 76 00           JSR CHRGOT
dec0 b0 4d              BCS Renu_15         ; no arguments
dec2 20 f6 b8           JSR Scan_Linenumber
dec5 a5 11              LDA LINNUM
dec7 85 23              STA RENNEW          ; start low
dec9 05 12              ORA LINNUM+1
decb d0 03              BNE Renu_10
decd 4c 73 c3 Renu_Err  JMP Jump_To_Illegal_Quantity
ded0 a5 12    Renu_10   LDA LINNUM+1
ded2 85 24              STA RENNEW+1        ; start high
ded4 20 76 00           JSR CHRGOT
ded7 c9 2c              CMP #','
ded9 d0 34              BNE Renu_15
dedb 20 70 00           JSR CHRGET
dede 20 f6 b8           JSR Scan_Linenumber
dee1 a5 11              LDA LINNUM
dee3 85 21              STA RENINC          ; inc low
dee5 05 12              ORA LINNUM+1
dee7 f0 e4              BEQ Renu_Err
dee9 a5 12              LDA LINNUM+1
deeb 85 22              STA RENINC+1        ; inc high
deed 20 76 00           JSR CHRGOT
def0 c9 2c              CMP #','
def2 d0 1b              BNE Renu_15
def4 20 70 00           JSR CHRGET
def7 20 f6 b8           JSR Scan_Linenumber ; get old start
defa 20 e4 ea           JSR Find_Power_Line ; find start line
defd a0 02              LDY #2
deff b1 57              LDA (TMPPTB),Y      ; previous # low
df01 c5 23              CMP RENNEW
df03 c8                 INY
df04 b1 57              LDA (TMPPTB),Y      ; previous # high
df06 e5 24              SBC RENNEW+1
df08 b0 c3              BCS Renu_Err        ; New line # would be less than previous
df0a 20 2a ed           JSR Reset_BPTR
df0d d0 03              BNE Renu_20         ; always

              ; phase 1: build table of old and new numbers

df0f 20 22 ed Renu_15   JSR Reset_Renumber_Pointer
df12 20 43 ec Renu_20   JSR Install_Bank_Access
df15 a9 80              LDA #$80
df17 85 b6              STA R_Bank
df19 85 b7              STA W_Bank

              ; start of new line numbers

df1b a0 01    Renu_25   LDY #1
df1d b1 5c              LDA (TMPPTC),Y      ; link high
df1f f0 34              BEQ Renu_30         ; finished
df21 c8                 INY                 ; Y = 2

              ; next table entry

df22 b1 5c              LDA (TMPPTC),Y      ; old line low
df24 20 8b 02           JSR Bank_Store
df27 c8                 INY                 ; Y = 3
df28 b1 5c              LDA (TMPPTC),Y      ; old line high
df2a 20 8b 02           JSR Bank_Store
df2d a0 01              LDY #1
df2f a5 24              LDA RENNEW+1        ; new line high
df31 20 8b 02           JSR Bank_Store
df34 88                 DEY                 ; Y = 0
df35 a5 23              LDA RENNEW          ; new line low
df37 20 8b 02           JSR Bank_Store

              ; increment new line

df3a 18                 CLC
df3b a5 23              LDA RENNEW
df3d 65 21              ADC RENINC
df3f 85 23              STA RENNEW
df41 a5 24              LDA RENNEW+1
df43 65 22              ADC RENINC+1
df45 85 24              STA RENNEW+1
df47 c9 fa              CMP #$fa            ; > 64000
df49 b0 82              BCS Renu_Err        ; line # overflow

              ; increment table pointer

df4b a9 04              LDA #4
df4d 20 21 fb           JSR Add_BPTR

              ; next basic line

df50 20 33 ed           JSR Update_Link
df53 d0 c6              BNE Renu_25         ; branch if link is not zero

              ; table finished

df55 a0 03    Renu_30   LDY #3
df57 a9 ff              LDA #$ff            ; end marker
df59 20 8b 02 Renu_35   JSR Bank_Store
df5c 88                 DEY
df5d 10 fa              BPL Renu_35

              ; phase 2: build a renumbered copy in bank 2

df5f a9 8c              LDA #$8c
df61 85 b7              STA W_Bank
df63 20 22 ed           JSR Reset_Renumber_Pointer

              ; copy link - will be recalculated at end

df66 a0 00    Renu_40   LDY #0
df68 b1 5c              LDA (TMPPTC),Y      ; link low
df6a 20 8b 02           JSR Bank_Store
df6d c8                 INY
df6e b1 5c              LDA (TMPPTC),Y      ; link high
df70 20 8b 02           JSR Bank_Store
df73 f0 2b              BEQ Renu_45         ; finished

              ; exchange line number from table or copy if not found

df75 c8                 INY
df76 b1 5c              LDA (TMPPTC),Y      ; line # low
df78 aa                 TAX
df79 c8                 INY
df7a b1 5c              LDA (TMPPTC),Y      ; line # high
df7c 20 07 ec           JSR Find_Entry
df7f a0 02              LDY #2
df81 a5 11              LDA LINNUM
df83 20 8b 02           JSR Bank_Store
df86 c8                 INY
df87 a5 12              LDA LINNUM+1
df89 20 8b 02           JSR Bank_Store
df8c 20 7e ec           JSR Xfer_Line
df8f c8                 INY                 ; Add Y + 1
df90 98                 TYA
df91 20 21 fb           JSR Add_BPTR
df94 20 33 ed           JSR Update_Link
df97 a5 fa              LDA BPTR+1
df99 c9 fb              CMP #$fb
df9b 90 c9              BCC Renu_40
df9d 4c cd b3           JMP Error_Out_Of_Memory

              ; copy new program from bank 2 to BASIC memory

dfa0 a9 8c    Renu_45   LDA #$8c            ; bank 1
dfa2 85 b6              STA R_Bank
dfa4 18                 CLC
dfa5 a5 f9              LDA BPTR
dfa7 69 03              ADC #3
dfa9 85 23              STA RENNEW          ; end address low
dfab a5 fa              LDA BPTR+1
dfad 69 00              ADC #0
dfaf aa                 TAX                 ; end address high
dfb0 a9 00              LDA #0
dfb2 85 fb              STA STAL
dfb4 a9 80              LDA #$80
dfb6 85 fc              STA STAL+1
dfb8 20 22 ed           JSR Reset_Renumber_Pointer
dfbb a0 00              LDY #0
dfbd 20 7a 02 Renu_50   JSR Bank_Fetch
dfc0 91 5c              STA (TMPPTC),Y
dfc2 c4 23              CPY RENNEW
dfc4 d0 04              BNE Renu_55
dfc6 e4 fc              CPX STAL+1
dfc8 f0 09              BEQ Renu_60
dfca c8       Renu_55   INY
dfcb d0 f0              BNE Renu_50
dfcd e6 5d              INC TMPPTC+1
dfcf e6 fc              INC STAL+1
dfd1 d0 ea              BNE Renu_50
dfd3 a5 5d    Renu_60   LDA TMPPTC+1
dfd5 84 2a    Renu_90   STY VARTAB          ; entry for Delete routine
dfd7 85 2b              STA VARTAB+1
dfd9 20 e9 b5           JSR Reset_BASIC_Execution
dfdc 20 b6 b4           JSR Rechain
dfdf 4c ff b3           JMP Basic_Ready

dfe2 00 00 00           .FILL $e000-* (0) ; 30 bytes

              ; *****************
e000            EDITOR_JUMP_TABLE
              ; *****************

e000 4c 37 e0           JMP EDIT_RESET
e003 4c a7 e0           JMP EDIT_GETIN
e006 4c 16 e1           JMP EDIT_CHRIN
e009 4c 02 e2           JMP EDIT_CHROUT
e00c 4c 42 e4           JMP IRQ_MAIN
e00f 4c 55 e4           JMP IRQ_NORMAL
e012 4c 77 e4           JMP IRQ_END
e015 4c 3d e0           JMP EDIT_CLEAR
e018 4c d6 e9           JMP EDIT_CHARSET_TEXT
e01b 4c e4 e9           JMP EDIT_CHARSET_GRAPHICS
e01e 4c d3 e9           JMP EDIT_RESET_CRT
e021 4c 17 e4           JMP EDIT_SCROLL_DOWN
e024 4c 29 e4           JMP EDIT_SCROLL_UP
e027 4c 24 e9           JMP EDIT_KEY_SCAN
e02a 4c 8d e6           JMP EDIT_BEEP
e02d 4c 8d e6           JMP EDIT_BEEP
e030 4c ca e1           JMP EDIT_TOP_LEFT
e033 4c c5 e1           JMP EDIT_BOTTOM_RIGHT
e036 60                 RTS ; EDIT_REPEAT ;Size   55 [EDITOR_JUMP_TABLE]

              ; **********
e037            EDIT_RESET
              ; **********

e037 20 06 e6           JSR Edit_Init
e03a 20 d3 e9           JSR EDIT_RESET_CRT

              ; **********
e03d            EDIT_CLEAR
              ; **********

e03d a6 e0              LDX TopMargin
e03f 20 c9 e6 EDCL_10   JSR Cursor_BOL
e042 20 aa e1           JSR Edit_Erase_To_EOL
e045 e4 e1              CPX BotMargin
e047 e8                 INX
e048 90 f5              BCC EDCL_10         ; fall

              ; *********
e04a            EDIT_HOME
              ; *********

e04a a6 e0              LDX TopMargin
e04c 86 d8              STX CursorRow       ; fall

              ; *********************
e04e            Edit_Goto_Left_Margin
              ; *********************

e04e a4 e2              LDY LefMargin
e050 84 c6              STY CursorCol       ; fall

              ; ******************
e052            Edit_Use_CursorRow
              ; ******************

e052 a6 d8              LDX CursorRow
e054 4c cb e6           JMP Update_ScrPtr

              ; ************
e057            EDIT_SET_CRT
              ; ************

              ; Input:  A = table low
              ;         X = table high
              ;         Y = # of registers

e057 85 c7              STA SAL
e059 86 c8              STX SAL+1
e05b b1 c7    ESC_10    LDA (SAL),Y
e05d 8c 80 e8           STY CRT_Address
e060 8d 81 e8           STA CRT_Value
e063 88                 DEY
e064 10 f5              BPL ESC_10
e066 60                 RTS ;Size   16 [EDIT_SET_CRT]


              ; *****************
e067            Edit_Program_Rows
              ; *****************

              ; Input:  A = maximum raster address (7 or 9)
              ;         Y = screen rows (30 or 25)

e067 84 df              STY ScreenRows
e069 c8                 INY
e06a a2 06              LDX #6
e06c 8e 80 e8           STX CRT_Address
e06f 8c 81 e8           STY CRT_Value
e072 a2 09              LDX #9
e074 8e 80 e8           STX CRT_Address
e077 8d 81 e8           STA CRT_Value
e07a 60                 RTS ;Size   20 [Edit_Program_Rows]

e07b 00 00 00           .FILL $e0a7-* (0) ; 44 bytes

              ; ******************
e0a7            EDIT_GETIN ; $e0a7
              ; ******************

e0a7 ac 6f 02           LDY KEYD            ; get next character
e0aa a2 00              LDX #0              ; scroll keyboard buffer
e0ac bd 70 02 EDGE_10   LDA KEYD+1,X
e0af 9d 6f 02           STA KEYD,X
e0b2 e8                 INX
e0b3 e4 9e              CPX CharsInBuffer
e0b5 90 f5              BCC EDGE_10
e0b7 c6 9e              DEC CharsInBuffer
e0b9 98                 TYA                 ; return character in (A)
e0ba 58                 CLI
e0bb 60                 RTS ;Size   21 [EDIT_GETIN]

              ; *************
e0bc            Edit_Get_Line
              ; *************

e0bc 20 02 e2           JSR EDIT_CHROUT
e0bf a5 9e    EGL_10    LDA CharsInBuffer
e0c1 85 a7              STA BLNSW           ; empty buffer -> blink cursor
e0c3 f0 fa              BEQ EGL_10          ; loop until char in buffer
e0c5 78                 SEI                 ; disable IRQ while working with buffer
e0c6 a5 aa              LDA BLNON           ; blink phase
e0c8 f0 0d              BEQ EGL_20          ; normal ?
e0ca a0 00              LDY #0
e0cc 84 aa              STY BLNON           ; blink phase normal
e0ce c8                 INY
e0cf 84 a8              STY BLNCT           ; start with visible cursor
e0d1 a5 a9              LDA GDBLN           ; character under cursor
e0d3 a4 c6              LDY CursorCol
e0d5 91 c4              STA (ScrPtr),Y
e0d7 20 a7 e0 EGL_20    JSR EDIT_GETIN
e0da c9 83              CMP #$83            ; RUN key ?
e0dc d0 0f              BNE EGL_40
e0de a2 08              LDX #8
e0e0 86 9e              STX CharsInBuffer
e0e2 bd dc e6 EGL_30    LDA RUN_String-1,X  ; DLOAD"*" RUN
e0e5 9d 6e 02           STA KEYD-1,X
e0e8 ca                 DEX
e0e9 d0 f7              BNE EGL_30
e0eb f0 d2              BEQ EGL_10          ; always
e0ed c9 0d    EGL_40    CMP #CR             ; RETURN ?
e0ef d0 cb              BNE Edit_Get_Line
e0f1 a4 d5              LDY RigMargin
e0f3 84 ac              STY CRSW            ; not 0 -> Screen Input
e0f5 a9 20              LDA #' '            ; Ignore trailing blanks
e0f7 d1 c4    EGL_50    CMP (ScrPtr),Y
e0f9 d0 03              BNE EGL_60
e0fb 88                 DEY
e0fc d0 f9              BNE EGL_50
e0fe c8       EGL_60    INY
e0ff 84 a1              STY LastInputCol    ; position after last non blank char
e101 20 b4 e1           JSR Edit_To_Left_Margin
e104 84 cd              STY QTSW            ; = 0 (off)
e106 a5 a3              LDA InputRow
e108 c5 d8              CMP CursorRow
e10a d0 15              BNE Edit_CHRIN_Screen
e10c a5 a4              LDA InputCol
e10e 85 c6              STA CursorCol
e110 c5 a1              CMP LastInputCol
e112 90 0d              BCC Edit_CHRIN_Screen
e114 b0 36              BCS ECS_40

e116                    .SIZE ;   90 [Edit_Get_Line]

e116                    .FILL $e116-* (0) ; 0 bytes

              ; ******************
e116            EDIT_CHRIN ; $e116
              ; ******************

e116 98                 TYA
e117 48                 PHA
e118 8a                 TXA
e119 48                 PHA
e11a 6c e9 00           JMP (SCRIV)         ; default: jump to next statement

              ; *******************
e11d            Edit_CHRIN_Standard
              ; *******************

e11d a5 ac              LDA CRSW
e11f f0 9e              BEQ EGL_10

              ; *****************
e121            Edit_CHRIN_Screen
              ; *****************

e121 a4 c6              LDY CursorCol
e123 b1 c4              LDA (ScrPtr),Y      ; get char at cursor position
e125 c9 74              CMP #$74            ; code for Pi
e127 d0 04              BNE ECS_05
e129 a9 ff              LDA #$ff
e12b d0 16              BNE ECS_30
e12d 85 d9    ECS_05    STA DATAX           ; save it in DATAX
e12f 29 3f              AND #$3f            ; lower case, symbols and digits
e131 06 d9              ASL DATAX           ; reverse bit 7 -> carry
e133 24 d9              BIT DATAX           ; uppercase or graphics ?
e135 10 02              BPL ECS_10          ; branch if not
e137 09 80              ORA #$80            ; convert upper case to PETSCII
e139 90 04    ECS_10    BCC ECS_20          ; branch if not reversed
e13b a6 cd              LDX QTSW            ; quote mode ?
e13d d0 04              BNE ECS_30          ; no conversion in quote mode
e13f 70 02    ECS_20    BVS ECS_30          ; no conversion for graphics
e141 09 40              ORA #$40            ; display code to PETSCII
e143 e6 c6    ECS_30    INC CursorCol       ; advance cursor
e145 20 64 e1           JSR Edit_Quote_Toggle
e148 c4 a1              CPY LastInputCol    ; at end of input ?
e14a 90 0f              BCC ECS_50          ; return if not
e14c a9 00    ECS_40    LDA #0
e14e 85 ac              STA CRSW            ; switch input to keyboard
e150 a9 0d              LDA #CR             ; load CR
e152 a2 03              LDX #3              ; screen channel
e154 e4 b0              CPX DFLTO           ; output = screen ?
e156 f0 03              BEQ ECS_50          ; don't echo CR
e158 20 02 e2           JSR EDIT_CHROUT
e15b 85 d9    ECS_50    STA DATAX           ; save character in DATAX
e15d 68                 PLA
e15e aa                 TAX                 ; restore X
e15f 68                 PLA
e160 a8                 TAY                 ; restore Y
e161 a5 d9              LDA DATAX
e163 60       ECS_Ret   RTS ;Size   67 [Edit_CHRIN_Screen]

              ; *****************
e164            Edit_Quote_Toggle
              ; *****************

e164 c9 22              CMP #QUOTE
e166 d0 06              BNE EQT_Ret
e168 e5 cd              SBC QTSW
e16a 85 cd              STA QTSW
e16c a9 22              LDA #QUOTE
e16e 60       EQT_Ret   RTS ;Size   11 [Edit_Quote_Toggle]

              ; *****************
e16f            Edit_Display_Char
              ; *****************

e16f a6 9f              LDX ReverseFlag
e171 f0 02              BEQ EDC_10
e173 09 80              ORA #$80
e175 a6 dc    EDC_10    LDX INSRT        ;  3  ; # of inserts outstanding
e177 f0 02              BEQ EDC_20       ;  3
e179 c6 dc              DEC INSRT
e17b 91 c4    EDC_20    STA (ScrPtr),Y   ;  6
e17d a9 01              LDA #1           ;  2
e17f 85 a8              STA BLNCT        ;  3
e181 c4 d5              CPY RigMargin    ;  3
e183 c8                 INY              ;  2
e184 90 05              BCC EDC_30       ;  3 = 28 [total 85]

              ; ************************
e186           Edit_Chrout_Epilog_Return
              ; ************************

e186 20 e1 e3           JSR Edit_Cursor_Down
e189 a4 e2              LDY LefMargin
e18b 84 c6    EDC_30    STY CursorCol    ;  3

              ; ******************
e18d            Edit_Chrout_Epilog
              ; ******************

e18d 68                 PLA              ;  4
e18e a8                 TAY              ;  2 ; restore Y
e18f 68                 PLA              ;  4
e190 aa                 TAX              ;  2 ; restore X
e191 68                 PLA              ;  4
e192 85 e8              STA PrevChar     ;  3 ; save last used character
e194 58                 CLI              ;  2
e195 60                 RTS              ;  6 = 27 [total 112] ;Size    9 [Edit_Chrout_Epilog]

              ; **************
e196            Edit_Wrap_Back
              ; **************

e196 a4 e2              LDY LefMargin
e198 a6 e0              LDX TopMargin
e19a e4 d8              CPX CursorRow
e19c b0 07              BCS EWB_10          ; don't wrap on top row
e19e a4 d5              LDY RigMargin
e1a0 c6 d8              DEC CursorRow
e1a2 20 52 e0           JSR Edit_Use_CursorRow
e1a5 84 c6    EWB_10    STY CursorCol
e1a7 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *****************
e1aa            Edit_Erase_To_EOL
              ; *****************

e1aa a9 20              LDA #' '
e1ac 91 c4    EETE_10   STA (ScrPtr),Y
e1ae c4 d5              CPY RigMargin
e1b0 c8                 INY
e1b1 90 f9              BCC EETE_10
e1b3 60                 RTS ;Size   10 [Edit_Erase_To_EOL]

              ; *******************
e1b4            Edit_To_Left_Margin
              ; *******************

e1b4 a4 e2              LDY LefMargin
e1b6 84 c6              STY CursorCol
e1b8 a0 00              LDY #0
e1ba 60                 RTS ;Size    7 [Edit_To_Left_Margin]

              ; ****************
e1bb            Edit_Full_Screen
              ; ****************

e1bb a9 00              LDA #0
e1bd 85 e0              STA TopMargin
e1bf 85 e2              STA LefMargin
e1c1 a5 df              LDA ScreenRows      ; bottom margin
e1c3 a2 4f              LDX #79             ; right  margin

              ; *****************
e1c5            EDIT_BOTTOM_RIGHT
              ; *****************

e1c5 85 e1              STA BotMargin
e1c7 86 d5              STX RigMargin
e1c9 60                 RTS ;Size    5 [EDIT_BOTTOM_RIGHT]

              ; *************
e1ca            EDIT_TOP_LEFT
              ; *************

e1ca 85 e0              STA TopMargin
e1cc 86 e2              STX LefMargin
e1ce 60                 RTS ;Size    5 [EDIT_TOP_LEFT]

e1cf 4c 16 e3 CO_Shift  JMP Edit_CHROUT_Shifted

              ; ******
e1d2            CO_Tab
              ; ******

e1d2 a4 c6              LDY CursorCol
e1d4 c4 d5              CPY RigMargin
e1d6 b0 11              BCS EdDC_05         ; CO_Exit
e1d8 e6 c6              INC CursorCol
e1da 20 25 e5           JSR IS_TAB
e1dd f0 f3              BEQ CO_Tab
e1df 4c 66 e2           JMP CO_Exit

e1e2                    .SIZE ;   16 [CO_Tab]

e1e2 4c e2 e2 CO_Size   JMP Edit_Screen_25

              ; ****************
e1e5            Edit_Delete_Char
              ; ****************

e1e5 a6 e2              LDX LefMargin
e1e7 e4 c6              CPX CursorCol
e1e9 b0 7b    EdDC_05   BCS CO_Exit        ; no delete on left margin
e1eb c6 c6              DEC CursorCol
e1ed b1 c4    EdDC_10   LDA (ScrPtr),Y
e1ef 88                 DEY
e1f0 91 c4              STA (ScrPtr),Y
e1f2 c8                 INY
e1f3 c4 d5              CPY RigMargin
e1f5 c8                 INY
e1f6 90 f5              BCC EdDC_10
e1f8 88                 DEY
e1f9 a9 20              LDA #' '
e1fb 91 c4              STA (ScrPtr),Y
e1fd d0 67              BNE CO_Exit

e1ff                    .SIZE ;   26 [Edit_Delete_Char]

e1ff 00 00 00           .FILL $e202-* (0) ; 3 bytes

              ; *******************
e202            EDIT_CHROUT ; $e202
              ; *******************

e202 48                 PHA            ;  3
e203 85 d9              STA DATAX      ;  3
e205 8a                 TXA            ;  2
e206 48                 PHA            ;  3
e207 98                 TYA            ;  2
e208 48                 PHA            ;  3
e209 6c eb 00           JMP (SCROV)    ;  5    ; -> Edit_CHROUT_Standard
                                       ; 19

              ; ****************************
e20c            Edit_CHROUT_Standard ; $e20c
              ; ****************************

e20c a9 00              LDA #0         ;  2
e20e 85 ac              STA CRSW       ;  3 ; input from keyboard
e210 a4 c6              LDY CursorCol  ;  3
e212 a5 d9              LDA DATAX      ;  3 ; char to display (PETSCII)
e214 30 b9              BMI CO_Shift   ;  2
e216 c9 20              CMP #' '       ;  2 ; printable ?
e218 b0 4f              BCS CO_Normal  ;  3 = 16 [total 35]
e21a c9 0d              CMP #CR             ; RETURN
e21c f0 71              BEQ CO_Return
e21e c9 1b              CMP #ESC            ; ESCAPE
e220 f0 70              BEQ CO_Escape
e222 a6 dc              LDX INSRT           ; insert mode ?
e224 d0 76              BNE CO_Rev
e226 c9 14              CMP #DEL            ; DELETE
e228 f0 bb              BEQ Edit_Delete_Char
e22a a6 cd              LDX QTSW            ; quote mode ?
e22c d0 6e              BNE CO_Rev
e22e c9 1d              CMP #RIGHT          ; cursor RIGHT
e230 f0 3f              BEQ CO_Right
e232 c9 11              CMP #DOWN           ; cursor DOWN
e234 f0 44              BEQ CO_Down
e236 c9 12              CMP #RVS            ; REVERSE
e238 f0 45              BEQ CO_RVS
e23a c9 07              CMP #BELL           ; ring bell
e23c f0 47              BEQ CO_Bell
e23e c9 0e              CMP #CTRLN          ; select text character set
e240 f0 48              BEQ CO_ChText
e242 c9 02              CMP #CTRLB          ; select new character set
e244 f0 4f              BEQ CO_ChNew
e246 c9 0f              CMP #CTRLO          ; set top left window corner
e248 f0 57              BEQ CO_Top
e24a c9 09              CMP #TAB            ; TAB
e24c f0 84              BEQ CO_Tab
e24e c9 19              CMP #CTRLY          ; scroll window up
e250 f0 5a              BEQ CO_ScUp
e252 c9 16              CMP #CTRLV          ; Delete to EOL
e254 f0 61              BEQ CO_DEOL
e256 c9 15              CMP #CTRLU          ; delete line
e258 f0 68              BEQ CO_DLine
e25a c9 04              CMP #CTRLD          ; toggle screen size
e25c f0 84              BEQ CO_Size
e25e c9 13              CMP #HOME           ; HOME
e260 f0 6d              BEQ CO_Home
e262 c9 01              CMP #CTRLA          ; scroll window down
e264 f0 43              BEQ CO_ScDown
e266 4c 8d e1 CO_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Standard

e269 29 3f    CO_Normal AND #$3f               ;  2 ; PETSCII -> display code
e26b 20 64 e1           JSR Edit_Quote_Toggle  ; 17
e26e 4c 6f e1           JMP Edit_Display_Char  ;  3 = 22 [total 57]

e271 c4 d5    CO_Right  CPY RigMargin
e273 e6 c6              INC CursorCol
e275 90 ef              BCC CO_Exit
e277 4c 86 e1           JMP Edit_Chrout_Epilog_Return

e27a 20 e1 e3 CO_Down   JSR Edit_Cursor_Down
e27d d0 e7              BNE CO_Exit         ; always

e27f a9 80    CO_RVS    LDA #$80
e281 85 9f              STA ReverseFlag
e283 d0 e1              BNE CO_Exit         ; always

e285 20 8d e6 CO_Bell   JSR EDIT_BEEP
e288 f0 dc              BEQ CO_Exit         ; always

e28a 20 d6 e9 CO_ChText JSR EDIT_CHARSET_TEXT
e28d 30 d7              BMI CO_Exit         ; always

e28f 4c f4 e3 CO_Return JMP CO_Screen_Return

e292 4c ff e3 CO_Escape JMP CO_JMP_Escape

e295 a9 10    CO_ChNew  LDA #$10
e297 20 ca e9 CO_Switch JSR Edit_Switch_Char_ROM
e29a d0 ca              BNE CO_Exit         ; always

e29c 09 80    CO_Rev    ORA #$80
e29e 4c 6f e1           JMP Edit_Display_Char

e2a1 a6 d8    CO_Top    LDX CursorRow
e2a3 86 e0              STX TopMargin
e2a5 84 e2              STY LefMargin
e2a7 10 bd              BPL CO_Exit         ; always

e2a9 4c b5 e3 CO_ScDown JMP CS_ScDown

e2ac 20 29 e4 CO_ScUp   JSR EDIT_SCROLL_UP
e2af 20 39 ea           JSR Power_Scroll_Up
e2b2 20 52 e0           JSR Edit_Use_CursorRow
e2b5 d0 af              BNE CO_Exit         ; always

e2b7 a9 20    CO_DEOL   LDA #' '
e2b9 91 c4    CODE_10   STA (ScrPtr),Y
e2bb c4 d5              CPY RigMargin
e2bd c8                 INY
e2be 90 f9              BCC CODE_10
e2c0 b0 a4              BCS CO_Exit

e2c2 a5 e0    CO_DLine  LDA TopMargin
e2c4 48                 PHA
e2c5 a5 d8              LDA CursorRow
e2c7 85 e0              STA TopMargin
e2c9 20 29 e4           JSR EDIT_SCROLL_UP
e2cc 4c d8 e3           JMP TM_Epi

e2cf c5 e8    CO_Home   CMP PrevChar             ; twice pressed ?
e2d1 d0 03              BNE COHo_10
e2d3 20 bb e1 CoHo_05   JSR Edit_Full_Screen     ; 2nd. <HOME> resets margins
e2d6 20 4a e0 COHo_10   JSR EDIT_HOME
e2d9 4c 8d e1           JMP Edit_Chrout_Epilog

e2dc          Edit_Screen_30
e2dc a9 07              LDA #7              ; maximum raster address
e2de a0 1d              LDY #29             ; 30 rows
e2e0 d0 04              BNE Edit_Screen_Program
e2e2          Edit_Screen_25
e2e2 a9 09              LDA #9              ; maximum raster address
e2e4 a0 18              LDY #24             ; 25 rows (default)
e2e6          Edit_Screen_Program
e2e6 20 67 e0           JSR Edit_Program_Rows
e2e9 20 bb e1           JSR Edit_Full_Screen
e2ec 4c 79 e3           JMP CS_Clear

e2ef 4c f4 e3 CS_Return JMP CO_Screen_Return

              ; ****************
e2f2            Edit_Insert_Char
              ; ****************

e2f2 a4 d5              LDY RigMargin
e2f4 b1 c4              LDA (ScrPtr),Y
e2f6 c9 20              CMP #' '
e2f8 d0 66              BNE CS_Exit       ; right most char not blank
e2fa 88       InCh_10   DEY
e2fb c4 c6              CPY CursorCol     ; clc if left from cursor
e2fd b1 c4              LDA (ScrPtr),Y
e2ff c8                 INY
e300 90 05              BCC InCh_20
e302 91 c4              STA (ScrPtr),Y
e304 88                 DEY
e305 d0 f3              BNE InCh_10       ; at first column
e307 a9 20    InCh_20   LDA #' '
e309 91 c4              STA (ScrPtr),Y
e30b 98                 TYA
e30c 65 dc              ADC INSRT
e30e c5 d5              CMP RigMargin
e310 b0 4e              BCS CS_Exit
e312 e6 dc              INC INSRT
e314 d0 4a              BNE CS_Exit         ; always

e316                    .SIZE ;   36 [Edit_Insert_Char]

              ; *******************
e316            Edit_CHROUT_Shifted
              ; *******************

e316 29 7f              AND #$7f
e318 c9 7f              CMP #$7f            ; Pi
e31a f0 4a              BEQ CS_Pi
e31c c9 20              CMP #' '            ; printable ?
e31e b0 49              BCS CS_Print
e320 c9 0d              CMP #CR             ; shifted RETURN
e322 f0 cb              BEQ CS_Return
e324 a6 cd              LDX QTSW            ; quote mode
e326 d0 46              BNE CS_Rev
e328 c9 14              CMP #DEL            ; INSERT
e32a f0 c6              BEQ Edit_Insert_Char
e32c a6 dc              LDX INSRT           ; insert mode ?
e32e d0 3e              BNE CS_Rev
e330 c9 1d              CMP #RIGHT          ; cursor LEFT
e332 f0 5d              BEQ CS_Left
e334 c9 11              CMP #DOWN           ; cursor UP
e336 f0 73              BEQ CS_Up
e338 c9 12              CMP #RVS            ; REVERSE OFF
e33a f0 37              BEQ CS_RVS
e33c c9 13              CMP #HOME           ; CLEAR
e33e f0 39              BEQ CS_Clear
e340 c9 09              CMP #TAB            ; shifted TAB
e342 f0 58              BEQ CS_Tab
e344 c9 16              CMP #CTRLV          ; shifted Ctrl-V
e346 f0 79              BEQ CS_Delete_BOL
e348 c9 02              CMP #CTRLB          ; select old character set
e34a f0 32              BEQ CS_ChOld
e34c c9 19              CMP #CTRLY          ; scroll window down
e34e f0 65              BEQ CS_ScDown
e350 c9 0f              CMP #CTRLO          ; set window bottom right
e352 f0 2f              BEQ CS_Bottom
e354 c9 0e              CMP #CTRLN          ; select graphics character set
e356 f0 33              BEQ CS_Graph
e358 c9 15              CMP #CTRLU          ; shifted Ctrl-U
e35a f0 72              BEQ CS_Insert_Line
e35c c9 04              CMP #CTRLD          ; switch to 26 row screen
e35e f0 03              BEQ CS_Size
e360 4c 8d e1 CS_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Shifted

e363 4c dc e2 CS_Size   JMP Edit_Screen_30
e366 a9 74    CS_Pi     LDA #$74
e368 2c                 .BYTE $2c
e369 09 40    CS_Print  ORA #$40            ; PETSCII to display
e36b 4c 6f e1           JMP Edit_Display_Char

e36e 09 c0    CS_Rev    ORA #$c0            ; reverse upper case
e370 4c 6f e1           JMP Edit_Display_Char

e373 a9 00    CS_RVS    LDA #0
e375 85 9f              STA ReverseFlag
e377 f0 e7              BEQ CS_Exit         ; always

e379 20 3d e0 CS_Clear  JSR EDIT_CLEAR
e37c d0 e2              BNE CS_Exit         ; always

e37e a9 30    CS_ChOld  LDA #$30
e380 4c 97 e2           JMP CO_Switch

e383 a5 d8    CS_Bottom LDA CursorRow
e385 85 e1              STA BotMargin
e387 84 d5              STY RigMargin
e389 10 d5              BPL CS_Exit       ; always

e38b 20 e4 e9 CS_Graph  JSR EDIT_CHARSET_GRAPHICS
e38e 4c 8d e1           JMP Edit_Chrout_Epilog

e391 a4 e2    CS_Left   LDY LefMargin
e393 c4 c6              CPY CursorCol
e395 c6 c6              DEC CursorCol
e397 90 c7              BCC CS_Exit
e399 4c 96 e1           JMP Edit_Wrap_Back

e39c 20 25 e5 CS_Tab    JSR IS_TAB
e39f bd ee 03           LDA TABS_SET,X
e3a2 59 37 e5           EOR BITPOS,Y        ; toggle TAB bit
e3a5 9d ee 03           STA TABS_SET,X
e3a8 4c 8d e1           JMP Edit_Chrout_Epilog

e3ab a6 e0    CS_Up     LDX TopMargin
e3ad e4 d8              CPX CursorRow
e3af b0 04              BCS CS_ScDown
e3b1 c6 d8              DEC CursorRow
e3b3 10 06              BPL COSW_10         ; always

e3b5 20 17 e4 CS_ScDown JSR EDIT_SCROLL_DOWN
e3b8 20 71 ea           JSR Power_Scroll_Down
e3bb 20 52 e0 COSW_10   JSR Edit_Use_CursorRow
e3be 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *************
e3c1            CS_Delete_BOL
              ; *************

e3c1 a9 20              LDA #' '
e3c3 a4 e2              LDY LefMargin
e3c5 c4 c6    CSDB_10   CPY CursorCol
e3c7 b0 97              BCS CS_Exit
e3c9 91 c4              STA (ScrPtr),Y
e3cb c8                 INY
e3cc d0 f7              BNE CSDB_10

e3ce                    .SIZE ;   13 [CS_Delete_BOL]

              ; **************
e3ce            CS_Insert_Line
              ; **************

e3ce a5 e0              LDA TopMargin
e3d0 48                 PHA
e3d1 a5 d8              LDA CursorRow
e3d3 85 e0              STA TopMargin
e3d5 20 17 e4           JSR EDIT_SCROLL_DOWN
e3d8 68       TM_Epi    PLA
e3d9 85 e0              STA TopMargin
e3db 20 4e e0           JSR Edit_Goto_Left_Margin
e3de 4c 8d e1           JMP Edit_Chrout_Epilog

e3e1                    .SIZE ;   19 [CS_Insert_Line]

              ; ****************
e3e1            Edit_Cursor_Down
              ; ****************

e3e1 46 a3              LSR InputRow        ; invalidate InputRow
e3e3 a6 d8              LDX CursorRow
e3e5 e4 e1              CPX BotMargin
e3e7 90 06              BCC CSCD_10
e3e9 20 29 e4           JSR EDIT_SCROLL_UP
e3ec 4c 39 ea           JMP Power_Scroll_Up
e3ef e6 d8    CSCD_10   INC CursorRow
e3f1 4c 52 e0           JMP Edit_Use_CursorRow

e3f4                    .SIZE ;   19 [Edit_Cursor_Down]

              ; ****************
e3f4            CO_Screen_Return
              ; ****************

e3f4 a0 00              LDY #0
e3f6 84 99              STY Power_Flag
e3f8 a4 e2              LDY LefMargin
e3fa 84 c6              STY CursorCol
e3fc 20 e1 e3           JSR Edit_Cursor_Down

              ; *************
e3ff            CO_JMP_Escape
              ; *************

e3ff a9 00              LDA #0
e401 85 dc              STA INSRT           ; clear insert mode
e403 85 9f              STA ReverseFlag     ; clear reverse mode
e405 85 cd              STA QTSW            ; clear quote mode
e407 4c 8d e1           JMP Edit_Chrout_Epilog

              ; ***********
e40a            Edit_Scroll
              ; ***********

e40a 20 b7 e6           JSR Set_Screen_SAL  ; 25
e40d b1 c7    ES_10     LDA (SAL),Y         ;  5
e40f 91 c4              STA (ScrPtr),Y      ;  6
e411 c4 d5              CPY RigMargin       ;  3
e413 c8                 INY                 ;  2
e414 90 f7              BCC ES_10           ;  3
e416 60                 RTS ;Size   13 [Edit_Scroll]
                                            ; total = 25 + 80 * 19 + 2 = 1547

              ; ****************
e417            EDIT_SCROLL_DOWN
              ; ****************

e417 a6 e1              LDX BotMargin       ;    3
e419 20 c9 e6 ESD_10    JSR Cursor_BOL      ;   28
e41c e4 e0              CPX TopMargin       ;    3
e41e f0 06              BEQ ESD_30          ;    2
e420 ca                 DEX                 ;    2
e421 20 0a e4           JSR Edit_Scroll     ; 1552
e424 b0 f3              BCS ESD_10          ;    3
e426 4c aa e1 ESD_30    JMP Edit_Erase_To_EOL  ; total = 1100 + 24 * 1590 = 39260

e429                    .SIZE ;   18 [EDIT_SCROLL_DOWN]

              ; **************
e429            EDIT_SCROLL_UP
              ; **************

e429 a6 e0              LDX TopMargin
e42b 20 c9 e6 ESU_10    JSR Cursor_BOL
e42e e4 e1              CPX BotMargin
e430 b0 06              BCS ESU_30
e432 e8                 INX
e433 20 0a e4           JSR Edit_Scroll
e436 b0 f3              BCS ESU_10
e438 4c aa e1 ESU_30    JMP Edit_Erase_To_EOL

e43b                    .SIZE ;   18 [EDIT_SCROLL_UP]

e43b 00 00 00           .FILL $e442-* (0) ; 7 bytes

              ; ********
e442            IRQ_MAIN
              ; ********

e442 48                 PHA
e443 8a                 TXA
e444 48                 PHA
e445 98                 TYA
e446 48                 PHA
e447 ba                 TSX
e448 bd 04 01           LDA STACK+4,X
e44b 29 10              AND #16
e44d f0 03              BEQ IRQ_05
e44f 6c 92 00           JMP (CBINV)
e452 6c 90 00 IRQ_05    JMP (CINV)

              ; **********
e455            IRQ_NORMAL
              ; **********

e455 20 68 f7           JSR Kernal_UDTIM    ; increment jiffy clock
e458 a5 a7              LDA BLNSW           ; software cursor
e45a d0 18              BNE IRQ_20          ; branch if not visible
e45c c6 a8              DEC BLNCT           ; blink count down
e45e d0 14              BNE IRQ_20
e460 a9 14              LDA #20             ; reset blink count down
e462 85 a8              STA BLNCT
e464 a4 c6              LDY CursorCol
e466 46 aa              LSR BLNON           ; BLNON = 0 : C = old value
e468 b1 c4              LDA (ScrPtr),Y
e46a b0 04              BCS IRQ_10
e46c e6 aa              INC BLNON           ; BLNON = 1 : reverse character
e46e 85 a9              STA GDBLN           ; save character under cursor
e470 49 80    IRQ_10    EOR #$80
e472 91 c4              STA (ScrPtr),Y      ; invert character
e474 20 24 e9 IRQ_20    JSR EDIT_KEY_SCAN
e477 68       IRQ_END   PLA
e478 a8                 TAY
e479 68                 PLA
e47a aa                 TAX
e47b 68                 PLA
e47c 40                 RTI

              ; ******
e47d            Delete
              ; ******

e47d 20 76 00           JSR CHRGOT
e480 20 f6 b8           JSR Scan_Linenumber ; start #
e483 20 a6 b5           JSR Find_BASIC_Line
e486 a5 5c              LDA TMPPTC
e488 85 21              STA RENINC
e48a a5 5d              LDA TMPPTC+1
e48c 85 22              STA RENINC+1
e48e 20 76 00           JSR CHRGOT
e491 c9 2d              CMP #'-'
e493 d0 30              BNE DelErr
e495 20 70 00           JSR CHRGET
e498 20 f6 b8           JSR Scan_Linenumber ; end #
e49b a5 11              LDA LINNUM
e49d 05 12              ORA LINNUM+1
e49f d0 02              BNE Del_10
e4a1 c6 12              DEC LINNUM+1        ; end number = $ff00
e4a3 20 a6 b5 Del_10    JSR Find_BASIC_Line
e4a6 90 03              BCC Del_20          ; -> not found
e4a8 20 33 ed           JSR Update_Link     ; First line after DELETE range
e4ab a6 2b    Del_20    LDX VARTAB+1
e4ad a0 00              LDY #0              ; Y = 0
e4af b1 5c    Del_30    LDA (TMPPTC),Y      ; copy upper part of program
e4b1 91 21              STA (RENINC),Y      ; into area to delete
e4b3 c8                 INY
e4b4 d0 f9              BNE Del_30
e4b6 e6 22              INC RENINC+1
e4b8 e6 5d              INC TMPPTC+1
e4ba e4 5d              CPX TMPPTC+1        ; reached VARTAB ?
e4bc b0 f1              BCS Del_30
e4be a4 21              LDY RENINC
e4c0 a5 22              LDA RENINC+1
e4c2 4c d5 df           JMP Renu_90         ; set VARTAB, reset BASIC
e4c5 4c 73 c3 DelErr    JMP Jump_To_Illegal_Quantity
e4c8                    .SIZE ;   75 [Delete]

              ; ***************
e4c8            Get_Record_Size
              ; ***************

e4c8 a0 00              LDY #0
e4ca 84 96              STY STATUS
e4cc 20 af f4           JSR Send_Filename
e4cf 20 91 d9           JSR Kernal_Read_DS
e4d2 a9 6d              LDA #$6d
e4d4 85 d3              STA SA
e4d6 ad ad 03           LDA DOS_Status
e4d9 c9 35              CMP #'5'
e4db d0 1d              BNE GRS_90
e4dd c6 b9              DEC DOS_RL
e4df a9 9d              LDA #$9d
e4e1 20 d2 ff           JSR CHROUT
e4e4 20 d2 ff           JSR CHROUT
e4e7 a5 b9              LDA DOS_RL
e4e9 20 57 d7           JSR Print_Hex_Byte
e4ec a5 b9              LDA DOS_RL
e4ee c9 02              CMP #2
e4f0 90 08              BCC GRS_90
e4f2 a4 d1              LDY FNLEN
e4f4 88                 DEY
e4f5 91 da              STA (FNADR),Y       ; try next record length
e4f7 4c c8 e4           JMP Get_Record_Size
e4fa 60       GRS_90    RTS ;Size   51 [Get_Record_Size]

              ; ***********
e4fb            Mon_Message
              ; ***********

e4fb 0d 20 20           .BYTE "\r   PC  IRQ  SR AC XR YR SP RB WB SV-BDIZC"

              ; ******
e525            IS_TAB
              ; ******

e525 a5 c6              LDA CursorCol
e527 29 07              AND #7
e529 a8                 TAY                 ; bit position
e52a a5 c6              LDA CursorCol
e52c 4a                 LSR A
e52d 4a                 LSR A
e52e 4a                 LSR A               ; Column / 8
e52f aa                 TAX                 ; word index
e530 b9 37 e5           LDA BITPOS,Y
e533 3d ee 03           AND TABS_SET,X
e536 60                 RTS ;Size   18 [IS_TAB]

              ; ******
e537            BITPOS
              ; ******

e537 80 40 20           .BYTE $80,$40,$20,$10,$08,$04,$02,$01

              ; ********
e53f            Mon_Fill
              ; ********

e53f a2 f9              LDX #BPTR           ; start address
e541 20 6f d7           JSR Read_Hex_Word
e544 90 26              BCC MoFi_Err
e546 a2 fd              LDX #MEMUSS         ; end   address
e548 20 6f d7           JSR Read_Hex_Word
e54b 90 1f              BCC MoFi_Err
e54d 20 7c d7           JSR  Read_Hex       ; fill byte
e550 90 1a              BCC MoFi_Err
e552 aa                 TAX
e553 a0 00              LDY #0
e555 a5 fd    MoFi_10   LDA MEMUSS
e557 c5 f9              CMP BPTR            ; set or clear carry
e559 a5 fe              LDA MEMUSS+1
e55b e5 fa              SBC BPTR+1
e55d 90 0a              BCC MoFi_End        ; BPTR > MEMUSS ?
e55f 8a                 TXA
e560 20 8b 02           JSR Bank_Store
e563 20 1f fb           JSR Inc_BPTR
e566 4c 55 e5           JMP MoFi_10
e569 4c b1 d4 MoFi_End  JMP Mon_Main
e56c 4c ac d4 MoFi_Err  JMP Mon_Error

e56f                    .SIZE ;   48 [Mon_Fill]


              ; ****************
e56f            Open_Disk_Buffer
              ; ****************

e56f 20 ae e7           JSR Preset_U1
e572 20 15 f2           JSR Kernal_CHRIN
e575 8d 54 03           STA DOS_Command_Buffer+1
e578 20 6d d7           JSR Hex_To_STAL
e57b 20 15 f2           JSR Kernal_CHRIN    ; skip blank
e57e a2 05              LDX #5
e580 20 f4 d8 ODB_20    JSR Mon_CHRIN
e583 9d 53 03           STA DOS_Command_Buffer,X
e586 e8                 INX
e587 e0 28              CPX #40
e589 b0 04              BCS ODB_30
e58b c9 20              CMP #' '
e58d b0 f1              BCS ODB_20
e58f 20 4c dc ODB_30    JSR DOS_SETNAM
e592 20 c7 f8           JSR Wedge_Prepare   ; set FA, clear status
e595 85 ba              STA Dis_Line        ; Dis_Line = 0
e597 20 d5 f0           JSR LISTEN          ; open fa,9,"#"
e59a a9 f9              LDA #$f9            ; sa = 9
e59c 20 43 f1           JSR SECOND
e59f a9 23              LDA #'#'            ; open buffer
e5a1 20 9e f1           JSR CIOUT
e5a4 4c b9 f1           JMP UNLSN


              ; ********
e5a7            Mon_Disk
              ; ********

              ;         U1 1000 0 18 01 - memory,drive,track,sector

e5a7 20 6f e5           JSR Open_Disk_Buffer
e5aa ad 54 03           LDA DOS_Command_Buffer+1
e5ad c9 32              CMP #'2'
e5af f0 20              BEQ Mon_Output_Block
e5b1 20 ba e7           JSR Mon_Disk_Comm
e5b4 20 d2 f0           JSR TALK
e5b7 a9 69              LDA #$69
e5b9 85 d3              STA SA
e5bb 20 93 f1           JSR TKSA
e5be a0 00              LDY #0
e5c0 20 c0 f1 MIB_30    JSR ACPTR
e5c3 91 fb              STA (STAL),Y
e5c5 c8                 INY
e5c6 d0 f8              BNE MIB_30
e5c8 20 ae f1           JSR UNTLK
e5cb 20 2a f7           JSR Close_Disk_File
e5ce 4c fa d5           JMP DiMe_10         ; display loaded block

              ; ****************
e5d1            Mon_Output_Block
              ; ****************

              ;         U2 1000 0 18 01 - memory,drive,track,sector

e5d1 20 9b e7           JSR Reset_BP
e5d4 20 d5 f0           JSR LISTEN
e5d7 a9 69              LDA #$69
e5d9 85 d3              STA SA
e5db 20 43 f1           JSR SECOND
e5de a0 00              LDY #0
e5e0 b1 fb    MOB_10    LDA (STAL),Y
e5e2 20 9e f1           JSR CIOUT
e5e5 c8                 INY
e5e6 d0 f8              BNE MOB_10
e5e8 20 b9 f1           JSR UNLSN
e5eb 20 ba e7           JSR Mon_Disk_Comm
e5ee 20 2a f7           JSR Close_Disk_File
e5f1 4c fa d5           JMP DiMe_10         ; display output block

e5f4 00 00 00           .FILL $e606-* (0) ; 18 bytes

              ; *********
e606            Edit_Init
              ; *********

e606 a9 7f              LDA #$7f
e608 8d 4e e8           STA VIA_IER         ; disable all interrupts
e60b a2 6d              LDX #$6d
e60d a9 00              LDA #0
e60f 85 e8              STA PrevChar        ; clear # of HOME key pressed
e611 95 8d    EdIn_10   STA JIFFY_CLOCK,X   ; clear all kernal variables
e613 ca                 DEX
e614 10 fb              BPL EdIn_10
e616 86 98              STX Key_Flags       ; $FF = Clear all flags
e618 ad 99 b3           LDA BSOS_Bank_Init
e61b 85 9a              STA Default_Bank
e61d a9 55              LDA #<IRQ_NORMAL    ; set default IRQ vector
e61f 85 90              STA CINV
e621 a9 e4              LDA #>IRQ_NORMAL
e623 85 91              STA CINV+1
e625 a9 09              LDA #9
e627 85 e3              STA XMAX            ; size of keyboard bufferX
e629 a9 03              LDA #3
e62b 85 b0              STA DFLTO           ; standard output channel
e62d a9 0f              LDA #15
e62f 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e632 0a                 ASL A
e633 8d 40 e8           STA VIA_Port_B
e636 8d 42 e8           STA VIA_DDR_B
e639 8e 22 e8           STX PIA2_Port_B
e63c 8e 45 e8           STX VIA_Timer_1_Hi  ; Timer 1 latch hi = $ff
e63f a9 3d              LDA #$3d
e641 8d 13 e8           STA PIA1_Cont_B
e644 2c 12 e8           BIT PIA1_Port_B     ; Keyboard row
e647 a9 3c              LDA #$3c
e649 8d 21 e8           STA PIA2_Cont_A
e64c 8d 23 e8           STA PIA2_Cont_B
e64f 8d 11 e8           STA PIA1_Cont_A
e652 8e 22 e8           STX PIA2_Port_B
e655 a9 0e              LDA #14
e657 85 a8              STA BLNCT
e659 85 a7              STA BLNSW
e65b 85 e6              STA DELAY
e65d 85 e5              STA KOUNT
e65f 8d 4e e8           STA VIA_IER         ; enable CA1, SR, CB2 interrupt
e662 a9 18              LDA #24
e664 85 df              STA ScreenRows
e666 20 bb e1           JSR Edit_Full_Screen
e669 a2 0c              LDX #12
e66b a9 00              LDA #0
e66d 9d ee 03 EdIn_20   STA TABS_SET,X
e670 ca                 DEX
e671 10 fa              BPL EdIn_20
e673 a9 1d              LDA #<Edit_CHRIN_Standard
e675 a2 e1              LDX #>Edit_CHRIN_Standard
e677 85 e9              STA SCRIV
e679 86 ea              STX SCRIV+1
e67b a9 0c              LDA #<Edit_CHROUT_Standard
e67d a2 e2              LDX #>Edit_CHROUT_Standard
e67f 85 eb              STA SCROV
e681 86 ec              STX SCROV+1
e683 a9 10              LDA #16
e685 85 e7              STA CHIME
e687 20 8a e6           JSR Double_Beep

              ; ***********
e68a            Double_Beep
              ; ***********

e68a 20 8d e6           JSR EDIT_BEEP

              ; *********
e68d            EDIT_BEEP
              ; *********

e68d a4 e7              LDY CHIME
e68f f0 25              BEQ BEEP_Ret
e691 a9 10              LDA #16             ; shift out - rate controlled by timer 2
e693 8d 4b e8           STA VIA_ACR         ; free running mode
e696 a9 0f              LDA #15
e698 8d 4a e8           STA VIA_Shift       ; set shift pattern 0000 1111
e69b a2 07              LDX #7
e69d bd 4d e7 BEEP_10   LDA SOUND_TAB-1,X
e6a0 8d 48 e8           STA VIA_Timer_2_Lo  ; set sustain time
e6a3 a5 e7              LDA CHIME
e6a5 88       BEEP_20   DEY
e6a6 d0 fd              BNE BEEP_20           ; inner wait loop
e6a8 38                 SEC
e6a9 e9 01              SBC #1
e6ab d0 f8              BNE BEEP_20           ; outer wait loop
e6ad ca                 DEX
e6ae d0 ed              BNE BEEP_10           ; next note
e6b0 8e 4a e8           STX VIA_Shift       ; x=0 clear shift register
e6b3 8e 4b e8           STX VIA_ACR         ; x=0 clear access control register
e6b6 60       BEEP_Ret  RTS ;Size   42 [EDIT_BEEP]

              ; **************
e6b7            Set_Screen_SAL
              ; **************

e6b7 8a                 TXA
e6b8 48                 PHA
e6b9 29 0f              AND #15
e6bb aa                 TAX
e6bc bd 55 e7           LDA Line_Addr_Lo,X
e6bf 85 c7              STA SAL
e6c1 68                 PLA
e6c2 aa                 TAX
e6c3 bd 6e e7           LDA Line_Addr_Hi,X
e6c6 85 c8              STA SAL+1
e6c8 60                 RTS ;Size   18 [Set_Screen_SAL]

              ; **********
e6c9            Cursor_BOL
              ; **********

              ; Input:  X       = cursor row (0 - 24)
              ; Output: ScrPtr  = screen address of row X
              ;         Y       = left margin

e6c9 a4 e2              LDY LefMargin

              ; *************
e6cb            Update_ScrPtr
              ; *************

e6cb 8a                 TXA
e6cc 48                 PHA
e6cd 29 0f              AND #15             ; Line lo repeats after 16 lines
e6cf aa                 TAX
e6d0 bd 55 e7           LDA Line_Addr_Lo,X
e6d3 85 c4              STA ScrPtr
e6d5 68                 PLA
e6d6 aa                 TAX
e6d7 bd 6e e7           LDA Line_Addr_Hi,X
e6da 85 c5              STA ScrPtr+1
e6dc 60                 RTS ;Size   18 [Update_ScrPtr]

              ; **********
e6dd            RUN_String
              ; **********

              ;               dL"*<CR>rU<CR>
e6dd 44 cc 22           .BYTE $44,$cc,$22,$2a,$0d,$52,$d5,$0d

              ; ********
e6e5            CRT_TEXT
              ; ********

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6e5 3a                 .BYTE  58           ;  0: Horizontal Total
e6e6 28                 .BYTE  40           ;  1: Horizontal Displayed
e6e7 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6e8 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6e9 20                 .BYTE  32           ;  4: Vertical Total
e6ea 09                 .BYTE   9           ;  5: Vertical Total Adjust
e6eb 19                 .BYTE  25           ;  6: Vertical Displayed
e6ec 1e                 .BYTE  30           ;  7: Vertical Sync position
e6ed 00                 .BYTE   0           ;  8: Interlace and Skew
e6ee 09                 .BYTE   9           ;  9: Maximum Raster Address
e6ef 00                 .BYTE   0           ; 10: Cursor Start Raster
e6f0 00                 .BYTE   0           ; 11: Cursor End Raster
e6f1 10                 .BYTE $10           ; 12: Display Start Address (High)
e6f2 00                 .BYTE $00           ; 13: Display Start Address (Low)
e6f3 00                 .BYTE $00           ; 14: Cursor Address (High)
e6f4 00                 .BYTE $00           ; 15: Cursor Address (Low)
e6f5 00                 .BYTE $00           ; 16: Light Pen Address (High)
e6f6 00                 .BYTE $00           ; 17: Light Pen Address (Low)


              ; ************
e6f7            CRT_GRAPHICS
              ; ************

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6f7 3a                 .BYTE  58           ;  0: Horizontal Total
e6f8 28                 .BYTE  40           ;  1: Horizontal Displayed
e6f9 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6fa 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6fb 29                 .BYTE  41           ;  4: Vertical Total                  !!!
e6fc 03                 .BYTE   3           ;  5: Vertical Total Adjust           !!!
e6fd 19                 .BYTE  25           ;  6: Vertical Displayed
e6fe 22                 .BYTE  34           ;  7: Vertical Sync position          !!!
e6ff 00                 .BYTE   0           ;  8: Interlace and Skew
e700 07                 .BYTE   7           ;  9: Maximum Raster Address          !!!


              ; ***
e701            OLD
              ; ***
e701 a9 01              LDA #1
e703 a8                 TAY
e704 91 28              STA (TXTTAB),Y      ; non zero link
e706 88                 DEY
e707 91 28              STA (TXTTAB),Y
e709 20 b6 b4           JSR Rechain         ; restore all links
e70c 18                 CLC
e70d a5 1f              LDA INDEXA
e70f 69 02              ADC #2
e711 a8                 TAY
e712 a5 20              LDA INDEXA+1
e714 69 00              ADC #0
e716 4c d5 df           JMP Renu_90         ; set VARTAB and reset BASIC

e719 00 00 00           .FILL $e74e-* (0) ; 53 bytes

              ; ****************
e74e            SOUND_TAB ; e74e
              ; ****************

e74e 0e 1e 3e           .BYTE $0e,$1e,$3e,$7e,$3e,$1e,$0e

              ; ********************
e755            Line_Addr_Lo ; $e755
              ; ********************

e755 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e75d 80 d0 20           .BYTE $80,$d0,$20,$70,$c0,$10,$60,$b0
e765 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e76d 80                 .BYTE $80

              ; ********************
e76e            Line_Addr_Hi ; $e76e
              ; ********************

e76e 80 80 80           .BYTE $80,$80,$80,$80,$81,$81,$81,$82 ;  0 -  7
e776 82 82 83           .BYTE $82,$82,$83,$83,$83,$84,$84,$84 ;  8 - 15
e77e 85 85 85           .BYTE $85,$85,$85,$85,$86,$86,$86,$87 ; 16 - 23
e786 87 87 88           .BYTE $87,$87,$88,$88,$88,$89,$89,$89 ; 24 - 31

e78e 42 2d 50 B_P_0     .BYTE "B-P 9 0\r"
e796 55 31 3a U1        .BYTE "U1:9 "

              ; ********
e79b            Reset_BP
              ; ********

e79b 20 2b fb           JSR DOS_Open_Comm_Write
e79e a0 00              LDY #0
e7a0 b9 8e e7 RBP_30    LDA B_P_0,Y
e7a3 20 9e f1           JSR CIOUT
e7a6 c8                 INY
e7a7 c0 08              CPY #?B_P_0
e7a9 90 f5              BCC RBP_30
e7ab 4c b9 f1           JMP UNLSN

              ; *********
e7ae            Preset_U1
              ; *********

e7ae a2 04              LDX #4
e7b0 bd 96 e7 PU1_10    LDA U1,X
e7b3 9d 53 03           STA DOS_Command_Buffer,X
e7b6 ca                 DEX
e7b7 10 f7              BPL PU1_10
e7b9 60                 RTS ;Size   12 [Preset_U1]

              ; *************
e7ba            Mon_Disk_Comm
              ; *************

e7ba 20 2b fb           JSR DOS_Open_Comm_Write
e7bd a2 00              LDX #0
e7bf bd 53 03 MDC_10    LDA DOS_Command_Buffer,X
e7c2 e8                 INX
e7c3 20 9e f1           JSR CIOUT
e7c6 c9 20              CMP #' '
e7c8 b0 f5              BCS MDC_10
e7ca 4c b9 f1           JMP UNLSN

e7cd 00 00 00           .FILL $e800-* (0) ; 51 bytes

e800 48 41 4c           .BYTE "HALL OF FAME:"
e80d 43 48 55           .BYTE "CHUCK PEDDLE - "
e81c 42 49 4c           .BYTE "BILL MENSCH - "
e82a 4a 41 43           .BYTE "JACK TRAMIEL - "
e839 49 52 41           .BYTE "IRA VELINSKY - "
e848 4a 4f 48           .BYTE "JOHN FEAGANS - "
e857 42 49 4c           .BYTE "BILL GATES - "
e864 4a 49 4d           .BYTE "JIM BUTTERFIELD - "
e876 42 52 41           .BYTE "BRAD TEMPLETON - "
e887 4a 49 4d           .BYTE "JIM CONELLEY - "
e896 4e 49 4c           .BYTE "NILS EILERS - "
e8a4 56 49 43           .BYTE "VICE TEAM - "


e8b0 00 00 00           .FILL $e924-* (0) ; 116 bytes

              ; *************
e924            EDIT_KEY_SCAN
              ; *************

              ; Initialize

e924 ad 10 e8           LDA PIA1_Port_A     ; Keyboard row select
e927 29 f0              AND #%11110000      ; Select row 0
e929 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e92c a5 98              LDA Key_Flags
e92e 09 c0              ORA #%11000000      ; 7 no <shift> and 6 no <ctrl>
e930 85 98              STA Key_Flags
e932 a9 ff              LDA #$ff
e934 85 97              STA Key_Index       ; invalidate Key_Index
e936 85 a6              STA SFDX            ; invalidate SFDX
e938 a2 4f              LDX #$4f            ; check key 79 -> 0

              ; Load next keyboard row int oaccumulator

e93a ad 12 e8 ScKbd_02  LDA PIA1_Port_B     ; Keyboard row
e93d cd 12 e8           CMP PIA1_Port_B     ; Keyboard row
e940 d0 f8              BNE ScKbd_02        ; repeat until no bounce

              ; Rotate accumulator for all 8 keys of this row

e942 a0 08              LDY #8              ; Test the 8 keys of the row
e944 4a       ScKbd_04  LSR A               ; next key -> carry
e945 b0 1a              BCS ScKbd_10        ; 1 -> not pressed
e947 48                 PHA                 ; Save scanned row

              ; Test for right or left shift key

e948 a9 7f              LDA #%01111111      ; mask for <shift> pressed
e94a e0 19              CPX #$19            ; Right Shift ?
e94c f0 0e              BEQ ScKbd_06        ; -> pressed
e94e e0 1f              CPX #$1f            ; Left Shift ?
e950 f0 0a              BEQ ScKbd_06        ; -> pressed

              ; Test for control key (RVS on older keyboards)

e952 a9 bf              LDA #%10111111      ; mask for <ctrl> pressed
e954 e0 0f              CPX #15             ; <RVS = CTRL> ?
e956 f0 04              BEQ ScKbd_06        ; -> pressed

              ; normal key, save key index

e958 86 97              STX Key_Index
e95a d0 04              BNE ScKbd_08        ; branch always

              ; flag shift or control in Key_Flags

e95c 25 98    ScKbd_06  AND Key_Flags
e95e 85 98              STA Key_Flags       ; save shift and control status

              ; continue with next index

e960 68       ScKbd_08  PLA                 ; restore row
e961 ca       ScKbd_10  DEX                 ; next key index
e962 30 08              BMI ScKbd_12        ; finished

              ; next key in this row

e964 88                 DEY                 ; next column
e965 d0 dd              BNE ScKbd_04

              ; row scan finished -> next row

e967 ee 10 e8           INC PIA1_Port_A     ; next keyboard row
e96a d0 ce              BNE ScKbd_02        ; Branch always

              ; keyboard scan finished - check if a keypress occured

e96c a6 97    ScKbd_12  LDX Key_Index       ; any key ?
e96e 10 03              BPL ScKbd_13        ; branch on key press
e970 86 e4              STX LSTX            ; invalidate last key pressed
e972 60       ScKbd_22  RTS ;Size   79 [EDIT_KEY_SCAN]

              ; is it the same key index as in the last scan ?

e973 e4 e4    ScKbd_13  CPX LSTX            ; still holding the same key ?
e975 d0 18              BNE ScKbd_16        ; other key
e977 a4 e6              LDY DELAY
e979 f0 04              BEQ ScKbd_14        ; branch if delay expired
e97b c6 e6              DEC DELAY           ; else decrement repeat delay counter
e97d d0 f3              BNE ScKbd_22        ; branch if delay not expired
e97f c6 e5    ScKbd_14  DEC KOUNT           ; decrement repeat speed counter
e981 d0 ef              BNE ScKbd_22        ; branch if repeat speed count not expired
e983 a0 04              LDY #4              ; set for 4/60ths of a second
e985 e0 0b              CPX #$0b            ; index for cursor <- ->
e987 d0 02              BNE ScKbd_15        ; normaö repeat speed
e989 a0 02              LDY #2              ; cursor left right repeat faster
e98b 84 e5    ScKbd_15  STY KOUNT           ; set repeat speed counter
e98d d0 06              BNE ScKbd_18        ; branch always

              ; new key press - reset delay

e98f 86 e4    ScKbd_16  STX LSTX            ; save key index
e991 a9 15              LDA #21
e993 85 e6              STA DELAY           ; set repeat delay count
e995 20 b4 e9 ScKbd_18  JSR Lookup_Keycode
e998 e0 0f              CPX #15
e99a f0 15              BEQ ScKbd_30        ; <CONTROL> doesn't go into buffer
e99c a6 9e              LDX CharsInBuffer
e99e e4 e3              CPX XMAX
e9a0 b0 05              BCS ScKbd_26        ; buffer full

              ; add key to keyboard buffer

e9a2 9d 6f 02 ScKbd_24  STA KEYD,X
e9a5 e6 9e              INC CharsInBuffer   ; put key into buffer

              ; check for STOP key

e9a7 a0 ff    ScKbd_26  LDY #$ff            ; Clear STOP flag
e9a9 c9 03              CMP #3              ; <STOP>
e9ab d0 02              BNE ScKbd_28
e9ad a0 ef              LDY #$ef            ; Set STOP flag
e9af 84 9b    ScKbd_28  STY Stop_Flag
e9b1 85 a6    ScKbd_30  STA SFDX
e9b3 60                 RTS ;Size  144 [EDIT_KEY_SCAN]

              ; **************
e9b4            Lookup_Keycode
              ; **************

e9b4 bd b6 eb           LDA KEYBOARD_CONTROL,X
e9b7 24 98              BIT Key_Flags
e9b9 70 05              BVS LoKe_20         ; no control
e9bb 30 02              BMI LoKe_10
e9bd 09 80              ORA #$80            ; shift control
e9bf 60       LoKe_10   RTS ;Size   12 [Lookup_Keycode]
e9c0 30 04    LoKe_20   BMI LoKe_30         ; no shift
e9c2 bd 65 eb           LDA KEYBOARD_SHIFTED,X
e9c5 60                 RTS ;Size   18 [Lookup_Keycode]
e9c6 bd 15 eb LoKe_30   LDA KEYBOARD_NORMAL,X
e9c9 60                 RTS ;Size   22 [Lookup_Keycode]

              ; ********************
e9ca            Edit_Switch_Char_ROM
              ; ********************

              ; Input:   A = $10 (new charset)   $30 (old charset)

e9ca a0 0c               LDY #12
e9cc 8c 80 e8            STY CRT_Address
e9cf 8d 81 e8            STA CRT_Value
e9d2 60                  RTS ;Size    9 [Edit_Switch_Char_ROM]


              ; **************
e9d3            EDIT_RESET_CRT
              ; **************

e9d3 a0 11              LDY #17
e9d5 2c                 .BYTE $2c           ; skip next instruction

              ; *****************
e9d6            EDIT_CHARSET_TEXT
              ; *****************

e9d6 a0 09              LDY #9
e9d8 a9 0e              LDA #14
e9da 8d 4c e8           STA VIA_PCR
e9dd a9 e5              LDA #<CRT_TEXT
e9df a2 e6              LDX #>CRT_TEXT
e9e1 4c 57 e0           JMP EDIT_SET_CRT

              ; *********************
e9e4            EDIT_CHARSET_GRAPHICS
              ; *********************

e9e4 a0 09              LDY #9
e9e6 a9 0c              LDA #12
e9e8 8d 4c e8           STA VIA_PCR
e9eb a9 f7              LDA #<CRT_GRAPHICS
e9ed a2 e6              LDX #>CRT_GRAPHICS
e9ef 4c 57 e0           JMP EDIT_SET_CRT

              ; *****************
e9f2            Read_Power_String
              ; *****************

e9f2 a9 ff              LDA #$ff
e9f4 85 99              STA Power_Flag
e9f6 20 e2 b4           JSR Read_String
e9f9 e6 99              INC Power_Flag
e9fb 60                 RTS ;Size   10 [Read_Power_String]

              ; ****************
e9fc            Check_Linenumber
              ; ****************

e9fc 8a                 TXA                 ; X = Row
e9fd 48                 PHA
e9fe 48                 PHA
e9ff 29 0f              AND #15
ea01 aa                 TAX
ea02 18                 CLC
ea03 bd 55 e7           LDA Line_Addr_Lo,X
ea06 65 e2              ADC LefMargin
ea08 85 77              STA TXTPTR
ea0a 68                 PLA
ea0b aa                 TAX
ea0c bd 6e e7           LDA Line_Addr_Hi,X
ea0f 69 00              ADC #0
ea11 85 78              STA TXTPTR+1
ea13 20 76 00           JSR CHRGOT
ea16 b0 04              BCS ChLi_Ret        ; no  number
ea18 20 f6 b8           JSR Scan_Linenumber
ea1b 18                 CLC                 ; has number
ea1c 68       ChLi_Ret  PLA
ea1d aa                 TAX
ea1e 60                 RTS ;Size   35 [Check_Linenumber]

              ; ******************
ea1f            Check_Line_Upwards
              ; ******************

ea1f a6 e1              LDX BotMargin
ea21 e4 e0    CLU_10    CPX TopMargin
ea23 f0 06              BEQ CLU_Ret         ; carry set -> no number
ea25 ca                 DEX
ea26 20 fc e9           JSR Check_Linenumber
ea29 b0 f6              BCS CLU_10
ea2b 60       CLU_Ret   RTS ;Size   13 [Check_Line_Upwards]

              ; ********************
ea2c            Check_Line_Downwards
              ; ********************

ea2c a6 e0              LDX TopMargin
ea2e e4 e1    CLD_10    CPX BotMargin
ea30 f0 06              BEQ CLD_Ret         ; carry set -> no number
ea32 e8                 INX
ea33 20 fc e9           JSR Check_Linenumber
ea36 b0 f6              BCS CLD_10
ea38 60       CLD_Ret   RTS ;Size   13 [Check_Line_Downwards]

              ; ***************
ea39            Power_Scroll_Up
              ; ***************

ea39 24 99              BIT Power_Flag      ; active ?
ea3b 10 33              BPL PSU_Ret
ea3d a5 d8              LDA CursorRow       ; save row
ea3f 48                 PHA
ea40 a5 c6              LDA CursorCol
ea42 48                 PHA                 ; save col
ea43 a6 e1              LDX BotMargin
ea45 ca                 DEX
ea46 20 c9 e6           JSR Cursor_BOL      ; one row above bottom line
ea49 a9 20              LDA #' '            ; check, if this line is blank
ea4b d1 c4    PSU_10    CMP (ScrPtr),Y
ea4d d0 18              BNE PSU_30          ; don't list on non empty line
ea4f c8                 INY
ea50 c4 d5              CPY RigMargin
ea52 90 f7              BCC PSU_10
ea54 86 d8              STX CursorRow
ea56 20 1f ea           JSR Check_Line_Upwards
ea59 b0 0c              BCS PSU_30
ea5b e6 11              INC LINNUM
ea5d d0 02              BNE PSU_20
ea5f e6 12              INC LINNUM+1
ea61 20 e4 ea PSU_20    JSR Find_Power_Line
ea64 20 ce ea           JSR List_BASIC_Line
ea67 68       PSU_30    PLA
ea68 85 c6              STA CursorCol
ea6a 68                 PLA
ea6b 85 d8              STA CursorRow       ; restore row
ea6d 20 52 e0           JSR Edit_Use_CursorRow
ea70 60       PSU_Ret   RTS ;Size   56 [Power_Scroll_Up]

              ; *****************
ea71            Power_Scroll_Down
              ; *****************

ea71 24 99              BIT Power_Flag
ea73 10 fb              BPL PSU_Ret
ea75 a5 d8              LDA CursorRow       ; save row
ea77 48                 PHA
ea78 a5 c6              LDA CursorCol
ea7a 48                 PHA                 ; save col
ea7b 20 2c ea           JSR Check_Line_Downwards
ea7e b0 e7              BCS PSU_30
ea80 20 e4 ea           JSR Find_Power_Line
ea83 a5 5c              LDA TMPPTC
ea85 c5 28              CMP TXTTAB
ea87 d0 06              BNE PSD_20
ea89 a5 5d              LDA TMPPTC+1
ea8b c5 29              CMP TXTTAB+1
ea8d f0 d8              BEQ PSU_30
ea8f a5 57    PSD_20    LDA TMPPTB
ea91 85 5c              STA TMPPTC
ea93 a5 58              LDA TMPPTB+1
ea95 85 5d              STA TMPPTC+1
ea97 20 4a e0           JSR EDIT_HOME
ea9a 20 ce ea           JSR List_BASIC_Line
ea9d a6 d8              LDX CursorRow
ea9f e4 e0              CPX TopMargin
eaa1 f0 c4              BEQ PSU_30
eaa3 a4 c6              LDY CursorCol       ; Basic line was oversize
eaa5 a9 20              LDA #' '            ; erase to EOL and scroll again
eaa7 91 c4    PSD_30    STA (ScrPtr),Y
eaa9 c4 d5              CPY RigMargin
eaab c8                 INY
eaac 90 f9              BCC PSD_30
eaae a5 e0              LDA TopMargin
eab0 48                 PHA
eab1 e8                 INX
eab2 86 e0              STX TopMargin
eab4 20 17 e4           JSR EDIT_SCROLL_DOWN
eab7 68                 PLA
eab8 85 e0              STA TopMargin
eaba a0 01              LDY #1
eabc b1 5c              LDA (TMPPTC),Y      ; link hi
eabe aa                 TAX
eabf 88                 DEY
eac0 b1 5c              LDA (TMPPTC),Y      ; link lo
eac2 85 5c              STA TMPPTC
eac4 86 5d              STX TMPPTC+1
eac6 e6 d8              INC CursorRow
eac8 20 ce ea           JSR List_BASIC_Line
eacb 4c 67 ea           JMP PSU_30          ; always

eace                    .SIZE ;   93 [Power_Scroll_Down]

              ; ***************
eace            List_BASIC_Line
              ; ***************

eace 20 4e e0           JSR Edit_Goto_Left_Margin
ead1 a0 01              LDY #1
ead3 b1 5c              LDA (TMPPTC),Y      ; check link for valid line
ead5 f0 0c              BEQ LBL_Ret
ead7 c8                 INY
ead8 b1 5c              LDA (TMPPTC),Y      ; line # lo
eada aa                 TAX
eadb c8                 INY
eadc b1 5c              LDA (TMPPTC),Y      ; line # hi
eade 20 89 b6           JSR List_Line       ; returns A=0
eae1 85 cd              STA QTSW
eae3 60       LBL_Ret   RTS ;Size   22 [List_BASIC_Line]

              ; ***************
eae4            Find_Power_Line
              ; ***************

eae4 a5 28              LDA TXTTAB
eae6 a6 29              LDX TXTTAB+1
eae8 85 57              STA TMPPTB
eaea 86 58              STX TMPPTB+1
eaec 85 5c    FPL_10    STA TMPPTC
eaee 86 5d              STX TMPPTC+1
eaf0 a0 01              LDY #1
eaf2 b1 5c              LDA (TMPPTC),Y      ; link hi
eaf4 f0 1e              BEQ FPL_40
eaf6 c8                 INY                 ; Y = 2
eaf7 b1 5c              LDA (TMPPTC),Y      ; line # lo
eaf9 c5 11              CMP LINNUM
eafb c8                 INY                 ; Y = 3
eafc b1 5c              LDA (TMPPTC),Y      ; line # hi
eafe e5 12              SBC LINNUM+1
eb00 b0 12              BCS FPL_40          ; >= LINNUM
eb02 a5 5c              LDA TMPPTC
eb04 85 57              STA TMPPTB
eb06 a6 5d              LDX TMPPTC+1        ; last ptr
eb08 86 58              STX TMPPTB+1
eb0a 88                 DEY                 ; Y = 2
eb0b 88                 DEY                 ; Y = 1
eb0c b1 5c              LDA (TMPPTC),Y      ; link hi
eb0e aa                 TAX
eb0f 88                 DEY                 ; Y = 0
eb10 b1 5c              LDA (TMPPTC),Y      ; link lo
eb12 90 d8              BCC FPL_10          ; branch always
eb14 60       FPL_40    RTS ;Size   49 [Find_Power_Line]

              ; ***************
eb15            KEYBOARD_NORMAL
              ; ***************

              ; The keyboard table has 80 ($50) entries scanned backwards
              ; The map is organized in 10 rows x 8 columns
              ; Val = Scancode assigned to this key
              ; X   = Index of this key
              ; R   = Physical row on keyboard (1-5)
              ; C   = Physical column on keyboard (1-16 and k1-k3 for keypad)
              ; Key = Description

              ;               Val     X  R  C Key
              ;         --------------------------------
eb15 16                 .PET $16  ; 00  -  - Ctrl V
eb16 00                 .PET $00  ; 01  -  -
eb17 be                 .PET $be  ; 02  1 12 SZ  ?
0000 TRUE     #if BSOS_KBD
eb18 14                 .PET $14  ; 03  1 16 DEL INST
              #else
SKIP                    .PET $13  ; 03  1 16 HOME CLR
              #endif
eb19 39                 .PET '9'  ; 04  1 10 9   )
eb1a 36                 .PET '6'  ; 05  1  7 6   &
eb1b 33                 .PET '3'  ; 06  1  4 3   Paragraph
eb1c 3c                 .PET '<'  ; 07  1  1 <   >

eb1d 31                 .PET '1'  ; 08  3 k1 1
eb1e 2d                 .PET '-'  ; 09  4 12 -   _
eb1f 15                 .PET $15  ; 0a  -  - Ctrl U
0000 TRUE     #if BSOS_KBD
eb20 1d                 .PET $1d  ; 0b  4 15 RIGHT LEFT
              #else
SKIP                    .PET $14  ; 0b  4 15 DEL INST
              #endif
eb21 4d                 .PET 'm'  ; 0c  4  9 m
eb22 20                 .PET ' '  ; 0d  5  1 SPACE
eb23 58                 .PET 'x'  ; 0e  4  4 x
eb24 00                 .PET $00  ; 0f  4  1 CTRL (used by index)

eb25 32                 .PET '2'  ; 10  3 k2 2
0000 TRUE     #if BSOS_KBD
eb26 11                 .PET $11  ; 11  4 14 DOWN UP
              #else
SKIP                    .PET $03  ; 11  4 14 STOP RUN
              #endif
eb27 0f                 .PET $0f  ; 12  -  - Ctrl O
eb28 30                 .PET '0'  ; 13  4 k1 0
eb29 2c                 .PET ','  ; 14  4 10 ,
eb2a 4e                 .PET 'n'  ; 15  4  8 n
eb2b 56                 .PET 'v'  ; 16  4  6 v
eb2c 59                 .PET 'y'  ; 17  4  3 y

eb2d 33                 .PET '3'  ; 18  3 k3 3
eb2e 00                 .PET $00  ; 19  4 13 Right SHIFT (used by index)
eb2f 19                 .PET $19  ; 1a  -  - Ctrl Y
eb30 2e                 .PET '.'  ; 1b  4 11 .
eb31 2e                 .PET '.'  ; 1c  4 k2 .
eb32 42                 .PET 'b'  ; 1d  4  7 b
eb33 43                 .PET 'c'  ; 1e  4  5 c
eb34 00                 .PET $00  ; 1f  4  2 Left SHIFT (used by index)

eb35 34                 .PET '4'  ; 20  2 k1 4
eb36 bd                 .PET $bd  ; 21  2 12 u umlaut
eb37 4f                 .PET 'o'  ; 22  2 10 o
eb38 5b                 .PET '['  ; 23  2 14 [   ^
eb39 55                 .PET 'u'  ; 24  2  8 u
eb3a 54                 .PET 't'  ; 25  2  6 t
eb3b 45                 .PET 'e'  ; 26  2  4 e
eb3c 51                 .PET 'q'  ; 27  2  2 q

eb3d 5d                 .PET ']'  ; 28  2 15 ]   \
eb3e 50                 .PET 'p'  ; 29  2 11 p
eb3f 49                 .PET 'i'  ; 2a  2  9 i
eb40 2b                 .PET '+'  ; 2b  2 13 +
eb41 5a                 .PET 'z'  ; 2c  2  7 z
eb42 52                 .PET 'r'  ; 2d  2  5 r
eb43 57                 .PET 'w'  ; 2e  2  3 w
eb44 09                 .PET $09  ; 2f  2  1 TAB

eb45 36                 .PET '6'  ; 30  2 k3 6
eb46 bb                 .PET $bb  ; 31  3 13 a umlaut
eb47 4c                 .PET 'l'  ; 32  3 11 l
eb48 0d                 .PET $0d  ; 33  3 15 RETURN
eb49 4a                 .PET 'j'  ; 34  3  9 j
eb4a 47                 .PET 'g'  ; 35  3  7 g
eb4b 44                 .PET 'd'  ; 36  3  5 d
eb4c 41                 .PET 'a'  ; 37  3  3 a

eb4d 35                 .PET '5'  ; 38  2 k2 5
eb4e bc                 .PET $bc  ; 39  3 12 o umlaut
eb4f 4b                 .PET 'k'  ; 3a  3 10 k
eb50 23                 .PET '#'  ; 3b  3 14 #
eb51 48                 .PET 'h'  ; 3c  3  8 h
eb52 46                 .PET 'f'  ; 3d  3  6 f
eb53 53                 .PET 's'  ; 3e  3  4 s
eb54 1b                 .PET $1b  ; 3f  3  1 ESC

eb55 39                 .PET '9'  ; 40  1 k3 9
eb56 00                 .PET $00  ; 41  -  -
0000 TRUE     #if BSOS_KBD
eb57 13                 .PET $13  ; 42  1 16 HOME
              #else
SKIP                    .PET $11  ; 42  1 16 DOWN UP
              #endif
eb58 37                 .PET '7'  ; 43  1 k1 7
eb59 30                 .PET '0'  ; 44  1 11 0
eb5a 37                 .PET '7'  ; 45  1  8 7
eb5b 34                 .PET '4'  ; 46  1  5 4
eb5c 31                 .PET '1'  ; 47  1  2 1

eb5d 00                 .PET $00  ; 48  -  -
eb5e 0e                 .PET $0e  ; 49  -  - Ctrl N
0000 TRUE     #if BSOS_KBD
eb5f 03                 .PET $03  ; 4a  1 15 STOP (RUN)
              #else
SKIP                    .PET $1d  ; 4a  1 15 RIGHT LEFT
              #endif
eb60 38                 .PET '8'  ; 4b  1 k2 Keypad 8
eb61 af                 .PET $af  ; 4c  1 13 ACUTE (GRAVE)
eb62 38                 .PET '8'  ; 4d  1  9
eb63 35                 .PET '5'  ; 4e  1  6
eb64 32                 .PET '2'  ; 4f  1  3

              ; ****************
eb65            KEYBOARD_SHIFTED
              ; ****************

eb65 96                 .PET $96  ; 00    Shift Ctrl V
eb66 00                 .PET $00  ; 01
eb67 3f                 .PET '?'  ; 02
0000 TRUE     #if BSOS_KBD
eb68 94                 .PET $94  ; 03    INST
              #else
SKIP                    .PET $93  ; 03    CLR
              #endif
eb69 29                 .PET ')'  ; 04    )
eb6a 26                 .PET '&'  ; 05    &
eb6b 40                 .PET '@'  ; 06    Paragraph
eb6c 3e                 .PET '>'  ; 07    >

eb6d a2                 .PET $a2  ; 08    Graph a2  KP 1
eb6e 5f                 .PET '_'  ; 09    UNDERLINE
eb6f 95                 .PET $95  ; 0a    Shift Ctrl U
0000 TRUE     #if BSOS_KBD
eb70 9d                 .PET $9d  ; 0b    LEFT
              #else
SKIP                    .PET $94  ; 0b    INST
              #endif
eb71 cd                 .PET 'M'  ; 0c    M
eb72 a0                 .PET $a0  ; 0d    SHIFT SPACE
eb73 d8                 .PET 'X'  ; 0e    X
eb74 00                 .PET $00  ; 0f    CTRL (used by index)

eb75 a3                 .PET $a3  ; 10    Graph a3
0000 TRUE     #if BSOS_KBD
eb76 91                 .PET $91  ; 11    Cursor UP
              #else
SKIP                    .PET $93  ; 11    RUN
              #endif
eb77 8f                 .PET $8f  ; 12    Shift Ctrl O
eb78 a1                 .PET $a1  ; 13    Graph a1  KP 0
eb79 3b                 .PET ';'  ; 14    ;
eb7a ce                 .PET 'N'  ; 15    N
eb7b d6                 .PET 'V'  ; 16    V
eb7c d9                 .PET 'Y'  ; 17    Y

eb7d a4                 .PET $a4  ; 18    Graph a4   KP 3
eb7e 00                 .PET $00  ; 19    Right SHIFT (used by index)
eb7f 99                 .PET $99  ; 1a    Shift Ctrl Y
eb80 ff                 .PET $ff  ; 1b    KP . Pi
eb81 3a                 .PET ':'  ; 1c    :
eb82 c2                 .PET 'B'  ; 1d    B
eb83 c3                 .PET 'C'  ; 1e    C
eb84 00                 .PET $00  ; 1f    Left SHIFT (used by index)

eb85 a5                 .PET $a5  ; 20    Graph a5   KP 4
eb86 f3                 .PET $f3  ; 21    U umlaut
eb87 cf                 .PET 'O'  ; 22    O
eb88 5e                 .PET '^'  ; 23    Circumflex
eb89 d5                 .PET 'U'  ; 24    U
eb8a d4                 .PET 'T'  ; 25    T
eb8b c5                 .PET 'E'  ; 26    E
eb8c d1                 .PET 'Q'  ; 27    Q

eb8d 5c                 .PET $5c  ; 28    Backslash
eb8e d0                 .PET 'P'  ; 29    P
eb8f c9                 .PET 'I'  ; 2a    I
eb90 2a                 .PET '*'  ; 2b    *
eb91 da                 .PET 'Z'  ; 2c    Z
eb92 d2                 .PET 'R'  ; 2d    R
eb93 d7                 .PET 'W'  ; 2e    W
eb94 89                 .PET $89  ; 2f    Shift TAB

eb95 a7                 .PET $a7  ; 30    Graph a7   KP 6
eb96 f1                 .PET $f1  ; 31    A umlaut
eb97 cc                 .PET 'L'  ; 32    L
eb98 8d                 .PET $8d  ; 33    SHIFT RETURN
eb99 ca                 .PET 'J'  ; 34    J
eb9a c7                 .PET 'G'  ; 35    G
eb9b c4                 .PET 'D'  ; 36    D
eb9c c1                 .PET 'A'  ; 37    A

eb9d a6                 .PET $a6  ; 38    Graph a6   KP 5
eb9e f2                 .PET $f2  ; 39    O umlaut
eb9f cb                 .PET 'K'  ; 3a    K
eba0 27                 .PET $27  ; 3b    '
eba1 c8                 .PET 'H'  ; 3c    H
eba2 c6                 .PET 'F'  ; 3d    F
eba3 d3                 .PET 'S'  ; 3e    S
eba4 1b                 .PET $1b  ; 3f    ESC

eba5 aa                 .PET $aa  ; 40    Graph aa   KP 9
eba6 00                 .PET $00  ; 41
0000 TRUE     #if BSOS_KBD
eba7 93                 .PET $93  ; 42    CLR
              #else
SKIP                    .PET $91  ; 42    CURSOR UP
              #endif
eba8 a8                 .PET $a8  ; 43    Graph a8   KP 7
eba9 3d                 .PET '='  ; 44    =
ebaa 2f                 .PET '/'  ; 45    /
ebab 24                 .PET '$'  ; 46    $
ebac 21                 .PET '!'  ; 47    !

ebad 00                 .PET $00  ; 48
ebae 8e                 .PET $8e  ; 49    Shift Ctrl N
0000 TRUE     #if BSOS_KBD
ebaf 83                 .PET $83  ; 4a    RUN
              #else
SKIP                    .PET $9d  ; 4a    CURSOR LEFT
              #endif
ebb0 a9                 .PET $a9  ; 4b    Graph a9   KP 8
ebb1 c0                 .PET $c0  ; 4c    GRAVE
ebb2 28                 .PET '('  ; 4d    (
ebb3 25                 .PET '%'  ; 4e    %
ebb4 22                 .PET '"'  ; 4f    "

ebb5 00                 .PET 0

              ; ****************
ebb6            KEYBOARD_CONTROL
              ; ****************

ebb6 00                 .BYTE $00           ;                                  10h  -------
ebb7 00                 .BYTE $00           ; SHIFT                            10g  LEFT SHIFT
ebb8 00                 .BYTE $00           ; ?                                10f  SZ ?
ebb9 00                 .BYTE $00           ; INS                              10e  DEL INST
ebba dd                 .BYTE $dd           ; }                                10d  9 )
ebbb 00                 .BYTE $00           ; &                                10c  6 &
ebbc 00                 .BYTE $00           ; `                                10b  3 Paragraph
ebbd 00                 .BYTE $00           ; >                                10a  < >

ebbe 00                 .BYTE $00           ; Graph a2                         9h  KP 1
ebbf 00                 .BYTE $00           ; UNDERLINE                        9g  - _
ebc0 00                 .BYTE $00           ; Shift Ctrl U                     9f  -------
ebc1 00                 .BYTE $00           ; LEFT                             9e  CURSOR <->
ebc2 00                 .BYTE $00           ; M                                9d  M
ebc3 00                 .BYTE $00           ; SHIFT SPC                        9c  SPACE
ebc4 18                 .BYTE $18           ; X                                9b  X
ebc5 00                 .BYTE $00           ; Control                          9a  CTRL (by index)

ebc6 00                 .BYTE $00           ; Graph a3                         8h  KP 2
ebc7 00                 .BYTE $00           ; 8g  CURSOR V^
ebc8 00                 .BYTE $00           ; Shift Ctrl O                     8f  -------
ebc9 00                 .BYTE $00           ; Graph a1                         8e  KP 0
ebca 00                 .BYTE $00           ; ;                                8d  ,
ebcb 0e                 .BYTE $0e           ; N                                8c  N
ebcc 16                 .BYTE $16           ; V                                8b  V
ebcd 19                 .BYTE $19           ; Y                                8a  Y

ebce 00                 .BYTE $00           ; Graph a4                         7h  KP 3
ebcf 00                 .BYTE $00           ; SHIFT                            7g  RIGHT SHIFT
ebd0 00                 .BYTE $00           ; Shift Ctrl Y                     7f  -------
ebd1 de                 .BYTE $de           ; ~                                7e  KP . Pi
ebd2 00                 .BYTE $00           ; :                                7d  . :
ebd3 02                 .BYTE $02           ; B                                7c  B
ebd4 03                 .BYTE $03           ; C                                7b  C
ebd5 00                 .BYTE $00           ; SHIFT                            7a  LEFT SHIFT

ebd6 00                 .BYTE $00           ; Graph a5                         6h  KP 4
ebd7 00                 .BYTE $00           ;                                  6g  UE
ebd8 0f                 .BYTE $0f           ; O                                6f  O
ebd9 00                 .BYTE $00           ; ARROW UP                         6e  Arrow up
ebda 15                 .BYTE $15           ; U                                6d  U
ebdb 14                 .BYTE $14           ; T                                6c  T
ebdc 05                 .BYTE $05           ; E                                6b  E
ebdd 11                 .BYTE $11           ; Q                                6a  Q

ebde 00                 .BYTE $00           ; 5h  ] Backslash
ebdf 10                 .BYTE $10           ; P                                5g  P
ebe0 09                 .BYTE $09           ; I                                5f  I
ebe1 00                 .BYTE $00           ; *                                5e  + *
ebe2 1a                 .BYTE $1a           ; Z                                5d  Z
ebe3 12                 .BYTE $12           ; R                                5c  R
ebe4 17                 .BYTE $17           ; W                                5b  W
ebe5 00                 .BYTE $00           ; SET TAB                          5a  TAB

ebe6 00                 .BYTE $00           ; Graph a7                         4h  KP 6
ebe7 00                 .BYTE $00           ;                                  4g  AE
ebe8 0c                 .BYTE $0c           ; L                                4f  L
ebe9 00                 .BYTE $00           ; SHIFT RET                        4e  RETURN
ebea 0a                 .BYTE $0a           ; J                                4d  J
ebeb 07                 .BYTE $07           ; G                                4c  G
ebec 04                 .BYTE $04           ; D                                4b  D
ebed 01                 .BYTE $01           ; A                                4a  A

ebee 00                 .BYTE $00           ; Graph a6                         3h  KP 5
ebef 00                 .BYTE $00           ;                                  3g  OE
ebf0 0b                 .BYTE $0b           ; K                                3f  K
ebf1 00                 .BYTE $00           ; '                                3e  # '
ebf2 08                 .BYTE $08           ; H                                3d  H
ebf3 06                 .BYTE $06           ; F                                3c  F
ebf4 13                 .BYTE $13           ; S                                3b  S
ebf5 1b                 .BYTE $1b           ; ESC                              3a  ESC

ebf6 00                 .BYTE $00           ; Graph aa                         2h  KP 9
ebf7 00                 .BYTE $00           ; SHIFT                            2g  -------
ebf8 00                 .BYTE $00           ; CLR                              2f  HOME CLR
ebf9 00                 .BYTE $00           ; Graph a8                         2e  KP 7
ebfa 00                 .BYTE $00           ; =                                2d  0 =
ebfb dc                 .BYTE $dc           ; |                                2c  7 /
ebfc 00                 .BYTE $00           ; $                                2b  4 $
ebfd 00                 .BYTE $00           ; !                                2a  1 !

ebfe 00                 .BYTE $00           ; SHIFT                            1h  -------
ebff 00                 .BYTE $00           ; Shift Ctrl N                     1g  -------
ec00 00                 .BYTE $00           ; 1f  [ \
ec01 00                 .BYTE $00           ; Graph a9                         1e  KP 8
ec02 00                 .BYTE $00           ;                                  1d  ACUTE GRAVE
ec03 db                 .BYTE $db           ; {                                1c  8 (
ec04 00                 .BYTE $00           ; %                                1b  5 %
ec05 00                 .BYTE $00           ; "                                1a  2 "
ec06 00                 .BYTE $00           ; SHIFT

              ; **********
ec07            Find_Entry
              ; **********

ec07 86 11              STX LINNUM          ; save old #
ec09 85 12              STA LINNUM+1

              ; ***********
ec0b            Find_LINNUM
              ; ***********

ec0b 98                 TYA
ec0c 48                 PHA
ec0d a0 00              LDY #0
ec0f 84 fb              STY STAL            ; STAL = $8000
ec11 a9 80              LDA #$80
ec13 85 fc              STA STAL+1
ec15 85 b6              STA R_Bank
ec17 a0 03    FiEn_10   LDY #3              ; old line high
ec19 20 7a 02           JSR Bank_Fetch
ec1c c9 ff              CMP #$ff            ; EOT
ec1e f0 18              BEQ FiEn_20
ec20 c5 12              CMP LINNUM+1
ec22 d0 17              BNE FiEn_30
ec24 88                 DEY                 ; old line low
ec25 20 7a 02           JSR Bank_Fetch
ec28 c5 11              CMP LINNUM
ec2a d0 0f              BNE FiEn_30
ec2c 88                 DEY                 ; new line high
ec2d 20 7a 02           JSR Bank_Fetch
ec30 85 12              STA LINNUM+1
ec32 88                 DEY                 ; new line low
ec33 20 7a 02           JSR Bank_Fetch
ec36 85 11              STA LINNUM
ec38 68       FiEn_20   PLA
ec39 a8                 TAY
ec3a 60                 RTS ;Size   48 [Find_LINNUM]
ec3b a9 04    FiEn_30   LDA #4
ec3d 20 15 fb           JSR Add_STAL
ec40 d0 d5              BNE FiEn_10
ec42 60                 RTS ;Size   56 [Find_LINNUM]

              ; *******************
ec43            Install_Bank_Access
              ; *******************

ec43 a2 00              LDX #0
ec45 bd 51 ec FSC_10    LDA Bank_Fetch_Start,X
ec48 9d 7a 02           STA Bank_Fetch,X
ec4b e8                 INX
ec4c e0 24              CPX #[Bank_Store_End - Bank_Fetch_Start]
ec4e 90 f5              BCC FSC_10
ec50 60                 RTS ;Size   14 [Install_Bank_Access]

              ; ****************
ec51            Bank_Fetch_Start
              ; ****************

ec51 a5 b6              LDA R_Bank
ec53 78                 SEI
ec54 8d f0 ff           STA $FFF0
ec57 b1 fb              LDA (STAL),Y
ec59 48                 PHA
ec5a a5 9a              LDA Default_Bank
ec5c 8d f0 ff           STA $FFF0
ec5f 58                 CLI
ec60 68                 PLA
ec61 60                 RTS ;Size   17 [Bank_Fetch_Start]

              ; **************
ec62            Bank_Fetch_End
              ; **************

              ; ****************
ec62            Bank_Store_Start
              ; ****************

ec62 48                 PHA
ec63 a5 b7              LDA W_Bank
ec65 78                 SEI
ec66 8d f0 ff           STA $FFF0
ec69 68                 PLA
ec6a 91 f9              STA (BPTR),Y
ec6c 48                 PHA
ec6d a5 9a              LDA Default_Bank
ec6f 8d f0 ff           STA $FFF0
ec72 58                 CLI
ec73 68                 PLA
ec74 60                 RTS ;Size   19 [Bank_Store_Start]

              ; **************
ec75            Bank_Store_End
              ; **************


              ; ********
ec75            Get_Next
              ; ********

ec75 e6 77              INC TXTPTR
ec77 d0 02              BNE GeNe_10
ec79 e6 78              INC TXTPTR+1
ec7b a1 77    GeNe_10   LDA (TXTPTR,X)      ; X = 0
ec7d 60                 RTS ;Size    9 [Bank_Store_End]

              ; *********
ec7e            Xfer_Line
              ; *********

              ; copy BASIC line and adjust targets for

              ; GOTO
              ; GOSUB
              ; THEN
              ; GO TO
              ; RUN

              ; Set TXTPTR to start of BASIC line

ec7e 18                 CLC
ec7f a5 5c              LDA TMPPTC
ec81 69 03              ADC #3
ec83 85 77              STA TXTPTR
ec85 a5 5d              LDA TMPPTC+1
ec87 69 00              ADC #0
ec89 85 78              STA TXTPTR+1
ec8b a2 00              LDX #0              ; source index
ec8d a0 03              LDY #3              ; destination index
ec8f c8       XfLi_10   INY
ec90 20 75 ec           JSR Get_Next        ; next byte
ec93 20 8b 02           JSR Bank_Store      ; store
ec96 f0 4d              BEQ XfLi_Ret        ; finished
ec98 c9 22              CMP #QUOTE
ec9a d0 0f              BNE XfLi_30
ec9c c8       XfLi_20   INY
ec9d 20 75 ec           JSR Get_Next        ; inside string
eca0 20 8b 02           JSR Bank_Store      ; store
eca3 f0 40              BEQ XfLi_Ret        ; finished
eca5 c9 22              CMP #QUOTE
eca7 d0 f3              BNE XfLi_20         ; continue string copy
eca9 f0 e4              BEQ XfLi_10         ; reenter normal loop
ecab c9 8f    XfLi_30   CMP #$8f            ; REM token
ecad d0 0a              BNE XfLi_50
ecaf c8       XfLi_40   INY
ecb0 20 75 ec           JSR Get_Next        ; after REM
ecb3 20 8b 02           JSR Bank_Store      ; store
ecb6 d0 f7              BNE XfLi_40
ecb8 60                 RTS ;Size   59 [Xfer_Line]
ecb9 c9 89    XfLi_50   CMP #$89            ; GOTO token
ecbb 90 d2              BCC XfLi_10         ; no further action
ecbd f0 1f              BEQ XfLi_70
ecbf c9 8a              CMP #$8a            ; RUN token
ecc1 f0 1b              BEQ XfLi_70
ecc3 c9 8d              CMP #$8d            ; GOSUB token
ecc5 f0 17              BEQ XfLi_70
ecc7 c9 a7              CMP #$a7            ; THEN token
ecc9 f0 13              BEQ XfLi_70
eccb c9 cb              CMP #$cb            ; GO token
eccd d0 0b              BNE XfLi_60
eccf c8       XfLi_55   INY
ecd0 20 75 ec           JSR Get_Next
ecd3 20 8b 02           JSR Bank_Store
ecd6 c9 20              CMP #' '            ; skip blanks after GO
ecd8 f0 f5              BEQ XfLi_55
ecda c9 a4    XfLi_60   CMP #$a4            ; TO token
ecdc d0 b1              BNE XfLi_10         ; continue
ecde 20 e6 ec XfLi_70   JSR Exchange_Number
ece1 c9 00              CMP #0
ece3 d0 d4              BNE XfLi_50         ; continue if not EOL
ece5 60       XfLi_Ret  RTS ;Size  104 [Xfer_Line]


              ; ***************
ece6            Exchange_Number
              ; ***************

ece6 c8                 INY                 ; char after token
ece7 20 70 00           JSR CHRGET
ecea b0 29              BCS ExNu_20         ; no number e.g. after THEN
ecec 20 f6 b8           JSR Scan_Linenumber
ecef 20 0b ec           JSR Find_LINNUM
ecf2 98                 TYA
ecf3 48                 PHA
ecf4 a5 11              LDA LINNUM
ecf6 85 60              STA FAC1M2
ecf8 a5 12              LDA LINNUM+1
ecfa 85 5f              STA FAC1M1
ecfc a2 90              LDX #$90
ecfe 38                 SEC
ecff 20 7f cd           JSR Convert_Integer_To_Real
ed02 20 93 cf           JSR Format_FAC1
ed05 68                 PLA
ed06 a8                 TAY
ed07 a2 01              LDX #1
ed09 bd 00 01 ExNu_10   LDA STACK,X
ed0c f0 07              BEQ ExNu_20
ed0e 20 8b 02           JSR Bank_Store
ed11 c8                 INY
ed12 e8                 INX
ed13 d0 f4              BNE ExNu_10
ed15 a2 00    ExNu_20   LDX#0
ed17 20 76 00           JSR CHRGOT          ; char after target
ed1a 20 8b 02           JSR Bank_Store
ed1d c9 2c              CMP #','            ; on .. goto or on .. gosub ?
ed1f f0 c5              BEQ Exchange_Number
ed21 60       ExNu_Ret  RTS ;Size   60 [Exchange_Number]

              ; **********************
ed22            Reset_Renumber_Pointer
              ; **********************

              ; read basic program with pointer TMPPTC

ed22 a5 28              LDA TXTTAB
ed24 85 5c              STA TMPPTC
ed26 a5 29              LDA TXTTAB+1
ed28 85 5d              STA TMPPTC+1

              ; **********
ed2a            Reset_BPTR
              ; **********

ed2a a9 00              LDA #0
ed2c 85 f9              STA BPTR
ed2e a9 80              LDA #$80
ed30 85 fa              STA BPTR+1
ed32 60                 RTS ;Size    9 [Reset_BPTR]

              ; ***********
ed33            Update_Link
              ; ***********

ed33 a0 00              LDY #0
ed35 b1 5c              LDA (TMPPTC),Y      ; link low
ed37 aa                 TAX
ed38 c8                 INY                 ; Y = 1
ed39 b1 5c              LDA (TMPPTC),Y      ; link high
ed3b 86 5c              STX TMPPTC
ed3d 85 5d              STA TMPPTC+1        ; Z flag set if link high is zero
ed3f 60                 RTS ;Size   13 [Update_Link]


              ; ****************
ed40            Extended_Command
              ; ****************

ed40 a0 00              LDY #0
ed42 84 05              STY COUNT           ; count command #
ed44 88       ExCo_10   DEY
ed45 a6 77              LDX TXTPTR
ed47 ca                 DEX
ed48 e8       ExCo_20   INX
ed49 c8                 INY
ed4a bd 00 02           LDA BUF,X
ed4d 38                 SEC
ed4e f9 3a bf           SBC Extended_Keyword_Table,Y
ed51 f0 f5              BEQ ExCo_20         ; character match
ed53 c9 80              CMP #$80            ; match with difference $80 -> OK
ed55 d0 13              BNE ExCo_30         ; not this keyword
ed57 68                 PLA                 ; remove CALL
ed58 68                 PLA
ed59 86 77              STX TXTPTR
ed5b a5 05              LDA COUNT           ; command #
ed5d 0a                 ASL A
ed5e a8                 TAY
ed5f b9 2d bf           LDA Extended_Statement_Table+1,Y
ed62 48                 PHA
ed63 b9 2c bf           LDA Extended_Statement_Table,Y
ed66 48                 PHA
ed67 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
ed6a e6 05    ExCo_30   INC COUNT           ; try next keyword
ed6c c8       ExCo_40   INY
ed6d b9 39 bf           LDA Extended_Keyword_Table-1,Y
ed70 10 fa              BPL ExCo_40
ed72 b9 2c bf           LDA Extended_Statement_Table,Y
ed75 d0 cd              BNE ExCo_10         ; next keyword if not end of table
ed77 60                 RTS                 ; finished scan ;Size   56 [Extended_Command]


              ; *********
ed78            Find_Text
              ; *********

ed78 20 fb b4           JSR Tokenize_Line
ed7b 20 70 00           JSR CHRGET
ed7e 85 23              STA RENNEW          ; delimiter
ed80 20 22 ed           JSR Reset_Renumber_Pointer
ed83 a0 03    FiTe_10   LDY #3
ed85 84 24              STY RENNEW+1
ed87 20 9a ed           JSR Contains_Pattern
ed8a d0 06              BNE FiTe_20
ed8c 20 ce ea           JSR List_BASIC_Line
ed8f 20 21 d5           JSR Mon_Print_CR
ed92 20 33 ed FiTe_20   JSR Update_Link
ed95 d0 ec              BNE FiTe_10
ed97 4c ff b3           JMP Basic_Ready

              ; ****************
ed9a            Contains_Pattern
              ; ****************

ed9a a6 77    CoPa_10   LDX TXTPTR          ; text to find - 1
ed9c a4 24              LDY RENNEW+1
ed9e c8       CoPa_20   INY
ed9f e8                 INX
eda0 bd 00 02           LDA BUF,X           ; next pattern
eda3 f0 10              BEQ CoPa_Ret        ; match
eda5 c5 23              CMP RENNEW          ; delimiter
eda7 f0 0c              BEQ CoPa_Ret        ; match
eda9 d1 5c              CMP (TMPPTC),Y      ; next program byte
edab f0 f1              BEQ CoPa_20         ; continue compare
edad e6 24              INC RENNEW+1        ; advance search pos
edaf b1 5c              LDA (TMPPTC),Y
edb1 d0 e7              BNE CoPa_10
edb3 a9 01              LDA #1
edb5 60       CoPa_Ret  RTS ;Size   28 [Contains_Pattern]

              ; **************
edb6            Load_Directory
              ; **************

edb6 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
edb9 a4 2f              LDY STREND+1        ; load directory into free RAM
edbb c8                 INY
edbc 84 ca              STY EAL+1
edbe a0 00              LDY #0
edc0 84 c9              STY EAL
edc2 84 96              STY STATUS
edc4 a0 02              LDY #2              ; header start
edc6 a6 ca    LoDi_10   LDX EAL+1           ; next page
edc8 e8                 INX
edc9 e4 31              CPX FRETOP+1        ; end of free RAM
edcb 90 03              BCC LoDi_20         ; branch if OK
edcd 4c cd b3           JMP Error_Out_Of_Memory
edd0 86 ca    LoDi_20   STX EAL+1
edd2 20 c0 f1 LoDi_30   JSR ACPTR           ; read next byte
edd5 91 c9              STA (EAL),Y
edd7 a5 96              LDA STATUS
edd9 d0 05              BNE LoDi_40         ; branch on EOI
eddb c8                 INY
eddc d0 f4              BNE LoDi_30         ; loop
edde f0 e6              BEQ LoDi_10         ; increment page
ede0 4c c1 f3 LoDi_40   JMP LoFi_70         ; Untalk & Close

              ; *****************
ede3            DOS_Get_Dir_Entry
              ; *****************

              ; Read directory entry from loaded $ file
              ; and store results in FNLEN and DOS_FC
              ; Store filename address in FNADR
              ; X = 0 flags no entry found on exit

ede3 18                 CLC                 ; advance to next entry
ede4 a5 bb              LDA DosPtr          ; start address
ede6 69 20              ADC #32
ede8 85 bb              STA DosPtr
edea 90 02              BCC DGDE_05
edec e6 bc              INC DosPtr+1

edee a0 03    DGDE_05   LDY #3              ; scan after size word

edf0 c8       DGDE_10   INY
edf1 b1 bb              LDA (DosPtr),Y
edf3 c9 22              CMP #QUOTE
edf5 90 f9              BCC DGDE_10         ; skip blanks before filename
edf7 d0 3a              BNE DGDE_80         ; no quote -> blocks free
edf9 88                 DEY                 ; byte for drive
edfa 88                 DEY                 ; byte for 'S' command
edfb 98                 TYA
edfc 05 bb              ORA DosPtr          ; set FNADR
edfe 85 da              STA FNADR
ee00 a5 bc              LDA DosPtr+1
ee02 85 db              STA FNADR+1
ee04 a0 00              LDY #0              ; prepare scratch command
ee06 a9 53              LDA #'S'
ee08 91 da              STA (FNADR),Y
ee0a c8                 INY
ee0b ad 3c 03           LDA DOS_Drive_2     ; target drive
ee0e 09 30              ORA #'0'
ee10 91 da              STA (FNADR),Y
ee12 c8                 INY
ee13 a9 3a              LDA #':'
ee15 91 da              STA (FNADR),Y       ; overwrite opening quote

ee17 c8       DGDE_20   INY
ee18 b1 da              LDA (FNADR),Y
ee1a c9 22              CMP #QUOTE          ; closing quote
ee1c f0 04              BEQ DGDE_40
ee1e c0 13              CPY #19             ; max length + "S0:"
ee20 90 f5              BCC DGDE_20

ee22 84 d1    DGDE_40   STY FNLEN           ; length of filename

ee24 c8       DGDE_60   INY
ee25 b1 da              LDA (FNADR),Y
ee27 c9 20              CMP #' '            ; skip blanks
ee29 f0 f9              BEQ DGDE_60
ee2b c9 2a              CMP #'*'            ; splat file ?
ee2d f0 b4              BEQ DOS_Get_Dir_Entry
ee2f 85 b1              STA DOS_FC          ; PRG, SEQ, USR, REL
ee31 a0 00              LDY #0              ; flag success

ee33 60       DGDE_80   RTS                 ; Y != 0 for no file ;Size   81 [DOS_Get_Dir_Entry]

              ; *************
ee34            DOS_Add_Comma
              ; *************

ee34 a9 2c              LDA #','
ee36 91 da              STA (FNADR),Y
ee38 c8                 INY
ee39 60                 RTS ;Size    6 [DOS_Add_Comma]

              ; DOS_Copy is an enhancement of the BASIC 4 COPY command.
              ; It is called from the original COPY if Source Unit and
              ; Target unit differ
              ; DOS_Copy uses the free RAM between variable storage and
              ; string storage (STREND - FRETOP)
              ; First a call to the Garbage_Collection maximises the
              ; free RAM area. The first 256 byte block after STREND is
              ; used as a transfer buffer. The area STREND + 256 is used
              ; to store the directory of the source unit. If the
              ; remaining space is not sufficient to load the directory
              ; an OOM (Out Of Memory) error occurs.

              ; ********
ee3a            DOS_Copy
              ; ********

ee3a 20 6a c6           JSR Garbage_Collection
ee3d a5 d4              LDA FA              ; target unit
ee3f 85 ad              STA Target_Unit     ; save it
ee41 a5 9c              LDA Source_Unit
ee43 85 d4              STA FA
ee45 a9 24              LDA #'$'            ; directory command
ee47 8d 53 03           STA DOS_Command_Buffer
ee4a a9 03              LDA #3              ; 3 parameter
ee4c a2 01              LDX #1              ; write after $
ee4e a0 02              LDY #2              ; build d1:f1
ee50 20 fc db           JSR Build_DOS_Command_X
ee53 20 b6 ed           JSR Load_Directory
ee56 a9 00              LDA #0              ; start of directory
ee58 85 bb              STA DosPtr
ee5a a6 2f              LDX STREND+1
ee5c e8                 INX
ee5d e8                 INX
ee5e 86 bc              STX DosPtr+1

ee60 20 e3 ed DOSC_10   JSR DOS_Get_Dir_Entry
ee63 98                 TYA                 ; 0: success
ee64 f0 01              BEQ DOSC_15
ee66 60                 RTS ;Size   45 [DOS_Copy]

ee67 84 b9    DOSC_15   STY DOS_RL          ; record length
ee69 84 11              STY LINNUM          ; initialize record #
ee6b 84 12              STY LINNUM+1
ee6d c8                 INY
ee6e 8c 3a 03           STY DOS_Tmp         ; pos in record# = 1
ee71 a4 d1              LDY FNLEN
ee73 20 34 ee           JSR DOS_Add_Comma
ee76 a5 b1              LDA DOS_FC          ; Filetype
ee78 c9 52              CMP #'R'            ; REL file ?
ee7a d0 0e              BNE DOSC_20
ee7c a9 4c              LDA #'L'            ; REL type
ee7e 91 da              STA (FNADR),Y
ee80 c8                 INY
ee81 20 34 ee           JSR DOS_Add_Comma   ; "St:FILENAME,L,CHR$(RL)"
ee84 a9 fe              LDA #254            ; max record length
ee86 85 b9              STA DOS_RL
ee88 d0 08              BNE DOSC_25         ; branch always

ee8a 91 da    DOSC_20   STA (FNADR),Y       ; "St:FILENAME,S"
ee8c c8                 INY
ee8d 20 34 ee           JSR DOS_Add_Comma
ee90 a9 57              LDA #'W'

ee92 91 da    DOSC_25   STA (FNADR),Y       ; "St:FILENAME,S,W"

              ; Scratch target file (avoid @ syntax)

ee94 a5 ad              LDA Target_Unit
ee96 85 d4              STA FA
ee98 20 9b da           JSR PDC_10          ; send DOS command

              ; Remove 'S' from Scratch command

ee9b e6 da              INC FNADR           ; always inside page

              ; Add ",S" ",P" ",U" or ",L,CHR$(RL)"

ee9d e6 d1              INC FNLEN           ; "t:FILENAME,S"
ee9f a5 b9              LDA DOS_RL          ; REL file ?
eea1 f0 04              BEQ DOSC_35         ; branch if not
eea3 e6 d1              INC FNLEN           ; "t:FILENAME,L,"
eea5 e6 d1              INC FNLEN           ; "t:FILENAME,L,(RL)"

              ; print filename

eea7 20 5d ef DOSC_35   JSR Print_Filename
eeaa 20 87 ef           JSR Open_Read_File

              ; Open write file

eead a5 b9    DOSC_47   LDA DOS_RL
eeaf d0 04              BNE DOSC_50
eeb1 e6 d1              INC FNLEN           ; "s:FILENAME,S,W"
eeb3 e6 d1              INC FNLEN

eeb5 20 a4 ef DOSC_50   JSR Open_Write_File

              ; Copy file

eeb8 a5 9c    DOSC_55   LDA Source_Unit
eeba 85 d4              STA FA
eebc 20 d2 f0           JSR TALK
eebf a9 6d              LDA #$6d
eec1 85 d3              STA SA
eec3 20 93 f1           JSR TKSA
eec6 a0 00              LDY #0
eec8 84 96              STY STATUS

eeca 20 c0 f1 DOSC_60   JSR ACPTR
eecd 91 2e              STA (STREND),Y
eecf c8                 INY
eed0 a5 96              LDA STATUS
eed2 85 b2              STA DOS_EOF
eed4 d0 04              BNE DOSC_65
eed6 c4 b9              CPY DOS_RL          ; copy max DOS_RL bytes
eed8 d0 f0              BNE DOSC_60         ; DOS_RL=0 -> copy 256 bytes

eeda 84 b1    DOSC_65   STY DOS_FC          ; Byte count
eedc 20 ae f1           JSR UNTLK
eedf a5 b9              LDA DOS_RL
eee1 f0 07              BEQ DOSC_66
eee3 20 91 d9           JSR Kernal_Read_DS
eee6 c9 30              CMP #'0'
eee8 d0 41              BNE DOSC_75

eeea a5 ad    DOSC_66   LDA Target_Unit
eeec 85 d4              STA FA
eeee a9 6e              LDA #$6e
eef0 85 d3              STA SA
eef2 a0 00              LDY #0
eef4 84 96              STY STATUS
eef6 a5 b9              LDA DOS_RL
eef8 f0 03              BEQ DOSC_67
eefa 20 4c ef           JSR Send_Record_No

eefd 20 d5 f0 DOSC_67   JSR LISTEN
ef00 a9 6e              LDA #$6e
ef02 85 d3              STA SA
ef04 20 43 f1           JSR SECOND

ef07 b1 2e    DOSC_70   LDA (STREND),Y
ef09 20 9e f1           JSR CIOUT
ef0c a5 96              LDA STATUS
ef0e d0 1b              BNE DOSC_75
ef10 c8                 INY
ef11 c4 b1              CPY DOS_FC
ef13 d0 f2              BNE DOSC_70
ef15 20 b9 f1           JSR UNLSN
ef18 a5 b2              LDA DOS_EOF
ef1a f0 9c              BEQ DOSC_55
ef1c a5 b9              LDA DOS_RL
ef1e f0 0b              BEQ DOSC_75
ef20 20 91 d9           JSR Kernal_Read_DS
ef23 c9 30              CMP #'0'
ef25 f0 91              BEQ DOSC_55
ef27 c9 35              CMP #'5'            ; ignore record not present
ef29 f0 8d              BEQ DOSC_55

ef2b 20 b9 f1 DOSC_75   JSR UNLSN
ef2e a5 ad              LDA Target_Unit
ef30 85 d4              STA FA
ef32 a9 6e              LDA #$6e
ef34 85 d3              STA SA
ef36 20 2a f7           JSR Close_Disk_File ; close write file
ef39 a9 0d              LDA #CR
ef3b 20 d2 ff           JSR CHROUT
ef3e a5 9c              LDA Source_Unit
ef40 85 d4              STA FA
ef42 a9 6d              LDA #$6d
ef44 85 d3              STA SA
ef46 20 2a f7           JSR Close_Disk_File ; close read file
ef49 4c 60 ee           JMP DOSC_10         ; next file

              ; **************
ef4c            Send_Record_No
              ; **************

ef4c e6 11              INC LINNUM
ef4e d0 02              BNE SRN_10
ef50 e6 12              INC LINNUM+1
ef52 20 43 da SRN_10    JSR DOS_Record_No
ef55 20 91 d9           JSR Kernal_Read_DS
ef58 a0 00              LDY #0
ef5a 84 96              STY STATUS
ef5c 60                 RTS ;Size   17 [Send_Record_No]

              ; **************
ef5d            Print_Filename
              ; **************

ef5d 20 51 f3           JSR In_Direct_Mode
ef60 d0 24              BNE PrFi_90
ef62 a0 00              LDY #0
ef64 b1 da    PrFi_10   LDA (FNADR),Y
ef66 c8                 INY
ef67 20 d2 ff           JSR CHROUT
ef6a c9 4c              CMP #'L'
ef6c d0 14              BNE PrFi_20
ef6e b1 da              LDA (FNADR),Y
ef70 c9 2c              CMP#','
ef72 d0 0e              BNE PrFi_20
ef74 20 d2 ff           JSR CHROUT
ef77 a9 24              LDA #'$'
ef79 20 d2 ff           JSR CHROUT
ef7c c8                 INY
ef7d b1 da              LDA (FNADR),Y
ef7f 4c 57 d7           JMP Print_Hex_Byte
ef82 c4 d1    PrFi_20   CPY FNLEN
ef84 90 de              BCC PrFi_10
ef86 60       PrFi_90   RTS ;Size   42 [Print_Filename]

              ; **************
ef87            Open_Read_File
              ; **************

ef87 a5 9c              LDA Source_Unit
ef89 85 d4              STA FA
ef8b a9 6d              LDA #$6d            ; channel 13
ef8d 85 d3              STA SA
ef8f a0 00              LDY #0
ef91 84 96              STY STATUS          ; clear status
ef93 ad 3b 03           LDA DOS_Drive_1     ; source drive
ef96 09 30              ORA #'0'
ef98 91 da              STA (FNADR),Y       ; into filename
ef9a a5 b9              LDA DOS_RL          ; REL file ?
ef9c f0 03              BEQ ORF_10          ; branch if not
ef9e 4c c8 e4           JMP Get_Record_Size
efa1 4c af f4 ORF_10    JMP Send_Filename

              ; ***************
efa4            Open_Write_File
              ; ***************

efa4 a5 ad              LDA Target_Unit
efa6 85 d4              STA FA
efa8 a9 6e              LDA #$6e
efaa 85 d3              STA SA
efac a0 00              LDY #0
efae 84 96              STY STATUS
efb0 ad 3c 03           LDA DOS_Drive_2
efb3 09 30              ORA #'0'
efb5 91 da              STA (FNADR),Y
efb7 4c af f4           JMP Send_Filename


efba 00 00 00           .FILL $f000 - * (0) ; 70 bytes

              ; ***************
f000            KERNAL_MESSAGES
              ; ***************

f000 54 4f 4f MSG_TOO_MANY    .BYTE "TOO MANY FILES"^
f00e 46 49 4c MSG_FILE_OPEN   .BYTE "FILE OPEN"^
f017 46 49 4c MSG_FILE_NOT_O  .BYTE "FILE NOT OPEN"^
f024 46 49 4c MSG_FILE_NOT_F  .BYTE "FILE NOT FOUND"^
f032 0d 53 45 MSG_SEARCHING   .BYTE "\rSEARCHING "^
f03d 46 4f 52 MSG_FOR         .BYTE "FOR "^
f041 0d 50 52 MSG_PRESS       .BYTE "\rPRESS PLAY "^
f04d 26 20 52 MSG_RECORD      .BYTE "& RECORD "^
f056 4f 4e 20 MSG_ON_TAPE     .BYTE "ON TAPE #"^
f05f 0d 4c 4f MSG_LOAD        .BYTE "\rLOAD"^
f064 0d 57 52 MSG_WRITING     .BYTE "\rWRITING "^
f06d 0d 56 45 MSG_VERIFY      .BYTE "\rVERIFY"^
f074 44 45 56 MSG_DEVICE_NOT  .BYTE "DEVICE NOT PRESENT"^
f086 4e 4f 54 MSG_NOT_INPUT   .BYTE "NOT INPUT FILE"^
f094 4e 4f 54 MSG_NOT_OUTPUT  .BYTE "NOT OUTPUT FILE"^
f0a3 0d 46 4f MSG_FOUND       .BYTE "\rFOUND "^
f0aa 0d 4f 4b MSG_OK          .BYTE "\rOK\r"^
f0ae 0d 52 45 MSG_READY       .BYTE "\rREADY.\r"^
f0b6 0d 41 52 MSG_SURE        .BYTE "\rARE YOU SURE ?"^
f0c5 0d 3f 20 MSG_BAD_DISK    .BYTE "\r? BAD DISK \r"^

              ; ****
f0d2            TALK
              ; ****

f0d2 a9 40              LDA #%01000000      ; TALK cmd: $40..$5e
f0d4 2c                 .BYTE $2c           ; skip next statement

              ; ******
f0d5            LISTEN
              ; ******

f0d5 a9 20              LDA #%00100000      ; LISTEN cmd: $20..$3e

              ; *******
f0d7            TALI_10
              ; *******

f0d7 48                 PHA                 ; save talk or listen bit
f0d8 ad 40 e8           LDA VIA_Port_B
f0db 09 02              ORA #%00000010      ; $02
f0dd 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f0e0 a9 3c              LDA #%00111100      ; $3c
f0e2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f0e5 24 a0              BIT C3PO            ; data in output buffer ?
f0e7 f0 11              BEQ TALI_20         ; branch if not
f0e9 a9 34              LDA #%00110100      ; $34
f0eb 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) low
f0ee 20 09 f1           JSR Send_IEEE_Byte  ; flush buffer (BSOUR)
f0f1 a9 00              LDA #0
f0f3 85 a0              STA C3PO            ; clear buffer flag
f0f5 a9 3c              LDA #%00111100      ; $3c
f0f7 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) high
f0fa 68       TALI_20   PLA                 ; restore talk or listen bit
f0fb 05 d4              ORA FA              ; combine signal with adress
f0fd 85 a5              STA BSOUR           ; store in output buffer
f0ff ad 40 e8 TALI_30   LDA VIA_Port_B      ; load signals
f102 10 fb              BPL TALI_30         ; wait until DAV high
f104 29 fb              AND #%11111011      ; $fb
f106 8d 40 e8           STA VIA_Port_B      ; set ATN (bit 2) low

              ; **************
f109            Send_IEEE_Byte
              ; **************

f109 a9 3c              LDA #%00111100      ; $3c
f10b 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f10e ad 40 e8           LDA VIA_Port_B      ; loadsignals
f111 29 41              AND #%01000001      ; mask NRFD & NDAC
f113 c9 41              CMP #%01000001      ; both high ?
f115 f0 55              BEQ Device_Not_Present
f117 a5 a5              LDA BSOUR           ; load byte to send
f119 49 ff              EOR #$ff            ; invert it
f11b 8d 22 e8           STA PIA2_Port_B     ; DATA OUT
f11e 2c 40 e8 SIB_10    BIT VIA_Port_B      ; test signals
f121 50 fb              BVC SIB_10          ; wait until NRFD high
f123 a9 34              LDA #%00110100      ; $34
f125 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) low
f128 a9 ff    SIB_20    LDA #$ff            ; set timer to MAX
f12a 8d 45 e8           STA VIA_Timer_1_Hi
f12d ad 40 e8 SIB_30    LDA VIA_Port_B      ; load signals
f130 2c 4d e8           BIT VIA_IFR         ; check timer, expect NDAC high in ca. 65 ms
f133 70 1c              BVS Time_Out_Writing
f135 4a                 LSR A               ; NDAC -> carry
f136 90 f5              BCC SIB_30          ; repeat until NDAC high
f138 a9 3c    tby6      LDA #%00111100      ; $3c
f13a 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f13d a9 ff              LDA #$ff            ; release data lines
f13f 8d 22 e8           STA PIA2_Port_B
f142 60                 RTS ;Size   58 [Send_IEEE_Byte]

              ; ******
f143            SECOND
              ; ******

f143 85 a5              STA BSOUR           ; output buffer
f145 20 09 f1           JSR Send_IEEE_Byte  ; send it

              ; *******
f148            Set_ATN
              ; *******

f148 ad 40 e8           LDA VIA_Port_B
f14b 09 04              ORA #%00000100      ; $04
f14d 8d 40 e8           STA VIA_Port_B      ; set ATN high
f150 60                 RTS ;Size    9 [Set_ATN]

              ; ****************
f151            Time_Out_Writing
              ; ****************

f151 ad fc 03           LDA Ignore_Timeout  ; load timeout flag (addr. 1020, bit 7)
f154 10 0f              BPL Timo_W          ; timeout if flag cleared (default value)
f156 20 43 f3           JSR Kernal_STOP
f159 d0 cd              BNE SIB_20          ; restart timer and try again to transmit

              ; ****************
f15b            Time_Out_Reading
              ; ****************

f15b ad fc 03           LDA Ignore_Timeout
f15e 10 10              BPL Timo_R
f160 20 43 f3           JSR Kernal_STOP
f163 d0 68              BNE Acptr_10
f165 a9 01    Timo_W    LDA #1              ; flag time out on writing
f167 20 c4 fb Timo_S    JSR Set_STATUS
f16a d0 cc              BNE tby6            ; branch always

              ; ******************
f16c            Device_Not_Present
              ; ******************

f16c a9 80              LDA #$80
f16e 30 f7              BMI Timo_S
f170 a9 02    Timo_R    LDA #2              ; flag time out reading
f172 20 c4 fb           JSR Set_STATUS

              ; *****************
f175            Set_NRFD_NDAC_low
              ; *****************

f175 ad 40 e8           LDA VIA_Port_B
f178 29 fd              AND #%11111101      ; $fd
f17a 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f17d a9 34              LDA #%00110100      ; $34
f17f 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f182 a9 0d              LDA #CR             ; load CR
f184 60                 RTS ;Size   16 [Set_NRFD_NDAC_low]

              ; **********************
f185            Display_Kernal_Message
              ; **********************

f185 b9 00 f0           LDA KERNAL_MESSAGES,Y  ; Y = offset for string
f188 08                 PHP                 ; save status (possible end marker)
f189 29 7f              AND #$7f            ; clear bit 7
f18b 20 02 e2           JSR EDIT_CHROUT     ; dispay it
f18e c8                 INY                 ; next character
f18f 28                 PLP                 ; restore status
f190 10 f3              BPL Display_Kernal_Message
f192 60                 RTS                 ; bit 7 = end marker ;Size   14 [Display_Kernal_Message]

              ; ****
f193            TKSA
              ; ****

f193 85 a5              STA BSOUR           ; SA (A) to Buffer
f195 20 09 f1           JSR Send_IEEE_Byte  ; send it
f198 20 75 f1           JSR Set_NRFD_NDAC_low
f19b 4c 48 f1           JMP Set_ATN

              ; *****
f19e            CIOUT
              ; *****

f19e 24 a0              BIT C3PO            ; C3PO = 0 flags empty buffer
f1a0 30 04              BMI Ciout_10        ; branch if not empty
f1a2 c6 a0              DEC C3PO            ; set flag for not empty
f1a4 d0 05              BNE Ciout_20        ; branch always
f1a6 48       Ciout_10  PHA                 ; save current byte
f1a7 20 09 f1           JSR Send_IEEE_Byte  ; send byte from buffer
f1aa 68                 PLA                 ; restore current byte
f1ab 85 a5    Ciout_20  STA BSOUR           ; put it into buffer
f1ad 60                 RTS ;Size   16 [CIOUT]

              ; *****
f1ae            UNTLK
              ; *****

f1ae ad 40 e8           LDA VIA_Port_B
f1b1 29 fb              AND #%11111011      ; $fb
f1b3 8d 40 e8           STA VIA_Port_B      ; set ATN low
f1b6 a9 5f              LDA #%01011111      ; $5f
f1b8 2c                 .BYTE $2c           ; skip next statement

              ; *****
f1b9            UNLSN
              ; *****

f1b9 a9 3f              LDA #%00111111      ; $3f
f1bb 20 d7 f0           JSR TALI_10
f1be d0 88              BNE Set_ATN         ; branch always

              ; *****
f1c0            ACPTR
              ; *****

f1c0 a9 34              LDA #%00110100      ; $34
f1c2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f1c5 ad 40 e8           LDA VIA_Port_B
f1c8 09 02              ORA #%00000010      ; $02
f1ca 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f1cd a9 ff    Acptr_10  LDA #$ff
f1cf 8d 45 e8           STA VIA_Timer_1_Hi  ; set timer
f1d2 2c 4d e8 Acptr_20  BIT VIA_IFR
f1d5 70 84              BVS Time_Out_Reading; timeout after 65 ms
f1d7 2c 40 e8           BIT VIA_Port_B      ; test DAV (bit 7)
f1da 30 f6              BMI Acptr_20        ; loop until DAV (bit 7) low
f1dc ad 40 e8           LDA VIA_Port_B
f1df 29 fd              AND #%11111101      ; $fd
f1e1 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f1e4 2c 10 e8           BIT PIA1_Port_A     ; test for EOI
f1e7 70 05              BVS Acptr_30        ; branch if not
f1e9 a9 40              LDA #%01000000      ; set EOI flag
f1eb 20 c4 fb           JSR Set_STATUS
f1ee ad 20 e8 Acptr_30  LDA PIA2_Port_A     ; read data byte
f1f1 49 ff              EOR #$ff            ; invert it
f1f3 48                 PHA                 ; save read byte
f1f4 a9 3c              LDA #%00111100      ; $3c
f1f6 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f1f9 2c 40 e8 Acptr_40  BIT VIA_Port_B      ; test DAV
f1fc 10 fb              BPL Acptr_40        ; loop until DAV (bit 7) high
f1fe a9 34              LDA #%00110100      ; $34
f200 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f203 68                 PLA                 ; restore read byte
f204 60                 RTS ;Size   69 [ACPTR]

              ; ************
f205            Kernal_GETIN
              ; ************

f205 a9 00              LDA #0
f207 85 96              STA STATUS          ; clear status
f209 a5 af              LDA DFLTN           ; current input device
f20b d0 17              BNE KeIn_10         ; branch if not keyboard
f20d a5 9e    GETIN_10  LDA CharsInBuffer   ; test keyboard queue
f20f f0 26              BEQ KeIn_30         ; return if empty
f211 78                 SEI                 ; disable interrupt
f212 4c a7 e0           JMP EDIT_GETIN      ; get character from keyboard queue

              ; ************
f215            Kernal_CHRIN
              ; ************

f215 a5 af              LDA DFLTN           ; current input device
f217 d0 0b              BNE KeIn_10         ; branch if not keyboard
f219 a5 c6              LDA CursorCol       ; get current cursor column
f21b 85 a4              STA InputCol        ; start input here
f21d a5 d8              LDA CursorRow       ; get current cursor row
f21f 85 a3              STA InputRow        ; start input here
f221 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f224 c9 04    KeIn_10   CMP #4              ; test device number
f226 b0 09              BCS KeIn_20         ; branch if IEEE-488 device
f228 85 ac              STA CRSW            ; device is screen (3)
f22a a5 d5              LDA RigMargin       ; limit input column
f22c 85 a1              STA LastInputCol    ; at right margin
f22e 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f231 a5 96    KeIn_20   LDA STATUS          ; It's IEEE-488 input
f233 f0 03              BEQ KeIn_40         ; continue at ACPTR if status is OK
f235 a9 0d              LDA #CR             ; status flags some error, return CR
f237 60       KeIn_30   RTS                 ; return ;Size   35 [Kernal_CHRIN]
f238 4c c0 f1 KeIn_40   JMP ACPTR           ; continue at ACPTR

f23b 00 00 00           .FILL $f266 - * (0) ; 43 bytes

              ; *************
f266            Kernal_CHROUT
              ; *************

f266 48                 PHA                 ; save character
f267 a5 b0              LDA DFLTO           ; load current output device
f269 c9 04              CMP #4              ; 4 = start of IEEE-488 devices
f26b 68                 PLA                 ; restore character
f26c b0 03              BCS KeCH_10         ; branch if IEEE-488 device
f26e 4c 02 e2           JMP EDIT_CHROUT     ; continue at display on screen
f271 4c 9e f1 KeCH_10   JMP CIOUT           ; continue on IEEE-488 output

f274 00 00 00           .FILL $f2a2 - * (0) ; 46 bytes

              ; ************
f2a2            Kernal_CLALL
              ; ************

f2a2 a9 00              LDA #0
f2a4 85 ae              STA LDTND           ; set # of open files to zero

              ; *************
f2a6            Kernal_CLRCHN
              ; *************

f2a6 a5 b0              LDA DFLTO           ; default output device
f2a8 c9 04              CMP #4              ; screen or IEEE-488 ?
f2aa 90 03              BCC KeCL_10         ; branch if screen
f2ac 20 b9 f1           JSR UNLSN           ; send unlisten
f2af a5 af    KeCL_10   LDA DFLTN           ; default input device
f2b1 c9 04              CMP #4              ; IEEE-488 or not ?
f2b3 90 03              BCC Set_Default_IO
f2b5 20 ae f1           JSR UNTLK           ; send untalk

              ; **************
f2b8            Set_Default_IO
              ; **************

f2b8 a9 03              LDA #3
f2ba 85 b0              STA DFLTO
f2bc a9 00              LDA #0
f2be 85 af              STA DFLTN
f2c0 60                 RTS ;Size    9 [Set_Default_IO]

              ; *********
f2c1            LOOKUP_LA
              ; *********

f2c1 a6 ae              LDX LDTND           ; # of open files
f2c3 ca       LOOK_10   DEX
f2c4 30 05              BMI LOOK_Ret        ; -> not found
f2c6 dd 51 02           CMP LAT,X
f2c9 d0 f8              BNE LOOK_10
f2cb 60       LOOK_Ret  RTS ;Size   11 [LOOKUP_LA]

f2cc 00                 .FILL $f2cd-* (0) ; 1 bytes

              ; **********************
f2cd            Set_LFS_From_X ; $f2cd
              ; **********************

              ; Input:  X = index to file
              ; Output: A = FA

f2cd bd 51 02           LDA LAT,X
f2d0 85 d2              STA LA
f2d2 bd 65 02           LDA SAT,X
f2d5 85 d3              STA SA
f2d7 bd 5b 02           LDA FAT,X
f2da 85 d4              STA FA
f2dc 60                 RTS ;Size   16 [Set_LFS_From_X]

              ; ************
f2dd            Kernal_CLOSE
              ; ************

f2dd 20 0d f5           JSR Get_Open_Close_Parameter
f2e0 a5 d2              LDA LA

              ; *************
f2e2            Close_LA_in_A
              ; *************

f2e2 20 c1 f2           JSR LOOKUP_LA
f2e5 d0 24              BNE ClFi_20

              ; ************
f2e7            Close_File_A
              ; ************

f2e7 20 cd f2           JSR Set_LFS_From_X
f2ea c9 04              CMP #4
f2ec 90 03              BCC ClFi_10         ; keyboard or screen
f2ee 20 2a f7           JSR Close_Disk_File
f2f1 c6 ae    ClFi_10   DEC LDTND
f2f3 e4 ae              CPX LDTND
f2f5 f0 14              BEQ ClFi_20
f2f7 a4 ae              LDY LDTND
f2f9 b9 51 02           LDA LAT,Y
f2fc 9d 51 02           STA LAT,X
f2ff b9 5b 02           LDA FAT,Y
f302 9d 5b 02           STA FAT,X
f305 b9 65 02           LDA SAT,Y
f308 9d 65 02           STA SAT,X
f30b 60       ClFi_20   RTS ;Size   37 [Close_File_A]

f30c 00 00 00           .FILL $f335 - * (0) ; 41 bytes

              ; **************
f335            Check_STOP_Key
              ; **************

f335 a5 9b              LDA Stop_Flag
f337 c9 ef              CMP #$ef
f339 d0 07              BNE ChST_Ret
f33b 08                 PHP
f33c 20 a6 f2           JSR Kernal_CLRCHN
f33f 85 9e              STA CharsInBuffer
f341 28                 PLP
f342 60       ChST_Ret  RTS ;Size   14 [Check_STOP_Key]

              ; ***********
f343            Kernal_STOP
              ; ***********

f343 20 35 f3           JSR Check_STOP_Key
f346 4c c6 b7           JMP Basic_STOP

              ; ************************
f349            Kernal_Message_If_Direct
              ; ************************

f349 20 51 f3           JSR In_Direct_Mode
f34c d0 f4              BNE ChST_Ret
f34e 4c 85 f1           JMP Display_Kernal_Message

              ; **************
f351            In_Direct_Mode
              ; **************

f351 a5 78              LDA TXTPTR+1
f353 c9 02              CMP #2
f355 60                 RTS ;Size    5 [In_Direct_Mode]

              ; *********
f356            Load_File
              ; *********

f356 a5 d4              LDA FA              ; primary device address
f358 c9 04              CMP #4              ; start of IEEE-488 devices
f35a b0 03              BCS LoFi_15
f35c 4c 00 bf LoFi_10   JMP Syntax_Error    ; no loading from devices 0-3
f35f a4 d1    LoFi_15   LDY FNLEN
f361 f0 f9              BEQ LoFi_10         ; error for zero length filenames
f363 a6 d3              LDX SA              ; 1: use load address from file
f365 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
f368 e0 00              CPX #0              ; ignore load address ?
f36a f0 04              BEQ LoFi_20
f36c 84 c9              STY EAL
f36e 85 ca              STA EAL+1
f370 a5 96    LoFi_20   LDA STATUS          ; check time out bit
f372 f0 03              BEQ LoFi_25         ; no time out -> continue
f374 4c ad f5           JMP Display_File_Not_Found
f377 20 51 f3 LoFi_25   JSR In_Direct_Mode
f37a d0 12              BNE LoFi_30
f37c 20 6d f4           JSR Display_Load_Or_Verify
f37f a5 ca              LDA EAL+1
f381 20 57 d7           JSR Print_Hex_Byte
f384 a5 c9              LDA EAL
f386 20 57 d7           JSR Print_Hex_Byte
f389 a9 2d              LDA #'-'
f38b 20 02 e2           JSR EDIT_CHROUT
f38e a0 00    LoFi_30   LDY #0              ; remains zero for loop
f390 84 96    LoFi_35   STY STATUS          ; clear status bits
f392 20 43 f3 LoFi_40   JSR Kernal_STOP     ; STOP key pressed?
f395 20 c0 f1           JSR ACPTR           ; read next byte
f398 24 9d              BIT VERCK           ; load (0) or verify ($80)
f39a 10 0b              BPL LoFi_45         ; branch if loading
f39c d1 c9              CMP (EAL),Y         ; verify
f39e f0 0f              BEQ LoFi_55         ; branch if OK
f3a0 a9 10              LDA #%00010000      ; flag verify error $10
f3a2 20 c4 fb           JSR Set_STATUS      ; and stop verifying
f3a5 d0 1a              BNE LoFi_70         ; branch always
f3a7 91 c9    LoFi_45   STA (EAL),Y         ; store byte
f3a9 b1 c9    LoFi_50   LDA (EAL),Y         ; this comparison is false for an
f3ab d1 c9              CMP (EAL),Y         ; unfinished write cycle to EEPROM
f3ad d0 fa              BNE LoFi_50         ; repeat until EEPROM bit toggle ceased
f3af e6 c9    LoFi_55   INC EAL             ; increment write address
f3b1 d0 0a              BNE LoFi_60
f3b3 e6 ca              INC EAL+1
f3b5 20 51 f3           JSR In_Direct_Mode
f3b8 d0 03              BNE LoFi_60
f3ba 20 40 f4           JSR Print_EAL
f3bd 24 96    LoFi_60   BIT STATUS          ; Get EOF marker in bit 6
f3bf 50 d1              BVC LoFi_40         ; repeat until EOF
f3c1 20 ae f1 LoFi_70   JSR UNTLK
f3c4 20 2a f7           JSR Close_Disk_File
f3c7 20 51 f3           JSR In_Direct_Mode
f3ca f0 01              BEQ LoFi_80
f3cc 60                 RTS ;Size  119 [Load_File]
f3cd 4c 40 f4 LoFi_80   JMP Print_EAL

              ; **************
f3d0            Open_Load_File
              ; **************

f3d0 a9 60              LDA #$60            ; secondary address for loading
f3d2 85 d3              STA SA
f3d4 20 af f4           JSR Send_Filename
f3d7 20 d2 f0           JSR TALK            ; send primary address
f3da a5 d3              LDA SA
f3dc 20 93 f1           JSR TKSA            ; send secondary address
f3df 20 c0 f1           JSR ACPTR           ; load address low
f3e2 a8                 TAY                 ; Y = load address low
f3e3 4c c0 f1           JMP ACPTR           ; A = load address high

              ; *****
f3e6            Merge
              ; *****

f3e6 a9 40              LDA #$40            ; load and merge file
f3e8 d0 19              BNE KeLO_10         ; always

f3ea 00 00 00           .FILL $f401 - * (0) ; 23 bytes

              ; ***********
f401            Kernal_LOAD
              ; ***********

f401 a9 00              LDA #0
f403 85 9d    KeLO_10   STA VERCK

              ; ***********
f405            Load_Verify
              ; ***********

f405 20 7d f4           JSR Get_File_Parameter
f408 24 9d              BIT VERCK
f40a 50 11              BVC Load_Verify_Params_Set
f40c 38                 SEC
f40d a5 2a              LDA VARTAB          ; set merge address
f40f e9 02              SBC #2
f411 85 c9              STA EAL
f413 a5 2b              LDA VARTAB+1
f415 e9 00              SBC #0
f417 85 ca              STA EAL+1
f419 a9 00              LDA #0
f41b 85 d3              STA SA

              ; **********************
f41d            Load_Verify_Params_Set
              ; **********************

f41d 20 56 f3           JSR Load_File       ; load file into RAM
f420 24 9d              BIT VERCK           ; (0) LOAD, ($80) VERIFY
f422 30 1b              BMI LVPS_Ret        ; done for verify
f424 a0 ae              LDY #<MSG_READY     ; $ae
f426 20 49 f3           JSR Kernal_Message_If_Direct
f429 20 51 f3           JSR In_Direct_Mode
f42c d0 0b              BNE LVPS_20
f42e a5 ca              LDA EAL+1
f430 85 2b              STA VARTAB+1        ; update VARPTR
f432 a5 c9              LDA EAL
f434 85 2a              STA VARTAB
f436 4c ad b4           JMP Reset_And_Rechain
f439 20 22 b6 LVPS_20   JSR Reset_BASIC_Exec_Pointer
f43c 4c 0b b6           JMP RVP_10
f43f 60       LVPS_Ret  RTS ;Size   35 [Load_Verify_Params_Set]

              ; *********
f440            Print_EAL
              ; *********

f440 a5 ca              LDA EAL+1
f442 20 57 d7           JSR Print_Hex_Byte
f445 a5 c9              LDA EAL
f447 20 57 d7           JSR Print_Hex_Byte
f44a a2 04              LDX #4
f44c a9 9d              LDA #$9d            ; cursor left
f44e 20 02 e2 PrEA_10   JSR EDIT_CHROUT
f451 ca                 DEX
f452 d0 fa              BNE PrEA_10
f454 60       PrEA_Ret  RTS ;Size   21 [Print_EAL]

f455 00 00 00           .FILL $f46d - * (0) ; 24 bytes

              ; **********************
f46d            Display_Load_Or_Verify
              ; **********************

f46d a0 5f              LDY #<MSG_LOAD      ; $5f
f46f 24 9d              BIT VERCK
f471 10 02              BPL DLOV_10
f473 a0 6d              LDY #<MSG_VERIFY    ; $6d
f475 20 49 f3 DLOV_10   JSR Kernal_Message_If_Direct
f478 a0 39              LDY #<[MSG_SEARCHING + 7];$39 add "ING"
f47a 4c 49 f3           JMP Kernal_Message_If_Direct

              ; ******************
f47d            Get_File_Parameter
              ; ******************

f47d a2 00              LDX #0
f47f 86 96              STX STATUS
f481 86 d1              STX FNLEN
f483 e8                 INX
f484 86 d3              STX SA              ; SA = 1
f486 a2 08              LDX #8
f488 86 d4              STX FA              ; FA = 8
f48a 20 4d f5           JSR ChrGot_Or_RTS
f48d 20 3c f5           JSR Set_Filename_From_String
f490 20 4d f5           JSR ChrGot_Or_RTS
f493 20 a9 f4           JSR Get_Comma_And_Byte
f496 86 d4              STX FA
f498 20 4d f5           JSR ChrGot_Or_RTS
f49b 20 a9 f4           JSR Get_Comma_And_Byte
f49e 86 d3              STX SA
f4a0 a6 28              LDX TXTTAB          ; default: start of BASIC
f4a2 a5 29              LDA TXTTAB+1
f4a4 86 c9              STX EAL
f4a6 85 ca              STA EAL+1
f4a8 60       GFP_Ret   RTS ;Size   44 [Get_File_Parameter]

              ; ******************
f4a9            Get_Comma_And_Byte
              ; ******************

f4a9 20 55 f5           JSR Get_Comma_And_Chr
f4ac 4c d4 c8           JMP Get_Byte_Value

              ; *************
f4af            Send_Filename
              ; *************

f4af a4 d1              LDY FNLEN
f4b1 f0 f5              BEQ GFP_Ret
f4b3 20 d5 f0           JSR LISTEN
f4b6 a5 d3              LDA SA
f4b8 09 f0              ORA #$f0

              ; ****************
f4ba            Send_DOS_Command
              ; ****************

f4ba 20 43 f1           JSR SECOND
f4bd a5 96              LDA STATUS
f4bf 10 05              BPL SeDC_10
f4c1 a0 74              LDY #<MSG_DEVICE_NOT; $74
f4c3 4c af f5           JMP Handle_IO_Error
f4c6 a0 00    SeDC_10   LDY #0
f4c8 b1 da    SeDC_20   LDA (FNADR),Y
f4ca 20 9e f1           JSR CIOUT
f4cd c8                 INY
f4ce c4 d1              CPY FNLEN
f4d0 d0 f6              BNE SeDC_20
f4d2 4c b9 f1           JMP UNLSN

f4d5 00 00 00           .FILL $f4f6 - * (0) ; 33 bytes

              ; *************
f4f6            Kernal_VERIFY
              ; *************

f4f6 a9 80              LDA #$80
f4f8 85 9d              STA VERCK
f4fa 20 05 f4           JSR Load_Verify
f4fd a5 96              LDA STATUS
f4ff 29 10              AND #16
f501 f0 05              BEQ VERI_OK
f503 a0 6e              LDY #<[MSG_VERIFY+1]; $6e
f505 4c af f5           JMP Handle_IO_Error
f508 a0 aa    VERI_OK   LDY #<MSG_OK        ; $aa
f50a 4c 85 f1           JMP Display_Kernal_Message

              ; ************************
f50d            Get_Open_Close_Parameter
              ; ************************

f50d a2 00              LDX #0              ; clear
f50f 86 d3              STX SA              ; secondary address
f511 86 96              STX STATUS          ; status
f513 86 d1              STX FNLEN           ; length of filename
f515 20 4c fd           JSR Set_FA_to_8     ; default device 8
f518 20 58 f5           JSR Assert_Not_At_End
f51b 20 d4 c8           JSR Get_Byte_Value
f51e 86 d2              STX LA              ; store logical address
f520 20 4d f5           JSR ChrGot_Or_RTS
f523 20 a9 f4           JSR Get_Comma_And_Byte
f526 86 d4              STX FA              ; store primary address
f528 20 4d f5           JSR ChrGot_Or_RTS
f52b 20 a9 f4           JSR Get_Comma_And_Byte
f52e 86 d3              STX SA              ; store secondary address
f530 20 4d f5           JSR ChrGot_Or_RTS
f533 20 55 f5           JSR Get_Comma_And_Chr
f536 4c 3c f5           JMP Set_Filename_From_String

f539 00 00 00           .FILL $f53c - * (0) ; 3 bytes

              ; ************************
f53c            Set_Filename_From_String
              ; ************************

f53c 20 98 bd           JSR Eval_Expression
f53f 20 b5 c7           JSR Eval_And_Free_String
f542 85 d1              STA FNLEN
f544 a5 1f              LDA INDEXA
f546 85 da              STA FNADR
f548 a5 20              LDA INDEXA+1
f54a 85 db              STA FNADR+1
f54c 60                 RTS ;Size   17 [Set_Filename_From_String]

              ; *************
f54d            ChrGot_Or_RTS
              ; *************

f54d 20 76 00           JSR CHRGOT
f550 d0 02              BNE Get_Ret
f552 68                 PLA
f553 68                 PLA
f554 60       Get_Ret   RTS ;Size    8 [ChrGot_Or_RTS]

              ; *****************
f555            Get_Comma_And_Chr
              ; *****************

f555 20 f5 be           JSR Need_Comma

              ; *****************
f558            Assert_Not_At_End
              ; *****************

f558 20 76 00           JSR CHRGOT
f55b d0 f7              BNE Get_Ret
f55d 4c 00 bf Err_f55d  JMP Syntax_Error

              ; ***********
f560            Kernal_OPEN
              ; ***********

f560 20 0d f5           JSR Get_Open_Close_Parameter
f563 a5 d2    Mf563     LDA LA

              ; *********
f565            Open_File
              ; *********

f565 f0 f6              BEQ Err_f55d
f567 a0 0e              LDY #<MSG_FILE_OPEN
f569 20 c1 f2           JSR LOOKUP_LA
f56c f0 41              BEQ Handle_IO_Error
f56e a6 ae              LDX LDTND
f570 a0 00              LDY #0              ; also MSG # for TOO MANY FILES
f572 84 96              STY STATUS
f574 e0 0a              CPX #10
f576 f0 37              BEQ Handle_IO_Error
f578 e6 ae              INC LDTND
f57a a5 d2              LDA LA
f57c 9d 51 02           STA LAT,X
f57f a5 d3              LDA SA
f581 09 60              ORA #$60
f583 85 d3              STA SA
f585 9d 65 02           STA SAT,X
f588 a5 d4              LDA FA
f58a 9d 5b 02           STA FAT,X
f58d f0 c5              BEQ Get_Ret         ; open keyboard
f58f c9 03              CMP #3
f591 f0 c1              BEQ Get_Ret         ; open screen
f593 90 c8              BCC Err_f55d        ; no tape support
f595 4c af f4           JMP Send_Filename

f598 00 00 00           .FILL $f5ad - * (0) ; 21 bytes


              ; **********************
f5ad            Display_File_Not_Found
              ; **********************

f5ad a0 24              LDY #<MSG_FILE_NOT_F; $24

              ; ***************
f5af            Handle_IO_Error
              ; ***************

f5af 20 a2 f2           JSR Kernal_CLALL
f5b2 a9 0d              LDA #CR
f5b4 20 66 f2           JSR Kernal_CHROUT
f5b7 a9 3f              LDA #$3f            ; '?'
f5b9 20 66 f2           JSR Kernal_CHROUT
f5bc 20 85 f1           JSR Display_Kernal_Message
f5bf 4c ea b3           JMP Berr_30

              ; ***********
f5c2            Disassemble
              ; ***********

f5c2 20 1b d6           JSR Mon_Get_Addr
f5c5 20 35 f3 Disa_10   JSR Check_STOP_Key  ; STOP key pressed?
f5c8 f0 19              BEQ Disa_Main
f5ca 20 e3 d5           JSR Mon_Cmp_Addr
f5cd 90 14              BCC Disa_Main       ; STAL > MEMUSS ?
f5cf a9 2e    Disa_15   LDA #'.'
f5d1 20 77 d5           JSR Mon_Prompt
f5d4 20 1e d5           JSR Mon_Print_Blank
f5d7 20 14 f6           JSR Dis_Inst        ; Disassemble
f5da 20 e6 f5           JSR Print_Dis_Line
f5dd a5 b3              LDA PC_Adjust
f5df d0 e4              BNE Disa_10
f5e1 e6 b3              INC PC_Adjust
f5e3 4c b1 d4 Disa_Main JMP Mon_Main

              ; **************
f5e6            Print_Dis_Line
              ; **************

f5e6 48                 PHA                 ; save mne index
f5e7 a0 00              LDY #0
f5e9 b9 c1 00 Disa_20   LDA Mon_Op,Y        ; next byte
f5ec 20 57 d7           JSR Print_Hex_Byte
f5ef 4c f8 f5           JMP Disa_50
f5f2 20 1e d5 Disa_40   JSR Mon_Print_Blank
f5f5 20 1e d5           JSR Mon_Print_Blank
f5f8 20 1e d5 Disa_50   JSR Mon_Print_Blank
f5fb c4 be              CPY Dis_Length
f5fd c8                 INY
f5fe 90 e9              BCC Disa_20         ; next byte
f600 c0 03              CPY #3
f602 90 ee              BCC Disa_40         ; blanks
f604 68                 PLA                 ; restore mne index
f605 20 39 f7           JSR Store_Mnemonic
f608 20 8d f9           JSR Store_Address
f60b 20 f9 f9           JSR Print_Dis_Buf
f60e 38                 SEC
f60f a5 be              LDA Dis_Length      ; carry is set
f611 4c 16 fb           JMP AdST_00



              ; ********
f614            Dis_Inst
              ; ********

f614 20 50 d7           JSR Mon_Print_STAL
f617 20 1e d5           JSR Mon_Print_Blank
f61a a0 02              LDY #2              ; fetch 3 bytes
f61c 20 7a 02 DiIn_10   JSR Bank_Fetch
f61f 99 c1 00           STA Mon_Op,Y
f622 88                 DEY
f623 10 f7              BPL DiIn_10         ; opcode in A

              ; **************
f625            Analyze_Opcode
              ; **************

              ; instruction pattern: aaa bbb cc
              ; aaa = instruction
              ; bbb = addressing mode
              ; cc  = group

              ; 1. analyze group cc
              ; ------------------------------------------
              ; cc = 00  one byte instructions, branches
              ; cc = 01  ORA,AND,EOR,ADC,STA,LDA,CMP,SBC
              ; cc = 10  ASL,ROL,LSR,ROR,STX,LDX,DEC,INC
              ; cc = 11  illegal opcodes

f625 a8                 TAY                 ; save opcode
f626 4a                 LSR A               ; bit 0 -> carry
f627 90 0b              BCC AnOp_10
f629 4a                 LSR A               ; bit 1 -> carry
f62a b0 17              BCS AnOp_30         ; 11 -> no valid opcode
f62c c9 22              CMP #$22            ; invalid opcode $89 ?
f62e f0 13              BEQ AnOp_30
f630 29 07              AND #7              ; mask addressing mode bbb
f632 09 80              ORA #$80            ; set bit 7
f634 4a       AnOp_10   LSR A               ; A,X = aaa bbb (cc = x0)
f635 aa                 TAX                 ; A,X = aaa bb  (cc = 10)
f636 bd 6b f6           LDA admode_index,X  ; get addressing mode index
f639 b0 04              BCS AnOp_20         ; branch on cc = 10
f63b 4a                 LSR A               ; move nibble for cc = 00
f63c 4a                 LSR A
f63d 4a                 LSR A
f63e 4a                 LSR A
f63f 29 0f    AnOp_20   AND #15             ; mask addressing mode index
f641 d0 04              BNE AnOp_40         ; branch for valid mode
f643 a0 80    AnOp_30   LDY #$80            ; set invalid opcode
f645 a9 00              LDA #0
f647 aa       AnOp_40   TAX                 ; X = addressing mode index
f648 bd 73 f9           LDA admode_format,X ; A = addressing mode format
f64b 85 bd              STA Mon_Format      ; format
f64d 29 03              AND #3
f64f 85 be              STA Dis_Length      ; length
f651 98                 TYA                 ; restore opcode
f652 29 8f              AND #$8f            ; mask
f654 aa                 TAX                 ; X =
f655 98                 TYA                 ; restore opcode
f656 a0 03              LDY #3              ; Y = 3
f658 e0 8a              CPX #$8a            ; TXS,TAX,TSX,DEX,NOP
f65a f0 0b              BEQ AnOp_70
f65c 4a       AnOp_50   LSR A
f65d 90 08              BCC AnOp_70
f65f 4a                 LSR A
f660 4a       AnOp_60   LSR A
f661 09 20              ORA #$20
f663 88                 DEY
f664 d0 fa              BNE AnOp_60
f666 c8                 INY
f667 88       AnOp_70   DEY
f668 d0 f2              BNE AnOp_50
f66a 60                 RTS ;Size   70 [Analyze_Opcode]

              ; ************
f66b            admode_index
              ; ************

f66b 40                 .BYTE $40           ; $4 BRK        $0 ---
f66c 02                 .BYTE $02           ; $0 ---        $2 ASL zz
f66d 45                 .BYTE $45           ; $4 PHP        $5 ASL A
f66e 03                 .BYTE $03           ; $0 ---        $3 ASL nnnn

f66f d0                 .BYTE $d0           ; $d BPL oo     $0 ---
f670 08                 .BYTE $08           ; $0 ---        $8 ASL zz,X
f671 40                 .BYTE $40           ; $4 CLC        $0 ---
f672 09                 .BYTE $09           ; $0 ---        $9 ASL nnnn,X

f673 30                 .BYTE $30           ; $3 JSR nnnn   $0 --
f674 22                 .BYTE $22           ; $2 BIT zz     $2 ROL zz
f675 45                 .BYTE $45           ; $4 PLP        $5 ROL A
f676 33                 .BYTE $33           ; $3 BIT nnnn   $3 ROL nnnn

f677 d0                 .BYTE $d0           ; $d BMI oo     $0 ---
f678 08                 .BYTE $08           ; $0 ---        $8 ROL zz,X
f679 40                 .BYTE $40           ; $4 SEC        $0 ---
f67a 09                 .BYTE $09           ; $0 ---        $9 ROL nnnn,X

f67b 40                 .BYTE $40           ; $4 RTI        $0 ---
f67c 02                 .BYTE $02           ; $0 ---        $2 LSR zz
f67d 45                 .BYTE $45           ; $4 PHA        $5 LSR A
f67e 33                 .BYTE $33           ; $3 JMP nnnn   $3 LSR nnnn

f67f d0                 .BYTE $d0           ; $d BVC oo     $0 ---
f680 08                 .BYTE $08           ; $0 ---        $8 LSR zz,X
f681 40                 .BYTE $40           ; $4 CLI        $0 ---
f682 09                 .BYTE $09           ; $0 ---        $9 LSR nnnn,X

f683 40                 .BYTE $40           ; $4 RTS        $0 ---
f684 02                 .BYTE $02           ; $0 ---        $2 ROR zz
f685 45                 .BYTE $45           ; $4 PLA        $5 ROR A
f686 b3                 .BYTE $b3           ; $b JMP (nnnn) $3 ROR nnnn

f687 d0                 .BYTE $d0           ; $d BVS oo     $0 ---
f688 08                 .BYTE $08           ; $0 ---        $8 ROR zz,X
f689 40                 .BYTE $40           ; $4 SEI        $0 ---
f68a 09                 .BYTE $09           ; $0 ---        $9 ROR nnnn,X

f68b 00                 .BYTE $00           ; $0 ---        $0 ---
f68c 22                 .BYTE $22           ; $2 STY zz     $2 STX zz
f68d 44                 .BYTE $44           ; $4 DEY        $4 TXA
f68e 33                 .BYTE $33           ; $3 STY nnnn   $3 STX nnnn

f68f d0                 .BYTE $d0           ; $d BCC oo     $0 ---
f690 8c                 .BYTE $8c           ; $8 STY zz,X   $c STX zz,Y
f691 44                 .BYTE $44           ; $4 TYA        $4 TXS
f692 00                 .BYTE $00           ; $0 ---        $0 ---

f693 11                 .BYTE $11           ; $1 LDY #      $1 LDX #
f694 22                 .BYTE $22           ; $2 LDY zz     $2 LDX zz
f695 44                 .BYTE $44           ; $4 TAY        $4 TAX
f696 33                 .BYTE $33           ; $3 LDY nnnn   $3 LDX nnnn

f697 d0                 .BYTE $d0           ; $d BCS oo     $0 ---
f698 8c                 .BYTE $8c           ; $8 LDY zz,X   $c LDX zz,Y
f699 44                 .BYTE $44           ; $4 CLV        $4 TSX
f69a 9a                 .BYTE $9a           ; $9 LDY nnnn,X $a LDX nnnn,Y

f69b 10                 .BYTE $10           ; $1 CPY #      $0 ---
f69c 22                 .BYTE $22           ; $2 CPY zz     $2 DEC zz
f69d 44                 .BYTE $44           ; $4 INY        $4 DEX
f69e 33                 .BYTE $33           ; $3 CPY nnnn   $3 DEC nnnn

f69f d0                 .BYTE $d0           ; $d BNE oo     $0 ---
f6a0 08                 .BYTE $08           ; $0 ---        $8 DEC zz,X
f6a1 40                 .BYTE $40           ; $4 CLD        $0 ---
f6a2 09                 .BYTE $09           ; $0 ---        $9 DEC nnnn,X

f6a3 10                 .BYTE $10           ; $1 CPX #      $0 ---
f6a4 22                 .BYTE $22           ; $2 CPX zz     $2 INC zz
f6a5 44                 .BYTE $44           ; $4 INX        $4 NOP
f6a6 33                 .BYTE $33           ; $3 CPX nnnn   $3 INC nnnn

f6a7 d0                 .BYTE $d0           ; $d BEQ oo     $0 ---
f6a8 08                 .BYTE $08           ; $0 ---        $8 INC zz,X
f6a9 40                 .BYTE $40           ; $4 SED        $0 ---
f6aa 09                 .BYTE $09           ; $0 ---        $9 INC nnnn,X

f6ab 62                 .BYTE $62           ; $6 (zz,X)     $2 zz
f6ac 13                 .BYTE $13           ; $1 #          $3 nnnn
f6ad 78                 .BYTE $78           ; $7 (zz),Y     $8 zz,X
f6ae a9                 .BYTE $a9           ; $a nnnn,Y     $9 nnnn,X

f6af 00 00 00            .FILL $f6c3 - * (0) ; 20 bytes


              ; **********
f6c3            Kernal_SYS
              ; **********

f6c3 20 84 bd           JSR Eval_Numeric
f6c6 20 2d c9           JSR FAC1_To_LINNUM
f6c9 6c 11 00           JMP (LINNUM)

              ; **************
f6cc            Set_Save_Range
              ; **************

f6cc a5 2a              LDA VARTAB
f6ce 85 c9              STA EAL
f6d0 a5 2b              LDA VARTAB+1
f6d2 85 ca              STA EAL+1
f6d4 a5 29              LDA TXTTAB+1
f6d6 85 fc              STA STAL+1
f6d8 a5 28              LDA TXTTAB
f6da 85 fb              STA STAL
f6dc 60                 RTS ;Size   17 [Set_Save_Range]

              ; ***********
f6dd            Kernal_SAVE
              ; ***********

f6dd 20 7d f4           JSR Get_File_Parameter
f6e0 20 cc f6 Mf6e0     JSR Set_Save_Range

              ; *********
f6e3            Save_File
              ; *********

f6e3 a5 d4              LDA FA              ; primary address
f6e5 c9 04              CMP #4              ; unit number >= 4
f6e7 b0 03              BCS SaFi_20         ; branch if OK
f6e9 4c 00 bf SaFi_10   JMP Syntax_Error    ; wrong unit or no filename
f6ec a9 61    SaFi_20   LDA #$61            ; secondary address for saving
f6ee 85 d3              STA SA
f6f0 a4 d1              LDY FNLEN           ; length of filename
f6f2 f0 f5              BEQ SaFi_10         ; error if zero
f6f4 20 af f4           JSR Send_Filename
f6f7 20 d5 f0           JSR LISTEN          ; Send Listen
f6fa a5 d3              LDA SA
f6fc 20 43 f1           JSR SECOND          ; Send Listen Secondary
f6ff a4 fb              LDY STAL            ; save start low
f701 a6 fc              LDX STAL+1          ; save start high
f703 98                 TYA
f704 20 9e f1           JSR CIOUT           ; send start low
f707 8a                 TXA
f708 20 9e f1           JSR CIOUT           ; send start high
f70b a9 00              LDA #0
f70d 85 fb              STA STAL            ; clear pointer low
f70f c4 c9    SaFi_30   CPY EAL             ; compare to end address low
f711 d0 04              BNE SaFi_40         ; not yet
f713 e4 ca              CPX EAL+1           ; compare to end address high
f715 f0 10              BEQ SaFi_50         ; branch if at end
f717 b1 fb    SaFi_40   LDA (STAL),Y        ; load next byte
f719 20 9e f1           JSR CIOUT           ; send it
f71c 20 43 f3           JSR Kernal_STOP     ; check STOP key
f71f c8                 INY                 ; increment Y (low address)
f720 d0 ed              BNE SaFi_30         ; continue loop if not zero
f722 e8                 INX                 ; increment X (high address)
f723 86 fc              STX STAL+1          ; update piointer
f725 d0 e8              BNE SaFi_30         ; branch always
f727 20 b9 f1 SaFi_50   JSR UNLSN           ; Unlisten and fall through

              ; ***************
f72a            Close_Disk_File
              ; ***************

f72a 20 d5 f0           JSR LISTEN          ; send listen
f72d a5 d3              LDA SA
f72f 29 ef              AND #%11101111      ; $ef
f731 09 e0              ORA #%11100000      ; $e0 + unit
f733 20 43 f1           JSR SECOND          ; send secondary listen
f736 4c b9 f1           JMP UNLSN           ; send unlisten

              ; **************
f739            Store_Mnemonic
              ; **************

f739 a2 00              LDX #0
f73b a8                 TAY
f73c b9 f3 f8           LDA Mnemonic_Left,Y
f73f 85 bf              STA Mon_A
f741 b9 33 f9           LDA Mnemonic_Right,Y
f744 85 c0              STA Mon_B
f746 a9 00    PrMn_10   LDA #0
f748 a0 05              LDY #5
f74a 06 c0    PrMn_20   ASL Mon_B
f74c 26 bf              ROL Mon_A
f74e 2a                 ROL A
f74f 88                 DEY
f750 d0 f8              BNE PrMn_20
f752 69 3f              ADC #$3f
f754 9d b1 02           STA Dis_Buf,X
f757 e8                 INX
f758 e0 03              CPX #3
f75a 90 ea              BCC PrMn_10
f75c 60                 RTS ;Size   36 [Store_Mnemonic]


f75d 00 00 00           .FILL $f768 - * (0) ; 11 bytes

              ; ************
f768            Kernal_UDTIM
              ; ************

f768 e6 8f              INC JIFFY_CLOCK+2   ; 1 jiffy = 1/60 sec
f76a d0 18              BNE ud_20
f76c e6 8e              INC JIFFY_CLOCK+1
f76e d0 02              BNE ud_10
f770 e6 8d              INC JIFFY_CLOCK
f772 a5 8d    ud_10     LDA JIFFY_CLOCK
f774 c9 4f              CMP #$4f            ; MSB of $4f1a00 = 24 * 60 * 60 * 60
f776 90 0c              BCC ud_20
f778 a5 8e              LDA JIFFY_CLOCK+1
f77a c9 1a              CMP #$1a
f77c 90 06              BCC ud_20
f77e a9 00              LDA #0
f780 85 8d              STA JIFFY_CLOCK
f782 85 8e              STA JIFFY_CLOCK+1
f784 c6 f8    ud_20     DEC JIFFY6          ; insert additional jiffy count every 5th. call
f786 d0 06              BNE ud_30           ; to generate 60Hz jiffy clock from 50Hz signal
f788 a9 06              LDA #6
f78a 85 f8              STA JIFFY6
f78c d0 da              BNE Kernal_UDTIM    ; branch always
f78e 60       ud_30     RTS ;Size   39 [Kernal_UDTIM]

f78f 00 00 00           .FILL $f7af - * (0) ; 32 bytes

              ; ************
f7af            Kernal_CHKIN
              ; ************

              ; Input:  X = local address
              ; Output: DFLTN (Default Input) set to device FA
              ;         IEEE-488 device will be talker

f7af 48                 PHA                 ; save A
f7b0 a9 00              LDA #0
f7b2 85 96              STA STATUS          ; clear status
f7b4 8a                 TXA
f7b5 48                 PHA                 ; save X
f7b6 20 c1 f2           JSR LOOKUP_LA
f7b9 d0 1b              BNE CHERR_17
f7bb 20 cd f2           JSR Set_LFS_From_X
f7be c9 04              CMP #4              ; A = FA
f7c0 90 0e              BCC CHKIN_10        ; keyboard or screen
f7c2 20 d2 f0           JSR TALK
f7c5 a5 d3              LDA SA
f7c7 20 93 f1           JSR TKSA
f7ca a5 96              LDA STATUS
f7cc 30 0b              BMI CHERR_74
f7ce a5 d4              LDA FA
f7d0 85 af    CHKIN_10  STA DFLTN
f7d2 68                 PLA
f7d3 aa                 TAX
f7d4 68                 PLA
f7d5 60                 RTS ;Size   39 [Kernal_CHKIN]

f7d6 a0 17    CHERR_17  LDY #<MSG_FILE_NOT_O
f7d8 2c                 .BYTE $2c
f7d9 a0 74    CHERR_74  LDY #<MSG_DEVICE_NOT
f7db 2c                 .BYTE $2c
f7dc a0 94    CHERR_94  LDY #<MSG_NOT_OUTPUT
f7de 4c af f5 CHERR_IO  JMP Handle_IO_Error

f7e1 00 00 00           .FILL $f7fe - * (0) ; 29 bytes

              ; *************
f7fe            Kernal_CHKOUT
              ; *************

              ; Input:  X = local address
              ; Output: DFLTO (Default Output) set to device FA
              ;         IEEE-488 device will be listener

f7fe 48                 PHA                 ; save A
f7ff a9 00              LDA #0
f801 85 96              STA STATUS          ; clear status
f803 8a                 TXA
f804 48                 PHA                 ; save X
f805 20 c1 f2           JSR LOOKUP_LA
f808 d0 cc              BNE CHERR_17        ; file not open
f80a 20 cd f2           JSR Set_LFS_From_X
f80d f0 cd              BEQ CHERR_94        ; cannot write to keyboard
f80f c9 04              CMP #4
f811 90 0e              BCC KeCo_10         ; -> screen
f813 20 d5 f0           JSR LISTEN
f816 a5 d3              LDA SA
f818 20 43 f1           JSR SECOND
f81b a5 96              LDA STATUS
f81d 30 ba              BMI CHERR_74
f81f a5 d4              LDA FA
f821 85 b0    KeCo_10   STA DFLTO
f823 68                 PLA
f824 aa                 TAX
f825 68                 PLA
f826 60                 RTS ;Size   41 [Kernal_CHKOUT]

              ; **************
f827            Set_Wedge_Unit
              ; **************

f827 20 70 00           JSR CHRGET
f82a 90 0c              BCC SWUN_10
f82c a6 ab              LDX Wedge_Unit      ; X = Unit
f82e 98                 TYA                 ; A = 0
f82f 20 83 cf           JSR Print_Integer_XA
f832 20 df ba           JSR Print_CR
f835 4c ff b3           JMP Basic_Ready
f838 20 f6 b8 SWUN_10   JSR Scan_Linenumber
f83b a5 11              LDA LINNUM
f83d 85 ab              STA Wedge_Unit
f83f 4c ff b3           JMP Basic_Ready

              ; ************
f842            Wedge_Parser
              ; ************

f842 a0 00              LDY #0
f844 84 9d              STY VERCK           ; no verify
f846 b1 77              LDA (TXTPTR),Y
f848 c9 40              CMP #'@'            ; wedge control
f84a f0 1d              BEQ Command_Or_Status
f84c c9 3e              CMP #'>'            ; wedge control
f84e f0 19              BEQ Command_Or_Status
f850 c9 24              CMP #'$'            ; directory
f852 f0 38              BEQ Wedge_Directory
f854 c9 23              CMP #'#'
f856 f0 cf              BEQ Set_Wedge_Unit
f858 c9 2f              CMP #'/'
f85a f0 57              BEQ Wedge_Load
f85c c9 5e              CMP #'^'
f85e f0 46              BEQ Wedge_Run
f860 20 40 ed           JSR Extended_Command
f863 20 fb b4           JSR Tokenize_Line
f866 4c 79 b7           JMP Start_Program

              ; *****************
f869            Command_Or_Status
              ; *****************

f869 e6 77              INC TXTPTR
f86b b1 77              LDA (TXTPTR),Y
f86d f0 14              BEQ Get_Status
f86f c9 24              CMP #'$'            ; dir command
f871 f0 19              BEQ Wedge_Directory

              ; ************
f873            Send_Command
              ; ************

f873 20 2b fb           JSR DOS_Open_Comm_Write
f876 b1 77    SeCo_10   LDA (TXTPTR),Y
f878 f0 06              BEQ SeCo_20
f87a 20 9e f1           JSR CIOUT
f87d c8                 INY
f87e 10 f6              BPL SeCo_10
f880 20 b9 f1 SeCo_20   JSR UNLSN

              ; **********
f883            Get_Status
              ; **********

f883 20 c7 f8           JSR Wedge_Prepare
f886 20 98 f8           JSR Print_Status
f889 4c ff b3           JMP Basic_Ready

              ; ***************
f88c            Wedge_Directory
              ; ***************

f88c 20 d0 f8           JSR Wedge_Filename
f88f 20 c7 f8           JSR Wedge_Prepare
f892 20 89 d8           JSR Wedge_Call_Dir
f895 4c ff b3           JMP Basic_Ready

              ; ************
f898            Print_Status
              ; ************

f898 20 e1 db           JSR Clear_Status
f89b 20 91 d9           JSR Kernal_Read_DS
f89e 4c 85 db           JMP Display_Status

f8a1 52 55 4e RUN_Now   .BYTE "RUN:\r"

              ; *********
f8a6            Wedge_Run
              ; *********

f8a6 a2 05              LDX #5              ; put "RUN" into keyboard buffer
f8a8 86 9e              STX CharsInBuffer
f8aa bd a0 f8 WeRu_10   LDA RUN_Now-1,X
f8ad 9d 6e 02           STA KEYD-1,X
f8b0 ca                 DEX
f8b1 d0 f7              BNE WeRu_10

              ; **********
f8b3            Wedge_Load
              ; **********

f8b3 20 70 00           JSR CHRGET
f8b6 c9 30              CMP #'0'            ; Skip size info in dir listings
f8b8 90 04              BCC WeLo_10
f8ba c9 3a              CMP #'9'+1
f8bc 90 f5              BCC Wedge_Load
f8be 20 d0 f8 WeLo_10   JSR Wedge_Filename
f8c1 20 c7 f8           JSR Wedge_Prepare
f8c4 4c 1d f4           JMP Load_Verify_Params_Set

              ; *************
f8c7            Wedge_Prepare
              ; *************

f8c7 a5 ab              LDA Wedge_Unit
f8c9 85 d4              STA FA
f8cb a9 00              LDA #0
f8cd 85 96              STA STATUS
f8cf 60                 RTS ;Size    9 [Wedge_Prepare]

              ; **************
f8d0            Wedge_Filename
              ; **************

f8d0 a0 ff              LDY #-1
f8d2 20 76 00           JSR CHRGOT
f8d5 c9 22              CMP #$22            ; quote
f8d7 d0 02              BNE WeFi_10
f8d9 e6 77              INC TXTPTR          ; skip quote
f8db c8       WeFi_10   INY
f8dc b1 77              LDA (TXTPTR),y
f8de f0 04              BEQ WeFi_20
f8e0 c9 22              CMP #$22            ; quote
f8e2 d0 f7              BNE WeFi_10
f8e4 84 d1    WeFi_20   STY FNLEN           ; store length
f8e6 a5 77              LDA TXTPTR
f8e8 85 da              STA FNADR
f8ea a5 78              LDA TXTPTR + 1
f8ec 85 db              STA FNADR + 1
f8ee a5 ab              LDA Wedge_Unit
f8f0 85 d4              STA FA
f8f2 60                 RTS ;Size   35 [Wedge_Filename]

              ; *************
f8f3            Mnemonic_Left
              ; *************

f8f3 1c                 .BYTE >"BRK"
f8f4 8a                 .BYTE >"PHP"
f8f5 1c                 .BYTE >"BPL"
f8f6 23                 .BYTE >"CLC"
f8f7 5d                 .BYTE >"JSR"
f8f8 8b                 .BYTE >"PLP"
f8f9 1b                 .BYTE >"BMI"
f8fa a1                 .BYTE >"SEC"
f8fb 9d                 .BYTE >"RTI"
f8fc 8a                 .BYTE >"PHA"
f8fd 1d                 .BYTE >"BVC"
f8fe 23                 .BYTE >"CLI"
f8ff 9d                 .BYTE >"RTS"
f900 8b                 .BYTE >"PLA"
f901 1d                 .BYTE >"BVS"
f902 a1                 .BYTE >"SEI"
f903 00                 .BYTE >"???"
f904 29                 .BYTE >"DEY"
f905 19                 .BYTE >"BCC"
f906 ae                 .BYTE >"TYA"
f907 69                 .BYTE >"LDY"
f908 a8                 .BYTE >"TAY"
f909 19                 .BYTE >"BCS"
f90a 23                 .BYTE >"CLV"
f90b 24                 .BYTE >"CPY"
f90c 53                 .BYTE >"INY"
f90d 1b                 .BYTE >"BNE"
f90e 23                 .BYTE >"CLD"
f90f 24                 .BYTE >"CPX"
f910 53                 .BYTE >"INX"
f911 19                 .BYTE >"BEQ"
f912 a1                 .BYTE >"SED"
f913 00                 .BYTE >"???"
f914 1a                 .BYTE >"BIT"
f915 5b                 .BYTE >"JMP"
f916 5b                 .BYTE >"JMP"
f917 a5                 .BYTE >"STY"
f918 69                 .BYTE >"LDY"
f919 24                 .BYTE >"CPY"
f91a 24                 .BYTE >"CPX"
f91b ae                 .BYTE >"TXA"
f91c ae                 .BYTE >"TXS"
f91d a8                 .BYTE >"TAX"
f91e ad                 .BYTE >"TSX"
f91f 29                 .BYTE >"DEX"
f920 00                 .BYTE >"???"
f921 7c                 .BYTE >"NOP"
f922 00                 .BYTE >"???"
f923 15                 .BYTE >"ASL"
f924 9c                 .BYTE >"ROL"
f925 6d                 .BYTE >"LSR"
f926 9c                 .BYTE >"ROR"
f927 a5                 .BYTE >"STX"
f928 69                 .BYTE >"LDX"
f929 29                 .BYTE >"DEC"
f92a 53                 .BYTE >"INC"
f92b 84                 .BYTE >"ORA"
f92c 13                 .BYTE >"AND"
f92d 34                 .BYTE >"EOR"
f92e 11                 .BYTE >"ADC"
f92f a5                 .BYTE >"STA"
f930 69                 .BYTE >"LDA"
f931 23                 .BYTE >"CMP"
f932 a0                 .BYTE >"SBC"

              ; **************
f933            Mnemonic_Right
              ; **************

f933 d8                 .BYTE <"BRK"
f934 62                 .BYTE <"PHP"
f935 5a                 .BYTE <"BPL"
f936 48                 .BYTE <"CLC"
f937 26                 .BYTE <"JSR"
f938 62                 .BYTE <"PLP"
f939 94                 .BYTE <"BMI"
f93a 88                 .BYTE <"SEC"
f93b 54                 .BYTE <"RTI"
f93c 44                 .BYTE <"PHA"
f93d c8                 .BYTE <"BVC"
f93e 54                 .BYTE <"CLI"
f93f 68                 .BYTE <"RTS"
f940 44                 .BYTE <"PLA"
f941 e8                 .BYTE <"BVS"
f942 94                 .BYTE <"SEI"
f943 00                 .BYTE <"???"
f944 b4                 .BYTE <"DEY"
f945 08                 .BYTE <"BCC"
f946 84                 .BYTE <"TYA"
f947 74                 .BYTE <"LDY"
f948 b4                 .BYTE <"TAY"
f949 28                 .BYTE <"BCS"
f94a 6e                 .BYTE <"CLV"
f94b 74                 .BYTE <"CPY"
f94c f4                 .BYTE <"INY"
f94d cc                 .BYTE <"BNE"
f94e 4a                 .BYTE <"CLD"
f94f 72                 .BYTE <"CPX"
f950 f2                 .BYTE <"INX"
f951 a4                 .BYTE <"BEQ"
f952 8a                 .BYTE <"SED"
f953 00                 .BYTE <"???"
f954 aa                 .BYTE <"BIT"
f955 a2                 .BYTE <"JMP"
f956 a2                 .BYTE <"JMP"
f957 74                 .BYTE <"STY"
f958 74                 .BYTE <"LDY"
f959 74                 .BYTE <"CPY"
f95a 72                 .BYTE <"CPX"
f95b 44                 .BYTE <"TXA"
f95c 68                 .BYTE <"TXS"
f95d b2                 .BYTE <"TAX"
f95e 32                 .BYTE <"TSX"
f95f b2                 .BYTE <"DEX"
f960 00                 .BYTE <"???"
f961 22                 .BYTE <"NOP"
f962 00                 .BYTE <"???"
f963 1a                 .BYTE <"ASL"
f964 1a                 .BYTE <"ROL"
f965 26                 .BYTE <"LSR"
f966 26                 .BYTE <"ROR"
f967 72                 .BYTE <"STX"
f968 72                 .BYTE <"LDX"
f969 88                 .BYTE <"DEC"
f96a c8                 .BYTE <"INC"
f96b c4                 .BYTE <"ORA"
f96c ca                 .BYTE <"AND"
f96d 26                 .BYTE <"EOR"
f96e 48                 .BYTE <"ADC"
f96f 44                 .BYTE <"STA"
f970 44                 .BYTE <"LDA"
f971 a2                 .BYTE <"CMP"
f972 c8                 .BYTE <"SBC"

              ; *************
f973            admode_format
              ; *************

              ;                 76543210
              ;                 --------
              ;                 x         $
              ;                  x        ($
              ;                   x       #$
              ;                    x      ,X
              ;                     x     )
              ;                      x    ,Y
              ;                       xx  length - 1

f973 00                  .BYTE %00000000  ; 0         implicit
f974 21                  .BYTE %00100001  ; 1  $#     immediate
f975 81                  .BYTE %10000001  ; 2  $zz    zeropage
f976 82                  .BYTE %10000010  ; 3  $nnnn  absolute
f977 00                  .BYTE %00000000  ; 4         implicit
f978 00                  .BYTE %00000000  ; 5         implicit
f979 59                  .BYTE %01011001  ; 6 ($zz,X) indexed indirect
f97a 4d                  .BYTE %01001101  ; 7 ($zz),Y indirect indexed
f97b 91                  .BYTE %10010001  ; 8 $zz,X   zeropage,X
f97c 92                  .BYTE %10010010  ; 9 $nnnn,X absolute,X
f97d 86                  .BYTE %10000110  ; a $nnnn,Y absolute,Y
f97e 4a                  .BYTE %01001010  ; b ($nnnn) indirect
f97f 85                  .BYTE %10000101  ; c $zz,Y   zeropage,Y
f980 9d                  .BYTE %10011101  ; d $nnnn   relative

f981 2c 29 2c adr_char1  .BYTE ",),#($"
f987 59 00 58 adr_char2  .BYTE "Y",0,"X$$",0

              ; *************
f98d            Store_Address
              ; *************

f98d a5 bd              LDA Mon_Format
f98f 85 bf              STA Mon_A
f991 a0 03              LDY #3              ; buffer pointer after mnemonic
f993 a5 be              LDA Dis_Length
f995 f0 41              BEQ StAd_Ret        ; finish for implied address
f997 a9 20              LDA #' '            ; store blank
f999 8d b4 02           STA Dis_Buf+3
f99c c8                 INY                 ; inc buffer pointer
f99d a2 05              LDX #5              ; 6 flags to process
f99f e0 02    StAd_10   CPX #2              ; flag2: address
f9a1 d0 16              BNE StAd_30
f9a3 a5 be              LDA Dis_Length
f9a5 c9 01              CMP #1
f9a7 f0 05              BEQ StAd_20         ; 8 bit operand
f9a9 a5 c3              LDA Mon_Hi
f9ab 20 e2 f9           JSR Store_Hex
f9ae a5 bf    StAd_20   LDA Mon_A
f9b0 c9 e8              CMP #$e8            ; branch ?
f9b2 b0 1e              BCS StAd_50         ; compute target
f9b4 a5 c2              LDA Mon_Lo          ; low  byte of operand
f9b6 20 e2 f9           JSR Store_Hex
f9b9 06 bf    StAd_30   ASL Mon_A
f9bb 90 10              BCC StAd_40
f9bd bd 81 f9           LDA adr_char1,X
f9c0 99 b1 02           STA Dis_Buf,Y
f9c3 c8                 INY
f9c4 bd 87 f9           LDA adr_char2,X
f9c7 f0 04              BEQ StAd_40
f9c9 99 b1 02           STA Dis_Buf,Y
f9cc c8                 INY
f9cd ca       StAd_40   DEX
f9ce 10 cf              BPL StAd_10
f9d0 30 06              BMI StAd_Ret
f9d2 20 46 fe StAd_50   JSR Offset_To_Target
f9d5 20 dc f9           JSR Store_Hex_XA
f9d8 8c b0 02 StAd_Ret  STY Dis_Buf_Length
f9db 60                 RTS ;Size   79 [Store_Address]


              ; ************
f9dc            Store_Hex_XA
              ; ************
f9dc 48                 PHA
f9dd 8a                 TXA
f9de 20 e2 f9           JSR Store_Hex
f9e1 68                 PLA

              ; *********
f9e2            Store_Hex
              ; *********

f9e2 48                 PHA
f9e3 4a                 LSR A
f9e4 4a                 LSR A
f9e5 4a                 LSR A
f9e6 4a                 LSR A
f9e7 20 63 d7           JSR Nibble_To_Hex
f9ea 99 b1 02           STA Dis_Buf,Y
f9ed c8                 INY
f9ee 68                 PLA
f9ef 29 0f              AND #15
f9f1 20 63 d7           JSR Nibble_To_Hex
f9f4 99 b1 02           STA Dis_Buf,Y
f9f7 c8                 INY
f9f8 60                 RTS ;Size   23 [Store_Hex]


              ; *************
f9f9            Print_Dis_Buf
              ; *************

f9f9 a0 00              LDY #0
f9fb b9 b1 02 PDB_10    LDA Dis_Buf,Y
f9fe 20 02 e2           JSR EDIT_CHROUT
fa01 c8                 INY
fa02 cc b0 02           CPY Dis_Buf_Length
fa05 90 f4              BCC PDB_10
fa07 60                 RTS ;Size   15 [Print_Dis_Buf]

              ; ***********
fa08            Ass_Operand
              ; ***********

fa08 20 f4 d8           JSR Mon_CHRIN
fa0b f0 11              BEQ AsOp_30         ; finished
fa0d c9 20              CMP #' '
fa0f f0 f7              BEQ Ass_Operand     ; ignore blanks
fa11 20 99 fd           JSR Get_Constant
fa14 f0 08              BEQ AsOp_30         ; no chars left
fa16 99 c1 02           STA Ass_Buf,Y
fa19 c8                 INY
fa1a c0 10              CPY #16
fa1c 90 ea              BCC Ass_Operand
fa1e ad c1 02 AsOp_30   LDA Ass_Buf         ; 1.st char of mnemonic
fa21 c9 42              CMP #'B'
fa23 d0 19              BNE AsOp_Ret        ; no branch
fa25 ad c2 02           LDA Ass_Buf+1       ; 2nd. char of mnemonic
fa28 c9 49              CMP #'I'
fa2a f0 12              BEQ AsOp_Ret        ; BIT
fa2c c9 52              CMP #'R'
fa2e f0 0e              BEQ AsOp_Ret        ; BRK
fa30 a5 c3              LDA Mon_Hi
fa32 f0 0b              BEQ AsOp_40
fa34 38                 SEC                 ; convert target to offset
fa35 a5 c2              LDA Mon_Lo
fa37 e5 fb              SBC STAL
fa39 38                 SEC
fa3a e9 02              SBC #2
fa3c 85 c2              STA Mon_Lo
fa3e 60       AsOp_Ret  RTS ;Size   55 [Ass_Operand]
fa3f 4c 36 fe AsOp_40   JMP Expand_Target


              ; ********
fa42            Assemble
              ; ********

              ; Strategy: convert operand to disassembler format
              ; Loop opcode from 0 to 255 and call disassembler
              ; until mnemonic and operand match.

fa42 20 6d d7           JSR Hex_To_STAL      ; target address
fa45 90 5d              BCC Ass_Err
fa47 a0 00    Ass_010   LDY #0               ; reset buffer pointer
fa49 84 c1              STY Mon_Op
fa4b 84 c2              STY Mon_Lo
fa4d 84 c3              STY Mon_Hi
fa4f 20 f4 d8 Ass_020   JSR Mon_CHRIN        ; get next char
fa52 f0 50              BEQ Ass_Err
fa54 c9 20              CMP #' '
fa56 f0 ef              BEQ Ass_010          ; restart on blank
fa58 99 c1 02           STA Ass_Buf,Y        ; save char
fa5b c8                 INY
fa5c c0 03              CPY #3
fa5e d0 ef              BNE Ass_020          ; look for more
fa60 20 f4 d8           JSR Mon_CHRIN
fa63 f0 0b              BEQ Ass_040          ; Mnemonic only
fa65 c9 20              CMP #' '
fa67 d0 3b              BNE Ass_Err          ; blank after mnemonic is mandatory
fa69 8d c4 02           STA Ass_Buf+3
fa6c c8                 INY
fa6d 20 08 fa           JSR Ass_Operand
fa70 8c c0 02 Ass_040   STY Ass_Buf_Length
fa73 a5 c1    Ass_050   LDA Mon_Op
fa75 20 25 f6           JSR Analyze_Opcode
fa78 8d d0 02           STA Ass_Index
fa7b 20 39 f7           JSR Store_Mnemonic
fa7e 20 8d f9           JSR Store_Address
fa81 ae c0 02           LDX Ass_Buf_Length
fa84 ec b0 02           CPX Dis_Buf_Length
fa87 d0 0b              BNE Ass_070
fa89 ca       Ass_060   DEX
fa8a 30 1b              BMI Ass_080         ; match
fa8c bd c1 02           LDA Ass_Buf,X
fa8f dd b1 02           CMP Dis_Buf,X
fa92 f0 f5              BEQ Ass_060
fa94 e6 c1    Ass_070   INC Mon_Op          ; try next op code
fa96 d0 db              BNE Ass_050
fa98 a5 cc              LDA Mon_ZP          ; was a zP mode ?
fa9a d0 08              BNE Ass_Err
fa9c c6 cc              DEC Mon_ZP          ; invalidate
fa9e 20 17 fe           JSR Expand_Address
faa1 4c 73 fa           JMP Ass_050         ; now try two byte operands
faa4 4c ac d4 Ass_Err   JMP Mon_Error
faa7 86 ba    Ass_080   STX Dis_Line        ; disable disassembler line count
faa9 a5 fb              LDA STAL
faab 85 f9              STA BPTR
faad a5 fc              LDA STAL+1
faaf 85 fa              STA BPTR+1
fab1 a4 be              LDY Dis_Length
fab3 b9 c1 00 Ass_090   LDA Mon_Op,Y        ; store instruction
fab6 20 8b 02           JSR Bank_Store
fab9 20 7a 02           JSR Bank_Fetch
fabc d9 c1 00           CMP Mon_Op,Y        ; successfull ?
fabf d0 e3              BNE Ass_Err
fac1 88                 DEY
fac2 10 ef              BPL Ass_090
fac4 20 b4 e1           JSR Edit_To_Left_Margin
fac7 a9 9d              LDA #$9d            ; Cursor UP
fac9 20 02 e2           JSR EDIT_CHROUT
facc a9 41              LDA #'A'
face 20 77 d5           JSR Mon_Prompt
fad1 20 1e d5           JSR Mon_Print_Blank
fad4 20 50 d7           JSR Mon_Print_STAL
fad7 20 1e d5           JSR Mon_Print_Blank
fada ad d0 02           LDA Ass_Index
fadd 20 e6 f5           JSR Print_Dis_Line
fae0 a9 0d              LDA #CR
fae2 20 02 e2           JSR EDIT_CHROUT
fae5 78                 SEI                 ; prompt to keyboard buffer
fae6 a9 41              LDA #'A'
fae8 8d 6f 02           STA KEYD
faeb a9 20              LDA #' '
faed 8d 70 02           STA KEYD+1
faf0 a5 fc              LDA STAL+1
faf2 20 41 d7           JSR Make_Hex_Byte
faf5 8e 71 02           STX KEYD+2
faf8 8d 72 02           STA KEYD+3
fafb a5 fb              LDA STAL
fafd 20 41 d7           JSR Make_Hex_Byte
fb00 8e 73 02           STX KEYD+4
fb03 8d 74 02           STA KEYD+5
fb06 a9 20              LDA #' '
fb08 8d 75 02           STA KEYD+6
fb0b a2 07              LDX #7
fb0d 86 9e              STX CharsInBuffer
fb0f 58                 CLI
fb10 4c b4 d4           JMP Mon_10

              ; ********
fb13            Inc_STAL
              ; ********

fb13 a9 01              LDA #1

              ; ********
fb15            Add_STAL
              ; ********

fb15 18                 CLC
fb16 65 fb    AdST_00   ADC STAL
fb18 85 fb              STA STAL
fb1a 90 02              BCC AdST_Ret
fb1c e6 fc    AdST_10   INC STAL+1
fb1e 60       AdST_Ret  RTS ;Size   10 [Add_STAL]


              ; ********
fb1f            Inc_BPTR
              ; ********

fb1f a9 01              LDA #1

              ; ********
fb21            Add_BPTR
              ; ********

fb21 18                 CLC
fb22 65 f9    AdBP_00   ADC BPTR
fb24 85 f9              STA BPTR
fb26 90 02              BCC AdBP_Ret
fb28 e6 fa    AdBP_10   INC BPTR+1
fb2a 60       AdBP_Ret  RTS ;Size   10 [Add_BPTR]


              ; *******************
fb2b            DOS_Open_Comm_Write
              ; *******************

fb2b 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
fb2e 20 d5 f0           JSR LISTEN
fb31 a9 6f              LDA #$6f
fb33 85 d3              STA SA
fb35 4c 43 f1           JMP SECOND

              ; *********
fb38            Mon_Wedge
              ; *********

fb38 20 f4 d8           JSR Mon_CHRIN
fb3b f0 10              BEQ Mon_Wedge_Status
fb3d 48                 PHA
fb3e 20 2b fb           JSR DOS_Open_Comm_Write
fb41 68                 PLA
fb42 20 9e f1 MoWe_10   JSR CIOUT
fb45 20 f4 d8           JSR Mon_CHRIN
fb48 d0 f8              BNE MoWe_10
fb4a 20 b9 f1           JSR UNLSN

              ; ****************
fb4d            Mon_Wedge_Status
              ; ****************

fb4d 20 21 d5           JSR Mon_Print_CR
fb50 20 c7 f8           JSR Wedge_Prepare
fb53 20 98 f8           JSR Print_Status
fb56 4c b1 d4           JMP Mon_Main

              ; *******
fb59            Mon_Dir
              ; *******

fb59 a0 00              LDY #0
fb5b a9 24              LDA #'$'
fb5d 99 42 03 MoDi_10   STA DOS_Filename,Y
fb60 c8                 INY
fb61 20 f4 d8           JSR Mon_CHRIN
fb64 d0 f7              BNE MoDi_10
fb66 84 d1              STY FNLEN
fb68 20 c8 d6           JSR Set_DOS_FNADR
fb6b 20 21 d5           JSR Mon_Print_CR
fb6e 20 c7 f8           JSR Wedge_Prepare
fb71 20 89 d8           JSR Wedge_Call_Dir
fb74 4c b1 d4           JMP Mon_Main

              ; ****************
fb77            Init_RAM_Vectors
              ; ****************

fb77 a2 0b              LDX #RBVT_END - ROM_BASIC_Vector_Table - 1
fb79 bd 83 fb IRV_10    LDA ROM_BASIC_Vector_Table,X
fb7c 9d 00 03           STA IERROR,X
fb7f ca                 DEX
fb80 10 f7              BPL IRV_10
fb82 60                 RTS ;Size   12 [Init_RAM_Vectors]

              ; **********************
fb83            ROM_BASIC_Vector_Table
              ; **********************

fb83 d2 b3              .WORD DEF_ERROR     ; $0300 IERROR
fb85 09 b4              .WORD DEF_MAIN      ; $0302 IMAIN
fb87 fe b4              .WORD DEF_CRUNCH    ; $0304 ICRNCH
fb89 ab b6              .WORD DEF_QPLOP     ; $0306 IQPLOP
fb8b 7c b7              .WORD DEF_GONE      ; $0308 IGONE
fb8d 81 be              .WORD DEF_EVAL      ; $030a IEVAL
fb8f          RBVT_END
fb8f 00 00 00           .FILL $fbc4 - * (0) ; 53 bytes

              ; **********
fbc4            Set_STATUS
              ; **********

fbc4 05 96              ORA STATUS
fbc6 85 96              STA STATUS
fbc8 60                 RTS ;Size    5 [Set_STATUS]


              ; *********
fbc9            Mon_Get_3
              ; *********

fbc9 20 6d d7           JSR Hex_To_STAL
fbcc 90 11              BCC MG3_Err
fbce a2 fd              LDX #MEMUSS
fbd0 20 6f d7           JSR Read_Hex_Word
fbd3 90 0a              BCC MG3_Err
fbd5 a2 f9              LDX #BPTR
fbd7 20 6f d7           JSR Read_Hex_Word
fbda 90 03              BCC MG3_Err
fbdc a0 00              LDY #0
fbde 60                 RTS ;Size   22 [Mon_Get_3]
fbdf 68       MG3_Err   PLA
fbe0 68                 PLA
fbe1 4c ac d4           JMP Mon_Error

              ; ***********
fbe4            Mon_Compare
              ; ***********

fbe4 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fbe7 20 21 d5           JSR Mon_Print_CR
fbea a9 f9    MoCo_10   LDA #BPTR
fbec 8d 81 02           STA Bank_Fetch+7
fbef a5 b7              LDA W_Bank
fbf1 20 7c 02           JSR Bank_Fetch+2    ; LDA (BPTR),Y
fbf4 85 bf              STA Mon_A
fbf6 a9 fb              LDA #STAL
fbf8 8d 81 02           STA Bank_Fetch+7
fbfb 20 7a 02           JSR Bank_Fetch      ; LDA (STAL),Y
fbfe c5 bf              CMP Mon_A
fc00 f0 06              BEQ MoCo_20
fc02 20 50 d7           JSR Mon_Print_STAL
fc05 20 1e d5           JSR Mon_Print_Blank
fc08 20 13 fb MoCo_20   JSR Inc_STAL
fc0b 20 1f fb           JSR Inc_BPTR
fc0e 20 ee d5           JSR Cmp_STAL_MEMUSS
fc11 b0 d7              BCS MoCo_10
fc13 4c b1 d4           JMP Mon_Main

              ; ************
fc16            Mon_Transfer
              ; ************

fc16 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fc19 a5 f9              LDA BPTR            ; BPTR > STAL ?
fc1b c5 fb              CMP STAL
fc1d a5 fa              LDA BPTR+1
fc1f e5 fc              SBC STAL+1
fc21 b0 17              BCS MoTr_20         ; BPTR > STAL: copy backward
fc23 20 7a 02 MoTr_10   JSR Bank_Fetch
fc26 20 8b 02           JSR Bank_Store
fc29 20 13 fb           JSR Inc_STAL
fc2c 20 1f fb           JSR Inc_BPTR
fc2f 20 ee d5           JSR Cmp_STAL_MEMUSS
fc32 b0 ef              BCS MoTr_10
fc34 4c b1 d4 MoTr_Ret  JMP Mon_Main
fc37 4c ac d4 MoTr_Err  JMP Mon_Error
fc3a 38       MoTr_20   SEC
fc3b a5 fd              LDA MEMUSS          ; exchange STAL <-> MEMUSS
fc3d a6 fb              LDX STAL
fc3f 86 fd              STX MEMUSS
fc41 85 fb              STA STAL
fc43 e5 fd              SBC MEMUSS
fc45 85 bf              STA Mon_A           ; Mon_A = MEMUSS - STAL
fc47 a5 fe              LDA MEMUSS+1
fc49 a6 fc              LDX STAL+1
fc4b 86 fe              STX MEMUSS+1
fc4d 85 fc              STA STAL+1
fc4f e5 fe              SBC MEMUSS+1
fc51 85 c0              STA Mon_A+1
fc53 90 e2              BCC MoTr_Err        ; Error: MEMUSS < STAL
fc55 18                 CLC
fc56 a5 f9              LDA BPTR            ; BPTR += (MEMUSS - STAL)
fc58 65 bf              ADC Mon_A
fc5a 85 f9              STA BPTR
fc5c a5 fa              LDA BPTR+1
fc5e 65 c0              ADC Mon_A+1
fc60 85 fa              STA BPTR+1
fc62 20 7a 02 MoTr_30   JSR Bank_Fetch
fc65 20 8b 02           JSR Bank_Store
fc68 20 ee d5           JSR Cmp_STAL_MEMUSS ; STAL == MEMUSS -> finished
fc6b b0 c7              BCS MoTr_Ret
fc6d a5 fb              LDA STAL
fc6f d0 02              BNE MoTr_40
fc71 c6 fc              DEC STAL+1
fc73 c6 fb    MoTr_40   DEC STAL
fc75 a5 f9              LDA BPTR
fc77 d0 02              BNE MoTr_50
fc79 c6 fa              DEC BPTR+1
fc7b c6 f9    MoTr_50   DEC BPTR
fc7d 4c 62 fc           JMP MoTr_30

              ; ********
fc80            Mon_Hunt
              ; ********

fc80 20 1b d6           JSR Mon_Get_Addr    ; get range
fc83 a0 00              LDY #0
fc85 20 f4 d8 MoHu_10   JSR Mon_CHRIN       ; skip blanks
fc88 f0 5b              BEQ MoHu_Err
fc8a c9 20              CMP #' '
fc8c f0 f7              BEQ MoHu_10
fc8e c9 22              CMP #$22            ; quote ?
fc90 f0 16              BEQ MoHu_40         ; string
fc92 20 83 d7           JSR Read_Hex_A      ; get first byte
fc95 90 4e              BCC MoHu_Err
fc97 b0 05              BCS MoHu_30         ; continue reading hex
fc99 20 7c d7 MoHu_20   JSR Read_Hex        ; loop for reading hex bytes
fc9c 90 1b              BCC MoHu_50         ; end of line
fc9e 99 42 03 MoHu_30   STA DOS_Filename,Y
fca1 c8                 INY
fca2 c0 10              CPY #16
fca4 90 f3              BCC MoHu_20
fca6 b0 11              BCS MoHu_50
fca8 20 f4 d8 MoHu_40   JSR Mon_CHRIN       ; loop for reading string
fcab f0 0c              BEQ MoHu_50
fcad c9 22              CMP #$22            ; quote
fcaf f0 08              BEQ MoHu_50
fcb1 99 42 03           STA DOS_Filename,Y
fcb4 c8                 INY
fcb5 c0 10              CPY #16
fcb7 90 ef              BCC MoHu_40
fcb9 84 b5    MoHu_50   STY MONCNT
fcbb 20 21 d5           JSR Mon_Print_CR
fcbe 20 35 f3 MoHu_60   JSR Check_STOP_Key  ; STOP key pressed?
fcc1 f0 1f              BEQ MoHu_Ret
fcc3 20 e3 d5           JSR Mon_Cmp_Addr
fcc6 90 1a              BCC MoHu_Ret
fcc8 a0 00              LDY #0
fcca 20 7a 02 MoHu_70   JSR Bank_Fetch
fccd d9 42 03           CMP DOS_Filename,Y
fcd0 d0 0b              BNE MoHu_80         ; no match
fcd2 c8                 INY
fcd3 c4 b5              CPY MONCNT
fcd5 90 f3              BCC MoHu_70
fcd7 20 50 d7           JSR Mon_Print_STAL
fcda 20 1e d5           JSR Mon_Print_Blank
fcdd 20 13 fb MoHu_80   JSR Inc_STAL
fce0 d0 dc              BNE MoHu_60
fce2 4c b1 d4 MoHu_Ret  JMP Mon_Main
fce5 4c ac d4 MoHu_Err  JMP Mon_Error


fce8 00 00 00           .FILL $fd16 - * (0) ; 46 bytes

              ; ***********
fd16            Entry_RESET
              ; ***********

fd16 a2 ff              LDX #$ff
fd18 78                 SEI
fd19 9a                 TXS
fd1a d8                 CLD
fd1b 20 37 e0           JSR EDIT_RESET
fd1e a9 ff              LDA #<Basic_Ready
fd20 85 94              STA NMINV
fd22 a9 b3              LDA #>Basic_Ready
fd24 85 95              STA NMINV+1
fd26 a9 51              LDA #<MONITOR_BREAK
fd28 85 92              STA CBINV
fd2a a9 d4              LDA #>MONITOR_BREAK
fd2c 85 93              STA CBINV+1
fd2e a9 ac              LDA #<Mon_Error
fd30 8d fa 03           STA Reset_Vector
fd33 a9 d4              LDA #>Mon_Error
fd35 8d fb 03           STA Reset_Vector+1
fd38 a9 00              LDA #0
fd3a 8d fc 03           STA Ignore_Timeout
fd3d 58                 CLI
fd3e 4c b6 d3           JMP Init_BASIC_RAM_Vectors

fd41 00 00 00           .FILL $fd49 - * (0) ; 8 bytes

              ; *********
fd49            Entry_NMI
              ; *********

fd49 6c 94 00           JMP (NMINV)

              ; ***********
fd4c            Set_FA_to_8
              ; ***********

fd4c a2 08              LDX #8
fd4e 86 d4              STX FA
fd50 60                 RTS ;Size    5 [Set_FA_to_8]

              ; ********
fd51            Mon_Unit
              ; ********

fd51 20 7c d7           JSR Read_Hex
fd54 90 0a              BCC MoUn_10
fd56 c9 10              CMP #16
fd58 b0 06              BCS MoUn_10
fd5a c9 04              CMP #4
fd5c 90 02              BCC MoUn_10
fd5e 85 ab              STA Wedge_Unit
fd60 20 1e d5 MoUn_10   JSR Mon_Print_Blank
fd63 a5 ab              LDA Wedge_Unit
fd65 20 57 d7           JSR Print_Hex_Byte
fd68 20 21 d5           JSR Mon_Print_CR
fd6b 4c b1 d4           JMP Mon_Main

              ; ********
fd6e            Mon_Next
              ; ********

fd6e 78                 SEI
fd6f a9 89              LDA #<Mon_Step_IRQ
fd71 85 90              STA CINV
fd73 a9 fd              LDA #>Mon_Step_IRQ
fd75 85 91              STA CINV+1
fd77 a9 a0              LDA #$a0            ; enable T2 time out interrupt
fd79 8d 4e e8           STA VIA_IER         ; interrupt enable register
fd7c a9 2f              LDA #47             ; overhead + 1 cycle
fd7e 8d 48 e8           STA VIA_Timer_2_Lo
fd81 a9 00              LDA #0
fd83 8d 49 e8           STA VIA_Timer_2_Hi  ; trigger start of timer T2
fd86 4c a7 d6           JMP Mon_Step

              ; ************
fd89            Mon_Step_IRQ
              ; ************

fd89 ad 4d e8           LDA VIA_IFR
fd8c 29 20              AND #$20            ; T2 timeout interrupt ?
fd8e f0 06              BEQ MSI_10
fd90 2c 48 e8           BIT VIA_Timer_2_Lo  ; clear interrupt
fd93 6c 92 00           JMP (CBINV)
fd96 4c 55 e4 MSI_10    JMP IRQ_NORMAL


              ; ************
fd99            Get_Constant
              ; ************

fd99 20 05 d9           JSR Is_Int
fd9c 90 51              BCC GeCo_Ret
fd9e c9 24              CMP #'$'
fda0 d0 50              BNE GeCo_45
fda2 20 f4 d8 GeCo_10   JSR Mon_CHRIN       ; parse hex constant
fda5 20 11 d9           JSR Is_Hex
fda8 90 25              BCC GeCo_30
fdaa 20 fa d8           JSR Hex_To_Bin
fdad a2 04              LDX #4
fdaf 06 c2    GeCo_20   ASL Mon_Lo
fdb1 26 c3              ROL Mon_Hi
fdb3 ca                 DEX
fdb4 d0 f9              BNE GeCo_20
fdb6 05 c2              ORA Mon_Lo
fdb8 85 c2              STA Mon_Lo
fdba 4c a2 fd           JMP GeCo_10
fdbd a6 cb    GeCo_25   LDX Mon_Tmp
fdbf e0 2d              CPX #'-'
fdc1 d0 0c              BNE GeCo_30
fdc3 a6 c3              LDX Mon_Hi
fdc5 d0 28              BNE GeCo_Ret        ; no negative 16 bit values
fdc7 48                 PHA
fdc8 a9 00              LDA #0
fdca e5 c2              SBC Mon_Lo          ; carry was set from CPX
fdcc 85 c2              STA Mon_Lo
fdce 68                 PLA
fdcf 48       GeCo_30   PHA                 ; push char after constant
fdd0 a9 24              LDA #'$'
fdd2 99 c1 02           STA Ass_Buf,Y
fdd5 c8                 INY
fdd6 98                 TYA
fdd7 18                 CLC
fdd8 69 10              ADC #16
fdda a8                 TAY
fddb a5 c3              LDA Mon_Hi
fddd 85 cc              STA Mon_ZP
fddf f0 03              BEQ GeCo_40
fde1 20 e2 f9           JSR Store_Hex
fde4 a5 c2    GeCo_40   LDA Mon_Lo
fde6 20 e2 f9           JSR Store_Hex
fde9 98                 TYA
fdea 38                 SEC
fdeb e9 10              SBC #16
fded a8                 TAY
fdee 68                 PLA                 ; pop char after constant
fdef c9 0d    GeCo_Ret  CMP #CR             ; EOI
fdf1 60                 RTS ;Size   89 [Get_Constant]
fdf2 85 cb    GeCo_45   STA Mon_Tmp         ; save sign
fdf4 c9 2b              CMP #'+'
fdf6 f0 15              BEQ GeCo_70
fdf8 c9 2d              CMP #'-'
fdfa f0 11              BEQ GeCo_70
fdfc a6 c2    GeCo_50   LDX Mon_Lo
fdfe 86 11              STX LINNUM
fe00 a6 c3              LDX Mon_Hi
fe02 86 12              STX LINNUM+1
fe04 20 0d b9           JSR Dec_Char
fe07 85 c2              STA Mon_Lo
fe09 a5 12              LDA LINNUM+1
fe0b 85 c3              STA Mon_Hi
fe0d 20 f4 d8 GeCo_70   JSR Mon_CHRIN
fe10 20 19 d9           JSR Is_Dec
fe13 b0 e7              BCS GeCo_50
fe15 90 a6              BCC GeCo_25         ; finished


              ; **************
fe17            Expand_Address
              ; **************

fe17 ac c0 02           LDY Ass_Buf_Length
fe1a b9 c0 02 ExAd_10   LDA Ass_Buf-1,Y
fe1d c9 24              CMP #'$'
fe1f f0 06              BEQ ExAd_20
fe21 99 c2 02           STA Ass_Buf+1,Y
fe24 88                 DEY
fe25 d0 f3              BNE ExAd_10
fe27 a9 30    ExAd_20   LDA #'0'
fe29 99 c1 02           STA Ass_Buf,Y
fe2c 99 c2 02           STA Ass_Buf+1,Y
fe2f ee c0 02           INC Ass_Buf_Length
fe32 ee c0 02           INC Ass_Buf_Length
fe35 60                 RTS ;Size   31 [Expand_Address]

              ; *************
fe36            Expand_Target
              ; *************

              ; Take branch offset, stored in Mon_Lo
              ; Convert it it to ASCII target of format $xxxx
              ; Store it in Ass_Buf after the branch mnemonic
              ; E.g.: BEQ $1234
              ;       ^   ^    ^
              ;       0   4    9

fe36 a9 24              LDA #'$'
fe38 8d c5 02           STA Ass_Buf+4
fe3b a0 15              LDY #21             ; 5 + 16
fe3d 20 46 fe           JSR Offset_To_Target
fe40 20 dc f9           JSR Store_Hex_XA
fe43 a0 09              LDY #9              ; length of branch instruction
fe45 60                 RTS ;Size   16 [Expand_Target]


              ; ****************
fe46            Offset_To_Target
              ; ****************

              ; Input:  Mon_Lo  = Offset
              ;         STAL    = PC
              ; Output: X       = Target Hi
              ;         A       = Target Lo

fe46 a6 fc              LDX STAL+1
fe48 a5 c2              LDA Mon_Lo
fe4a 10 01              BPL OTT_10
fe4c ca                 DEX
fe4d 18       OTT_10    CLC
fe4e 65 fb              ADC STAL
fe50 90 01              BCC OTT_20
fe52 e8                 INX
fe53 18       OTT_20    CLC
fe54 69 02              ADC #2
fe56 90 01              BCC OTT_30
fe58 e8                 INX
fe59 60       OTT_30    RTS ;Size   20 [Offset_To_Target]

fe5a                    .SIZE ;   20 [Offset_To_Target]

              ; *******
fe5a            Replace
              ; *******

fe5a 20 76 00           JSR CHRGOT
fe5d c9 22              CMP #QUOTE
fe5f f0 06              BEQ Repl_00
fe61 20 fb b4           JSR Tokenize_Line
fe64 20 70 00           JSR CHRGET
fe67 85 23    Repl_00   STA RENNEW          ; 1st. delimiter
fe69 a6 77              LDX TXTPTR
fe6b e8       Repl_01   INX
fe6c bd 00 02           LDA BUF,X
fe6f f0 4a              BEQ Repl_Err
fe71 c5 23              CMP RENNEW          ; 2nd. delimiter ?
fe73 d0 f6              BNE Repl_01
fe75 86 25              STX RENNEW+2        ; remember position
fe77 a9 00              LDA #0
fe79 9d 00 02           STA BUF,X
fe7c 8a                 TXA
fe7d 18                 CLC                 ; subtract one more
fe7e e5 77              SBC TXTPTR
fe80 85 26              STA RENNEW+3        ; length of search string
fe82 e8       Repl_02   INX
fe83 bd 00 02           LDA BUF,X
fe86 f0 33              BEQ Repl_Err
fe88 c5 23              CMP RENNEW          ; 3rd. delimiter ?
fe8a d0 f6              BNE Repl_02
fe8c a9 00              LDA #0
fe8e 9d 00 02           STA BUF,X
fe91 8a                 TXA
fe92 18                 CLC                 ; subtract one more
fe93 e5 25              SBC RENNEW+2
fe95 85 27              STA RENNEW+4        ; length of replace string
fe97 20 22 ed           JSR Reset_Renumber_Pointer
fe9a a0 03    Repl_08   LDY #3
fe9c 84 24              STY RENNEW+1        ; start position for scan
fe9e 20 35 f3 Repl_10   JSR Check_STOP_Key  ; STOP key pressed?
fea1 f0 15              BEQ Repl_Ret
fea3 20 9a ed           JSR Contains_Pattern
fea6 d0 08              BNE Repl_20
fea8 20 be fe           JSR Replace_String
feab e6 24              INC RENNEW+1
fead 4c 9e fe           JMP Repl_10
feb0 20 33 ed Repl_20   JSR Update_Link
feb3 d0 e5              BNE Repl_08
feb5 20 f0 b5           JSR Reset_Variable_Pointer
feb8 4c ff b3 Repl_Ret  JMP Basic_Ready
febb 4c 00 bf Repl_Err  JMP Syntax_Error


              ; **************
febe            Replace_String
              ; **************

febe 38                 SEC
febf a5 27              LDA RENNEW+4        ; length of replacement string
fec1 e5 26              SBC RENNEW+3        ; length of search string
fec3 85 23              STA RENNEW          ; difference
fec5 d0 20              BNE ReSt_30
fec7 98       ReSt_05   TYA
fec8 38                 SEC
fec9 e5 26              SBC RENNEW+3        ; length of search string
fecb a8                 TAY
fecc a6 25              LDX RENNEW+2        ; position of replacement
fece e8       ReSt_10   INX
fecf bd 00 02           LDA BUF,X
fed2 f0 05              BEQ ReSt_20
fed4 91 5c              STA (TMPPTC),Y
fed6 c8                 INY
fed7 d0 f5              BNE ReSt_10         ; always
fed9 a5 23    ReSt_20   LDA RENNEW
fedb f0 03              BEQ ReSt_25
fedd 20 b6 b4           JSR Rechain
fee0 20 ce ea ReSt_25   JSR List_BASIC_Line
fee3 20 21 d5           JSR Mon_Print_CR
fee6 60                 RTS ;Size   41 [Replace_String]
fee7 90 38    ReSt_30   BCC ReSt_50
fee9 98                 TYA
feea 48                 PHA
feeb a5 5c              LDA TMPPTC
feed 48                 PHA
feee a5 5d              LDA TMPPTC+1
fef0 48                 PHA
fef1 18                 CLC
fef2 98                 TYA
fef3 65 5c              ADC TMPPTC
fef5 85 5c              STA TMPPTC
fef7 90 02              BCC ReSt_35
fef9 e6 5d              INC TMPPTC+1
fefb a5 2a    ReSt_35   LDA VARTAB          ; search str < replace str
fefd 85 57              STA TMPPTB
feff 65 23              ADC RENNEW
ff01 85 55              STA TMPPTA
ff03 a4 2b              LDY VARTAB+1
ff05 84 58              STY TMPPTB+1
ff07 90 01              BCC ReSt_40
ff09 c8                 INY
ff0a 84 56    ReSt_40   STY TMPPTA+1
ff0c 20 50 b3           JSR Open_Up_Space
ff0f a5 2e              LDA STREND
ff11 85 2a              STA VARTAB
ff13 a5 2f              LDA STREND+1
ff15 85 2b              STA VARTAB+1
ff17 68                 PLA
ff18 85 5d              STA TMPPTC+1
ff1a 68                 PLA
ff1b 85 5c              STA TMPPTC
ff1d 68       ReSt_45   PLA
ff1e a8                 TAY
ff1f d0 a6              BNE ReSt_05         ; always
ff21 98       ReSt_50   TYA
ff22 48                 PHA
ff23 65 5c              ADC TMPPTC
ff25 85 55              STA TMPPTA
ff27 a5 5d              LDA TMPPTC+1
ff29 69 00              ADC #0
ff2b 85 56              STA TMPPTA+1
ff2d 38                 SEC
ff2e a5 26              LDA RENNEW+3        ; length of search string
ff30 e5 27              SBC RENNEW+4        ; length of replacement string
ff32 85 23              STA RENNEW
ff34 38                 SEC
ff35 a5 55              LDA TMPPTA
ff37 e5 23              SBC RENNEW
ff39 85 57              STA TMPPTB
ff3b a5 56              LDA TMPPTA+1
ff3d e9 00              SBC #0
ff3f 85 58              STA TMPPTB+1
ff41 a0 00              LDY #0
ff43 b1 55    ReSt_60   LDA (TMPPTA),Y
ff45 91 57              STA (TMPPTB),Y
ff47 e6 57              INC TMPPTB
ff49 d0 02              BNE ReSt_62
ff4b e6 58              INC TMPPTB+1
ff4d e6 55    ReSt_62   INC TMPPTA
ff4f d0 02              BNE ReSt_64
ff51 e6 56              INC TMPPTA+1
ff53 a5 2a    ReSt_64   LDA VARTAB
ff55 c5 55              CMP TMPPTA
ff57 d0 ea              BNE ReSt_60
ff59 a6 2b              LDX VARTAB+1
ff5b e4 56              CPX TMPPTA+1
ff5d d0 e4              BNE ReSt_60
ff5f e5 23              SBC RENNEW
ff61 85 2a              STA VARTAB
ff63 85 2e              STA STREND
ff65 8a                 TXA
ff66 e9 00              SBC #0
ff68 85 2b              STA VARTAB+1
ff6a 85 2f              STA STREND+1
ff6c 4c 1d ff           JMP ReSt_45
ff6f 60       ReSt_Ret  RTS ;Size  178 [Replace_String]

ff70 00 00 00           .FILL $ff93-* (0) ; 35 bytes

              ; ************
ff93            Basic_CONCAT
              ; ************

ff93 4c c7 da           JMP Kernal_CONCAT

              ; ***********
ff96            Basic_DOPEN
              ; ***********

ff96 4c 42 d9           JMP Kernal_DOPEN

              ; ************
ff99            Basic_DCLOSE
              ; ************

ff99 4c 07 da           JMP Kernal_DCLOSE

              ; ************
ff9c            Basic_RECORD
              ; ************

ff9c 4c af d7           JMP Kernal_RECORD

              ; ************
ff9f            Basic_HEADER
              ; ************

ff9f 4c d2 d9           JMP Kernal_HEADER

              ; *************
ffa2            Basic_COLLECT
              ; *************

ffa2 4c 65 da           JMP Kernal_COLLECT

              ; ************
ffa5            Basic_BACKUP
              ; ************

ffa5 4c 7e da           JMP Kernal_BACKUP

              ; **********
ffa8            Basic_COPY
              ; **********

ffa8 4c a7 da           JMP Kernal_COPY

              ; ************
ffab            Basic_APPEND
              ; ************

ffab 4c 77 d9           JMP Kernal_APPEND

              ; ***********
ffae            Basic_DSAVE
              ; ***********

ffae 4c 0d db           JMP Kernal_DSAVE

              ; ***********
ffb1            Basic_DLOAD
              ; ***********

ffb1 4c 3a db           JMP Kernal_DLOAD

              ; ***************
ffb4            Basic_DIRECTORY
              ; ***************

ffb4 4c 73 d8           JMP Kernal_DIRECTORY

              ; ************
ffb7            Basic_RENAME
              ; ************

ffb7 4c 55 db           JMP Kernal_RENAME

              ; *************
ffba            Basic_SCRATCH
              ; *************

ffba 4c 66 db           JMP Kernal_SCRATCH

              ; *******
ffbd            Read_DS
              ; *******

ffbd 4c 91 d9           JMP Kernal_Read_DS

              ; ****
ffc0            OPEN
              ; ****

ffc0 4c 60 f5           JMP Kernal_OPEN

              ; *****
ffc3            CLOSE
              ; *****

ffc3 4c dd f2           JMP Kernal_CLOSE

              ; *****
ffc6            CHKIN
              ; *****

ffc6 4c af f7           JMP Kernal_CHKIN

              ; ******
ffc9            CHKOUT
              ; ******

ffc9 4c fe f7           JMP Kernal_CHKOUT

              ; ******
ffcc            CLRCHN
              ; ******

ffcc 4c a6 f2           JMP Kernal_CLRCHN

              ; *****
ffcf            CHRIN
              ; *****

ffcf 4c 15 f2           JMP Kernal_CHRIN

              ; ******
ffd2            CHROUT
              ; ******

ffd2 4c 66 f2           JMP Kernal_CHROUT

              ; **********
ffd5            Basic_LOAD
              ; **********

ffd5 4c 01 f4           JMP Kernal_LOAD

              ; **********
ffd8            Basic_SAVE
              ; **********

ffd8 4c dd f6           JMP Kernal_SAVE

              ; ************
ffdb            Basic_VERIFY
              ; ************

ffdb 4c f6 f4           JMP Kernal_VERIFY

              ; *********
ffde            Basic_SYS
              ; *********

ffde 4c c3 f6           JMP Kernal_SYS

              ; ****
ffe1            STOP
              ; ****

ffe1 4c 43 f3           JMP Kernal_STOP

              ; *****
ffe4            GETIN
              ; *****

ffe4 4c 05 f2           JMP Kernal_GETIN

              ; *****
ffe7            CLALL
              ; *****

ffe7 4c a2 f2           JMP Kernal_CLALL

              ; *****
ffea            UDTIM
              ; *****

ffea 4c 68 f7           JMP Kernal_UDTIM
ffed 8c 8c 8c           .FILL $fffa-* ($8c) ; 13 bytes

              ; ***************
fffa            HardwareVectors
              ; ***************

fffa 49 fd              .WORD Entry_NMI
fffc 16 fd              .WORD Entry_RESET
fffe 42 e4              .WORD IRQ_MAIN


 1867 Symbols
-------------
Basic_USR                      $0000   267D  1143   7080
BSOS_KBD                       $0001    15D 10703  10716  10727  10786
                                     10799  10817  10830  10841  10900
                                     10913
USRVEC                         $0001   268D  7083   7084
CTRLA                          $0001   243D  9462
CTRLB                          $0002   244D  9446   9603
CHARAC                         $0003   270D  2363   2367   2368   3063
                                      3068   3072   3778   3787   4675
                                      4690   6237   6732   6789
CTRLD                          $0004   245D  9458   9613
ENDCHR                         $0004   271D  1706   1754   1757   2365
                                      2366   2369   2372   3075   4676
                                      4692
COUNT                          $0005   272D  1559   1608   1624   1721
                                      1738   1764   4144   4231   4285
                                      4309   4333   4371   4403  11268
                                     11283  11291
DIMFLG                         $0006   279D  3896   4199   4238   4282
                                      4316   4367
BELL                           $0007   246D  9442
VALTYP                         $0007   285D  2489   2776   3056   3246
                                      3294   3316   3423   3609   3829
                                      3913   3927   4202   4234   4474
                                      4490   4735   5188
INTFLG                         $0008   291D  2487   3089   3641   3914
                                      3934   4200   4236
GARBFL                         $0009   306D  1697   1709   1750   3703
                                      3706   3707   3710   4753   4790
                                      4794
TAB                            $0009   247D  9450   9599
SUBFLG                         $000a   312D  1890   2052   3931   3943
                                      3948   4534   4559
INPFLG                         $000b   316D  2891   3018   3037   3058
                                      3140
TANSGN                         $000c   326D  3392   3867   6948   6950
                                      6968   6978
DS_Len                         $000d   330
CR                             $000d   248D  1675   2799   7293   7966
                                      7996   8403   8433   8441   8443
                                      9168   9238   9426   9583  11599
                                     11832  11955  12445  13371  13797
CTRLN                          $000e   249D  9444   9609
DS_Ptr                         $000e   331
CTRLO                          $000f   250D  9448   9607
IOPMPT                         $0010   338D  1498   2752   2792   2866
                                      2901   2925   2932   2945   2952
                                      2955   2979   2998   3046   3146
                                      3557   7090
LINNUM                         $0011   346D  1616   1617   1800   1805
                                      1925   1926   1928   1951   1953
                                      2286   2433   2434   2436   2457
                                      2459   2461   2462   2463   2465
                                      2466   2467   2468   2470   2471
                                      2473   5298   5299   5306   5308
                                      5312y  5315   5317   5327y  5342y
                                      7095   7096   7101y  7104y  7105y
                                      7108y  7109y  7112y  7115   7117
                                      8213   8215   8854   8856   8859
                                      8866   8868   8870   8972   8975
                                      9838   9839   9841  10570  10572
                                     10668  10671  11025  11026  11043
                                     11047  11051  11054  11204  11206
                                     11476  11477  11612  11614  12669
                                     12877  13805  13807  13810
DOWN                           $0011   251D  9438   9593
RVS                            $0012   252D  9440   9595
HOME                           $0013   253D  9460   9597
TEMPPT                         $0013   351D  1879   4719   4740   5062
LASTPT                         $0014   356D  4736   5058   5060   5064
                                      7091
DEL                            $0014   254D  9432   9587
CTRLU                          $0015   255D  9456   9611
CTRLV                          $0016   256D  9454   9601
TEMPST                         $0016   363D  1878   4720
CTRLY                          $0019   257D  9452   9605
ESC                            $001b   258D  9428
RIGHT                          $001d   259D  2870   9436   9591
INDEXA                         $001f   367D  1399   1409   1415   1564
                                      1566   1589   1591   1593y  1597
                                      1649y  1653   1656y  1658   1660y
                                      1661   1662   1663y  1724   1726
                                      1729   1731   1734y  1765y  1767
                                      1769   1772y  2021   2023   2027
                                      2029   2030y  2034y  2560y  2634
                                      2635   2648   2650   2681y  2685y
                                      2688y  2695   2696   2700   2702
                                      2853y  3299   3301   3356   3358
                                      3373   3375   4046   4047   4049y
                                      4052y  4055y  4059y  4067y  4071
                                      4072   4074   4075   4081y  4085y
                                      4089y  4098   4101   4105   4106
                                      4108   4332   4400   4433   4760
                                      4763   4768   4780y  4783y  4835
                                      4837   4840y  4850   4854y  4865y
                                      4875y  4878y  4968   4969   4979y
                                      5012   5013   5023   5024   5039y
                                      5042y  5045y  5047   5048   5106
                                      5107   5109   5199y  5239   5242
                                      5244   5755   5756   5758y  5761y
                                      5764y  5767y  5775y  5955   5956
                                      5958y  6010   6011   6014y  6017y
                                      6020y  6025y  6028y  8675y  8791y
                                      8797   8799   8809   8810  10219
                                     10222  12366  12368
RENINC                         $0021   375D  8846   8849   8867   8871
                                      8921   8924   9830   9832   9848y
                                      9851   9855   9856
INDEXB                         $0021   371D  1568   1575   1587   1594y
                                      1598   3187   5243   5248   5250y
                                      5253y  5258y  6140   6146   6148y
                                      6152y  6157y  6162y  6166y  6172
QUOTE                          $0022   260D  1988   1997   2375   2964
                                      3069   3442   4674   4694   7596
                                      7600   8595   8702   9255   9259
                                     11153  11159  11385  11408  13886
RENNEW                         $0023   388D  8847   8850   8855   8860
                                      8880   8883   8911   8914   8920
                                      8922   8923   8925   8994   9006
                                     11306  11309  11323  11328  11332
                                     13890  13895  13897  13903  13907
                                     13913  13914  13917  13923  13937
                                     13938  13939  13943  13945  13952
                                     13973  14000  14001  14002  14005
                                     14025
FAC3M1                         $0023   379D  5588   5591   5690   5731
                                      5733   5734   5941
FAC3M2                         $0024   380D  5586   5589   5691   5728
                                      5730   5735   5943
FAC3M3                         $0025   381D  4414   4435   4460   5584
                                      5587   5692   5725   5727   5736
                                      5945
FAC3M4                         $0026   382D  4443   4463   5582   5585
                                      5693   5722   5724   5737   5890
                                      5947
FAC3M5                         $0027   384
TXTTAB                         $0028   392D  1643   1644   1786   1787
                                      1829y  1831y  1832   1836   1898
                                      1901   2191   2193   2295   2296
                                      6420   6421   7094   7100   7128
                                      7131  10214y 10216y 10596  10599
                                     10657  10658  11234  11236  12278
                                     12279  12679  12681
VARTAB                         $002a   396D  1565   1573   1574   1576
                                      1578   1583   1606   1610   1622
                                      1623   1835   1838   1866   1867
                                      2606   2610   3949   3950   6431
                                      6433   9016   9017   9845  12201
                                     12204  12222  12224  12675  12677
                                     13971  13975  13982  13984  14019
                                     14022  14026  14030
ARYTAB                         $002c   400D  1868   1869   3953   3955
                                      4014   4015   4032   4033   4239
                                      4240
STREND                         $002e   404D  1394   1395   1620   1621
                                      1870   1871   4018   4019   4042
                                      4044   4243   4245   4345   4346
                                      4359   4363   4480   4483   4771
                                      4774  11343  11465  11544y 11575y
                                     13981  13983  14027  14031
FRETOP                         $0030   408D  1458   1461   1470   1473
                                      1859   1860   2599   2603   2690
                                      2693   4092   4095   4479   4482
                                      4758   4761   4786   4787   4811
                                      4813   4881   4883   5025   5027
                                      5032   5035   7120   7121  11352
FRESPC                         $0032   412D  4776   4777   4784   4785
                                      4805   4808   4845   4847   4848
                                      4851y  4853   4855   4857   4861
                                      4868y  4872y  4874   4877   4880
                                      4882   4980y  4985   4986   4988
MEMSIZ                         $0034   416D  1857   1858   4804   4807
                                      7118   7119   7126   7130
CURLIN                         $0036   422D  1512   1544   2071   2073
                                      2126   2129   2214   2219   2220
                                      2245   2246   2267   2269   2285
                                      2325   2327   2898   2899   3205
                                      3207   4513   6447   6448
OLDLIN                         $0038   427D  2221   2222   2243   2244
OLDTXT                         $003a   434D  1889   2115   2116   2217
                                      2218   2237   2240   2908   2909
DATLIN                         $003c   442D  2896   2897   3125   3129
DATPTR                         $003e   448D  2196   2197   3008   3009
INPPTR                         $0040   454D  3019   3020   3031   3032
                                      3102   3103   3138   3139   3144
VARNAM                         $0042   464D  3607   3608   3902   3935
                                      3936   3941   3957   3960   3995
                                      3996   4112   4115   4207   4209
                                      4213   4215   4250   4252   4298
                                      4303   4407   4410
VARPTR                         $0044   470D  4134   4135   4419   4422
                                      4424   4541   4543   4581   4586
                                      4588y  4592   4603   4605   6606
                                      6618
FORPNT                         $0046   475D  1365   1368   1370   1373
                                      2096   2098   2313   2483   2484
                                      2507y  2510y  2520   2639   2642
                                      2647   2649   2663y  3025   3026
                                      3175   3176   3194   3195   5335
                                      5340   5343   5344   6002   6003
YSAVE                          $0048   481D  3029   3030   3104   3105
                                      3310   3389
ACCSYM                         $004a   485D  3273   3282   3283   3285
                                      3289   3324   3339   3830
FUNCPT                         $004b   491D  4561   4562   4576   4578
                                      4580y  4584y  4598y  4601y  4609
                                      4611   4621y  4624y  4627y  4630y
                                      4633y  4806   4809   4812   4814
                                      4817   4819   4821   4824y  4828
                                      4829y  4830   4832   4836y  4839
                                      4841   4843   4859   4862   4867y
                                      4871y  6721   6722   6727   6728
                                      6737   6738   6970   6971   6980
                                      6981
DESCPT                         $004d   495D  2632   2633   2662y  4657
                                      4658   4939   4940   5089y  5092y
                                      5099   5100   5120y  5142y  5164
                                      5166
INDEXC                         $004f   499D  2640y  2643y  2654y  2657y
                                      2701   2704   5019y  5022y  5030
                                      5033
JUMPER                         $0051   504D  3763   7079
FUNJMP                         $0052   509D  3760   3762   5158   5167
                                      5389   5419   5433   5484   6782
                                      6799
FACTPA                         $0054   514D  5994   5995   6821   6824
                                      6825   6973   6974
TMPPTA                         $0055   515D  1414   1416   1418   1421y
                                      1425y  1427   1609   1614   4026
                                      4027   4029   4030   4034   4035
                                      4040   4041   4056   4057   4060
                                      4061   4076   4078   4151   4152
                                      4335   4337   4340   4352y  4354
                                      4357   4418   4421  13974  13979
                                     13995  13998  14004  14007  14011y
                                     14016  14018  14020  14023
TMPPTB                         $0057   516D  1397   1401   1407   1410
                                      1412   1420y  1424y  1426   1607
                                      1611   4020   4021   4086   4091
                                      4099y  4102y  8879y  8882y 10601
                                     10603  10659  10660  10674  10676
                                     13972  13976  14006  14009  14012y
                                     14013  14015
FACTPB                         $0059   521D  5987   6859   6860
TMPVAR                         $005a   522D  3618   3622   4445   4466
                                      6256   6288   6295   6297   6298
                                      6303   6308   6320   6345   6355
                                      6362   6482   6514   6523   6529
                                      6545   6556   6557   6612   6639
                                      6644
TMPPTC                         $005c   523D  1398   1402   1563y  1567
                                      1569   1571y  1579   1582   1627y
                                      1794   1795   1796y  1801y  1806y
                                      1810y  1936y  1944y  1947y  1965y
                                      1968y  1969   1970   1994y  2003y
                                      2299   2302   3951   3952   3958y
                                      3962y  3967   4016   4017   4113y
                                      4116y  4119y  4121y  4123y  4125y
                                      4127y  4128   4131   4147   4148
                                      4241   4242   4248y  4253y  4256y
                                      4258   4261y  4262   4287y  4299y
                                      4304y  4313y  4325y  4328y  4360
                                      4362y  4365   4366y  4370y  4381y
                                      4386y  4434y  4437y  6281   6284
                                      6291   6292   6318   6349   8899y
                                      8905y  8908y  8956y  8959y  8966y
                                      8969y  9005y  9012   9015   9829
                                      9831   9847y  9852   9853  10595
                                     10598  10602  10604  10624y 10627y
                                     10628  10629  10642y 10645y 10648y
                                     10661  10662  10664y 10667y 10670y
                                     10673  10675  10679y 10682y 11141
                                     11144  11235  11237  11254y 11257y
                                     11258  11259  11330y 11333y 13949y
                                     13961  13963  13967  13968  13970
                                     13986  13988  13994  13996
FAC1EX                         $005e   527D  2389   2527   2627   2628
                                      3371   3407   3832   3842   3846
                                      4182   4667   4697   4724   4890
                                      5292   5371   5410   5413   5420
                                      5427   5480   5508   5512   5519
                                      5652   5656   5777   5787   5794
                                      5827   5868   5869   5871   5959
                                      5968   6027   6045   6062   6073
                                      6090   6124   6155   6188   6225
                                      6230   6340   6499   6749   6784
                                      6794   6795   6908   6911   7014
FAC1M1/FAC1M2                  $005f   528D  2080   2081   3369   3678
                                      3833   3859y  4491   4665   4684
                                      4726   5079y  5446   5460   5463
                                      5495   5497   5505   5521   5540
                                      5542   5568   5702   5876   5914
                                      5942   5964   5967   5975   6024
                                      6109   6113   6159   6198   6454
                                      6588   6590   6881   6899   6901
                                     11207    529D  2549   3367   3834
                                      4492   4666   4685   4728   5443
                                      5462   5465   5492   5494   5504
                                      5522   5543   5545   5566   5700
                                      5879   5911   5944   5976   6019
                                      6111   6163   6199   6455   6585
                                      6587   6883   6902   6904  11205
FAC1M3/FAC1M4                  $0061   530D  2506   2590y  2593y  2609
                                      2612   2619y  2624   2729   2730
                                      3365   3475   3605   3644y  3647y
                                      3719   3746   3780   3792   3797
                                      4223   4378   4397   4655   4731
                                      4922   4933y  5001   5223   5296
                                      5440   5464   5467   5489   5491
                                      5503   5523   5546   5548   5564
                                      5698   5882   5908   5946   5977
                                      6016   6123   6167   6200   6582
                                      6584   6885   6903   6905    531D
                                      2413   2509   2605   2613   2625
                                      2726   2727   3363   3472   3606
                                      3611   3656   3720   3744   3782
                                      3789   3794   4225   4380   4401
                                      4656   4732   4920   5002   5129
                                      5145   5147   5225   5297   5437
                                      5466   5469   5486   5488   5502
                                      5524   5549   5551   5562   5696
                                      5885   5905   5948   5978   6013
                                      6122   6173   6201   6231   6236
                                      6579   6581   6887   6898   6900
FAC1SI                         $0063   532D  2078   2093   2528   2722
                                      3193   3360   3405   3848   3854
                                      4175   5290   5366   5368   5415
                                      5481   5532   5534   5769   5797
                                      5799   5965   6022   6042   6092
                                      6126   6133   6153   6175   6206
                                      6232   6338   6488   6492   6751
                                      6753   6907   6942   6946   6977
                                      7010   7013   7030
SGNFLG                         $0064   533D  6264   6311   6841   6861
BITS                           $0065   535D  4892   4898   4899   6195
FAC2EX                         $0066   539D  3394   3823   3824   5390
                                      5391   5428   5430   5776   5784
                                      6044   6063   6718   6793   6796
FAC2M1                         $0067   540D  3396   3821   3822   5496
                                      5732   5773   5875   5899   5913
                                      5915
FAC2M2                         $0068   541D  3398   5493   5729   5765
                                      5878   5898   5910   5912
FAC2M3/FAC2M4                  $0069   542D  3400   3835   3838   3858y
                                      5490   5726   5762   5881   5897
                                      5907   5909    543D  3402   3836
                                      3839   5487   5723   5759   5884
                                      5896   5904   5906
FAC2SI                         $006b   544D  3404   3819   5369   5414
                                      5768   5771   6036   6337   6724
                                      6932
STRPTR/FROUND                  $006c   548D  2591   2594   2598   2602
                                      2621   2622   3406   4682   4683
                                      4688y  4699   4701   4705   4711
                                      4712   4927   4929   4931y  4943
                                      4944   4954y  4957y  4960y  5370
                                      5425   5770   5796   5825   5850
                                      6339   6807   6937    553D  4733
                                      4897   5388   5423   5434   5468
                                      5470   5485   5501   5525   5552
                                      5554   5555   5583   5604   5694
                                      5738   5926   5963   6029   6048
                                      6066   6075   6125   6171   6202
                                      6203   6211   6778   6800   6909
TMPPTD                         $006e   557D  1719   1739   2529   2532
                                      2533   2541   3620   4296   4308
                                      4330   4331   4348   4349   4355
                                      4373   4374   4391   4392   4402
                                      4405   4455   4456   4700   4704
                                      5237   5238   5264   5265   6493
                                      6561   6570   6607   6617   6630
                                      6818   6819   6832   6833   6840y
                                      6842   6846   6847   6848   6850
                                      6851   6856   6857
CHRGET                         $0070   577D  1540   1920   2090   2171
                                      2417   2440   2836   2921   3055
                                      3220   3286   3424   3434   3520
                                      3548   3735   3915   3920   3940
                                      4167   5210   6265   6271   6282
                                      7087   8616   8666   8687   8695
                                      8762   8819   8864   8875   9836
                                     11198  11290  11305  12869  12968
                                     13889
CHRGOT                         $0076   578D  1916   2087   2181   2273
                                      2384   2398   2758   3035   3094
                                      3108   3217   3274   3551   3881
                                      3890   3903   4228   4612   5130
                                      5226   5254   5337   7740   7757
                                      7767   8575   8682   8729   8851
                                      8861   8872   9826   9833  10516
                                     11222  12376  12392  12992  13885
TXTPTR                         $0077   579D  1538   1539   1695   1722
                                      1763   1777   1779   1900   1903
                                      2066   2068   2111   2114   2118y
                                      2121y  2125y  2128y  2131   2132
                                      2134   2212   2213   2241   2242
                                      2263   2265   2290   2291   2301
                                      2304   2329   2331   2345   2346
                                      2348   2370y  2910   2911   3027
                                      3028   3033   3034   3050   3051
                                      3061   3076   3077   3100   3101
                                      3106   3107   3121y  3124y  3127y
                                      3130y  3209   3211   3261   3263
                                      3264   3319   3321   3322   3449
                                      3450   3518y  4545   4547   4594
                                      4596   4599   4602   4616   4618
                                      5235   5236   5240   5245   5266
                                      5267   6359y  7057   7059   8656
                                      8658   8659y 10510  10515  11120
                                     11122  11123x 11143  11146  11270
                                     11282  11322  12101  12887y 12908
                                     12909y 12919y 12995  12997y 13002
                                     13004  13891  13902
ISNUM                          $007d   580D  2561
RNDX                           $0088   584D  6889   6890   6913   6914
JIFFY_CLOCK                    $008d   593D  2550   3673   3674  10030
                                     12772  12774  12776  12777  12780
                                     12784  12785
CINV                           $0090   601D  7186   7188   7537   7539
                                      9793  10037  10039  13725  13727
CBINV                          $0092   609D  9792  13674  13676  13744
NMINV                          $0094   614D 13670  13672  13692
STATUS                         $0096   625D  2981   3560   3689   6425
                                      7944   7954   8458   9866  11348
                                     11358  11541  11546  11565  11577
                                     11618  11655  11673  11928  11953
                                     12121  12134  12154  12264  12306
                                     12327  12341  12413  12805  12816
                                     12844  12856  12984  13507  13508
Key_Index                      $0097   630D 10323  10356  10382
Key_Flags                      $0098   639D  6409  10033  10319  10321
                                     10361  10362  10436
Power_Flag                     $0099   644D  9719  10493  10495  10552
                                     10586
Default_Bank                   $009a   651D 10035  11084  11105
Stop_Flag                      $009b   656D 10427  12073
Source_Unit                    $009c   661D  8271   8572   8633   8636
                                     11454  11534  11601  11650
VERCK                          $009d   666D  7588   7608   7633   8374
                                     12137  12191  12198  12215  12252
                                     12325  12886
CharsInBuffer                  $009e   670D  9133   9135   9145   9162
                                     10412  10419  11931  12078  12958
                                     13389
ReverseFlag                    $009f   674D  9266   9481   9629   9730
C3PO                           $00a0   678D 11730  11736  11861  11863
LastInputCol                   $00a1   680D  9178   9186   9234  11951
InputRow                       $00a3   681D  9181   9703  11945
InputCol                       $00a4   682D  9184  11943
BSOUR                          $00a5   693D 11741  11757  11781  11852
                                     11868
SFDX                           $00a6   719D 10324  10428
BLNSW                          $00a7   726D  9146   9800  10061
BLNCT                          $00a8   733D  9154   9274   9802   9805
                                     10060
GDBLN                          $00a9   742D  9155   9811
BLNON                          $00aa   749D  9149   9152   9807   9810
Wedge_Unit                     $00ab   754D  7098  12871  12878  12981
                                     13006  13712  13714
CRSW                           $00ac   759D  9171   9208   9237   9420
                                     11949
Target_Unit                    $00ad   761D 11453  11502  11560  11594
                                     11668
LDTND                          $00ae   768D  8053   8182  11980  12009
                                     12055  12056  12058  12411  12416
DFLTN                          $00af   772D 11929  11940  11990  12002
                                     12819
DFLTO                          $00b0   776D  9240  10043  11966  11986
                                     12000  12859
DOS_FC                         $00b1   786D 11421  11482  11552  11580
DOS_EOF                        $00b2   787D 11547  11583
PC_Adjust                      $00b3   788D  7169   7181   7197   7407
                                     12466  12468
SCROLLING                      $00b4   789
MONCNT                         $00b5   790D  7239   7248   7251   7267
                                      7399   7402   7505   7519  13637
                                     13648
R_Bank                         $00b6   795D  7192   7380   7493   7980
                                      8893   8990  11038  11079
W_Bank                         $00b7   796D  7194   7382   7495   7988
                                      8894   8950  11099  13538
ZP_b8                          $00b8   797
DOS_RL                         $00b9   798D  9874   9878   9880  11475
                                     11490  11513  11525  11549  11554
                                     11566  11585  11659
Dis_Line                       $00ba   799D  7420   7422   7424   7462
                                      7475   9965  13348
DosPtr                         $00bb   800D 11375  11377  11379  11384y
                                     11391  11393  11464  11468
Mon_Format                     $00bd   801D 12549  13184
Dis_Length                     $00be   802D 12483  12493  12551  13187
                                     13195  13353
Mon_A                          $00bf   803D 12748  12754  13185  13200
                                     13205  13540  13544  13578  13584
                                     13588  13591
Mon_B                          $00c0   804D 12750  12753
Mon_Op                         $00c1   805D 12477  12506  13308  13327
                                     13340  13354  13357
Mon_Lo                         $00c2   806D 13203  13288  13292  13309
                                     13761  13765  13766  13775  13776
                                     13790  13804  13809  13866
Mon_Hi                         $00c3   807D 13198  13285  13310  13762
                                     13771  13786  13806  13811
ScrPtr                         $00c4   812D  9157y  9173y  9216y  9272y
                                      9319y  9386y  9388y  9395y  9514y
                                      9552y  9557y  9560y  9564y  9677y
                                      9740y  9808y  9813y 10151  10155
                                     10562y 10612
CursorCol                      $00c6   813D  2809   2828   4500   9078
                                      9156   9185   9215   9232   9285
                                      9311   9330   9366   9369   9383
                                      9385   9421   9473   9556   9647
                                      9648   9675   9721   9806   9899
                                      9902  10556  10576  10590  10610
                                     11942
SAL                            $00c7   815D  9095   9096   9097y  9739y
                                     10125  10129
EAL                            $00c9   816D  6422   6423   6430   6432
                                      7630  11345  11347  11350  11355
                                     11357y 12119  12120  12127  12129
                                     12139y 12144y 12145y 12146y 12148
                                     12150  12203  12206  12221  12223
                                     12234  12236  12280  12281  12676
                                     12678  12716  12718
Mon_Tmp                        $00cb   818D  7513   7516   7722   7727
                                     13768  13799
Mon_ZP                         $00cc   819D 13342  13344  13787
QTSW                           $00cd   839D  9180   9228   9257   9258
                                      9434   9585   9731  10650
BITTS                          $00ce   841
EOT                            $00cf   842
ZD0                            $00d0   843
FNLEN                          $00d1   845D  6416   7613   8296   8513
                                      8569   8671   9883  11413  11480
                                     11512  11515  11516  11527  11528
                                     11642  12113  12265  12295  12314
                                     12342  12365  12702  13001  13472
LA                             $00d2   846D  7746   7936   8173   8197
                                      8565   8609  12026  12038  12346
                                     12401  12417
SA                             $00d3   847D  6419   7590   7626   7934
                                      8059   8117   8211   9870   9987
                                     10007  11538  11563  11572  11597
                                     11604  11653  11671  12028  12115
                                     12168  12171  12208  12267  12277
                                     12298  12340  12352  12419  12421
                                     12701  12706  12735  12814  12854
                                     13436
FA                             $00d4   848D  7619   8111   8114   8181
                                      8273   8574   8775  11452  11455
                                     11503  11535  11561  11595  11602
                                     11651  11669  11740  12030  12109
                                     12269  12274  12349  12423  12696
                                     12818  12858  12982  13007  13699
RigMargin                      $00d5   850D  9170   9275   9308   9320
                                      9349   9367   9390   9472   9515
                                      9551   9567   9640   9741  10565
                                     10613  11950
TAPE1                          $00d6   851
CursorRow                      $00d8   852D  9071   9084   9182   9306
                                      9309   9501   9522   9638   9659
                                      9661   9689   9704   9709  10554
                                     10567  10578  10588  10607  10630
                                     11944
DATAX                          $00d9   853D  9221   9223   9224   9243
                                      9248   9407   9422
FNADR                          $00da   854D  6412   6414   7571   7573
                                      7602y  8298   8300   8515   8517
                                      9885y 11392  11394  11397y 11401y
                                     11404y 11407y 11416y 11431y 11486y
                                     11493y 11498y 11508  11628y 11633y
                                     11640y 11658y 11676y 12311y 12367
                                     12369  13003  13005
INSRT                          $00dc   855D  9269   9271   9430   9566
                                      9569   9589   9729
ROPRTY                         $00dd   856
FSBLK                          $00de   857
ScreenRows                     $00df   858D  9112   9341  10066
TopMargin                      $00e0   859D  9059   9070   9305   9339
                                      9356   9502   9520   9523   9658
                                      9687   9690   9693   9753   9766
                                     10529  10540  10608  10616  10619
                                     10622
BotMargin                      $00e1   860D  9062   9348   9639   9705
                                      9751   9768  10528  10541  10558
LefMargin                      $00e2   861D  9077   9284   9304   9329
                                      9340   9357   9382   9503   9646
                                      9674   9720  10140  10509
XMAX                           $00e3   862D 10041  10413
LSTX                           $00e4   863D 10384  10389  10406
KOUNT                          $00e5   864D 10063  10395  10401
DELAY                          $00e6   865D 10062  10391  10393  10408
CHIME                          $00e7   866D 10082  10095  10104
PrevChar                       $00e8   872D  9296   9527  10029
SCRIV                          $00e9   873D  9202  10075  10076
SCROV                          $00eb   874D  9412  10079  10080
JIFFY6                         $00f8   875D 12786  12789
BPTR                           $00f9   876D  7507   7509   8982   8992
                                      8995   9921   9932   9934  11103y
                                     11244  11246  13350  13352  13422
                                     13423  13425  13521  13536  13559
                                     13561  13587  13589  13590  13592
                                     13601  13603  13604
STAL                           $00fb   877D  7276   7278   7410   7412
                                      7432   7434   7506   7508   7657
                                      7659   7692   8999   9001   9008
                                      9013   9991y 10010y 11035  11037
                                     11082y 12680  12682  12708  12709
                                     12715  12720y 12726  13289  13349
                                     13351  13378  13382  13404  13405
                                     13407  13541  13560  13562  13574
                                     13576  13580  13582  13597  13599
                                     13600  13865  13870
MEMUSS                         $00fd   878D  7431   7433   7464   7465
                                      7472   8299   8301   8312y  8725
                                      8726   9924   9931   9933  13518
                                     13573  13575  13577  13579  13581
                                     13583
STACK                          $0100   887D  1362   1367   1369   1371
                                      1374   3189   3192   3198   3202
                                      3204   3206   3208   3210   4219
                                      4221   4224   4226   4647   4648
                                      6491   6564   6569   6611   6616
                                      6631   6647   6649   6657   6659
                                      6661   6664   6666   9789  11215
BUF                            $0200   892D  1603   1618   1619   1626
                                      1677   1698   1732   1742   1743
                                      1755   1760   1774   1776   2789
                                      2790   2791   2926   2927   2929
                                      2977   2986   3040   3041   3042
                                     11274  11326  13893  13899  13905
                                     13910  13947
LAT                            $0251   894D  8187  12012  12025  12059
                                     12060  12418
FAT                            $025b   895D  8185  12029  12061  12062
                                     12424
SAT                            $0265   896D  8056  12027  12063  12064
                                     12422
KEYD                           $026f   897D  9128   9130   9131   9164
                                     10418  12960  13375  13377  13380
                                     13381  13384  13385  13387
Bank_Fetch                     $027a   908D   907   7242   7255   7515
                                      9004  11040  11046  11050  11053
                                     11069  12505  13356  13537  13539
                                     13542  13543  13564  13593  13644
Bank_Store                     $028b   907D  7514   8906   8909   8912
                                      8915   8943   8957   8960   8973
                                      8976   9937  11151  11157  11166
                                     11182  11217  11223  13355  13565
                                     13594
Mon_Register                   $02a0   909D  7172   7174   7176   7178
                                      7182   7185   7187   7189   7191
                                      7193   7195   7275   7277   7381
                                      7383   7387   7389   7392   7394
                                      7398   7409   7411   7488   7492
                                      7494   7532   7534   7536   7538
                                      7545   7547   7549   7551   7553
                                      7554   7555   7562
Dis_Buf_Length                 $02b0   910D 13219  13259  13333
Dis_Buf                        $02b1   911D 12759  13190  13208  13212
                                     13241  13246  13256  13338
Ass_Buf_Length                 $02c0   912D 13326  13332  13822  13832
                                     13833
Ass_Buf                        $02c1   913D 13273  13277  13280  13315
                                     13323  13337  13780  13823  13826
                                     13830  13831  13848
Ass_Index                      $02d0   914D 13329  13369
IERROR                         $0300   919D  1491  13485
IMAIN                          $0302   920D  1531
ICRNCH                         $0304   921D  1689
IQPLOP                         $0306   922D  2005
IGONE                          $0308   923D  2140
IEVAL                          $030a   924D  3416
DOS_Tmp                        $033a   930D  7739   7766   8217   8297
                                      8309   8316   8570   8724  11479
DOS_Drive_1                    $033b   931D  8499   8567   8644  11656
DOS_Drive_2                    $033c   932D  8503   8568   8645   8713
                                     11399  11674
DOS_Attr                       $033d   933D  8488   8524   8529   8566
                                      8624   8650   8665
DOS_Flags                      $033e   946D  7789   7793   7810   7819
                                      7829   7922   8073   8232   8248
                                      8348   8564   8603   8614   8638
                                      8668   8707   8721   8738   8745
                                      8746   8794
DOS_Id                         $033f   947D  8149   8329   8332   8571
                                      8660
DOS_Command_Length             $0341   948D  8473   8475   8672   8678
DOS_Filename                   $0342   949D  7570   7572   8676  13468
                                     13624  13633  13645
DOS_Command_Buffer             $0353   950D  8080   8210   8212   8214
                                      8216   8218   8313   8330   8333
                                      8352   8505   8514   8516   9952
                                      9957   9981  10274  10285  11457
DOS_Status                     $03ad   951D  3632   3633   3708   8121
                                      8128   8130   8411   9871
TABS_SET                       $03ee   952D  9653   9655   9908  10070
Reset_Vector                   $03fa   953D 13678  13680
Ignore_Timeout                 $03fc   954D 11797  11806  13682
SCREEN_RAM                     $8000   956
Basic_Statement_Table          $b000  1079D  2167   2169
Basic_Function_Table           $b066  1137D  3759   3761
Basic_Operator_Table           $b094  1167D  3304   3326   3334   3336
                                      3348
Basic_Keyword_Table            $b0b2  1184D  1723   1725   2020   2022
Msg_Start                      $b20d  1283D  1483   1501   1681   2318
                                      2320   2903   3251   3526   4269
                                      4276   4281   4516   4523   4722
                                      4789   4935   5575   5934   8755
                                      8807
Msg_SYNTA                      $b21d  1287D  3526
Msg_GOSUB                      $b223  1288D  2318
Msg_QUANT                      $b242  1290D  4276   8755
Msg_FLOW                       $b252  1291D  5575
Msg_OOM                        $b25a  1292D  1483   4789
Msg_UNDEF                      $b267  1293D  2320
Msg_SUBSC                      $b278  1294D  4269
Msg_REDIM                      $b285  1295D  4281
Msg_DIV                        $b292  1296D  5934
Msg_DIREC                      $b2a2  1297D  4516
Msg_TYPE                       $b2b0  1298D  3251
Msg_LONG                       $b2bd  1299D  1681   4935   8807
Msg_DATA                       $b2cc  1300D  2903
Msg_COMPL                      $b2d5  1301D  4722
Msg_FUNC                       $b2f6  1303D  4523
Msg_ERR                        $b306  1304D  1509   1510
Msg_IN                         $b30d  1305D  6444   6445
Msg_READY                      $b312  1310D  1523   1524
Msg_BREAK                      $b31b  1316D  2225   2226
Find_Active_FOR                $b322  1350D  2054   2314   3177
FAF_10                         $b327  1362D  1380
FAF_20                         $b33c  1371D  1366
FAF_30                         $b348  1376D  1372
FAF_Ret                        $b34f  1381D  1364   1375
Open_Up_Space                  $b350  1384D  1615   4028  13980
OUS_10                         $b374  1414D  1411
OUS_20                         $b380  1420D  1423
OUS_30                         $b384  1422D  1417   1419   1429
OUS_40                         $b38b  1426D  1406
Check_Stack_Avail              $b393  1433D  2062   2262   3270
BSOS_Bank_Init                 $b399  1442D 10034
Check_Mem_Avail                $b3a0  1450D  1393   4294   4344
CMA_10                         $b3aa  1463D  1460
CMA_Ret                        $b3bd  1475D  1459   1462   1471
Error_Out_Of_Memory            $b3cd  1480D  1438   1472   1474   4389
                                      8985  11354
Basic_Error                    $b3cf  1486D  1682   2239   2321   2904
                                      3252   3527   4277   4524   4723
                                      4936   5576   5935   8756   8808
DEF_ERROR                      $b3d2  1494D 13494
Berr_20                        $b3dd  1501D  1507
Berr_30                        $b3ea  1508D 12450
Berr_40                        $b3f1  1511D  2228
Basic_Ready                    $b3ff  1520D  1514   1975   2229   7139
                                      7150   7152   7564   9020  11316
                                     12875  12879  12932  12941  13669
                                     13671  13928
Get_Basic_Statement            $b406  1528D  1542   1604   1637
DEF_MAIN                       $b409  1534D 13495
New_Basic_Line                 $b41f  1549D  1545
NBL_10                         $b45a  1588D  1585
NBL_20                         $b462  1593D  1590   1596   1600
NBL_30                         $b470  1601D  1561
NBL_40                         $b48b  1614D  1612
NBL_50                         $b4a5  1626D  1629
Reset_And_Rechain              $b4ad  1632D 12225
Rechain                        $b4b6  1640D  1602   1636   6435   9019
                                     10217  13954
Rech_10                        $b4be  1647D  1664
Rech_20                        $b4c0  1648D  1650
Rech_30                        $b4d4  1661D  1646
Read_String                    $b4e2  1670D  3002  10494
ReaS_10                        $b4e4  1674D  1680
ReaS_20                        $b4f8  1683D  1676
Tokenize_Line                  $b4fb  1686D  1558  11304  12901  13888
DEF_CRUNCH                     $b4fe  1692D 13496
ToLi_01                        $b504  1698D  1703   1753
ToLi_02                        $b510  1704D  1699
ToLi_03                        $b526  1715D  1712
ToLi_04                        $b52e  1719D  1716
ToLi_05                        $b540  1728D  1735
ToLi_06                        $b547  1732D  1727   1730   1773
ToLi_07                        $b555  1739D  1775
ToLi_08                        $b557  1740D  1701   1705   1710   1714
                                      1718   1756   1758
ToLi_09                        $b56a  1750D  1747
ToLi_10                        $b56c  1751D  1749
ToLi_11                        $b573  1755D  1762
ToLi_12                        $b57c  1759D  1708
ToLi_13                        $b583  1763D  1737
ToLi_14                        $b587  1765D  1771
ToLi_15                        $b590  1770D  1768
ToLi_16                        $b59c  1776D  1744
Find_BASIC_Line                $b5a6  1783D  1560   1915   9828   9842
Find_BASIC_Line_AX             $b5aa  1790D  1811   2297
FBL_10                         $b5c8  1809D  1803
FBL_30                         $b5ce  1812D  1797
FBL_Ret                        $b5cf  1813D  1802   1807   1808   1821
Basic_NEW                      $b5d2  1818D  1116
Perform_NEW                    $b5d4  1824D  7136
Reset_BASIC_Execution          $b5e9  1841D  1601   1635   2254   6434
                                      9018
Basic_CLR                      $b5ee  1848D  1110
Reset_Variable_Pointer         $b5f0  1854D  2255  13927
RVP_10                         $b60b  1872D 12227
Flush_BASIC_Stack              $b60e  1875D  1508   7077
FBS_Ret                        $b621  1891D  1851
Reset_BASIC_Exec_Pointer       $b622  1894D  1844  12226
RBEP_Ret                       $b62f  1904D  1913   1919   1922
Basic_LIST                     $b630  1907D  1109
LIST_10                        $b638  1914D  1910   1911
LIST_15                        $b64f  1923D  1917
LIST_20                        $b659  1932D  1927   1971
LIST_25                        $b674  1955D  1952
LIST_30                        $b676  1960D  1954
LIST_60                        $b679  1964
LIST_50                        $b686  1975D  1937   1955
List_Line                      $b689  1980D  1960  10649
LiLi_08                        $b690  1987D  2011   2013
LiLi_10                        $b697  1993D  1998
LiLi_20                        $b6a3  2002D  1989   2042
DEF_QPLOP                      $b6ab  2008D 13497
LiLi_30                        $b6be  2025D  2032
LiLi_40                        $b6c1  2027D  2031
LiLi_50                        $b6c7  2030D  2028
LiLi_60                        $b6cd  2033D  2026   2039
LiLi_Ret                       $b6dd  2043D  1995   2004
Basic_FOR                      $b6de  2048D  1083
FOR_10                         $b6ef  2060D  2055
FOR_30                         $b72f  2092D  2089
Execute                        $b74a  2107D  2102   2148   2275   3212
                                      6436
Exec_10                        $b759  2117D  2113
Start_Program                  $b779  2137D  2133   2174  12902
DEF_GONE                       $b77c  2143D 13498
Interpret                      $b785  2151D  2147   2401
Inpr_10                        $b787  2158D  2416
Inpr_20                        $b795  2165D  2161
Inpr_30                        $b7a2  2172D  2159
Inpr_40                        $b7a5  2173D  2119
Inpr_50                        $b7a9  2175D  2163
Basic_GO                       $b7ac  2178D  1117
Basic_RESTORE                  $b7b7  2187D  1094   1872
REST_10                        $b7c1  2196D  2194   3142
REST_Ret                       $b7c5  2198D  2157
Basic_STOP                     $b7c6  2201D  1098  12087
Basic_END                      $b7c8  2207D  1082
END_10                         $b7c9  2211D  2204
END_20                         $b7d8  2219D  2990
END_30                         $b7e0  2223D  2216
END_40                         $b7e2  2225D  2123
END_50                         $b7eb  2229D  2227
Basic_CONT                     $b7ee  2232D  1108
CONT_10                        $b7f9  2240D  2238
CONT_Ret                       $b807  2247D  2211   2235
Basic_RUN                      $b808  2250D  1092
RUN_10                         $b80a  2254
RUN_20                         $b80d  2255D  2253
Basic_GOSUB                    $b813  2259D  1095
GOSUB_10                       $b825  2273D  2256
Basic_GOTO                     $b830  2280D  1091   2184   2274   2400
GOTO_10                        $b847  2295D  2287
GOTO_20                        $b84b  2297D  2292   2294
GOTO_Ret                       $b85c  2305D  2311
Basic_RETURN                   $b85d  2308D  1096
RET_10                         $b86e  2320D  2298
RET_20                         $b873  2322D  2412
RET_30                         $b876  2323D  2317
Basic_DATA                     $b883  2334D  1085   2985   4549
Add_Y_To_Execution_Pointer     $b886  2340D  2397   3132
AYEP_Ret                       $b890  2349D  2347   2371   2373
Skip_To_EOS                    $b891  2352D  2063   2337   3115
Skip_To_EOL                    $b894  2359D  2284   2396
NeSt_10                        $b89c  2366D  2377
NeSt_20                        $b8a4  2370D  2376
Basic_IF                       $b8b3  2380D  1093
IF_10                          $b8c2  2389D  2386
Basic_REM                      $b8c6  2393D  1097
REM_10                         $b8cb  2398D  2390
REM_20                         $b8d3  2401D  2399
Basic_ON                       $b8d6  2404D  1099
ON_10                          $b8de  2411D  2438
ON_20                          $b8e2  2413D  2410   2420
ON_30                          $b8ea  2417D  2414
Scan_Linenumber                $b8f6  2425D  1557   1914   1921   2283
                                      2418   8853   8865   8876   9827
                                      9837  10518  11200  12876
ScLi_10                        $b8fe  2436D  2441
ScLi_Ret                       $b90c  2442D  2435
Dec_Char                       $b90d  2445D  2439  13808
LIM_10                         $b92e  2474D  2472
Basic_LET                      $b930  2479D  1090   2053   2172
Assign_Numeric_variable        $b94d  2499D  3090
LET_10                         $b961  2512D  2502
LET_20                         $b964  2514D  2495
Assign_String_Variable         $b965  2517D  3083
CLOCK_10                       $b978  2529D  2544
CLOCK_20                       $b992  2541D  2537
CLOCK_30                       $b9a2  2549D  2552
Add_TI_String_Digit_To_FAC1    $b9ab  2557D  2530   2534
ATSD_10                        $b9b2  2563D  2525
ATSD_20                        $b9b5  2564D  2562
Assign_Normal_String           $b9ba  2568D  2522
ANS_10                         $b9c9  2598
ANS_20                         $b9cb  2599
ANS_30                         $b9d7  2605D  2601
ANS_40                         $b9e5  2612D  2600   2604   2607
ANS_50                         $b9ec  2618D  2596   2608   2611
ANS_60                         $ba05  2632D  2614
ANS_70                         $ba1e  2647D  2638
ANS_80                         $ba33  2661D  2652
ANS_90                         $ba35  2662D  2665
Back_Reference_Position        $ba3d  2669D  2637   2651   5016
BRP_10                         $ba57  2695D  2692
BRP_no                         $ba6c  2708D  2683   2689   2691   2694
FAC1_INT                       $ba6f  2718D  4189
FACI_Ret                       $ba81  2731D  2723
Basic_PRINTN                   $ba88  2736D  1106
Basic_CMD                      $ba8e  2743D  1111   2739
CMD_10                         $ba98  2750D  2747
PRINT_10                       $baa2  2757D  2777
PRINT_20                       $baa5  2758D  2782
Basic_PRINT                    $baa8  2761D  1107   2754
PRINT_30                       $baaa  2765D  2837
Terminate_BUF                  $bad2  2785D  1683
Print_CR                       $badf  2796D  1499   1939   2764  12874
PRINT_Ret                      $bae4  2801D  2765   2793
Comma_Tab                      $baf0  2806D  2772
CoTa_10                        $baf3  2811D  2812
Tab_Spc                        $bafd  2818D  2767   2770
TaSp_10                        $bb0d  2830D  2815
TaSp_20                        $bb0e  2831D  2826
TaSp_30                        $bb11  2833D  2835
TaSp_40                        $bb14  2834D  2832
TaSp_50                        $bb17  2836D  2774   2829
Print_String                   $bb1d  2840D  1511   1525   2907   3150
                                      6465   7125   7135
Print_String_From_Descriptor   $bb20  2846D  2757   2780   2969
PSFD_10                        $bb28  2853D  2857
PSFD_Ret                       $bb31  2858D  2851
Cursor_Right_Or_Space          $bb3a  2863D  2781   2833   3001
CROS_10                        $bb41  2870D  2867
Print_Question_Mark            $bb44  2874D  1500   3000   3048
Print_Char                     $bb46  2880D  1987   1996   2037
Bad_Input                      $bb4c  2888D  3098
BaIn_10                        $bb56  2896D  2893
BaIn_20                        $bb5a  2898D  2895
SynErr                         $bb5e  2900D  2824
BaIn_30                        $bb61  2901D  2892
BaIn_40                        $bb6a  2905D  2902
Basic_GET                      $bb7a  2915D  1115
GET_10                         $bb8f  2926D  2920
Basic_INPUTN                   $bba4  2939D  1086
Set_Default_Channels           $bbb2  2949D  2740   2984
SDC_10                         $bbb4  2953D  2933
Basic_INPUT                    $bbbe  2961D  1087
Input_String                   $bbcd  2972D  2946   2965
InSt_10                        $bbd5  2978D  3563
InSt_20                        $bbe8  2986D  2980   2983
InSt_30                        $bbf0  2989D  3559
Prompt_And_Input               $bbf5  2995D  2978   3049
PAI_10                         $bbff  3002D  2999
Basic_READ                     $bc02  3005D  1089
READ_10                        $bc09  3012D  2987   3564
Read_Get                       $bc0b  3015D  2931
READ_15                        $bc11  3024D  3111
READ_20                        $bc3d  3045D  3038
READ_25                        $bc46  3049D  3047
READ_30                        $bc49  3050D  3043
READ_35                        $bc4d  3055D  3036   3135
READ_40                        $bc61  3068D  3059
READ_45                        $bc6d  3074D  3064
READ_50                        $bc6e  3075D  3070
READ_55                        $bc79  3081D  3079
READ_60                        $bc85  3088D  3057
READ_65                        $bc8d  3094D  3084
READ_70                        $bc99  3100D  3095   3097
READ_75                        $bcb4  3115D  3045   3134
READ_80                        $bccd  3130D  3118
READ_85                        $bcda  3138D  3109
READ_90                        $bce5  3143D  3141
READ_Ret                       $bcf6  3151D  3145   3147
Msg_Extra_Ignored              $bcf7  3156D  3148   3149
Msg_Redo_From_Start            $bd07  3162D  2905   2906
Basic_NEXT                     $bd19  3168D  1084
NEXT_10                        $bd1f  3174D  3171   3221
NEXT_20                        $bd24  3176D  3173
NEXT_30                        $bd2d  3180D  3122
NEXT_40                        $bd2f  3181D  3178
NEXT_50                        $bd6f  3212D  3219
NEXT_60                        $bd72  3213D  3203
Eval_Numeric                   $bd84  3224D  2077   2091   4607   5216
                                      5276  12667
Is_Numeric                     $bd87  3230D  3306   3388   3764   4174
                                      4536   4563   4574   4642
Is_String                      $bd89  3237D  3741   4925   4995
Check_Var_Type                 $bd8a  3243D  2494   3817
CVT_10                         $bd90  3249D  3250
CVT_20                         $bd91  3250D  3247
CVT_30                         $bd93  3251D  3248
CVT_40                         $bd95  3252D  3180
Eval_Expression                $bd98  3258D  2383   2491   2775   3227
                                      3491   3739   4168   7751   7755
                                      8786  12363
EvEx_05                        $bd9e  3264D  3262
EvEx_10                        $bda3  3267D  3340
EvEx_15                        $bdb0  3274D  4947
EvEx_20                        $bdb3  3275D  3287
EvEx_25                        $bdce  3289D  3277   3279
EvEx_30                        $bddf  3298D  3295
EvEx_35                        $bde7  3303D  3325
EvEx_40                        $bdf0  3307D  3328
EvEx_45                        $bdf1  3308D  3536
EvEx_50                        $bdfe  3316D  3290
EvEx_55                        $be08  3322D  3320
EvEx_60                        $be10  3326D  3311
Use_Operator                   $be17  3331D  3308
SynErr1                        $be27  3342D  3284
Push_Operand                   $be2a  3345D  3338
Push_FAC1                      $be2e  3352D  2083   2095
PuFA_10                        $be39  3362D  3359
Pop_FAC2                       $be52  3380D  3291   3293
PoFA_10                        $be55  3385D  3313
PoFA_20                        $be57  3386D  3305
PoFA_30                        $be5e  3389D  3387
PoFA_40                        $be60  3390D  3314   3327
PoFA_50                        $be7a  3407D  3385
Evaluate                       $be7e  3413D  3271   4924
DEF_EVAL                       $be81  3419D 13499
Eva_10                         $be85  3424D  3441
Eva_20                         $be8a  3426D  3437
Eva_30                         $be8d  3427D  3425
Float_PI                       $bea0  3435D  3431   3432
Eva_40                         $bea5  3436D  3430
Make_String_Descriptor_From_Co $beb5  3446D  2966
MSDF_10                        $bebe  3454D  3452
Eva_50                         $bec4  3457D  3443
Op_NOT                         $becc  3463D  1178
Eva_60                         $bedb  3479D  3458
Eva_70                         $bee2  3482D  3480
Eval_In_Parenthesis            $bee9  3487D  3483   3756   4573
Need_Right_Parenthesis         $beef  3494D  4232   4537   5154   7753
                                      8830
Need_Left_Parenthesis          $bef2  3501D  3490   3738   4532   7750
                                      8828
Need_Comma                     $bef5  3508D  2923   2943   3110   3740
                                      3873   5133   5283   7747   7759
                                     12386
Need_A                         $bef7  3514D  2076   2183   2388   2486
                                      2749   2968   4539   4557   7742
Syntax_Error                   $bf00  3523D  2175   2322   2900   3342
                                      3519   3550   3906   4003   4614
                                      7783   8085   8171   8247   8346
                                      8369   8601   8653   8694   8706
                                      8737   8796   8826  12112  12394
                                     12699  13929
Negate                         $bf05  3530D  3439
Nega_10                        $bf07  3534D  3460
JMP_Get_Var                    $bf0c  3539D  3428
Any_Except_Pi                  $bf0f  3545D  2146
Input_String_Patch             $bf19  3554D  2988
InSt_40                        $bf20  3560D  3558
InSt_50                        $bf29  3564D  3562
Extended_Statement_Table       $bf2c  3567D 11286  11288  11295
Extended_Keyword_Table         $bf3a  3579D 11276  11293
Get_Var                        $bf8c  3594D  3542   3990
GeVa_10                        $bfbb  3627D  3614   3616
GeVa_Ret                       $bfcd  3635D  3612   3628   3630
Get_Numeric_Value              $bfce  3638D  3610
Load_Float                     $bfdf  3653D  3642
Load_Jiffyclock                $c003  3670D  3617   3662
Check_ST_Var                   $c00f  3682D  3659
Check_DS_Var                   $c01c  3693D  3686   3688
Load_Float_Var                 $c040  3716D  3657   3661   3697   3699
Function_Call                  $c047  3724D  3484
FuCa_10                        $c071  3756D  3737
FuCa_20                        $c076  3759D  3755
Op_OR                          $c086  3767D  1176
Op_AND                         $c088  3774D  1175
ANDOR_10                       $c0a8  3794D  3788
Op_COMPARE                     $c0b6  3809D  1179
OpCO_10                        $c0ce  3828D  3818
OpCO_20                        $c0f6  3848D  3843   3845
OpCO_30                        $c0fb  3851D  3860
OpCO_40                        $c101  3855D  3827
OpCO_50                        $c106  3858D  3853
OpCO_60                        $c112  3864D  3855   3857   3862
OpCO_70                        $c11b  3870D  3868
DIM_10                         $c11e  3873D  3882
Basic_DIM                      $c121  3876D  1088
Parse_Name                     $c12b  3886D  2482   3024   3174   3604
                                      4535
Get_Array_Address              $c130  3893D  3880
Get_FN_Address                 $c132  3899D  4560
GFA_Err                        $c13c  3906D  3932
Get_Address                    $c13f  3909D  3905
GeAd_05                        $c14f  3919D  3916
GeAd_10                        $c150  3920D  3921   3923
GeAd_15                        $c15a  3924D  3918
GeAd_20                        $c164  3929D  3925
GeAd_25                        $c174  3937D  3928
GeAd_30                        $c17b  3941D  3930
GeAd_35                        $c187  3947D  3945
GeAd_40                        $c18f  3951D  3971
GeAd_45                        $c191  3952D  3969
GeAd_50                        $c19b  3957D  3954
GeAd_55                        $c1ab  3965D  3963
GeAd_60                        $c1ac  3966D  3959
Is_Alpha                       $c1b6  3974D  3427   3904   3917   3922
IsAl_Ret                       $c1bf  3982D  3978
Create_Var                     $c1c0  3985D  3956
CrVa_05                        $c1c6  3992D  4000
CrVa_10                        $c1cb  3995D  3991
CrVa_15                        $c1db  4003D  4007   4011   4013
CrVa_20                        $c1de  4004D  3998   4002
CrVa_25                        $c1e6  4008D  4005
CrVa_30                        $c1f2  4014D  4009
CrVa_35                        $c208  4026D  4024
CrVa_40                        $c21c  4040D  4063   4065
CrVa_45                        $c220  4042D  4079
CrVa_50                        $c228  4046D  4043
CrVa_55                        $c259  4075D  4073   4107   4109
CrVa_60                        $c263  4080D  4077
CrVa_65                        $c281  4097D  4094
CrVa_70                        $c28b  4103D  4082   4093   4096
CrVa_75                        $c298  4111D  4045
CrVa_80                        $c2b4  4128D  3964
CrVa_85                        $c2be  4134D  4132
Array_Pointer_To_First         $c2c8  4141D  4284   4293
APTF_10                        $c2d4  4151D  4149
Float_M32768                   $c2d9  4156D  4185   4186
Eval_Positive_Integer          $c2dd  4164D  4211
Eval_Positive_Integer_Check    $c2e3  4171D  5222
Real_To_Integer                $c2ea  4179D  2504   3471   3779   3785
RIT_10                         $c2f7  4188D  4176
RIT_20                         $c2f9  4189D  4184
Find_Array                     $c2fc  4192D  3946
FiAr_05                        $c306  4205D  4230
FiAr_10                        $c347  4241D  4263
FiAr_15                        $c353  4247D  4244
FiAr_20                        $c362  4255D  4251
Bad_Subscript                  $c370  4266D  4288   4388
Jump_To_Illegal_Quantity       $c373  4273D  2563   4188   5202   5651
                                      7081   7082   8858   9858
FiAr_Err                       $c375  4277D  4283
FiAr_25                        $c378  4281D  4254
FiAr_30                        $c38c  4293D  4246
FiAr_35                        $c39f  4302D  4300
FiAr_40                        $c3a8  4308D  4305
FiAr_45                        $c3b1  4314D  4334
FiAr_50                        $c3c1  4324D  4317
FiAr_55                        $c3e4  4344D  4341
FiAr_60                        $c3f3  4351D  4353   4356
FiAr_65                        $c3f8  4354D  4350
FiAr_70                        $c415  4370D  4289
FiAr_72                        $c41d  4374D  4404
FiAr_74                        $c433  4388D  4383
FiAr_76                        $c436  4389D  4336   4343   4454   4465
FiAr_78                        $c439  4390D  4382
FiAr_80                        $c43a  4391D  4387
FiAr_82                        $c44b  4401D  4394
FiAr_84                        $c45c  4410D  4408
FiAr_86                        $c462  4414D  4411
FiAr_Ret                       $c476  4425D  4368   4515
Mult_16x16                     $c477  4430D  4329   4395
Mult_16x16_A                   $c480  4440D  4416
Mu16_10                        $c48a  4448D  4467
Mu16_20                        $c4a3  4466D  4457
Basic_FRE                      $c4a8  4471D  1144
FRE_10                         $c4af  4477D  4475
AY_To_Real                     $c4bc  4486D  3477   3650   3793   3798
                                      4507
Basic_POS                      $c4c9  4497D  1145
Y_To_Float                     $c4cb  4503D  5180   5201   5318
Assert_Non_Direct              $c4cf  4510D  2918   2975   4531
Undefined_Function             $c4d7  4520D  4585
Basic_DEF                      $c4dc  4527D  1104
Get_FN                         $c50a  4553D  4530   4569
Eval_FNX                       $c51d  4566D  3481
FNX_10                         $c53e  4588D  4591
FNX_20                         $c56f  4615D  4613
FNX_30                         $c575  4619D  4550
Basic_STR                      $c58e  4639D  1156
STR_10                         $c598  4647D  3625
Allocate_String_FAC1           $c59e  4652D  4710   4937
Allocate_String_A              $c5a6  4661D  2620   5076   5098
Create_String_Descriptor       $c5b0  4671D  2779   2843   3454   3634
                                      4649
Create_String_Descriptor_AY    $c5b6  4679D  3081
CSD_10                         $c5c0  4687D  4693
CSD_20                         $c5cd  4694D  4691
CSD_30                         $c5d1  4696D  4689
CSD_40                         $c5d2  4697D  4695
CSD_50                         $c5de  4704D  4702
CSD_60                         $c5e8  4709D  4706
Push_String_Descriptor         $c5f3  4716D  4708   4946   5082   5112
PuSD_Err                       $c5fb  4723D  4791
PuSD_10                        $c5fe  4724D  4721
Allocate_String_Space          $c61d  4744D  4664
ASS_10                         $c61f  4754D  4796
ASS_30                         $c63a  4771D  4769
ASS_40                         $c644  4776D  4773
ASS_50                         $c65a  4788D  4755
ASS_60                         $c65b  4789D  4772   4775
Garbage_Collection             $c66a  4801D  1466   4477   4792  11451
GaCo_05                        $c676  4811D  4831   4833   4863   4879
GaCo_10                        $c68a  4823D  4820
GaCo_15                        $c69f  4835D  4827
GaCo_20                        $c6b0  4845D  4842
GaCo_25                        $c6b6  4848D  4846
GaCo_30                        $c6c7  4859D  4856
GaCo_35                        $c6d1  4865D  4860
GaCo_40                        $c6d4  4867D  4870
GaCo_45                        $c6eb  4880D  4815
FAC1_LSB                       $c6f4  4887D  6193
FACX_LSB                       $c6f6  4891D  5603
FACB_10                        $c6fa  4893D  4910
FACB_Ret                       $c71c  4911D  4894
Concatenate                    $c74f  4917D  3296
Conc_10                        $c76f  4937D  4934
Store_String_STRPTR            $c78c  4950D  4938
Store_String_XY                $c79a  4965D  2623   4713
Store_String_INDEXA            $c79e  4972D  4942   5111
SSI_10                         $c7a2  4978D  4982
SSI_Ret                        $c7b4  4989D  4976   4987
Eval_And_Free_String           $c7b5  4992D  5186   8787  12364
Free_String_FAC1               $c7b8  4998D  2523   2849   3831   4476
Free_String_AY                 $c7bc  5005D  3837   4941   4945   5101
GSD_40                         $c7ed  5038D  5015   5017
GSD_Ret                        $c7ff  5050D  5026   5028
Pop_Descriptor_Stack           $c811  5055D  2626   2636   5014
PDS_Ret                        $c821  5066D  5059   5061
Basic_CHR                      $c822  5069D  1159
Basic_LEFT                     $c836  5085D  1160
LEFT_10                        $c83c  5091D  5122
LEFT_20                        $c842  5095D  5091
LEFT_30                        $c843  5096D  5143
LEFT_40                        $c844  5097D  5146   5148
LEFT_50                        $c85b  5110D  5108
Basic_RIGHT                    $c862  5115D  1161
Basic_MID                      $c86d  5125D  1162
MID_10                         $c87e  5135D  5132
Pop_DESCPT                     $c897  5151D  5088   5118   5135
Basic_LEN                      $c8b2  5176D  1155
Eval_String_Desc               $c8b8  5183D  5179   5196   5232
Basic_ASC                      $c8c1  5193D  1158
ASC_10                         $c8cb  5201D  5197
ASC_Err                        $c8ce  5202D  5136   5224   5291   5294
Get_Next_Byte_Value            $c8d1  5207D  2822
Get_Byte_Value                 $c8d4  5213D  2407   2746   2922   2942
                                      3750   5134   5284   8829   8831
                                     12289  12345
Eval_Byte                      $c8d7  5219D  5072
Basic_VAL                      $c8e3  5229D  1157
VAL_10                         $c8eb  5235D  5233
VAL_20                         $c903  5248D  5246
Restore_Execution_Pointer      $c918  5261D  3082   3455
Get_Word_And_Byte              $c921  5273D  5324   5334
Need_Comma_Get_Byte            $c927  5280D  5339
FAC1_To_LINNUM                 $c92d  5287D  5277   5310   7752   7756
                                     12668
Basic_PEEK                     $c943  5303D  1154
Basic_POKE                     $c95a  5321D  1105
Basic_WAIT                     $c963  5331D  1100
WAIT_10                        $c972  5340D  5338
WAIT_20                        $c976  5342D  5345
WAIT_Ret                       $c97e  5346D  5408
Add_0_5_To_FAC1                $c97f  5349D  6538   6945
AY_Minus_FAC1                  $c986  5357D  5665   6941   7028
Op_MINUS                       $c989  5363D  1171   6801   6938
Add_Var_AY_To_FAC1             $c99d  5377D  3196   5354   5659   5671
                                      6858   6897   6923   6954
Op_PLUS                        $c9a0  5383D  1170   5372   6341
PLUS_10                        $c9a5  5388D  5386
AddSub_FAC2_To_FAC1            $c9ad  5394D  5826
AFTF_10                        $c9c9  5422D  5412
AFTF_20                        $c9cd  5424D  5421
AFTF_30                        $c9d0  5425D  5411
AFTF_40                        $c9dc  5431D  5429
AFTF_50                        $c9ff  5447D  6127
Normalise_FAC1                 $ca0d  5454D  5447   5449   5949   6238
                                      6912
NF1_10                         $ca11  5460D  5473
Clear_FAC1                     $ca2d  5476D  5234   5509   5804
CF1_10                         $ca2f  5480D  6720
AFTF_60                        $ca34  5484D  5426
AFTF_65                        $ca53  5500D  5506
AFTF_70                        $ca5f  5506D  5461
Mantissa_Overflow              $ca6c  5515D  5498
AFTF_80                        $ca6e  5519D  6084
AFTF_Ret                       $ca7c  5526D  5518
Negate_FAC1                    $ca7d  5529D  5448
Negate_FAC1_Mantissa           $ca83  5537
Inc_FAC1_Mantissa              $caa5  5559D  6082   6210
IFM_Ret                        $cab3  5569D  5556   5563   5565   5567
Overflow_Error                 $cab4  5572D  5520   5805   6351
Shift_FAC3                     $cab9  5579D  5711
Shift_FACX_A                   $cacf  5600D  5424
SFA_10                         $cad8  5607D  5613
SFA_40                         $cae4  5614D  5606
REAL_1                         $caf2  5620D  2084   2085   5663   5664
                                      7018   7019
VLOG_A                         $caf7  5624D  5666   5667
HALF_SQRT_2                    $cb0c  5631D  5657   5658
SQRT_2                         $cb11  5635D  5660   5661
MINUS_0_5                      $cb16  5638D  5669   5670
LN_2                           $cb1b  5642D  5674   5675
Basic_LOG                      $cb20  5645D  1148   6736
LOG_10                         $cb27  5651D  5649
LOG_20                         $cb2a  5652D  5650
Multiply_FAC1_With_AY          $cb5e  5678D  6512   6739   6777   6822
                                      6826   6849   6894
Op_MULTIPLY                    $cb61  5684D  1172
Mult_SubA                      $cb8c  5707D  5695   5697   5699   5701
Mult_SubB                      $cb91  5714D  5703   5710
MULT_20                        $cb94  5719D  5741
MULT_30                        $cbb0  5734D  5720
MULT_Ret                       $cbbe  5742D  5687
Load_FAC2_From_AY              $cbc2  5747D  5360   5380   5681   5858
Check_FAC                      $cbed  5781D  5688   5870
ChFA_10                        $cbef  5785D  6809
ChFA_20                        $cbfa  5792D  5788
ChFA_30                        $cc04  5797D  5795
ChFA_40                        $cc07  5799D  6787
ChFA_50                        $cc0d  5802D  5785   5792
ChFA_Err                       $cc12  5805D  5789   5801   5818   5828
                                      5872
Multiply_FAC1_BY_10            $cc18  5810D  2531   2545   6307   6321
                                      6522
Add_And_Double                 $cc23  5821D  2540
Mul10_Ret                      $cc2e  5829D  5815
Float_10                       $cc2f  5832D  5842   5843
Divide_FAC1_By_10              $cc34  5838D  6302   6528
Divide_FAC2_By_AY              $cc3d  5847D  6933
AY_Divided_By_FAC1             $cc45  5855D  5662   6982   7020
Op_DIVIDE                      $cc48  5861D  1173   5852
DIV_10                         $cc5f  5875D  5901
DIV_20                         $cc75  5886D  5877   5880   5883   5900
                                      5902
DIV_30                         $cc82  5894D  5888   5919
DIV_40                         $cc85  5896D  5917
DIV_50                         $cc93  5903D  5895
DIV_60                         $ccb0  5918D  5891
DIV_70                         $ccb4  5920D  5892
Divide_By_Zero                 $ccc0  5931D  5864
FAC3_To_FAC1                   $ccc5  5938D  5704   5928
Load_FAC1_AY                   $ccd8  5952D  2086   3190   3433   3676
                                      3721   5851   6711   6891   6975
LFAY_10                        $ccde  5958D  5961
Set_FAC1                       $ccf4  5972D  6190
FAC1_To_FACTPB                 $ccfd  5984D  6839
FAC1_To_FACTPA                 $cd00  5991D  6820   6966
FAC1_To_FORPNT                 $cd06  5999D  2512   3197
FAC1_To_XY                     $cd0a  6006D  4593   5996   6723   6915
                                      6972
FAC2_To_FAC1                   $cd32  6033D  3784   5387
Copy_ABS_FAC2_To_FAC1          $cd34  6039D  6733
F1F2_10                        $cd38  6044D  6047
FAC1_Round_And_Copy_To_FAC2    $cd42  6052D  2535   5813   5841   6334
                                      6708   6929   6934
FAC1_To_FAC2                   $cd45  6058D  6783
FA12_10                        $cd47  6062D  6065
FA12_Ret                       $cd50  6067D  6074   6076   6083
Round_FAC1                     $cd51  6070D  2503   3362   5865   6009
                                      6055
Inc_FAC1                       $cd59  6079D  6781
Get_FAC1_Sign                  $cd61  6087D  2092   5648   6103   6151
                                      6877
GFS_10                         $cd65  6092D  6154
GFS_20                         $cd67  6093D  6178
GFS_Ret                        $cd6e  6097D  6091   6095
Basic_SGN                      $cd6f  6100D  1140
A_To_FAC1                      $cd72  6106D  3690   3711   3870   6336
ATOF_10                        $cd7a  6113D  4494
Convert_Integer_To_Real        $cd7f  6118D  6458  11210
CITR_10                        $cd85  6124D  3665
Basic_ABS                      $cd8e  6130D  1142
Compare_FAC1_AY                $cd91  6137D  3825   4187   6520   6532
                                      6729
Compare_FAC1_INDEXB_Y          $cd93  6143D  3199
CFAY_10                        $cdc8  6175D  6156   6160   6164   6168
CFAY_20                        $cdce  6178D  6176
FAC1_LSR                       $cdd1  6181D  2546   2721   5295   6228
                                      6539
FLSR_10                        $cdd5  6190
FLSR_20                        $cdd8  6191D  6189
FLSR_30                        $cde6  6198D  6196   6205
FLSR_40                        $cdff  6211D  6194   6207   6209
FLSR_Ret                       $ce01  6212D  6174   6227
Basic_INT                      $ce02  6217D  1141   6726   6788   6935
INT_10                         $ce1a  6237D  6233
Read_Real_To_FAC1              $ce29  6243D  3088   3426   5255
RRTF_02                        $ce2d  6256D  6258
RRTF_04                        $ce3e  6265D  6261   6293   6325
RRTF_06                        $ce43  6267D  6263
RRTF_08                        $ce60  6281D  6278
RRTF_10                        $ce62  6282D  6274   6276   6363
RRTF_12                        $ce67  6284D  6280
RRTF_20                        $ce73  6291D  6268
RRTF_22                        $ce79  6295D  6270   6285
RRTF_24                        $ce7b  6296D  6289
RRTF_26                        $ce84  6302D  6304
RRTF_28                        $ce8d  6307D  6300   6309
RRTF_30                        $ce94  6311D  6299   6305
RRTF_32                        $ce99  6315D  6312
RRTF_34                        $ce9c  6317D  6259   6266
RRTF_36                        $cea3  6321D  6319
Add_A_To_FAC1                  $ceb4  6330D  2565   5673   6324
RRTF_40                        $cec7  6345D  6272   6283
RRTF_42                        $ced6  6352D  6347
RRTF_44                        $cee4  6362D  6350
REAL_1e8                       $cee9  6366D  6518   6519
REAL_9x9                       $ceee  6372D  6530   6531
REAL_1e9                       $cef3  6378D  6510   6511
BSOS_TEXT                      $cef8  6383D  6391   6398   6411   6413
                                      6415
Option_ROM                     $cf01  6386D  7137
OpRO_10                        $cf03  6390D  6394
OpRO_20                        $cf11  6396D  6392
OpRO_30                        $cf13  6397D  6401
OpRO_40                        $cf21  6403D  6399   6410
BOOT_File                      $cf22  6406D  7138
BOFi_10                        $cf4e  6429D  6426
Print_IN                       $cf78  6441D  1515
Print_Integer_XA               $cf83  6451D  1983   7132   7949  12873
To_Print_String                $cf90  6462D  6446
Format_FAC1                    $cf93  6468D  2778   6459  11211
Format_FAC1_Y                  $cf95  6474D  4644
FoFA_02                        $cfa1  6491D  6489
FoFA_04                        $cfb2  6507D  6500
FoFA_06                        $cfc1  6514D  6509
FoFA_08                        $cfc3  6518D  6524
FoFA_10                        $cfd3  6528D  6533
FoFA_12                        $cfd8  6530D  6521
FoFA_14                        $cff9  6554D  6548
FoFA_16                        $cffa  6555D  6550
FoFA_18                        $d005  6561D  6559
FoFA_20                        $d016  6570D  6566
FoFA_22                        $d018  6571D  6560
Format_Jiffyclock              $d01a  6574D  3624
FoFA_78                        $d01c  6578D  6593   6596   6626
FoFA_80                        $d040  6596D  6592
FoFA_82                        $d042  6597D  6594
FoFA_84                        $d049  6601D  6598
FoFA_86                        $d064  6617D  6613
FoFA_88                        $d076  6630D  6624
FoFA_90                        $d078  6631D  6634
FoFA_91                        $d085  6638D  6636
FoFA_92                        $d095  6647D  6641
FoFA_93                        $d0a1  6653D  6655
FoFA_94                        $d0b6  6664D  6501
FoFA_95                        $d0b9  6665D  6640
FoFA_96                        $d0be  6667D  6662
Float_0_5                      $d0c7  6674D  2521   3992   3993   5352
                                      5353   6709   6710
Decimal_Conversion_Table       $d0cc  6680D  6580   6583   6586   6589
Jiffy_Conversion_Table         $d0f0  6694
Basic_SQR                      $d108  6705D  1146
Op_POWER                       $d112  6714D  1174
PWR_10                         $d11b  6721D  6719
PWR_20                         $d135  6733D  6725   6730
Op_NEGATE                      $d14b  6746D  1177   6315   6802   6951
                                      6957
NEGA_Ret                       $d155  6754D  6743   6750
REV_LOG_2                      $d156  6757D  6775   6776
VAR_EXP                        $d15b  6761D  6803   6804
Basic_EXP                      $d184  6772D  1149   6717   6740
EXP_10                         $d194  6782D  6780
EXP_20                         $d19f  6787
EXP_30                         $d1a2  6788D  6786
EXP_40                         $d1ac  6793D  6798
Square_And_Series_Eval         $d1d7  6815D  5668   6960   7023
Eval_Series_AY                 $d1ed  6829D  6805
Eval_Series                    $d1f1  6836D  6823
EvSe_10                        $d200  6847D  6845
EvSe_20                        $d204  6849D  6862
EvSe_30                        $d211  6856D  6854
RND_VA                         $d221  6865D  6892   6893
RND_VB                         $d225  6866D  6895   6896
Basic_RND                      $d229  6869D  1147
RND_10                         $d247  6889D  6879
RND_20                         $d25c  6898D  6878
RND_30                         $d26c  6906D  6888
Basic_COS                      $d282  6918D  1150
Basic_SIN                      $d289  6926D  1151   6969
SIN_10                         $d2bb  6951D  6944   6989
SIN_20                         $d2be  6952D  6947
SIN_30                         $d2cb  6958D  6956
Basic_TAN                      $d2d2  6963D  1152
TAN_10                         $d2fa  6985D  6979
PI_Half                        $d2fe  6990D  6921   6922   7026   7027
Two_PI                         $d303  6991D  6930   6931
Float_0_25                     $d308  6994D  6939   6940   6952   6953
VAR_SIN                        $d30d  6998D  6958   6959
Basic_ATN                      $d32c  7007D  1153
ATN_20                         $d341  7021D  7017
ATN_30                         $d352  7029D  7025
VAR_ATN                        $d35c  7036D  7021   7022
CHRGET_ROM                     $d399  7054D  7064   7086
CHRG_10                        $d39f  7060D  7058
CHRG_20                        $d3b0  7069D  7062
Init_BASIC_RAM_Vectors         $d3b6  7074D 13684
IBRV_10                        $d3c9  7086D  7089
IBRV_20                        $d3e8  7101D  7114   7116
IBRV_30                        $d404  7117D  7106   7110
Bytes_Free_Message             $d438  7142D  7133   7134
Monitor                        $d445  7148D  3571
MONITOR_BREAK                  $d451  7161D 13673  13675
MOBR_05                        $d459  7169D  7167
MOBR_10                        $d49c  7200D  7204
MOBR_20                        $d4a8  7205D  7198   7202
Mon_Error                      $d4ac  7209D  7226   7480   7606   9941
                                     13347  13528  13571  13655  13677
                                     13679
Mon_Main                       $d4b1  7216D  7221   7455   7496   7611
                                      7636   7981   7989   9940  12469
                                     13460  13477  13552  13570  13654
                                     13717
Mon_10                         $d4b4  7220D  7223  13391
Mon_20                         $d4bd  7224D  7206
Mon_30                         $d4bf  7225D  7228
Mon_Print_A_Hex_Values         $d4d0  7236D  7397   7450
MPAH_10                        $d4d4  7241D  7249
MPAH_12                        $d4e5  7248D  7246
MPAH_20                        $d4f4  7255D  7268
MPAH_30                        $d501  7261D  7258
MPAH_40                        $d503  7262D  7260
MPAH_42                        $d50e  7267D  7265
MPAH_Ret                       $d512  7269D  7253
Mon_STAL_Register              $d513  7272D  7396
Mon_Print_Blank                $d51e  7283D  7241   7247   7250   7266
                                      7386   7391  12463  12480  12481
                                     12482  12503  13366  13368  13547
                                     13651  13713
Mon_Print_CR                   $d521  7290D  7219   7366  11313  13457
                                     13474  13535  13638  13716  13956
Mon_Start                      $d526  7297D  7201
Mon_Commands                   $d531  7300D  7227
Mon_Sub_Hi                     $d549  7306D  7229
Mon_Sub_Lo                     $d560  7334D  7231
Mon_Prompt                     $d577  7362D  7385   7447  12462  13365
Display_Register               $d57f  7371D  7326   7354
DiRe_10                        $d581  7375D  7379
DiRe_20                        $d5c6  7401D  7406
Mon_Cmp_Addr                   $d5e3  7417D  7444  12459  13641
Cmp_STAL_MEMUSS                $d5ee  7428D  7421  13550  13568  13595
Display_Memory                 $d5f7  7438D  7324   7352
DiMe_10                        $d5fa  7442D  7453   9996  10017
To_Mon_Main                    $d618  7454D  7408   7443   7445   7521
Mon_Get_Addr                   $d61b  7458D  7441  12456  13611
MGA_Ret                        $d63c  7476D  7467   7471
MGA_Err                        $d63d  7477D  7469   7474
To_Mon_Err                     $d63f  7479D  7503   7512   7517   7530
Modify_Register                $d642  7483D  7314   7342
MoRe_10                        $d644  7487D  7491
Modify_Memory                  $d65c  7499D  7313   7341
MoMe_10                        $d663  7505
MoMe_20                        $d66f  7511D  7520
MoMe_30                        $d680  7518
Mon_Go                         $d687  7524D  7321   7349
MoGo_10                        $d69c  7535D  7528
Mon_Step                       $d6a7  7542D 13734
Mon_Exit                       $d6c1  7559D  7331   7359
Set_DOS_FNADR                  $d6c8  7567D  7592   8673  13473
Mon_Load                       $d6d1  7577D  7312   7323   7340   7351
Mon_Save                       $d6d4  7584D  7327   7355
MLS_10                         $d6e3  7594D  7597
MLS_20                         $d6ec  7598D  7605
MLS_Err                        $d6fc  7606D  7595   7599   7609   7623
                                      7629   7632   7634
MLS_30                         $d6ff  7608D  7615   7621
MLS_35                         $d701  7609
MLS_50                         $d709  7613D  7601   7617
Make_Hex_Byte                  $d741  7639D  7665  13379  13383
Mon_Print_STAL                 $d750  7654D  7448  12502  13367  13546
                                     13650
Print_Hex_Byte                 $d757  7662D  7243   7388   7390   7393
                                      7395   7658   9879  11641  12128
                                     12130  12235  12237  12478  13715
Mon_Print_XA                   $d75a  7668
Nibble_To_Hex                  $d763  7678D  7647   7651  13240  13245
NTH_10                         $d76a  7685D  7683
Hex_To_STAL                    $d76d  7689D  7468   7502   7624   9953
                                     13305  13516
Read_Hex_Word                  $d76f  7695D  7473   7631   9922   9925
                                     13519  13522
RHW_Ret                        $d77b  7703D  7699
Read_Hex                       $d77c  7706D  7487   7511   7531   7533
                                      7618   7698   7701   7713   7979
                                      7987   9927  13622  13706
Read_Hex_A                     $d783  7714D 13619
ReHe_Ret                       $d79f  7729D  7716   7725
Kernal_RECORD                  $d7af  7735D 14059
RECO_10                        $d7db  7755D  7749
RECO_20                        $d7e1  7757D  7754
RECO_30                        $d7fe  7769D  7758
RECO_40                        $d801  7770D  7745   7763   7765
Allow_Drive_Unit_Filename      $d804  7773D  8140   8394
DOS_JMP_Syntax_Error           $d808  7780D  7748   7760   7768   7792
                                      7801   7809   7818   7828
Check_Filename_Given           $d80b  7786D  7777   8343   8366
Allow_Drive_And_Unit           $d818  7797D  7919   8228
No_WL_Record                   $d81d  7805D  8287
Check_Filename_Syntax          $d824  7813D  8382
Check_Record_Syntax            $d82e  7823D  8067   8096
DOS_Build_Table                $d838  7833D  8478
Kernal_DIRECTORY               $d873  7915D 14107
DIRE_10                        $d885  7926D  7924
Wedge_Call_Dir                 $d889  7930D 12940  13476
WCD_10                         $d89e  7942D  7948   7969
WCD_20                         $d8b4  7952D  7961   7964
WCD_30                         $d8cc  7962D  7963
WCD_40                         $d8d3  7966D  7953
WCD_80                         $d8dc  7971D  7945   7955   7958
Mon_Set_Bank                   $d8e4  7976D  7317   7345
Mon_Write_Bank                 $d8ec  7984D  7330   7358
Mon_CHRIN                      $d8f4  7992D  7220   7466   7470   7527
                                      7594   7598   7614   7620   7627
                                      7711   7723   9956  13267  13311
                                     13319  13443  13449  13470  13613
                                     13629  13756  13812
Hex_To_Bin                     $d8fa  8000D  7717   7726  13759
HTB_Ret                        $d904  8009D  8007
Is_Int                         $d905  8012D 13752
Is_Hex                         $d911  8023D  7715   7724  13757
Is_Dec                         $d919  8032D 13813
IH_True                        $d921  8039D  8016   8018   8020   8029
IH_False                       $d923  8041D  8027   8036   8038
Select_Free_SA                 $d92f  8047D  8070   8099
SFSA_10                        $d931  8051D  8057
SFSA_20                        $d935  8054D  8058
SFSA_30                        $d93f  8059D  8055
Kernal_DOPEN                   $d942  8063D 14047
DOPEN_20                       $d95c  8078D  8074
DOPEN_30                       $d964  8082D  8078
DOPEN_Err                      $d96c  8085D  8069   8098   8143
Kernal_APPEND                  $d977  8092D 14089
Kernal_Read_DS                 $d991  8108D  3631   3700   6428   8153
                                      8402   9868  11556  11587  11616
                                     12948  14125
KRD_10                         $d999  8115D  8112
KDR_20                         $d9a5  8120D  8126
KDR_30                         $d9b4  8127D  8124
Kernal_HEADER                  $d9d2  8136D 14065
HEAD_10                        $d9f1  8152D  8150
HEAD_20                        $da05  8160D  8146   8155   8157
Kernal_DCLOSE                  $da07  8165D 14053
CLOSE_10                       $da11  8172D  8170
Close_All_Device_Files         $da1b  8178D  8144   8174   8190   8229
                                      8251
CLOSE_20                       $da1f  8183D  8186
CLOSE_Ret                      $da30  8191D  8184
Build_Record_Command           $da31  8194D  7769
BRC_10                         $da3d  8202D  8199
DOS_Record_No                  $da43  8206D 11615
Kernal_COLLECT                 $da65  8224D 14071
COLL_10                        $da7a  8236D  8234
Kernal_BACKUP                  $da7e  8240D 14077
BACK_Err                       $da87  8247D  8250
BACK_10                        $da8a  8248D  8246
Put_DOS_Command                $da98  8256D  8152   8237   8278   8290
                                      8387   8399
PDC_10                         $da9b  8260D  8221  11504
Kernal_COPY                    $daa7  8267D 14083
KECO_10                        $dab5  8276D  8272   8274
Kernal_CONCAT                  $dac7  8283D 14041
Copy_Filename_To_DOS_Buffer    $dad4  8293D  8482
Copy_MEMUSS_To_DOS_Buffer      $dae1  8304D  8485
CMDB_10                        $daea  8312D  8317
CMDB_20                        $daf8  8319D  8310
CMDB_30                        $daf9  8320D  8318
Insert_DOS_Id                  $dafd  8326D  8492
Kernal_DSAVE                   $db0d  8339D 14095
DSAVE_10                       $db1a  8347D  8345
DSAVE_20                       $db32  8357D  8350
Kernal_DLOAD                   $db3a  8362D 14101
DLOAD_10                       $db44  8369D  8384
DLOAD_20                       $db47  8370D  8368
Kernal_RENAME                  $db55  8378D 14113
Kernal_SCRATCH                 $db66  8390D 14119
Display_Status                 $db85  8407D 12949
DiSt_10                        $db87  8411D  8415
DiSt_Ret                       $db92  8416D  8396   8401
Are_You_Sure                   $db9e  8421D  8145   8395
AYS_10                         $dbcb  8443D  8431   8436   8439   8447
AYS_20                         $dbd5  8448D  8425   8434   8442
AYS_Ret                        $dbd6  8449D  8445
Clear_Status                   $dbe1  8454D  8172   8203   8474  12947
Build_DOS_Command              $dbfa  8464D  7927   8102   8259   8358
                                      8372
Build_DOS_Command_X            $dbfc  8470D  8083   8355  11461
BDC_10                         $dc02  8475D  8502   8507
BDC_20                         $dc14  8483D  8481
BDC_30                         $dc1b  8486D  8484
BDC_40                         $dc24  8490D  8487
BDC_50                         $dc2b  8493D  8491
BDC_60                         $dc34  8497D  8494
BDC_70                         $dc3d  8501D  8498
BDC_80                         $dc44  8504D  8500
BDC_90                         $dc46  8505D  8479   8489   8496
DOS_SETNAM                     $dc4c  8510D  8220   8476   9963
Write_Attribute                $dc57  8521D  8495
WrAt_10                        $dc60  8528D  8525
WrAt_Ret                       $dc67  8531D  8527
Parse_DOS_Parameter            $dc68  8560D  7918   8066   8095   8139
                                      8168   8227   8243   8270   8286
                                      8342   8365   8381   8393
PDP_02                         $dc8e  8579D  8576   8688
PDP_04                         $dca1  8589D  8586
PDP_08                         $dcb9  8601D  8605   8615   8640
PDP_10                         $dcbc  8603D  8580
PDP_12                         $dcd4  8614D  8582
PDP_14                         $dcdf  8619D  8584
PDP_16                         $dced  8626D  8617
PDP_20                         $dcf5  8630D  8596   8600
PDP_22                         $dcf8  8632D  8592   8691
PDP_24                         $dd00  8635D  8594
PDP_26                         $dd08  8638D  8590
PDP_28                         $dd24  8649D  8608   8621   8623   8643
PDP_30                         $dd27  8650D  8598
PDP_32                         $dd31  8654D  8652
PDP_34                         $dd35  8656D  8663
PDP_36                         $dd3b  8659D  8657
PDP_37                         $dd4a  8666D  8587
PDP_38                         $dd50  8668D  8630
PDP_40                         $dd62  8675D  8679
PDP_44                         $dd72  8682D  8612   8628   8634   8637
                                      8648   8667
PDP_46                         $dd7a  8685D  8683
PDP_48                         $dd84  8689D  8686
PDP_50                         $dd8b  8692D  8690
PDP_52                         $dd92  8695D  8693   8732
PDP_54                         $dda9  8706D  8709
PDP_56                         $ddac  8707D  8697
PDP_58                         $ddc5  8717D  8699   8734
PDP_60                         $ddcb  8719D  8701   8736
PDP_62                         $ddd1  8721D  8703   8705
PDP_64                         $dde5  8729D  8716   8718   8720
PDP_66                         $ddf6  8737D  8764   8785
PDP_68                         $ddf9  8738D  8577   8684   8730
Set_DOS_Flags                  $ddfd  8742D  8611   8627   8647   8681
                                      8715   8728   8777   8802
DOS_JMP_Illegal_Quantity       $de27  8752D  7770   8649   8712   8772
                                      8774   8789   8804
DOS_Parse_Unit                 $de2c  8759D  8632   8717
Get_Unit_Value                 $de33  8767D  8635   8719
DOS_Parse_Filename             $de49  8782D  8670   8723
DPF_10                         $de64  8797D  8795
DPF_20                         $de6a  8800D  8798
DPF_30                         $de70  8803D  8793
DPF_40                         $de7c  8809D  8806
DOS_Parse_Value                $de87  8816D  8606   8619   8641   8710
                                      8770
DOS_Get_Byte                   $de8a  8822D  7743   7761
DGB_10                         $de8f  8827D  8825
DGB_20                         $de9a  8831D  8827
Start_Message                  $de9d  8834D  7123   7124
Renumber                       $deb1  8840D  3570
Renu_Err                       $decd  8858D  8869   8884   8927
Renu_10                        $ded0  8859D  8857
Renu_15                        $df0f  8890D  8852   8863   8874
Renu_20                        $df12  8891D  8886
Renu_25                        $df1b  8898D  8937
Renu_30                        $df55  8941D  8900
Renu_35                        $df59  8943D  8945
Renu_40                        $df66  8955D  8984
Renu_45                        $dfa0  8989D  8961
Renu_50                        $dfbd  9004D  9011   9014
Renu_55                        $dfca  9010D  9007
Renu_60                        $dfd3  9015D  9009
Renu_90                        $dfd5  9016D  9857  10224
EDITOR_JUMP_TABLE              $e000  9025
EDIT_RESET                     $e037  9049D  9028  13668
EDIT_CLEAR                     $e03d  9056D  9035   9632
EDCL_10                        $e03f  9060D  9064
EDIT_HOME                      $e04a  9067D  9530  10605
Edit_Goto_Left_Margin          $e04e  9074D  9694  10640
Edit_Use_CursorRow             $e052  9081D  9310   9510   9666   9710
                                     10579
EDIT_SET_CRT                   $e057  9088D 10475  10486
ESC_10                         $e05b  9097D  9101
Edit_Program_Rows              $e067  9106D  9541
EDIT_GETIN                     $e0a7  9125D  9029   9158  11934
EDGE_10                        $e0ac  9130D  9134
Edit_Get_Line                  $e0bc  9141D  9169
EGL_10                         $e0bf  9145D  9147   9167   9209
EGL_20                         $e0d7  9158D  9150
EGL_30                         $e0e2  9163D  9166
EGL_40                         $e0ed  9168D  9160
EGL_50                         $e0f7  9173D  9176
EGL_60                         $e0fe  9177D  9174
EDIT_CHRIN                     $e116  9195D  9030  11946  11952
Edit_CHRIN_Standard            $e11d  9205D 10073  10074
Edit_CHRIN_Screen              $e121  9212D  9183   9187
ECS_05                         $e12d  9221D  9218
ECS_10                         $e139  9227D  9225
ECS_20                         $e13f  9230D  9227
ECS_30                         $e143  9232D  9220   9229   9230
ECS_40                         $e14c  9236D  9188
ECS_50                         $e15b  9243D  9235   9241
ECS_Ret                        $e163  9249
Edit_Quote_Toggle              $e164  9252D  9233   9469
EQT_Ret                        $e16e  9260D  9256
Edit_Display_Char              $e16f  9263D  9470   9499   9623   9626
EDC_10                         $e175  9269D  9267
EDC_20                         $e17b  9272D  9270
Edit_Chrout_Epilog_Return      $e186  9280D  9475
EDC_30                         $e18b  9285D  9277
Edit_Chrout_Epilog             $e18d  9288D  9312   9464   9531   9615
                                      9644   9656   9667   9695   9732
Edit_Wrap_Back                 $e196  9301D  9650
EWB_10                         $e1a5  9311D  9307
Edit_Erase_To_EOL              $e1aa  9315D  9061   9758   9773
EETE_10                        $e1ac  9319D  9322
Edit_To_Left_Margin            $e1b4  9326D  9179  13361
Edit_Full_Screen               $e1bb  9335D  9529   9542  10067
EDIT_BOTTOM_RIGHT              $e1c5  9345D  9045
EDIT_TOP_LEFT                  $e1ca  9353D  9044
CO_Shift                       $e1cf  9360D  9423
CO_Tab                         $e1d2  9363D  9371   9451
CO_Size                        $e1e2  9376D  9459
Edit_Delete_Char               $e1e5  9379D  9433
EdDC_05                        $e1e9  9384D  9368
EdDC_10                        $e1ed  9386D  9392
EDIT_CHROUT                    $e202  9403D  7203   7213   7262   7294
                                      7368   7376   7404   7673   7675
                                      7951   7956   7967   8404   8413
                                      9031   9144   9242  11842  11970
                                     12132  12240  13257  13363  13372
Edit_CHROUT_Standard           $e20c  9416D 10077  10078
CO_Exit                        $e266  9464D  9372   9384   9396   9474
                                      9478   9482   9485   9488   9496
                                      9504   9511   9518
CO_Normal                      $e269  9468D  9425
CO_Right                       $e271  9472D  9437
CO_Down                        $e27a  9477D  9439
CO_RVS                         $e27f  9480D  9441
CO_Bell                        $e285  9484D  9443
CO_ChText                      $e28a  9487D  9445
CO_Return                      $e28f  9490D  9427
CO_Escape                      $e292  9492D  9429
CO_ChNew                       $e295  9494D  9447
CO_Switch                      $e297  9495D  9636
CO_Rev                         $e29c  9498D  9431   9435
CO_Top                         $e2a1  9501D  9449
CO_ScDown                      $e2a9  9506D  9463
CO_ScUp                        $e2ac  9508D  9453
CO_DEOL                        $e2b7  9513D  9455
CODE_10                        $e2b9  9514D  9517
CO_DLine                       $e2c2  9520D  9457
CO_Home                        $e2cf  9527D  9461
CoHo_05                        $e2d3  9529
COHo_10                        $e2d6  9530D  9528
Edit_Screen_30                 $e2dc  9533D  9619
Edit_Screen_25                 $e2e2  9537D  9376
Edit_Screen_Program            $e2e6  9540D  9536
CS_Return                      $e2ef  9545D  9584
Edit_Insert_Char               $e2f2  9548D  9588
InCh_10                        $e2fa  9555D  9562
InCh_20                        $e307  9563D  9559
Edit_CHROUT_Shifted            $e316  9575D  9360
CS_Exit                        $e360  9615D  9554   9568   9570   9630
                                      9633   9641   9649   9676
CS_Size                        $e363  9619D  9614
CS_Pi                          $e366  9620D  9580
CS_Print                       $e369  9622D  9582
CS_Rev                         $e36e  9625D  9586   9590
CS_RVS                         $e373  9628D  9596
CS_Clear                       $e379  9632D  9543   9598
CS_ChOld                       $e37e  9635D  9604
CS_Bottom                      $e383  9638D  9608
CS_Graph                       $e38b  9643D  9610
CS_Left                        $e391  9646D  9592
CS_Tab                         $e39c  9652D  9600
CS_Up                          $e3ab  9658D  9594
CS_ScDown                      $e3b5  9664D  9506   9606   9660
COSW_10                        $e3bb  9666D  9662
CS_Delete_BOL                  $e3c1  9670D  9602
CSDB_10                        $e3c5  9675D  9679
CS_Insert_Line                 $e3ce  9684D  9612
TM_Epi                         $e3d8  9692D  9525
Edit_Cursor_Down               $e3e1  9700D  9283   9477   9722
CSCD_10                        $e3ef  9709D  9706
CO_Screen_Return               $e3f4  9715D  9490   9545
CO_JMP_Escape                  $e3ff  9725D  9492
Edit_Scroll                    $e40a  9735D  9756   9771
ES_10                          $e40d  9739D  9743
EDIT_SCROLL_DOWN               $e417  9748D  9039   9664   9691  10620
ESD_10                         $e419  9752D  9757
ESD_30                         $e426  9758D  9754
EDIT_SCROLL_UP                 $e429  9763D  9040   9508   9524   9707
ESU_10                         $e42b  9767D  9772
ESU_30                         $e438  9773D  9769
IRQ_MAIN                       $e442  9780D  9032  14224
IRQ_05                         $e452  9793D  9791
IRQ_NORMAL                     $e455  9796D  9033  10036  10038  13745
IRQ_10                         $e470  9812D  9809
IRQ_20                         $e474  9814D  9801   9803
IRQ_END                        $e477  9815D  9034
Delete                         $e47d  9823D  3572
Del_10                         $e4a3  9842D  9840
Del_20                         $e4ab  9845D  9843
Del_30                         $e4af  9847D  9850   9854
DelErr                         $e4c5  9858D  9835
Get_Record_Size                $e4c8  9862D  9886  11661
GRS_90                         $e4fa  9887D  9873   9882
Mon_Message                    $e4fb  9890D  7375
IS_TAB                         $e525  9896D  9370   9652
BITPOS                         $e537  9912D  9654   9907
Mon_Fill                       $e53f  9918D  7320   7348
MoFi_10                        $e555  9931D  9939
MoFi_End                       $e569  9940D  9935
MoFi_Err                       $e56c  9941D  9923   9926   9928
Open_Disk_Buffer               $e56f  9947D  9980
ODB_20                         $e580  9956D  9962
ODB_30                         $e58f  9963D  9960
Mon_Disk                       $e5a7  9975D  7329   7357
MIB_30                         $e5c0  9990D  9993
Mon_Output_Block               $e5d1  9999D  9983
MOB_10                         $e5e0 10010D 10013
Edit_Init                      $e606 10022D  9052
EdIn_10                        $e611 10030D 10032
EdIn_20                        $e66d 10070D 10072
Double_Beep                    $e68a 10086D 10083
EDIT_BEEP                      $e68d 10092D  9042   9043   9484  10089
BEEP_10                        $e69d 10102D 10111
BEEP_20                        $e6a5 10105D 10106  10109
BEEP_Ret                       $e6b6 10114D 10096
Set_Screen_SAL                 $e6b7 10117D  9738
Cursor_BOL                     $e6c9 10133D  9060   9752   9767  10560
Update_ScrPtr                  $e6cb 10143D  9085
RUN_String                     $e6dd 10159D  9163
CRT_TEXT                       $e6e5 10166D 10473  10474
CRT_GRAPHICS                   $e6f7 10192D 10484  10485
OLD                            $e701 10210D  3576
SOUND_TAB                      $e74e 10229D 10102
Line_Addr_Lo                   $e755 10235D 10124  10150  10508
Line_Addr_Hi                   $e76e 10244D 10128  10154  10513
B_P_0                          $e78e 10252D 10261  10264
U1                             $e796 10253D 10273
Reset_BP                       $e79b 10256D 10004
RBP_30                         $e7a0 10261D 10265
Preset_U1                      $e7ae 10269D  9950
PU1_10                         $e7b0 10273D 10276
Mon_Disk_Comm                  $e7ba 10280D  9984  10015
MDC_10                         $e7bf 10285D 10289
PIA1_Port_A                    $e810   973D 10045  10316  10318  10377
                                     11907
PIA1_Cont_A                    $e811   974D 10057  11733  11738
PIA1_Port_B                    $e812   975D 10053  10329  10330
PIA1_Cont_B                    $e813   976D 10052
PIA2_Port_A                    $e820   993D 11911
PIA2_Cont_A                    $e821   994D 10055  11729  11831  11894
                                     11915  11919
PIA2_Port_B                    $e822   995D 10049  10058  11759  11774
PIA2_Cont_B                    $e823   996D 10056  11752  11763  11772
VIA_Port_B                     $e840  1037D 10047  11725  11727  11742
                                     11745  11753  11760  11766  11788
                                     11790  11827  11829  11875  11877
                                     11895  11897  11902  11904  11906
                                     11916
VIA_Port_A                     $e841  1038
VIA_DDR_B                      $e842  1039D 10048
VIA_DDR_A                      $e843  1040
VIA_Timer_1_Lo                 $e844  1041D  6880
VIA_Timer_1_Hi                 $e845  1042D  6884  10050  11765  11899
VIA_Timer_1_Latch_Lo           $e846  1043
VIA_Timer_1_Latch_Hi           $e847  1044
VIA_Timer_2_Lo                 $e848  1045D  6882  10103  13731  13743
VIA_Timer_2_Hi                 $e849  1046D  6886  13733
VIA_Shift                      $e84a  1047D 10100  10112
VIA_ACR                        $e84b  1049D 10098  10113
VIA_PCR                        $e84c  1054D 10472  10483
VIA_IFR                        $e84d  1056D 11767  11900  13740
VIA_IER                        $e84e  1066D 10026  10064  13729
VIA_Port_A_no_HS               $e84f  1067
CRT_Address                    $e880  1072D  9098   9115   9118  10454
CRT_Value                      $e881  1073D  9099   9116   9119  10455
EDIT_KEY_SCAN                  $e924 10311D  9041   9814
ScKbd_02                       $e93a 10329D 10331  10378
ScKbd_04                       $e944 10336D 10373
ScKbd_06                       $e95c 10361D 10344  10346  10352
ScKbd_08                       $e960 10366D 10357
ScKbd_10                       $e961 10367D 10337
ScKbd_12                       $e96c 10382D 10368
ScKbd_22                       $e972 10385D 10394  10396
ScKbd_13                       $e973 10389D 10383
ScKbd_14                       $e97f 10395D 10392
ScKbd_15                       $e98b 10401D 10399
ScKbd_16                       $e98f 10406D 10390
ScKbd_18                       $e995 10409D 10402
ScKbd_24                       $e9a2 10418
ScKbd_26                       $e9a7 10423D 10414
ScKbd_28                       $e9af 10427D 10425
ScKbd_30                       $e9b1 10428D 10411
Lookup_Keycode                 $e9b4 10432D 10409
LoKe_10                        $e9bf 10440D 10438
LoKe_20                        $e9c0 10441D 10437
LoKe_30                        $e9c6 10444D 10441
Edit_Switch_Char_ROM           $e9ca 10448D  9495
EDIT_RESET_CRT                 $e9d3 10460D  9038   9053
EDIT_CHARSET_TEXT              $e9d6 10467D  9036   9487
EDIT_CHARSET_GRAPHICS          $e9e4 10478D  9037   9643
Read_Power_String              $e9f2 10489D  1537
Check_Linenumber               $e9fc 10499D 10532  10544
ChLi_Ret                       $ea1c 10520D 10517
Check_Line_Upwards             $ea1f 10525D 10568
CLU_10                         $ea21 10529D 10533
CLU_Ret                        $ea2b 10534D 10530
Check_Line_Downwards           $ea2c 10537D 10592
CLD_10                         $ea2e 10541D 10545
CLD_Ret                        $ea38 10546D 10542
Power_Scroll_Up                $ea39 10549D  9509   9708
PSU_10                         $ea4b 10562D 10566
PSU_20                         $ea61 10573D 10571
PSU_30                         $ea67 10575D 10563  10569  10593  10600
                                     10609  10632
PSU_Ret                        $ea70 10580D 10553  10587
Power_Scroll_Down              $ea71 10583D  9665
PSD_20                         $ea8f 10601D 10597
PSD_30                         $eaa7 10612D 10615
List_BASIC_Line                $eace 10637D 10574  10606  10631  11312
                                     13955
LBL_Ret                        $eae3 10651D 10643
Find_Power_Line                $eae4 10654D  8877  10573  10594
FPL_10                         $eaec 10661D 10683
FPL_40                         $eb14 10684D 10665  10672
KEYBOARD_NORMAL                $eb15 10687D 10444
KEYBOARD_SHIFTED               $eb65 10811D 10442
KEYBOARD_CONTROL               $ebb6 10927D 10435
Find_Entry                     $ec07 11022D  8970
Find_LINNUM                    $ec0b 11029D 11201
FiEn_10                        $ec17 11039D 11060
FiEn_20                        $ec38 11055D 11042
FiEn_30                        $ec3b 11058D 11044  11048
Install_Bank_Access            $ec43 11064D  7179   8891
FSC_10                         $ec45 11068D 11072
Bank_Fetch_Start               $ec51 11076D   907  11068  11071
Bank_Store_Start               $ec62 11095D   907
Bank_Fetch_End                 $ec62 11091
Bank_Store_End                 $ec75 11112D 11071
Get_Next                       $ec75 11117D 11150  11156  11165  11181
GeNe_10                        $ec7b 11123D 11121
Xfer_Line                      $ec7e 11127D  8977
XfLi_10                        $ec8f 11149D 11161  11170  11186
XfLi_20                        $ec9c 11155D 11160
XfLi_30                        $ecab 11162D 11154
XfLi_40                        $ecaf 11164D 11167
XfLi_50                        $ecb9 11169D 11163  11189
XfLi_55                        $eccf 11180D 11184
XfLi_60                        $ecda 11185D 11179
XfLi_70                        $ecde 11187D 11171  11173  11175  11177
XfLi_Ret                       $ece5 11190D 11152  11158
Exchange_Number                $ece6 11194D 11187  11225
ExNu_10                        $ed09 11215D 11220
ExNu_20                        $ed15 11221D 11199  11216
ExNu_Ret                       $ed21 11226
Reset_Renumber_Pointer         $ed22 11229D  8890   8951   9002  11307
                                     13915
Reset_BPTR                     $ed2a 11240D  8885
Update_Link                    $ed33 11250D  8936   8981   9844  11314
                                     13925
Extended_Command               $ed40 11264D 12900
ExCo_10                        $ed44 11269D 11296
ExCo_20                        $ed48 11272D 11277
ExCo_30                        $ed6a 11291D 11279
ExCo_40                        $ed6c 11292D 11294
Find_Text                      $ed78 11301D  3573
FiTe_10                        $ed83 11308D 11315
FiTe_20                        $ed92 11314D 11311
Contains_Pattern               $ed9a 11319D 11310  13920
CoPa_10                        $ed9a 11322D 11334
CoPa_20                        $ed9e 11324D 11331
CoPa_Ret                       $edb5 11336D 11327  11329
Load_Directory                 $edb6 11339D 11462
LoDi_10                        $edc6 11350D 11362
LoDi_20                        $edd0 11355D 11353
LoDi_30                        $edd2 11356D 11361
LoDi_40                        $ede0 11363D 11359
DOS_Get_Dir_Entry              $ede3 11366D 11420  11470
DGDE_05                        $edee 11381D 11378
DGDE_10                        $edf0 11383D 11386
DGDE_20                        $ee17 11406D 11411
DGDE_40                        $ee22 11413D 11409
DGDE_60                        $ee24 11415D 11418
DGDE_80                        $ee33 11424D 11387
DOS_Add_Comma                  $ee34 11427D 11481  11488  11495
DOS_Copy                       $ee3a 11448D  8275
DOSC_10                        $ee60 11470D 11606
DOSC_15                        $ee67 11475D 11472
DOSC_20                        $ee8a 11493D 11484
DOSC_25                        $ee92 11498D 11491
DOSC_35                        $eea7 11520D 11514
DOSC_47                        $eead 11525
DOSC_50                        $eeb5 11530D 11526
DOSC_55                        $eeb8 11534D 11584  11589  11591
DOSC_60                        $eeca 11543D 11550
DOSC_65                        $eeda 11552D 11548
DOSC_66                        $eeea 11560D 11555
DOSC_67                        $eefd 11570D 11567
DOSC_70                        $ef07 11575D 11581
DOSC_75                        $ef2b 11593D 11558  11578  11586
Send_Record_No                 $ef4c 11609D 11568
SRN_10                         $ef52 11615D 11613
Print_Filename                 $ef5d 11622D 11520
PrFi_10                        $ef64 11628D 11643
PrFi_20                        $ef82 11642D 11632  11635
PrFi_90                        $ef86 11644D 11626
Open_Read_File                 $ef87 11647D 11521
ORF_10                         $efa1 11662D 11660
Open_Write_File                $efa4 11665D 11530
KERNAL_MESSAGES                $f000 11683D 11839
MSG_TOO_MANY                   $f000 11686
MSG_FILE_OPEN                  $f00e 11687D 12408
MSG_FILE_NOT_O                 $f017 11688D  8200  12825
MSG_FILE_NOT_F                 $f024 11689D 12438
MSG_SEARCHING                  $f032 11690D 12256
MSG_FOR                        $f03d 11691
MSG_PRESS                      $f041 11692
MSG_RECORD                     $f04d 11693
MSG_ON_TAPE                    $f056 11694
MSG_LOAD                       $f05f 11695D 12251
MSG_WRITING                    $f064 11696
MSG_VERIFY                     $f06d 11697D 12254  12330
MSG_DEVICE_NOT                 $f074 11698D 12308  12827
MSG_NOT_INPUT                  $f086 11699
MSG_NOT_OUTPUT                 $f094 11700D 12829
MSG_FOUND                      $f0a3 11701
MSG_OK                         $f0aa 11702D 12332
MSG_READY                      $f0ae 11703D 12217
MSG_SURE                       $f0b6 11704D  8426
MSG_BAD_DISK                   $f0c5 11705D  8158
TALK                           $f0d2 11708D  8115   9985  11536  12170
                                     12813
LISTEN                         $f0d5 11715D  8260   9966  10005  11570
                                     12297  12705  12734  12853  13434
TALI_10                        $f0d7 11721D 11886
TALI_20                        $f0fa 11739D 11731
TALI_30                        $f0ff 11742D 11743
Send_IEEE_Byte                 $f109 11748D 11734  11782  11853  11866
SIB_10                         $f11e 11760D 11761
SIB_20                         $f128 11764D 11800
SIB_30                         $f12d 11766D 11770
tby6                           $f138 11771D 11812
SECOND                         $f143 11778D  9968  10008  11573  12305
                                     12707  12738  12855  13437
Set_ATN                        $f148 11785D 11855  11887
Time_Out_Writing               $f151 11794D 11768
Time_Out_Reading               $f15b 11803D 11901
Timo_W                         $f165 11810D 11798
Timo_S                         $f167 11811D 11819
Device_Not_Present             $f16c 11815D 11756
Timo_R                         $f170 11820D 11807
Set_NRFD_NDAC_low              $f175 11824D 11854
Display_Kernal_Message         $f185 11836D  8159   8427  11845  12095
                                     12333  12449
TKSA                           $f193 11849D  8118   9988  11539  12172
                                     12815
CIOUT                          $f19e 11858D  9970  10011  10262  10287
                                     11576  11971  12312  12711  12713
                                     12721  12921  13448
Ciout_10                       $f1a6 11865D 11862
Ciout_20                       $f1ab 11868D 11864
UNTLK                          $f1ae 11872D  6427   8129   9994  11553
                                     11993  12156
UNLSN                          $f1b9 11882D  7937   9971  10014  10266
                                     10290  11582  11593  11989  12316
                                     12728  12739  12924  13451
ACPTR                          $f1c0 11890D  7942   7946   7952   8120
                                      9990  11356  11543  11957  12136
                                     12173  12175
Acptr_10                       $f1cd 11898D 11809
Acptr_20                       $f1d2 11900D 11903
Acptr_30                       $f1ee 11911D 11908
Acptr_40                       $f1f9 11916D 11917
Kernal_GETIN                   $f205 11924D 14203
GETIN_10                       $f20d 11931D  7959   7962
Kernal_CHRIN                   $f215 11937D  7995   8429   8432   8437
                                      8440   8446   9951   9954  14161
KeIn_10                        $f224 11947D 11930  11941
KeIn_20                        $f231 11953D 11948
KeIn_30                        $f237 11956D 11932
KeIn_40                        $f238 11957D 11954
Kernal_CHROUT                  $f266 11962D 12446  12448  14167
KeCH_10                        $f271 11971D 11969
Kernal_CLALL                   $f2a2 11976D 12444  14209
Kernal_CLRCHN                  $f2a6 11983D  7170   7971   8428  12077
                                     14155
KeCL_10                        $f2af 11990D 11988
Set_Default_IO                 $f2b8 11996D 11992
LOOKUP_LA                      $f2c1 12006D  8198  12044  12409  12808
                                     12847
LOOK_10                        $f2c3 12010D 12013
LOOK_Ret                       $f2cb 12014D 12011
Set_LFS_From_X                 $f2cd 12019D  8202  12051  12810  12849
Kernal_CLOSE                   $f2dd 12034D 14137
Close_LA_in_A                  $f2e2 12041D  7973   8175
Close_File_A                   $f2e7 12048D  8188
ClFi_10                        $f2f1 12055D 12053
ClFi_20                        $f30b 12065D 12045  12057
Check_STOP_Key                 $f335 12070D  7442   7957  12086  12457
                                     13639  13918
ChST_Ret                       $f342 12080D 12075  12094
Kernal_STOP                    $f343 12083D  2110  11799  11808  12135
                                     12722  14197
Kernal_Message_If_Direct       $f349 12090D 12218  12255  12257
In_Direct_Mode                 $f351 12098D  8156   8400   8424  11625
                                     12093  12124  12151  12158  12219
Load_File                      $f356 12106D  7610  12214
LoFi_10                        $f35c 12112D 12114
LoFi_15                        $f35f 12113D 12111
LoFi_20                        $f370 12121D 12118
LoFi_25                        $f377 12124D 12122
LoFi_30                        $f38e 12133D  6429  12125
LoFi_35                        $f390 12134
LoFi_40                        $f392 12135D 12155
LoFi_45                        $f3a7 12144D 12138
LoFi_50                        $f3a9 12145D 12147
LoFi_55                        $f3af 12148D 12140
LoFi_60                        $f3bd 12154D 12149  12152
LoFi_70                        $f3c1 12156D 11363  12143
LoFi_80                        $f3cd 12161D 12159
Open_Load_File                 $f3d0 12164D  6424  11342  12116
Merge                          $f3e6 12178D  3575
Kernal_LOAD                    $f401 12187D 14173
KeLO_10                        $f403 12191D 12182
Load_Verify                    $f405 12194D 12326
Load_Verify_Params_Set         $f41d 12211D  8375  12199  12975
LVPS_20                        $f439 12226D 12220
LVPS_Ret                       $f43f 12228D 12216
Print_EAL                      $f440 12231D 12153  12161
PrEA_10                        $f44e 12240D 12242
PrEA_Ret                       $f454 12243
Display_Load_Or_Verify         $f46d 12248D 12126
DLOV_10                        $f475 12255D 12253
Get_File_Parameter             $f47d 12260D 12197  12689
GFP_Ret                        $f4a8 12282D 12296
Get_Comma_And_Byte             $f4a9 12285D 12273  12276  12348  12351
Send_Filename                  $f4af 12292D  9867  11662  11677  12169
                                     12429  12704
Send_DOS_Command               $f4ba 12302D  8262
SeDC_10                        $f4c6 12310D 12307
SeDC_20                        $f4c8 12311D 12315
Kernal_VERIFY                  $f4f6 12321D 14185
VERI_OK                        $f508 12332D 12329
Get_Open_Close_Parameter       $f50d 12336D 12037  12400
Set_Filename_From_String       $f53c 12360D 12271  12355
ChrGot_Or_RTS                  $f54d 12373D 12270  12272  12275  12347
                                     12350  12353
Get_Ret                        $f554 12380D 12377  12393  12425  12427
Get_Comma_And_Chr              $f555 12383D 12288  12354
Assert_Not_At_End              $f558 12389D 12344
Err_f55d                       $f55d 12394D 12407  12428
Kernal_OPEN                    $f560 12397D 14131
Mf563                          $f563 12401D  8084   8103
Open_File                      $f565 12404D  7938
Display_File_Not_Found         $f5ad 12435D 12123
Handle_IO_Error                $f5af 12441D  8201  12309  12331  12410
                                     12415  12830
Disassemble                    $f5c2 12453D  7319   7347
Disa_10                        $f5c5 12457D 12467
Disa_15                        $f5cf 12461D  7413
Disa_Main                      $f5e3 12469D 12458  12460
Print_Dis_Line                 $f5e6 12472D 12465  13370
Disa_20                        $f5e9 12477D 12485
Disa_40                        $f5f2 12480D 12487
Disa_50                        $f5f8 12482D 12479
Dis_Inst                       $f614 12499D 12464
DiIn_10                        $f61c 12505D 12508
Analyze_Opcode                 $f625 12511D 13328
AnOp_10                        $f634 12535D 12528
AnOp_20                        $f63f 12543D 12538
AnOp_30                        $f643 12545D 12530  12532
AnOp_40                        $f647 12547D 12544
AnOp_50                        $f65c 12559D 12568
AnOp_60                        $f660 12562D 12565
AnOp_70                        $f667 12567D 12558  12560
admode_index                   $f66b 12572D 12537
Kernal_SYS                     $f6c3 12664D 14191
Set_Save_Range                 $f6cc 12672D 12690
Kernal_SAVE                    $f6dd 12686D 14179
Mf6e0                          $f6e0 12690D  8356   8359
Save_File                      $f6e3 12693D  7635
SaFi_10                        $f6e9 12699D 12703
SaFi_20                        $f6ec 12700D 12698
SaFi_30                        $f70f 12716D 12724  12727
SaFi_40                        $f717 12720D 12717
SaFi_50                        $f727 12728D 12719
Close_Disk_File                $f72a 12731D  9995  10016  11598  11605
                                     12054  12157
Store_Mnemonic                 $f739 12742D 12489  13330
PrMn_10                        $f746 12751D 12762
PrMn_20                        $f74a 12753D 12757
Kernal_UDTIM                   $f768 12769D  9799  12790  14215
ud_10                          $f772 12777D 12775
ud_20                          $f784 12786D 12773  12779  12782
ud_30                          $f78e 12791D 12787
Kernal_CHKIN                   $f7af 12796D  7940  14143
CHKIN_10                       $f7d0 12819D 12812
CHERR_17                       $f7d6 12825D 12809  12848
CHERR_74                       $f7d9 12827D 12817  12857
CHERR_94                       $f7dc 12829D 12850
CHERR_IO                       $f7de 12830
Kernal_CHKOUT                  $f7fe 12835D 14149
KeCo_10                        $f821 12859D 12852
Set_Wedge_Unit                 $f827 12866D 12895
SWUN_10                        $f838 12876D 12870
Wedge_Parser                   $f842 12882D  1546
Command_Or_Status              $f869 12905D 12889  12891
Send_Command                   $f873 12915
SeCo_10                        $f876 12919D 12923
SeCo_20                        $f880 12924D 12920
Get_Status                     $f883 12927D 12910
Wedge_Directory                $f88c 12935D 12893  12912
Print_Status                   $f898 12944D 12931  13459
RUN_Now                        $f8a1 12951D 12959
Wedge_Run                      $f8a6 12954D 12899
WeRu_10                        $f8aa 12959D 12962
Wedge_Load                     $f8b3 12965D 12897  12972
WeLo_10                        $f8be 12973D 12970
Wedge_Prepare                  $f8c7 12978D  6417   7593   9964  12930
                                     12939  12974  13433  13458  13475
Wedge_Filename                 $f8d0 12988D 12938  12973
WeFi_10                        $f8db 12996D 12994  13000
WeFi_20                        $f8e4 13001D 12998
Mnemonic_Left                  $f8f3 13011D 12747
Mnemonic_Right                 $f933 13080D 12749
admode_format                  $f973 13149D 12548
adr_char1                      $f981 13177D 13207
adr_char2                      $f987 13178D 13210
Store_Address                  $f98d 13181D 12490  13331
StAd_10                        $f99f 13193D 13215
StAd_20                        $f9ae 13200D 13197
StAd_30                        $f9b9 13205D 13194
StAd_40                        $f9cd 13214D 13206  13211
StAd_50                        $f9d2 13217D 13202
StAd_Ret                       $f9d8 13219D 13188  13216
Store_Hex_XA                   $f9dc 13224D 13218  13851
Store_Hex                      $f9e2 13232D 13199  13204  13228  13789
                                     13791
Print_Dis_Buf                  $f9f9 13252D 12491
PDB_10                         $f9fb 13256D 13260
Ass_Operand                    $fa08 13264D 13270  13276  13325
AsOp_30                        $fa1e 13277D 13268  13272
AsOp_Ret                       $fa3e 13293D 13279  13282  13284
AsOp_40                        $fa3f 13294D 13286
Assemble                       $fa42 13298D  7311   7316   7339   7344
Ass_010                        $fa47 13307D 13314
Ass_020                        $fa4f 13311D 13318
Ass_040                        $fa70 13326D 13320
Ass_050                        $fa73 13327D 13341  13346
Ass_060                        $fa89 13335D 13339
Ass_070                        $fa94 13340D 13334
Ass_Err                        $faa4 13347D 13306  13312  13322  13343
                                     13358
Ass_080                        $faa7 13348D 13336
Ass_090                        $fab3 13354D 13360
Inc_STAL                       $fb13 13394D 13548  13566  13652
Add_STAL                       $fb15 13400D  7452  11059
AdST_00                        $fb16 13404D 12494
AdST_10                        $fb1c 13407
AdST_Ret                       $fb1e 13408D 13406
Inc_BPTR                       $fb1f 13412D  9938  13549  13567
Add_BPTR                       $fb21 13418D  8932   8980
AdBP_00                        $fb22 13422
AdBP_10                        $fb28 13425
AdBP_Ret                       $fb2a 13426D 13424
DOS_Open_Comm_Write            $fb2b 13430D 10259  10283  12918  13446
Mon_Wedge                      $fb38 13440D  7315   7343
MoWe_10                        $fb42 13448D 13450
Mon_Wedge_Status               $fb4d 13454D 13444
Mon_Dir                        $fb59 13463D  7310   7338
MoDi_10                        $fb5d 13468D 13471
Init_RAM_Vectors               $fb77 13480D  7122
IRV_10                         $fb79 13484D 13487
ROM_BASIC_Vector_Table         $fb83 13491D 13483  13484
RBVT_END                       $fb8f 13500D 13483
Set_STATUS                     $fbc4 13504D 11811  11821  11910  12142
Mon_Get_3                      $fbc9 13513D 13534  13558
MG3_Err                        $fbdf 13526D 13517  13520  13523
Mon_Compare                    $fbe4 13531D  7318   7346
MoCo_10                        $fbea 13536D 13551
MoCo_20                        $fc08 13548D 13545
Mon_Transfer                   $fc16 13555D  7328   7356
MoTr_10                        $fc23 13564D 13569
MoTr_Ret                       $fc34 13570D 13596
MoTr_Err                       $fc37 13571D 13585
MoTr_20                        $fc3a 13572D 13563
MoTr_30                        $fc62 13593D 13605
MoTr_40                        $fc73 13600D 13598
MoTr_50                        $fc7b 13604D 13602
Mon_Hunt                       $fc80 13608D  7322   7350
MoHu_10                        $fc85 13613D 13616
MoHu_20                        $fc99 13622D 13627
MoHu_30                        $fc9e 13624D 13621
MoHu_40                        $fca8 13629D 13618  13636
MoHu_50                        $fcb9 13637D 13623  13628  13630  13632
MoHu_60                        $fcbe 13639D 13653
MoHu_70                        $fcca 13644D 13649
MoHu_80                        $fcdd 13652D 13646
MoHu_Ret                       $fce2 13654D 13640  13642
MoHu_Err                       $fce5 13655D 13614  13620
Entry_RESET                    $fd16 13661D 14223
Entry_NMI                      $fd49 13689D 14222
Set_FA_to_8                    $fd4c 13695D 12343
Mon_Unit                       $fd51 13703D  7309   7337
MoUn_10                        $fd60 13713D 13707  13709  13711
Mon_Next                       $fd6e 13720D  7325   7353
Mon_Step_IRQ                   $fd89 13737D 13724  13726
MSI_10                         $fd96 13745D 13742
Get_Constant                   $fd99 13749D 13271
GeCo_10                        $fda2 13756D 13767
GeCo_20                        $fdaf 13761D 13764
GeCo_25                        $fdbd 13768D 13815
GeCo_30                        $fdcf 13778D 13758  13770
GeCo_40                        $fde4 13790D 13788
GeCo_Ret                       $fdef 13797D 13753  13772
GeCo_45                        $fdf2 13799D 13755
GeCo_50                        $fdfc 13804D 13814
GeCo_70                        $fe0d 13812D 13801  13803
Expand_Address                 $fe17 13819D 13345
ExAd_10                        $fe1a 13823D 13828
ExAd_20                        $fe27 13829D 13825
Expand_Target                  $fe36 13837D 13294
Offset_To_Target               $fe46 13857D 13217  13850
OTT_10                         $fe4d 13869D 13867
OTT_20                         $fe53 13873D 13871
OTT_30                         $fe59 13877D 13875
Replace                        $fe5a 13882D  3574
Repl_00                        $fe67 13890D 13887
Repl_01                        $fe6b 13892D 13896
Repl_02                        $fe82 13904D 13908
Repl_08                        $fe9a 13916D 13926
Repl_10                        $fe9e 13918D 13924
Repl_20                        $feb0 13925D 13921
Repl_Ret                       $feb8 13928D 13919
Repl_Err                       $febb 13929D 13894  13906
Replace_String                 $febe 13933D 13922
ReSt_05                        $fec7 13941D 13991
ReSt_10                        $fece 13946D 13951
ReSt_20                        $fed9 13952D 13948
ReSt_25                        $fee0 13955D 13953
ReSt_30                        $fee7 13958D 13940
ReSt_35                        $fefb 13971D 13969
ReSt_40                        $ff0a 13979D 13977
ReSt_45                        $ff1d 13989D 14032
ReSt_50                        $ff21 13992D 13958
ReSt_60                        $ff43 14011D 14021  14024
ReSt_62                        $ff4d 14016D 14014
ReSt_64                        $ff53 14019D 14017
ReSt_Ret                       $ff6f 14033
Basic_CONCAT                   $ff93 14038D  1118
Basic_DOPEN                    $ff96 14044D  1119
Basic_DCLOSE                   $ff99 14050D  1120
Basic_RECORD                   $ff9c 14056D  1121
Basic_HEADER                   $ff9f 14062D  1122
Basic_COLLECT                  $ffa2 14068D  1123
Basic_BACKUP                   $ffa5 14074D  1124
Basic_COPY                     $ffa8 14080D  1125
Basic_APPEND                   $ffab 14086D  1126
Basic_DSAVE                    $ffae 14092D  1127
Basic_DLOAD                    $ffb1 14098D  1128
Basic_DIRECTORY                $ffb4 14104D  1129   1132
Basic_RENAME                   $ffb7 14110D  1130
Basic_SCRATCH                  $ffba 14116D  1131
Read_DS                        $ffbd 14122
OPEN                           $ffc0 14128D  1113
CLOSE                          $ffc3 14134D  1114
CHKIN                          $ffc6 14140D  2924   2944
CHKOUT                         $ffc9 14146D  2751
CLRCHN                         $ffcc 14152D  1497   2953
CHRIN                          $ffcf 14158D  1674
CHROUT                         $ffd2 14164D  1504   2800   2854   2883
                                      9876   9877  11600  11630  11636
                                     11638
Basic_LOAD                     $ffd5 14170D  1101
Basic_SAVE                     $ffd8 14176D  1102
Basic_VERIFY                   $ffdb 14182D  1103
Basic_SYS                      $ffde 14188D  1112
STOP                           $ffe1 14194D  1938
GETIN                          $ffe4 14200D  3039
CLALL                          $ffe7 14206D  1865
UDTIM                          $ffea 14212
HardwareVectors                $fffa 14219
INDEXA                         $001f   367D  1399   1409   1415   1564
                                      1566   1589   1591   1593y  1597
                                      1649y  1653   1656y  1658   1660y
                                      1661   1662   1663y  1724   1726
                                      1729   1731   1734y  1765y  1767
                                      1769   1772y  2021   2023   2027
                                      2029   2030y  2034y  2560y  2634
                                      2635   2648   2650   2681y  2685y
                                      2688y  2695   2696   2700   2702
                                      2853y  3299   3301   3356   3358
                                      3373   3375   4046   4047   4049y
                                      4052y  4055y  4059y  4067y  4071
                                      4072   4074   4075   4081y  4085y
                                      4089y  4098   4101   4105   4106
                                      4108   4332   4400   4433   4760
                                      4763   4768   4780y  4783y  4835
                                      4837   4840y  4850   4854y  4865y
                                      4875y  4878y  4968   4969   4979y
                                      5012   5013   5023   5024   5039y
                                      5042y  5045y  5047   5048   5106
                                      5107   5109   5199y  5239   5242
                                      5244   5755   5756   5758y  5761y
                                      5764y  5767y  5775y  5955   5956
                                      5958y  6010   6011   6014y  6017y
                                      6020y  6025y  6028y  8675y  8791y
                                      8797   8799   8809   8810  10219
                                     10222  12366  12368
TMPPTC                         $005c   523D  1398   1402   1563y  1567
                                      1569   1571y  1579   1582   1627y
                                      1794   1795   1796y  1801y  1806y
                                      1810y  1936y  1944y  1947y  1965y
                                      1968y  1969   1970   1994y  2003y
                                      2299   2302   3951   3952   3958y
                                      3962y  3967   4016   4017   4113y
                                      4116y  4119y  4121y  4123y  4125y
                                      4127y  4128   4131   4147   4148
                                      4241   4242   4248y  4253y  4256y
                                      4258   4261y  4262   4287y  4299y
                                      4304y  4313y  4325y  4328y  4360
                                      4362y  4365   4366y  4370y  4381y
                                      4386y  4434y  4437y  6281   6284
                                      6291   6292   6318   6349   8899y
                                      8905y  8908y  8956y  8959y  8966y
                                      8969y  9005y  9012   9015   9829
                                      9831   9847y  9852   9853  10595
                                     10598  10602  10604  10624y 10627y
                                     10628  10629  10642y 10645y 10648y
                                     10661  10662  10664y 10667y 10670y
                                     10673  10675  10679y 10682y 11141
                                     11144  11235  11237  11254y 11257y
                                     11258  11259  11330y 11333y 13949y
                                     13961  13963  13967  13968  13970
                                     13986  13988  13994  13996
FAC1M3/FAC1M4                  $0061   530D  2506   2590y  2593y  2609
                                      2612   2619y  2624   2729   2730
                                      3365   3475   3605   3644y  3647y
                                      3719   3746   3780   3792   3797
                                      4223   4378   4397   4655   4731
                                      4922   4933y  5001   5223   5296
                                      5440   5464   5467   5489   5491
                                      5503   5523   5546   5548   5564
                                      5698   5882   5908   5946   5977
                                      6016   6123   6167   6200   6582
                                      6584   6885   6903   6905    531D
                                      2413   2509   2605   2613   2625
                                      2726   2727   3363   3472   3606
                                      3611   3656   3720   3744   3782
                                      3789   3794   4225   4380   4401
                                      4656   4732   4920   5002   5129
                                      5145   5147   5225   5297   5437
                                      5466   5469   5486   5488   5502
                                      5524   5549   5551   5562   5696
                                      5885   5905   5948   5978   6013
                                      6122   6173   6201   6231   6236
                                      6579   6581   6887   6898   6900
TXTPTR                         $0077   579D  1538   1539   1695   1722
                                      1763   1777   1779   1900   1903
                                      2066   2068   2111   2114   2118y
                                      2121y  2125y  2128y  2131   2132
                                      2134   2212   2213   2241   2242
                                      2263   2265   2290   2291   2301
                                      2304   2329   2331   2345   2346
                                      2348   2370y  2910   2911   3027
                                      3028   3033   3034   3050   3051
                                      3061   3076   3077   3100   3101
                                      3106   3107   3121y  3124y  3127y
                                      3130y  3209   3211   3261   3263
                                      3264   3319   3321   3322   3449
                                      3450   3518y  4545   4547   4594
                                      4596   4599   4602   4616   4618
                                      5235   5236   5240   5245   5266
                                      5267   6359y  7057   7059   8656
                                      8658   8659y 10510  10515  11120
                                     11122  11123x 11143  11146  11270
                                     11282  11322  12101  12887y 12908
                                     12909y 12919y 12995  12997y 13002
                                     13004  13891  13902
LINNUM                         $0011   346D  1616   1617   1800   1805
                                      1925   1926   1928   1951   1953
                                      2286   2433   2434   2436   2457
                                      2459   2461   2462   2463   2465
                                      2466   2467   2468   2470   2471
                                      2473   5298   5299   5306   5308
                                      5312y  5315   5317   5327y  5342y
                                      7095   7096   7101y  7104y  7105y
                                      7108y  7109y  7112y  7115   7117
                                      8213   8215   8854   8856   8859
                                      8866   8868   8870   8972   8975
                                      9838   9839   9841  10570  10572
                                     10668  10671  11025  11026  11043
                                     11047  11051  11054  11204  11206
                                     11476  11477  11612  11614  12669
                                     12877  13805  13807  13810
FAC1M1/FAC1M2                  $005f   528D  2080   2081   3369   3678
                                      3833   3859y  4491   4665   4684
                                      4726   5079y  5446   5460   5463
                                      5495   5497   5505   5521   5540
                                      5542   5568   5702   5876   5914
                                      5942   5964   5967   5975   6024
                                      6109   6113   6159   6198   6454
                                      6588   6590   6881   6899   6901
                                     11207    529D  2549   3367   3834
                                      4492   4666   4685   4728   5443
                                      5462   5465   5492   5494   5504
                                      5522   5543   5545   5566   5700
                                      5879   5911   5944   5976   6019
                                      6111   6163   6199   6455   6585
                                      6587   6883   6902   6904  11205
STRPTR/FROUND                  $006c   548D  2591   2594   2598   2602
                                      2621   2622   3406   4682   4683
                                      4688y  4699   4701   4705   4711
                                      4712   4927   4929   4931y  4943
                                      4944   4954y  4957y  4960y  5370
                                      5425   5770   5796   5825   5850
                                      6339   6807   6937    553D  4733
                                      4897   5388   5423   5434   5468
                                      5470   5485   5501   5525   5552
                                      5554   5555   5583   5604   5694
                                      5738   5926   5963   6029   6048
                                      6066   6075   6125   6171   6202
                                      6203   6211   6778   6800   6909
FAC1EX                         $005e   527D  2389   2527   2627   2628
                                      3371   3407   3832   3842   3846
                                      4182   4667   4697   4724   4890
                                      5292   5371   5410   5413   5420
                                      5427   5480   5508   5512   5519
                                      5652   5656   5777   5787   5794
                                      5827   5868   5869   5871   5959
                                      5968   6027   6045   6062   6073
                                      6090   6124   6155   6188   6225
                                      6230   6340   6499   6749   6784
                                      6794   6795   6908   6911   7014
STAL                           $00fb   877D  7276   7278   7410   7412
                                      7432   7434   7506   7508   7657
                                      7659   7692   8999   9001   9008
                                      9013   9991y 10010y 11035  11037
                                     11082y 12680  12682  12708  12709
                                     12715  12720y 12726  13289  13349
                                     13351  13378  13382  13404  13405
                                     13407  13541  13560  13562  13574
                                     13576  13580  13582  13597  13599
                                     13600  13865  13870
TMPPTD                         $006e   557D  1719   1739   2529   2532
                                      2533   2541   3620   4296   4308
                                      4330   4331   4348   4349   4355
                                      4373   4374   4391   4392   4402
                                      4405   4455   4456   4700   4704
                                      5237   5238   5264   5265   6493
                                      6561   6570   6607   6617   6630
                                      6818   6819   6832   6833   6840y
                                      6842   6846   6847   6848   6850
                                      6851   6856   6857
FUNCPT                         $004b   491D  4561   4562   4576   4578
                                      4580y  4584y  4598y  4601y  4609
                                      4611   4621y  4624y  4627y  4630y
                                      4633y  4806   4809   4812   4814
                                      4817   4819   4821   4824y  4828
                                      4829y  4830   4832   4836y  4839
                                      4841   4843   4859   4862   4867y
                                      4871y  6721   6722   6727   6728
                                      6737   6738   6970   6971   6980
                                      6981
TMPPTA                         $0055   515D  1414   1416   1418   1421y
                                      1425y  1427   1609   1614   4026
                                      4027   4029   4030   4034   4035
                                      4040   4041   4056   4057   4060
                                      4061   4076   4078   4151   4152
                                      4335   4337   4340   4352y  4354
                                      4357   4418   4421  13974  13979
                                     13995  13998  14004  14007  14011y
                                     14016  14018  14020  14023
FAC1SI                         $0063   532D  2078   2093   2528   2722
                                      3193   3360   3405   3848   3854
                                      4175   5290   5366   5368   5415
                                      5481   5532   5534   5769   5797
                                      5799   5965   6022   6042   6092
                                      6126   6133   6153   6175   6206
                                      6232   6338   6488   6492   6751
                                      6753   6907   6942   6946   6977
                                      7010   7013   7030
CHRGET                         $0070   577D  1540   1920   2090   2171
                                      2417   2440   2836   2921   3055
                                      3220   3286   3424   3434   3520
                                      3548   3735   3915   3920   3940
                                      4167   5210   6265   6271   6282
                                      7087   8616   8666   8687   8695
                                      8762   8819   8864   8875   9836
                                     11198  11290  11305  12869  12968
                                     13889
RENNEW                         $0023   388D  8847   8850   8855   8860
                                      8880   8883   8911   8914   8920
                                      8922   8923   8925   8994   9006
                                     11306  11309  11323  11328  11332
                                     13890  13895  13897  13903  13907
                                     13913  13914  13917  13923  13937
                                     13938  13939  13943  13945  13952
                                     13973  14000  14001  14002  14005
                                     14025
CHRGOT                         $0076   578D  1916   2087   2181   2273
                                      2384   2398   2758   3035   3094
                                      3108   3217   3274   3551   3881
                                      3890   3903   4228   4612   5130
                                      5226   5254   5337   7740   7757
                                      7767   8575   8682   8729   8851
                                      8861   8872   9826   9833  10516
                                     11222  12376  12392  12992  13885
VARTAB                         $002a   396D  1565   1573   1574   1576
                                      1578   1583   1606   1610   1622
                                      1623   1835   1838   1866   1867
                                      2606   2610   3949   3950   6431
                                      6433   9016   9017   9845  12201
                                     12204  12222  12224  12675  12677
                                     13971  13975  13982  13984  14019
                                     14022  14026  14030
SA                             $00d3   847D  6419   7590   7626   7934
                                      8059   8117   8211   9870   9987
                                     10007  11538  11563  11572  11597
                                     11604  11653  11671  12028  12115
                                     12168  12171  12208  12267  12277
                                     12298  12340  12352  12419  12421
                                     12701  12706  12735  12814  12854
                                     13436
STATUS                         $0096   625D  2981   3560   3689   6425
                                      7944   7954   8458   9866  11348
                                     11358  11541  11546  11565  11577
                                     11618  11655  11673  11928  11953
                                     12121  12134  12154  12264  12306
                                     12327  12341  12413  12805  12816
                                     12844  12856  12984  13507  13508
FNADR                          $00da   854D  6412   6414   7571   7573
                                      7602y  8298   8300   8515   8517
                                      9885y 11392  11394  11397y 11401y
                                     11404y 11407y 11416y 11431y 11486y
                                     11493y 11498y 11508  11628y 11633y
                                     11640y 11658y 11676y 12311y 12367
                                     12369  13003  13005
EAL                            $00c9   816D  6422   6423   6430   6432
                                      7630  11345  11347  11350  11355
                                     11357y 12119  12120  12127  12129
                                     12139y 12144y 12145y 12146y 12148
                                     12150  12203  12206  12221  12223
                                     12234  12236  12280  12281  12676
                                     12678  12716  12718
TXTTAB                         $0028   392D  1643   1644   1786   1787
                                      1829y  1831y  1832   1836   1898
                                      1901   2191   2193   2295   2296
                                      6420   6421   7094   7100   7128
                                      7131  10214y 10216y 10596  10599
                                     10657  10658  11234  11236  12278
                                     12279  12679  12681
TMPPTB                         $0057   516D  1397   1401   1407   1410
                                      1412   1420y  1424y  1426   1607
                                      1611   4020   4021   4086   4091
                                      4099y  4102y  8879y  8882y 10601
                                     10603  10659  10660  10674  10676
                                     13972  13976  14006  14009  14012y
                                     14013  14015
CursorCol                      $00c6   813D  2809   2828   4500   9078
                                      9156   9185   9215   9232   9285
                                      9311   9330   9366   9369   9383
                                      9385   9421   9473   9556   9647
                                      9648   9675   9721   9806   9899
                                      9902  10556  10576  10590  10610
                                     11942
FA                             $00d4   848D  7619   8111   8114   8181
                                      8273   8574   8775  11452  11455
                                     11503  11535  11561  11595  11602
                                     11651  11669  11740  12030  12109
                                     12269  12274  12349  12423  12696
                                     12818  12858  12982  13007  13699
FORPNT                         $0046   475D  1365   1368   1370   1373
                                      2096   2098   2313   2483   2484
                                      2507y  2510y  2520   2639   2642
                                      2647   2649   2663y  3025   3026
                                      3175   3176   3194   3195   5335
                                      5340   5343   5344   6002   6003
FRETOP                         $0030   408D  1458   1461   1470   1473
                                      1859   1860   2599   2603   2690
                                      2693   4092   4095   4479   4482
                                      4758   4761   4786   4787   4811
                                      4813   4881   4883   5025   5027
                                      5032   5035   7120   7121  11352
STREND                         $002e   404D  1394   1395   1620   1621
                                      1870   1871   4018   4019   4042
                                      4044   4243   4245   4345   4346
                                      4359   4363   4480   4483   4771
                                      4774  11343  11465  11544y 11575y
                                     13981  13983  14027  14031
BPTR                           $00f9   876D  7507   7509   8982   8992
                                      8995   9921   9932   9934  11103y
                                     11244  11246  13350  13352  13422
                                     13423  13425  13521  13536  13559
                                     13561  13587  13589  13590  13592
                                     13601  13603  13604
TMPVAR                         $005a   522D  3618   3622   4445   4466
                                      6256   6288   6295   6297   6298
                                      6303   6308   6320   6345   6355
                                      6362   6482   6514   6523   6529
                                      6545   6556   6557   6612   6639
                                      6644
FNLEN                          $00d1   845D  6416   7613   8296   8513
                                      8569   8671   9883  11413  11480
                                     11512  11515  11516  11527  11528
                                     11642  12113  12265  12295  12314
                                     12342  12365  12702  13001  13472
FRESPC                         $0032   412D  4776   4777   4784   4785
                                      4805   4808   4845   4847   4848
                                      4851y  4853   4855   4857   4861
                                      4868y  4872y  4874   4877   4880
                                      4882   4980y  4985   4986   4988
CURLIN                         $0036   422D  1512   1544   2071   2073
                                      2126   2129   2214   2219   2220
                                      2245   2246   2267   2269   2285
                                      2325   2327   2898   2899   3205
                                      3207   4513   6447   6448
FAC2M3/FAC2M4                  $0069   542D  3400   3835   3838   3858y
                                      5490   5726   5762   5881   5897
                                      5907   5909    543D  3402   3836
                                      3839   5487   5723   5759   5884
                                      5896   5904   5906
VARNAM                         $0042   464D  3607   3608   3902   3935
                                      3936   3941   3957   3960   3995
                                      3996   4112   4115   4207   4209
                                      4213   4215   4250   4252   4298
                                      4303   4407   4410
ScrPtr                         $00c4   812D  9157y  9173y  9216y  9272y
                                      9319y  9386y  9388y  9395y  9514y
                                      9552y  9557y  9560y  9564y  9677y
                                      9740y  9808y  9813y 10151  10155
                                     10562y 10612
MEMUSS                         $00fd   878D  7431   7433   7464   7465
                                      7472   8299   8301   8312y  8725
                                      8726   9924   9931   9933  13518
                                     13573  13575  13577  13579  13581
                                     13583
TopMargin                      $00e0   859D  9059   9070   9305   9339
                                      9356   9502   9520   9523   9658
                                      9687   9690   9693   9753   9766
                                     10529  10540  10608  10616  10619
                                     10622
CursorRow                      $00d8   852D  9071   9084   9182   9306
                                      9309   9501   9522   9638   9659
                                      9661   9689   9704   9709  10554
                                     10567  10578  10588  10607  10630
                                     11944
QUOTE                          $0022   260D  1988   1997   2375   2964
                                      3069   3442   4674   4694   7596
                                      7600   8595   8702   9255   9259
                                     11153  11159  11385  11408  13886
INDEXB                         $0021   371D  1568   1575   1587   1594y
                                      1598   3187   5243   5248   5250y
                                      5253y  5258y  6140   6146   6148y
                                      6152y  6157y  6162y  6166y  6172
CR                             $000d   248D  1675   2799   7293   7966
                                      7996   8403   8433   8441   8443
                                      9168   9238   9426   9583  11599
                                     11832  11955  12445  13371  13797
VALTYP                         $0007   285D  2489   2776   3056   3246
                                      3294   3316   3423   3609   3829
                                      3913   3927   4202   4234   4474
                                      4490   4735   5188
RigMargin                      $00d5   850D  9170   9275   9308   9320
                                      9349   9367   9390   9472   9515
                                      9551   9567   9640   9741  10565
                                     10613  11950
IOPMPT                         $0010   338D  1498   2752   2792   2866
                                      2901   2925   2932   2945   2952
                                      2955   2979   2998   3046   3146
                                      3557   7090
COUNT                          $0005   272D  1559   1608   1624   1721
                                      1738   1764   4144   4231   4285
                                      4309   4333   4371   4403  11268
                                     11283  11291
DESCPT                         $004d   495D  2632   2633   2662y  4657
                                      4658   4939   4940   5089y  5092y
                                      5099   5100   5120y  5142y  5164
                                      5166
VARPTR                         $0044   470D  4134   4135   4419   4422
                                      4424   4541   4543   4581   4586
                                      4588y  4592   4603   4605   6606
                                      6618
FAC2EX                         $0066   539D  3394   3823   3824   5390
                                      5391   5428   5430   5776   5784
                                      6044   6063   6718   6793   6796
LefMargin                      $00e2   861D  9077   9284   9304   9329
                                      9340   9357   9382   9503   9646
                                      9674   9720  10140  10509
Mon_Lo                         $00c2   806D 13203  13288  13292  13309
                                     13761  13765  13766  13775  13776
                                     13790  13804  13809  13866
CHARAC                         $0003   270D  2363   2367   2368   3063
                                      3068   3072   3778   3787   4675
                                      4690   6237   6732   6789
DOS_RL                         $00b9   798D  9874   9878   9880  11475
                                     11490  11513  11525  11549  11554
                                     11566  11585  11659
RENINC                         $0021   375D  8846   8849   8867   8871
                                      8921   8924   9830   9832   9848y
                                      9851   9855   9856
LA                             $00d2   846D  7746   7936   8173   8197
                                      8565   8609  12026  12038  12346
                                     12401  12417
Mon_A                          $00bf   803D 12748  12754  13185  13200
                                     13205  13540  13544  13578  13584
                                     13588  13591
VERCK                          $009d   666D  7588   7608   7633   8374
                                     12137  12191  12198  12215  12252
                                     12325  12886
JIFFY_CLOCK                    $008d   593D  2550   3673   3674  10030
                                     12772  12774  12776  12777  12780
                                     12784  12785
MONCNT                         $00b5   790D  7239   7248   7251   7267
                                      7399   7402   7505   7519  13637
                                     13648
CharsInBuffer                  $009e   670D  9133   9135   9145   9162
                                     10412  10419  11931  12078  12958
                                     13389
FAC2SI                         $006b   544D  3404   3819   5369   5414
                                      5768   5771   6036   6337   6724
                                      6932
FAC2M1                         $0067   540D  3396   3821   3822   5496
                                      5732   5773   5875   5899   5913
                                      5915
FUNJMP                         $0052   509D  3760   3762   5158   5167
                                      5389   5419   5433   5484   6782
                                      6799
INDEXC                         $004f   499D  2640y  2643y  2654y  2657y
                                      2701   2704   5019y  5022y  5030
                                      5033
ARYTAB                         $002c   400D  1868   1869   3953   3955
                                      4014   4015   4032   4033   4239
                                      4240
FAC3M4                         $0026   382D  4443   4463   5582   5585
                                      5693   5722   5724   5737   5890
                                      5947
FAC3M3                         $0025   381D  4414   4435   4460   5584
                                      5587   5692   5725   5727   5736
                                      5945
GARBFL                         $0009   306D  1697   1709   1750   3703
                                      3706   3707   3710   4753   4790
                                      4794
ENDCHR                         $0004   271D  1706   1754   1757   2365
                                      2366   2369   2372   3075   4676
                                      4692
BSOS_KBD                       $0001    15D 10703  10716  10727  10786
                                     10799  10817  10830  10841  10900
                                     10913
BotMargin                      $00e1   860D  9062   9348   9639   9705
                                      9751   9768  10528  10541  10558
LDTND                          $00ae   768D  8053   8182  11980  12009
                                     12055  12056  12058  12411  12416
CINV                           $0090   601D  7186   7188   7537   7539
                                      9793  10037  10039  13725  13727
INPPTR                         $0040   454D  3019   3020   3031   3032
                                      3102   3103   3138   3139   3144
OLDTXT                         $003a   434D  1889   2115   2116   2217
                                      2218   2237   2240   2908   2909
QTSW                           $00cd   839D  9180   9228   9257   9258
                                      9434   9585   9731  10650
Mon_Hi                         $00c3   807D 13198  13285  13310  13762
                                     13771  13786  13806  13811
DosPtr                         $00bb   800D 11375  11377  11379  11384y
                                     11391  11393  11464  11468
W_Bank                         $00b7   796D  7194   7382   7495   7988
                                      8894   8950  11099  13538
R_Bank                         $00b6   795D  7192   7380   7493   7980
                                      8893   8990  11038  11079
Source_Unit                    $009c   661D  8271   8572   8633   8636
                                     11454  11534  11601  11650
FAC2M2                         $0068   541D  3398   5493   5729   5765
                                      5878   5898   5910   5912
ACCSYM                         $004a   485D  3273   3282   3283   3285
                                      3289   3324   3339   3830
MEMSIZ                         $0034   416D  1857   1858   4804   4807
                                      7118   7119   7126   7130
INSRT                          $00dc   855D  9269   9271   9430   9566
                                      9569   9589   9729
DATAX                          $00d9   853D  9221   9223   9224   9243
                                      9248   9407   9422
Mon_Op                         $00c1   805D 12477  12506  13308  13327
                                     13340  13354  13357
Dis_Line                       $00ba   799D  7420   7422   7424   7462
                                      7475   9965  13348
Wedge_Unit                     $00ab   754D  7098  12871  12878  12981
                                     13006  13712  13714
Key_Flags                      $0098   639D  6409  10033  10319  10321
                                     10361  10362  10436
FACTPA                         $0054   514D  5994   5995   6821   6824
                                      6825   6973   6974
FAC3M2                         $0024   380D  5586   5589   5691   5728
                                      5730   5735   5943
FAC3M1                         $0023   379D  5588   5591   5690   5731
                                      5733   5734   5941
SUBFLG                         $000a   312D  1890   2052   3931   3943
                                      3948   4534   4559
INTFLG                         $0008   291D  2487   3089   3641   3914
                                      3934   4200   4236
Mon_Tmp                        $00cb   818D  7513   7516   7722   7727
                                     13768  13799
SAL                            $00c7   815D  9095   9096   9097y  9739y
                                     10125  10129
Dis_Length                     $00be   802D 12483  12493  12551  13187
                                     13195  13353
PC_Adjust                      $00b3   788D  7169   7181   7197   7407
                                     12466  12468
DFLTO                          $00b0   776D  9240  10043  11966  11986
                                     12000  12859
YSAVE                          $0048   481D  3029   3030   3104   3105
                                      3310   3389
TANSGN                         $000c   326D  3392   3867   6948   6950
                                      6968   6978
DIMFLG                         $0006   279D  3896   4199   4238   4282
                                      4316   4367
DFLTN                          $00af   772D 11929  11940  11990  12002
                                     12819
Target_Unit                    $00ad   761D 11453  11502  11560  11594
                                     11668
CRSW                           $00ac   759D  9171   9208   9237   9420
                                     11949
BLNCT                          $00a8   733D  9154   9274   9802   9805
                                     10060
BSOUR                          $00a5   693D 11741  11757  11781  11852
                                     11868
Power_Flag                     $0099   644D  9719  10493  10495  10552
                                     10586
LASTPT                         $0014   356D  4736   5058   5060   5064
                                      7091
INPFLG                         $000b   316D  2891   3018   3037   3058
                                      3140
DELAY                          $00e6   865D 10062  10391  10393  10408
DOS_FC                         $00b1   786D 11421  11482  11552  11580
BLNON                          $00aa   749D  9149   9152   9807   9810
LastInputCol                   $00a1   680D  9178   9186   9234  11951
C3PO                           $00a0   678D 11730  11736  11861  11863
ReverseFlag                    $009f   674D  9266   9481   9629   9730
CBINV                          $0092   609D  9792  13674  13676  13744
RNDX                           $0088   584D  6889   6890   6913   6914
BITS                           $0065   535D  4892   4898   4899   6195
SGNFLG                         $0064   533D  6264   6311   6841   6861
DATPTR                         $003e   448D  2196   2197   3008   3009
DATLIN                         $003c   442D  2896   2897   3125   3129
OLDLIN                         $0038   427D  2221   2222   2243   2244
TEMPPT                         $0013   351D  1879   4719   4740   5062
SCROV                          $00eb   874D  9412  10079  10080
SCRIV                          $00e9   873D  9202  10075  10076
PrevChar                       $00e8   872D  9296   9527  10029
CHIME                          $00e7   866D 10082  10095  10104
KOUNT                          $00e5   864D 10063  10395  10401
LSTX                           $00e4   863D 10384  10389  10406
ScreenRows                     $00df   858D  9112   9341  10066
Mon_ZP                         $00cc   819D 13342  13344  13787
BLNSW                          $00a7   726D  9146   9800  10061
InputRow                       $00a3   681D  9181   9703  11945
Default_Bank                   $009a   651D 10035  11084  11105
Key_Index                      $0097   630D 10323  10356  10382
NMINV                          $0094   614D 13670  13672  13692
FACTPB                         $0059   521D  5987   6859   6860
RIGHT                          $001d   259D  2870   9436   9591
JIFFY6                         $00f8   875D 12786  12789
XMAX                           $00e3   862D 10041  10413
Mon_B                          $00c0   804D 12750  12753
Mon_Format                     $00bd   801D 12549  13184
DOS_EOF                        $00b2   787D 11547  11583
GDBLN                          $00a9   742D  9155   9811
SFDX                           $00a6   719D 10324  10428
InputCol                       $00a4   682D  9184  11943
Stop_Flag                      $009b   656D 10427  12073
JUMPER                         $0051   504D  3763   7079
CTRLY                          $0019   257D  9452   9605
CTRLV                          $0016   256D  9454   9601
TEMPST                         $0016   363D  1878   4720
CTRLU                          $0015   255D  9456   9611
DEL                            $0014   254D  9432   9587
HOME                           $0013   253D  9460   9597
RVS                            $0012   252D  9440   9595
DOWN                           $0011   251D  9438   9593
CTRLO                          $000f   250D  9448   9607
CTRLN                          $000e   249D  9444   9609
TAB                            $0009   247D  9450   9599
CTRLD                          $0004   245D  9458   9613
CTRLB                          $0002   244D  9446   9603
USRVEC                         $0001   268D  7083   7084
Basic_USR                      $0000   267D  1143   7080
ISNUM                          $007d   580D  2561
ESC                            $001b   258D  9428
BELL                           $0007   246D  9442
CTRLA                          $0001   243D  9462
FSBLK                          $00de   857
ROPRTY                         $00dd   856
TAPE1                          $00d6   851
ZD0                            $00d0   843
EOT                            $00cf   842
BITTS                          $00ce   841
ZP_b8                          $00b8   797
SCROLLING                      $00b4   789
FAC3M5                         $0027   384
DS_Ptr                         $000e   331
DS_Len                         $000d   330
INDEXA                         $001f   367D  1399   1409   1415   1564
                                      1566   1589   1591   1593y  1597
                                      1649y  1653   1656y  1658   1660y
                                      1661   1662   1663y  1724   1726
                                      1729   1731   1734y  1765y  1767
                                      1769   1772y  2021   2023   2027
                                      2029   2030y  2034y  2560y  2634
                                      2635   2648   2650   2681y  2685y
                                      2688y  2695   2696   2700   2702
                                      2853y  3299   3301   3356   3358
                                      3373   3375   4046   4047   4049y
                                      4052y  4055y  4059y  4067y  4071
                                      4072   4074   4075   4081y  4085y
                                      4089y  4098   4101   4105   4106
                                      4108   4332   4400   4433   4760
                                      4763   4768   4780y  4783y  4835
                                      4837   4840y  4850   4854y  4865y
                                      4875y  4878y  4968   4969   4979y
                                      5012   5013   5023   5024   5039y
                                      5042y  5045y  5047   5048   5106
                                      5107   5109   5199y  5239   5242
                                      5244   5755   5756   5758y  5761y
                                      5764y  5767y  5775y  5955   5956
                                      5958y  6010   6011   6014y  6017y
                                      6020y  6025y  6028y  8675y  8791y
                                      8797   8799   8809   8810  10219
                                     10222  12366  12368
TMPPTC                         $005c   523D  1398   1402   1563y  1567
                                      1569   1571y  1579   1582   1627y
                                      1794   1795   1796y  1801y  1806y
                                      1810y  1936y  1944y  1947y  1965y
                                      1968y  1969   1970   1994y  2003y
                                      2299   2302   3951   3952   3958y
                                      3962y  3967   4016   4017   4113y
                                      4116y  4119y  4121y  4123y  4125y
                                      4127y  4128   4131   4147   4148
                                      4241   4242   4248y  4253y  4256y
                                      4258   4261y  4262   4287y  4299y
                                      4304y  4313y  4325y  4328y  4360
                                      4362y  4365   4366y  4370y  4381y
                                      4386y  4434y  4437y  6281   6284
                                      6291   6292   6318   6349   8899y
                                      8905y  8908y  8956y  8959y  8966y
                                      8969y  9005y  9012   9015   9829
                                      9831   9847y  9852   9853  10595
                                     10598  10602  10604  10624y 10627y
                                     10628  10629  10642y 10645y 10648y
                                     10661  10662  10664y 10667y 10670y
                                     10673  10675  10679y 10682y 11141
                                     11144  11235  11237  11254y 11257y
                                     11258  11259  11330y 11333y 13949y
                                     13961  13963  13967  13968  13970
                                     13986  13988  13994  13996
FAC1M3/FAC1M4                  $0061   530D  2506   2590y  2593y  2609
                                      2612   2619y  2624   2729   2730
                                      3365   3475   3605   3644y  3647y
                                      3719   3746   3780   3792   3797
                                      4223   4378   4397   4655   4731
                                      4922   4933y  5001   5223   5296
                                      5440   5464   5467   5489   5491
                                      5503   5523   5546   5548   5564
                                      5698   5882   5908   5946   5977
                                      6016   6123   6167   6200   6582
                                      6584   6885   6903   6905    531D
                                      2413   2509   2605   2613   2625
                                      2726   2727   3363   3472   3606
                                      3611   3656   3720   3744   3782
                                      3789   3794   4225   4380   4401
                                      4656   4732   4920   5002   5129
                                      5145   5147   5225   5297   5437
                                      5466   5469   5486   5488   5502
                                      5524   5549   5551   5562   5696
                                      5885   5905   5948   5978   6013
                                      6122   6173   6201   6231   6236
                                      6579   6581   6887   6898   6900
TXTPTR                         $0077   579D  1538   1539   1695   1722
                                      1763   1777   1779   1900   1903
                                      2066   2068   2111   2114   2118y
                                      2121y  2125y  2128y  2131   2132
                                      2134   2212   2213   2241   2242
                                      2263   2265   2290   2291   2301
                                      2304   2329   2331   2345   2346
                                      2348   2370y  2910   2911   3027
                                      3028   3033   3034   3050   3051
                                      3061   3076   3077   3100   3101
                                      3106   3107   3121y  3124y  3127y
                                      3130y  3209   3211   3261   3263
                                      3264   3319   3321   3322   3449
                                      3450   3518y  4545   4547   4594
                                      4596   4599   4602   4616   4618
                                      5235   5236   5240   5245   5266
                                      5267   6359y  7057   7059   8656
                                      8658   8659y 10510  10515  11120
                                     11122  11123x 11143  11146  11270
                                     11282  11322  12101  12887y 12908
                                     12909y 12919y 12995  12997y 13002
                                     13004  13891  13902
LINNUM                         $0011   346D  1616   1617   1800   1805
                                      1925   1926   1928   1951   1953
                                      2286   2433   2434   2436   2457
                                      2459   2461   2462   2463   2465
                                      2466   2467   2468   2470   2471
                                      2473   5298   5299   5306   5308
                                      5312y  5315   5317   5327y  5342y
                                      7095   7096   7101y  7104y  7105y
                                      7108y  7109y  7112y  7115   7117
                                      8213   8215   8854   8856   8859
                                      8866   8868   8870   8972   8975
                                      9838   9839   9841  10570  10572
                                     10668  10671  11025  11026  11043
                                     11047  11051  11054  11204  11206
                                     11476  11477  11612  11614  12669
                                     12877  13805  13807  13810
FAC1M1/FAC1M2                  $005f   528D  2080   2081   3369   3678
                                      3833   3859y  4491   4665   4684
                                      4726   5079y  5446   5460   5463
                                      5495   5497   5505   5521   5540
                                      5542   5568   5702   5876   5914
                                      5942   5964   5967   5975   6024
                                      6109   6113   6159   6198   6454
                                      6588   6590   6881   6899   6901
                                     11207    529D  2549   3367   3834
                                      4492   4666   4685   4728   5443
                                      5462   5465   5492   5494   5504
                                      5522   5543   5545   5566   5700
                                      5879   5911   5944   5976   6019
                                      6111   6163   6199   6455   6585
                                      6587   6883   6902   6904  11205
STRPTR/FROUND                  $006c   548D  2591   2594   2598   2602
                                      2621   2622   3406   4682   4683
                                      4688y  4699   4701   4705   4711
                                      4712   4927   4929   4931y  4943
                                      4944   4954y  4957y  4960y  5370
                                      5425   5770   5796   5825   5850
                                      6339   6807   6937    553D  4733
                                      4897   5388   5423   5434   5468
                                      5470   5485   5501   5525   5552
                                      5554   5555   5583   5604   5694
                                      5738   5926   5963   6029   6048
                                      6066   6075   6125   6171   6202
                                      6203   6211   6778   6800   6909
FAC1EX                         $005e   527D  2389   2527   2627   2628
                                      3371   3407   3832   3842   3846
                                      4182   4667   4697   4724   4890
                                      5292   5371   5410   5413   5420
                                      5427   5480   5508   5512   5519
                                      5652   5656   5777   5787   5794
                                      5827   5868   5869   5871   5959
                                      5968   6027   6045   6062   6073
                                      6090   6124   6155   6188   6225
                                      6230   6340   6499   6749   6784
                                      6794   6795   6908   6911   7014
STAL                           $00fb   877D  7276   7278   7410   7412
                                      7432   7434   7506   7508   7657
                                      7659   7692   8999   9001   9008
                                      9013   9991y 10010y 11035  11037
                                     11082y 12680  12682  12708  12709
                                     12715  12720y 12726  13289  13349
                                     13351  13378  13382  13404  13405
                                     13407  13541  13560  13562  13574
                                     13576  13580  13582  13597  13599
                                     13600  13865  13870
TMPPTD                         $006e   557D  1719   1739   2529   2532
                                      2533   2541   3620   4296   4308
                                      4330   4331   4348   4349   4355
                                      4373   4374   4391   4392   4402
                                      4405   4455   4456   4700   4704
                                      5237   5238   5264   5265   6493
                                      6561   6570   6607   6617   6630
                                      6818   6819   6832   6833   6840y
                                      6842   6846   6847   6848   6850
                                      6851   6856   6857
FUNCPT                         $004b   491D  4561   4562   4576   4578
                                      4580y  4584y  4598y  4601y  4609
                                      4611   4621y  4624y  4627y  4630y
                                      4633y  4806   4809   4812   4814
                                      4817   4819   4821   4824y  4828
                                      4829y  4830   4832   4836y  4839
                                      4841   4843   4859   4862   4867y
                                      4871y  6721   6722   6727   6728
                                      6737   6738   6970   6971   6980
                                      6981
TMPPTA                         $0055   515D  1414   1416   1418   1421y
                                      1425y  1427   1609   1614   4026
                                      4027   4029   4030   4034   4035
                                      4040   4041   4056   4057   4060
                                      4061   4076   4078   4151   4152
                                      4335   4337   4340   4352y  4354
                                      4357   4418   4421  13974  13979
                                     13995  13998  14004  14007  14011y
                                     14016  14018  14020  14023
FAC1SI                         $0063   532D  2078   2093   2528   2722
                                      3193   3360   3405   3848   3854
                                      4175   5290   5366   5368   5415
                                      5481   5532   5534   5769   5797
                                      5799   5965   6022   6042   6092
                                      6126   6133   6153   6175   6206
                                      6232   6338   6488   6492   6751
                                      6753   6907   6942   6946   6977
                                      7010   7013   7030
CHRGET                         $0070   577D  1540   1920   2090   2171
                                      2417   2440   2836   2921   3055
                                      3220   3286   3424   3434   3520
                                      3548   3735   3915   3920   3940
                                      4167   5210   6265   6271   6282
                                      7087   8616   8666   8687   8695
                                      8762   8819   8864   8875   9836
                                     11198  11290  11305  12869  12968
                                     13889
RENNEW                         $0023   388D  8847   8850   8855   8860
                                      8880   8883   8911   8914   8920
                                      8922   8923   8925   8994   9006
                                     11306  11309  11323  11328  11332
                                     13890  13895  13897  13903  13907
                                     13913  13914  13917  13923  13937
                                     13938  13939  13943  13945  13952
                                     13973  14000  14001  14002  14005
                                     14025
CHRGOT                         $0076   578D  1916   2087   2181   2273
                                      2384   2398   2758   3035   3094
                                      3108   3217   3274   3551   3881
                                      3890   3903   4228   4612   5130
                                      5226   5254   5337   7740   7757
                                      7767   8575   8682   8729   8851
                                      8861   8872   9826   9833  10516
                                     11222  12376  12392  12992  13885
Mon_Register                   $02a0   909D  7172   7174   7176   7178
                                      7182   7185   7187   7189   7191
                                      7193   7195   7275   7277   7381
                                      7383   7387   7389   7392   7394
                                      7398   7409   7411   7488   7492
                                      7494   7532   7534   7536   7538
                                      7545   7547   7549   7551   7553
                                      7554   7555   7562
VARTAB                         $002a   396D  1565   1573   1574   1576
                                      1578   1583   1606   1610   1622
                                      1623   1835   1838   1866   1867
                                      2606   2610   3949   3950   6431
                                      6433   9016   9017   9845  12201
                                     12204  12222  12224  12675  12677
                                     13971  13975  13982  13984  14019
                                     14022  14026  14030
SA                             $00d3   847D  6419   7590   7626   7934
                                      8059   8117   8211   9870   9987
                                     10007  11538  11563  11572  11597
                                     11604  11653  11671  12028  12115
                                     12168  12171  12208  12267  12277
                                     12298  12340  12352  12419  12421
                                     12701  12706  12735  12814  12854
                                     13436
STACK                          $0100   887D  1362   1367   1369   1371
                                      1374   3189   3192   3198   3202
                                      3204   3206   3208   3210   4219
                                      4221   4224   4226   4647   4648
                                      6491   6564   6569   6611   6616
                                      6631   6647   6649   6657   6659
                                      6661   6664   6666   9789  11215
STATUS                         $0096   625D  2981   3560   3689   6425
                                      7944   7954   8458   9866  11348
                                     11358  11541  11546  11565  11577
                                     11618  11655  11673  11928  11953
                                     12121  12134  12154  12264  12306
                                     12327  12341  12413  12805  12816
                                     12844  12856  12984  13507  13508
FNADR                          $00da   854D  6412   6414   7571   7573
                                      7602y  8298   8300   8515   8517
                                      9885y 11392  11394  11397y 11401y
                                     11404y 11407y 11416y 11431y 11486y
                                     11493y 11498y 11508  11628y 11633y
                                     11640y 11658y 11676y 12311y 12367
                                     12369  13003  13005
EAL                            $00c9   816D  6422   6423   6430   6432
                                      7630  11345  11347  11350  11355
                                     11357y 12119  12120  12127  12129
                                     12139y 12144y 12145y 12146y 12148
                                     12150  12203  12206  12221  12223
                                     12234  12236  12280  12281  12676
                                     12678  12716  12718
TXTTAB                         $0028   392D  1643   1644   1786   1787
                                      1829y  1831y  1832   1836   1898
                                      1901   2191   2193   2295   2296
                                      6420   6421   7094   7100   7128
                                      7131  10214y 10216y 10596  10599
                                     10657  10658  11234  11236  12278
                                     12279  12679  12681
BUF                            $0200   892D  1603   1618   1619   1626
                                      1677   1698   1732   1742   1743
                                      1755   1760   1774   1776   2789
                                      2790   2791   2926   2927   2929
                                      2977   2986   3040   3041   3042
                                     11274  11326  13893  13899  13905
                                     13910  13947
TMPPTB                         $0057   516D  1397   1401   1407   1410
                                      1412   1420y  1424y  1426   1607
                                      1611   4020   4021   4086   4091
                                      4099y  4102y  8879y  8882y 10601
                                     10603  10659  10660  10674  10676
                                     13972  13976  14006  14009  14012y
                                     14013  14015
CursorCol                      $00c6   813D  2809   2828   4500   9078
                                      9156   9185   9215   9232   9285
                                      9311   9330   9366   9369   9383
                                      9385   9421   9473   9556   9647
                                      9648   9675   9721   9806   9899
                                      9902  10556  10576  10590  10610
                                     11942
FA                             $00d4   848D  7619   8111   8114   8181
                                      8273   8574   8775  11452  11455
                                     11503  11535  11561  11595  11602
                                     11651  11669  11740  12030  12109
                                     12269  12274  12349  12423  12696
                                     12818  12858  12982  13007  13699
FORPNT                         $0046   475D  1365   1368   1370   1373
                                      2096   2098   2313   2483   2484
                                      2507y  2510y  2520   2639   2642
                                      2647   2649   2663y  3025   3026
                                      3175   3176   3194   3195   5335
                                      5340   5343   5344   6002   6003
FRETOP                         $0030   408D  1458   1461   1470   1473
                                      1859   1860   2599   2603   2690
                                      2693   4092   4095   4479   4482
                                      4758   4761   4786   4787   4811
                                      4813   4881   4883   5025   5027
                                      5032   5035   7120   7121  11352
STREND                         $002e   404D  1394   1395   1620   1621
                                      1870   1871   4018   4019   4042
                                      4044   4243   4245   4345   4346
                                      4359   4363   4480   4483   4771
                                      4774  11343  11465  11544y 11575y
                                     13981  13983  14027  14031
BPTR                           $00f9   876D  7507   7509   8982   8992
                                      8995   9921   9932   9934  11103y
                                     11244  11246  13350  13352  13422
                                     13423  13425  13521  13536  13559
                                     13561  13587  13589  13590  13592
                                     13601  13603  13604
TMPVAR                         $005a   522D  3618   3622   4445   4466
                                      6256   6288   6295   6297   6298
                                      6303   6308   6320   6345   6355
                                      6362   6482   6514   6523   6529
                                      6545   6556   6557   6612   6639
                                      6644
FNLEN                          $00d1   845D  6416   7613   8296   8513
                                      8569   8671   9883  11413  11480
                                     11512  11515  11516  11527  11528
                                     11642  12113  12265  12295  12314
                                     12342  12365  12702  13001  13472
FRESPC                         $0032   412D  4776   4777   4784   4785
                                      4805   4808   4845   4847   4848
                                      4851y  4853   4855   4857   4861
                                      4868y  4872y  4874   4877   4880
                                      4882   4980y  4985   4986   4988
CURLIN                         $0036   422D  1512   1544   2071   2073
                                      2126   2129   2214   2219   2220
                                      2245   2246   2267   2269   2285
                                      2325   2327   2898   2899   3205
                                      3207   4513   6447   6448
FAC2M3/FAC2M4                  $0069   542D  3400   3835   3838   3858y
                                      5490   5726   5762   5881   5897
                                      5907   5909    543D  3402   3836
                                      3839   5487   5723   5759   5884
                                      5896   5904   5906
VARNAM                         $0042   464D  3607   3608   3902   3935
                                      3936   3941   3957   3960   3995
                                      3996   4112   4115   4207   4209
                                      4213   4215   4250   4252   4298
                                      4303   4407   4410
DOS_Flags                      $033e   946D  7789   7793   7810   7819
                                      7829   7922   8073   8232   8248
                                      8348   8564   8603   8614   8638
                                      8668   8707   8721   8738   8745
                                      8746   8794
ScrPtr                         $00c4   812D  9157y  9173y  9216y  9272y
                                      9319y  9386y  9388y  9395y  9514y
                                      9552y  9557y  9560y  9564y  9677y
                                      9740y  9808y  9813y 10151  10155
                                     10562y 10612
Bank_Store                     $028b   907D  7514   8906   8909   8912
                                      8915   8943   8957   8960   8973
                                      8976   9937  11151  11157  11166
                                     11182  11217  11223  13355  13565
                                     13594
MEMUSS                         $00fd   878D  7431   7433   7464   7465
                                      7472   8299   8301   8312y  8725
                                      8726   9924   9931   9933  13518
                                     13573  13575  13577  13579  13581
                                     13583
TopMargin                      $00e0   859D  9059   9070   9305   9339
                                      9356   9502   9520   9523   9658
                                      9687   9690   9693   9753   9766
                                     10529  10540  10608  10616  10619
                                     10622
CursorRow                      $00d8   852D  9071   9084   9182   9306
                                      9309   9501   9522   9638   9659
                                      9661   9689   9704   9709  10554
                                     10567  10578  10588  10607  10630
                                     11944
DOS_Command_Buffer             $0353   950D  8080   8210   8212   8214
                                      8216   8218   8313   8330   8333
                                      8352   8505   8514   8516   9952
                                      9957   9981  10274  10285  11457
Bank_Fetch                     $027a   908D   907   7242   7255   7515
                                      9004  11040  11046  11050  11053
                                     11069  12505  13356  13537  13539
                                     13542  13543  13564  13593  13644
QUOTE                          $0022   260D  1988   1997   2375   2964
                                      3069   3442   4674   4694   7596
                                      7600   8595   8702   9255   9259
                                     11153  11159  11385  11408  13886
INDEXB                         $0021   371D  1568   1575   1587   1594y
                                      1598   3187   5243   5248   5250y
                                      5253y  5258y  6140   6146   6148y
                                      6152y  6157y  6162y  6166y  6172
CR                             $000d   248D  1675   2799   7293   7966
                                      7996   8403   8433   8441   8443
                                      9168   9238   9426   9583  11599
                                     11832  11955  12445  13371  13797
VALTYP                         $0007   285D  2489   2776   3056   3246
                                      3294   3316   3423   3609   3829
                                      3913   3927   4202   4234   4474
                                      4490   4735   5188
RigMargin                      $00d5   850D  9170   9275   9308   9320
                                      9349   9367   9390   9472   9515
                                      9551   9567   9640   9741  10565
                                     10613  11950
IOPMPT                         $0010   338D  1498   2752   2792   2866
                                      2901   2925   2932   2945   2952
                                      2955   2979   2998   3046   3146
                                      3557   7090
COUNT                          $0005   272D  1559   1608   1624   1721
                                      1738   1764   4144   4231   4285
                                      4309   4333   4371   4403  11268
                                     11283  11291
DESCPT                         $004d   495D  2632   2633   2662y  4657
                                      4658   4939   4940   5089y  5092y
                                      5099   5100   5120y  5142y  5164
                                      5166
VARPTR                         $0044   470D  4134   4135   4419   4422
                                      4424   4541   4543   4581   4586
                                      4588y  4592   4603   4605   6606
                                      6618
FAC2EX                         $0066   539D  3394   3823   3824   5390
                                      5391   5428   5430   5776   5784
                                      6044   6063   6718   6793   6796
KEYD                           $026f   897D  9128   9130   9131   9164
                                     10418  12960  13375  13377  13380
                                     13381  13384  13385  13387
LefMargin                      $00e2   861D  9077   9284   9304   9329
                                      9340   9357   9382   9503   9646
                                      9674   9720  10140  10509
Mon_Lo                         $00c2   806D 13203  13288  13292  13309
                                     13761  13765  13766  13775  13776
                                     13790  13804  13809  13866
CHARAC                         $0003   270D  2363   2367   2368   3063
                                      3068   3072   3778   3787   4675
                                      4690   6237   6732   6789
Ass_Buf                        $02c1   913D 13273  13277  13280  13315
                                     13323  13337  13780  13823  13826
                                     13830  13831  13848
DOS_RL                         $00b9   798D  9874   9878   9880  11475
                                     11490  11513  11525  11549  11554
                                     11566  11585  11659
RENINC                         $0021   375D  8846   8849   8867   8871
                                      8921   8924   9830   9832   9848y
                                      9851   9855   9856
LA                             $00d2   846D  7746   7936   8173   8197
                                      8565   8609  12026  12038  12346
                                     12401  12417
Mon_A                          $00bf   803D 12748  12754  13185  13200
                                     13205  13540  13544  13578  13584
                                     13588  13591
VERCK                          $009d   666D  7588   7608   7633   8374
                                     12137  12191  12198  12215  12252
                                     12325  12886
JIFFY_CLOCK                    $008d   593D  2550   3673   3674  10030
                                     12772  12774  12776  12777  12780
                                     12784  12785
MONCNT                         $00b5   790D  7239   7248   7251   7267
                                      7399   7402   7505   7519  13637
                                     13648
CharsInBuffer                  $009e   670D  9133   9135   9145   9162
                                     10412  10419  11931  12078  12958
                                     13389
FAC2SI                         $006b   544D  3404   3819   5369   5414
                                      5768   5771   6036   6337   6724
                                      6932
FAC2M1                         $0067   540D  3396   3821   3822   5496
                                      5732   5773   5875   5899   5913
                                      5915
FUNJMP                         $0052   509D  3760   3762   5158   5167
                                      5389   5419   5433   5484   6782
                                      6799
INDEXC                         $004f   499D  2640y  2643y  2654y  2657y
                                      2701   2704   5019y  5022y  5030
                                      5033
ARYTAB                         $002c   400D  1868   1869   3953   3955
                                      4014   4015   4032   4033   4239
                                      4240
FAC3M4                         $0026   382D  4443   4463   5582   5585
                                      5693   5722   5724   5737   5890
                                      5947
FAC3M3                         $0025   381D  4414   4435   4460   5584
                                      5587   5692   5725   5727   5736
                                      5945
GARBFL                         $0009   306D  1697   1709   1750   3703
                                      3706   3707   3710   4753   4790
                                      4794
ENDCHR                         $0004   271D  1706   1754   1757   2365
                                      2366   2369   2372   3075   4676
                                      4692
BSOS_KBD                       $0001    15D 10703  10716  10727  10786
                                     10799  10817  10830  10841  10900
                                     10913
DOS_Tmp                        $033a   930D  7739   7766   8217   8297
                                      8309   8316   8570   8724  11479
BotMargin                      $00e1   860D  9062   9348   9639   9705
                                      9751   9768  10528  10541  10558
LDTND                          $00ae   768D  8053   8182  11980  12009
                                     12055  12056  12058  12411  12416
CINV                           $0090   601D  7186   7188   7537   7539
                                      9793  10037  10039  13725  13727
INPPTR                         $0040   454D  3019   3020   3031   3032
                                      3102   3103   3138   3139   3144
OLDTXT                         $003a   434D  1889   2115   2116   2217
                                      2218   2237   2240   2908   2909
DOS_Status                     $03ad   951D  3632   3633   3708   8121
                                      8128   8130   8411   9871
Dis_Buf                        $02b1   911D 12759  13190  13208  13212
                                     13241  13246  13256  13338
QTSW                           $00cd   839D  9180   9228   9257   9258
                                      9434   9585   9731  10650
Mon_Hi                         $00c3   807D 13198  13285  13310  13762
                                     13771  13786  13806  13811
DosPtr                         $00bb   800D 11375  11377  11379  11384y
                                     11391  11393  11464  11468
W_Bank                         $00b7   796D  7194   7382   7495   7988
                                      8894   8950  11099  13538
R_Bank                         $00b6   795D  7192   7380   7493   7980
                                      8893   8990  11038  11079
Source_Unit                    $009c   661D  8271   8572   8633   8636
                                     11454  11534  11601  11650
FAC2M2                         $0068   541D  3398   5493   5729   5765
                                      5878   5898   5910   5912
ACCSYM                         $004a   485D  3273   3282   3283   3285
                                      3289   3324   3339   3830
MEMSIZ                         $0034   416D  1857   1858   4804   4807
                                      7118   7119   7126   7130
DOS_Filename                   $0342   949D  7570   7572   8676  13468
                                     13624  13633  13645
DOS_Attr                       $033d   933D  8488   8524   8529   8566
                                      8624   8650   8665
INSRT                          $00dc   855D  9269   9271   9430   9566
                                      9569   9589   9729
DATAX                          $00d9   853D  9221   9223   9224   9243
                                      9248   9407   9422
Mon_Op                         $00c1   805D 12477  12506  13308  13327
                                     13340  13354  13357
Dis_Line                       $00ba   799D  7420   7422   7424   7462
                                      7475   9965  13348
Wedge_Unit                     $00ab   754D  7098  12871  12878  12981
                                     13006  13712  13714
Key_Flags                      $0098   639D  6409  10033  10319  10321
                                     10361  10362  10436
FACTPA                         $0054   514D  5994   5995   6821   6824
                                      6825   6973   6974
FAC3M2                         $0024   380D  5586   5589   5691   5728
                                      5730   5735   5943
FAC3M1                         $0023   379D  5588   5591   5690   5731
                                      5733   5734   5941
SUBFLG                         $000a   312D  1890   2052   3931   3943
                                      3948   4534   4559
INTFLG                         $0008   291D  2487   3089   3641   3914
                                      3934   4200   4236
DOS_Drive_2                    $033c   932D  8503   8568   8645   8713
                                     11399  11674
LAT                            $0251   894D  8187  12012  12025  12059
                                     12060  12418
Mon_Tmp                        $00cb   818D  7513   7516   7722   7727
                                     13768  13799
SAL                            $00c7   815D  9095   9096   9097y  9739y
                                     10125  10129
Dis_Length                     $00be   802D 12483  12493  12551  13187
                                     13195  13353
PC_Adjust                      $00b3   788D  7169   7181   7197   7407
                                     12466  12468
DFLTO                          $00b0   776D  9240  10043  11966  11986
                                     12000  12859
YSAVE                          $0048   481D  3029   3030   3104   3105
                                      3310   3389
TANSGN                         $000c   326D  3392   3867   6948   6950
                                      6968   6978
DIMFLG                         $0006   279D  3896   4199   4238   4282
                                      4316   4367
DOS_Id                         $033f   947D  8149   8329   8332   8571
                                      8660
Ass_Buf_Length                 $02c0   912D 13326  13332  13822  13832
                                     13833
SAT                            $0265   896D  8056  12027  12063  12064
                                     12422
FAT                            $025b   895D  8185  12029  12061  12062
                                     12424
DFLTN                          $00af   772D 11929  11940  11990  12002
                                     12819
Target_Unit                    $00ad   761D 11453  11502  11560  11594
                                     11668
CRSW                           $00ac   759D  9171   9208   9237   9420
                                     11949
BLNCT                          $00a8   733D  9154   9274   9802   9805
                                     10060
BSOUR                          $00a5   693D 11741  11757  11781  11852
                                     11868
Power_Flag                     $0099   644D  9719  10493  10495  10552
                                     10586
LASTPT                         $0014   356D  4736   5058   5060   5064
                                      7091
INPFLG                         $000b   316D  2891   3018   3037   3058
                                      3140
TABS_SET                       $03ee   952D  9653   9655   9908  10070
DOS_Command_Length             $0341   948D  8473   8475   8672   8678
DOS_Drive_1                    $033b   931D  8499   8567   8644  11656
DELAY                          $00e6   865D 10062  10391  10393  10408
DOS_FC                         $00b1   786D 11421  11482  11552  11580
BLNON                          $00aa   749D  9149   9152   9807   9810
LastInputCol                   $00a1   680D  9178   9186   9234  11951
C3PO                           $00a0   678D 11730  11736  11861  11863
ReverseFlag                    $009f   674D  9266   9481   9629   9730
CBINV                          $0092   609D  9792  13674  13676  13744
RNDX                           $0088   584D  6889   6890   6913   6914
BITS                           $0065   535D  4892   4898   4899   6195
SGNFLG                         $0064   533D  6264   6311   6841   6861
DATPTR                         $003e   448D  2196   2197   3008   3009
DATLIN                         $003c   442D  2896   2897   3125   3129
OLDLIN                         $0038   427D  2221   2222   2243   2244
TEMPPT                         $0013   351D  1879   4719   4740   5062
Ignore_Timeout                 $03fc   954D 11797  11806  13682
Dis_Buf_Length                 $02b0   910D 13219  13259  13333
SCROV                          $00eb   874D  9412  10079  10080
SCRIV                          $00e9   873D  9202  10075  10076
PrevChar                       $00e8   872D  9296   9527  10029
CHIME                          $00e7   866D 10082  10095  10104
KOUNT                          $00e5   864D 10063  10395  10401
LSTX                           $00e4   863D 10384  10389  10406
ScreenRows                     $00df   858D  9112   9341  10066
Mon_ZP                         $00cc   819D 13342  13344  13787
BLNSW                          $00a7   726D  9146   9800  10061
InputRow                       $00a3   681D  9181   9703  11945
Default_Bank                   $009a   651D 10035  11084  11105
Key_Index                      $0097   630D 10323  10356  10382
NMINV                          $0094   614D 13670  13672  13692
FACTPB                         $0059   521D  5987   6859   6860
RIGHT                          $001d   259D  2870   9436   9591
Reset_Vector                   $03fa   953D 13678  13680
IERROR                         $0300   919D  1491  13485
Ass_Index                      $02d0   914D 13329  13369
JIFFY6                         $00f8   875D 12786  12789
XMAX                           $00e3   862D 10041  10413
Mon_B                          $00c0   804D 12750  12753
Mon_Format                     $00bd   801D 12549  13184
DOS_EOF                        $00b2   787D 11547  11583
GDBLN                          $00a9   742D  9155   9811
SFDX                           $00a6   719D 10324  10428
InputCol                       $00a4   682D  9184  11943
Stop_Flag                      $009b   656D 10427  12073
JUMPER                         $0051   504D  3763   7079
CTRLY                          $0019   257D  9452   9605
CTRLV                          $0016   256D  9454   9601
TEMPST                         $0016   363D  1878   4720
CTRLU                          $0015   255D  9456   9611
DEL                            $0014   254D  9432   9587
HOME                           $0013   253D  9460   9597
RVS                            $0012   252D  9440   9595
DOWN                           $0011   251D  9438   9593
CTRLO                          $000f   250D  9448   9607
CTRLN                          $000e   249D  9444   9609
TAB                            $0009   247D  9450   9599
CTRLD                          $0004   245D  9458   9613
CTRLB                          $0002   244D  9446   9603
USRVEC                         $0001   268D  7083   7084
Basic_USR                      $0000   267D  1143   7080
IEVAL                          $030a   924D  3416
IGONE                          $0308   923D  2140
IQPLOP                         $0306   922D  2005
ICRNCH                         $0304   921D  1689
IMAIN                          $0302   920D  1531
ISNUM                          $007d   580D  2561
ESC                            $001b   258D  9428
BELL                           $0007   246D  9442
CTRLA                          $0001   243D  9462
FSBLK                          $00de   857
ROPRTY                         $00dd   856
TAPE1                          $00d6   851
ZD0                            $00d0   843
EOT                            $00cf   842
BITTS                          $00ce   841
ZP_b8                          $00b8   797
SCROLLING                      $00b4   789
FAC3M5                         $0027   384
DS_Ptr                         $000e   331
DS_Len                         $000d   330
