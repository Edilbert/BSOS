              ; ****************************************************
              ; * Complete Commodore 8296 Operating System & BASIC *
              ; ****************************************************

              ; Use the Bit Shift Assembler "bsa" for assembly of this source

b000          * = $b000   ; *** b000 ***  Commodore 8296

              .STORE $B000, $1000, "b000.basic"
              .STORE $C000, $1000, "c000.basic"
              .STORE $D000, $1000, "d000.basic"
              .STORE $E000, $1000, "e000.edit"
              .STORE $F000, $1000, "f000.kernal"

0001          BSOS_KBD = 1

              ; revision 1.12 10-Jan-2020
              ; -------------------------
              ; implement vector table for extension interception

              ; revision 1.11 08-Jan-2020
              ; -------------------------
              ; enhance DELETE commnd
              ; implement OLD command

              ; revision 1.10 09-Oct-2015
              ; -------------------------
              ; optimize garbage collection
              ; implement REPLACE command
              ; implement 26 rows mode

              ; revision 1.09 10-Sep-2015
              ; -------------------------
              ; optimize BASIC routines Scan_Linenumber and Basic_LIST
              ; in order to make parts of them callable subroutines
              ; These routines are used in the assembler and power scrolling

              ; revision 1.08 04-Aug-2015
              ; -------------------------
              ; Implement conditional code for original keyboard layout
              ; or BSOS keyboard layout (BSOS_KBD)

              ; revision 1.07 04-Aug-2015
              ; -------------------------
              ; Implement ML Disassembler

              ; revision 1.06 29-Jul-2015
              ; -------------------------
              ; Check disk error after trying to boot from disk

              ; revision 1.05 19-Jan-2015
              ; -------------------------
              ; Detect and activate option ROM's
              ; Detect and run "BSOS BOOT" during boot
              ; Non desctructive RAM test
              ; Optimization of BSM LOAD/SAVE

              ; revision 1.03 29-Dec-2014
              ; -------------------------
              ; Add unit to unit capability to the COPY command

              ; revision 1.02 23-Dec-2014
              ; -------------------------
              ; Fix bug in DSAVE/DOPEN (Save and Replace bug)
              ; Optimize DOS Parameter Parser

              ; revision 1.01 14-Dec-2014
              ; -------------------------
              ; Add support for Nils Eilers' SoftROM
              ; The LOAD and DLOAD routines may be used to load data files
              ; directly into the address range $9000 - $AFFF. This works well
              ; for RAM or SoftROM (which in fact is flashed) installed there.

              ; revision 1.00 30-Nov-2014
              ; -------------------------
              ; First public release

              ; The operating system and BASIC interpreter is stored on two chips:

              ; The editor is stored on a 2332 (4KB) ROM (or 2532 EPROM) for the
              ; address range $E000 - $EFFF. The range $E800 - $E8FF is reserved
              ; for I/O and is not accessible

              ; The remaining code is stored on a 23128 (16KB) ROM (or 27128 EPROM):
              ; The address ranges are: $C000 $D000 $B000 $F000

              ; So after assembling you can prepare the EPROM images by using
              ; 1) e000.edit for a 2532 EPROM
              ; 2) cat c000.basic d000.basic b000.basic f000.kernal >os8296.rom
              ;    and use os8296.rom then for a 27128 EPROM

              ; PATCHES APPLIED
              ; ===============

              ; DOS parameter parser accepts 0-9 for drive value (original 0-1)
              ; This allows BASIC4 to work with all 10 possible drives of petSD

              ; The BSM memory display and modifier uses 16 bytes per line

              ; DELETED FEATURES
              ; ================

              ; All tape related code is removed
              ; The entry of diacritic characters is removed (accented letters etc.)

              ; NEW FEATURES
              ; ============

              ; The COPY command accepts different units for source and target
              ; The full syntax is (s = source, t = target):
              ; COPY Ds,"filepattern",Us TO Dt,Ut
              ; The D(rive) parameter defaults to D0 if not specified
              ; The U(nit)  parameter defaults to U8 if not specified
              ; Examples:
              ;
              ; COPY U8 TO U9           copies all files from D0,U8 to D0,U9
              ; COPY D1,U8 TO D2,U10    copies all files from D1,U8 to D2,U10
              ; COPY "*" TO U11         copies all files from D0,U8 to D0,U11
              ; COPY D1,"A*" TO U10     copies all files beginning with A

              ; restrictions:
              ; Currently REL files are not supported.
              ; It is is not possible to give a different name for the target file,
              ; use the RENAME command if necessary

              ; The machine language monitor BSM can now display memory from other banks.
              ; The new command ".b" (set Bank) stores a byte for the bank register.
              ; This affects the memory display for the asddress range $8000 - $ffff.
              ; Common values for the bank register are:

              ; .b 00    : system bank (screen RAM, ROM, I/O)
              ; .b 80    ; RAM bank 0/2 in $8000 - $ffff
              ; .b 8c    ; RAM bank 1/3 in $8000 - $ffff

              ; BSM includes a disassembler:

              ; .d f5c2 f5ef     disassemble the given range
              ; .d f5c2          disassemble 10 statements starting with $f5c2
              ; .d               Disassemble next 10 statements

              ; EDITING
              ; =======

              ; The editor scrolls the BASIC listing upwards or downwards if the
              ; cursor is moved up on the top line or down on the bottom line
              ; The idea (not the code) is taken from Brad Templeton's POWER ROM
              ; The character set is expanded with the missing ASCII characters {|}~ 
              ; These can be used by pressing the CONTROL key together with:
              ; CONTROL 7/      |
              ; CONTROL 8(      {
              ; CONTROL 9)      }
              ; CONTROL .Pi     ~ 

              ; LOAD, SAVE and VERIFY use now unit 8 as default device

              ; LOAD "filename",8,0 forces the file to load to $0401
              ; this enables the loading of C64 and other BASIC programs, which use
              ; different start addresses for BASIC programs.

              ; The Disk-Wedge is integrated, loosely based on Nils Eilers' code.

              ; @                          read drive status
              ; @command                   send dos command
              ; @$                         directory
              ; $                          directory
              ; $0                         directory of drive 0
              ; $0:pat*                    directory of files starting with "pat"
              ; /prog                      load program prog
              ; ^prog                      load and run program prog
              ; #9                         switch to unit 9
              ; #                          display current unit

              ; New commands added:

              ; DELETE from-to       ; Deletes a line range
              ;   DELETE 500-700 deletes all lines in this range
              ; FIND "text"          ; lists all lines with strings containing <text>
              ; FIND /text/          ; lists all lines with BASIC   containing <text>
              ;                      ; any character may be used as delimiter
              ; MONITOR              ; Calls BSM
              ; RENUMBER new,inc,old ; Renumbers a BASIC program
              ;    The default values for new,inc,old are: 10,10,first line
              ;    RENUMBER 1000,10  renumbers the whole program to linenumbers
              ;       1000,1010,1020 etc.

              ; BSOS uses a vector table for important functions like C64, C128.
              ; This enables the interception for BASIC language extensions
              ; The names and addresses are the same as in the C128 BASIC.

0300            IERROR  = $0300     ; DEF_ERROR   BASIC error handler
0302            IMAIN   = $0302     ; DEF_MAIN    BASIC main loop
0304            ICRNCH  = $0304     ; DEF_CRUNCH  BASIC tokenizer
0306            IQPLOP  = $0306     ; DEF_QPLOP   BASIC statement lister
0308            IGONE   = $0308     ; DEF_GONE    BASIC interpret statement
030a            IEVAL   = $030a     ; DEF_EVAL    BASIC evaluate expression

              ; **********************
              ; BASIC scalar variables
              ; **********************

              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Type     | Exa.|  0  |  1  |  2  |  3  |  4  |  5  |  6
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Float    | AB  |  A  |  B  | EXP | MSB | MAN | MAN | LSB
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Integer  | AB% |  A^ |  B^ | MSB | LSB |  0  |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Function | AB( |  A^ |  B  | LFP | MFP | LBP | MBP | ARG
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; String   | AB$ |  A  |  B^ | LEN | LSP | MSP |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----

              ; ************
              ; BASIC arrays
              ; ************

              ; ---------+-----+-----+-----+---------------+
              ; Type     | Exa.|  0  |  1  |  Element Size |
              ; ---------+-----+-----+-----+---------------+
              ; Float    | AB  |  A  |  B  |       5       |
              ; ---------+-----+-----+-----+---------------+
              ; Integer  | AB% |  A^ |  B^ |       2       |
              ; ---------+-----+-----+-----+---------------+
              ; String   | AB$ |  A  |  B^ |       3       |
              ; ---------+-----+-----+-----+---------------+

              ; The circumflex ^ indicates characters OR'ed with $80

              ; Array header:

              ; Byte  0   : 1st. character of name
              ; Byte  1   : 2nd, character of name
              ; Byte  2-3 : length of array including header in bytes
              ; Byte  4   : dimension count
              ; Byte  5-6 : Hi/Lo elements of 1st. dimension, (e.g. 11 for dim a(10)
              ; Byte  7-8 : Hi/Lo elements of 2nd. dimension if dimension count > 1
              ; Byte  x-x : Two bytes for each dimension

              ; *******
              ; Equates
              ; *******

0001          CTRLA     = $01 ; scroll window down
0002          CTRLB     = $02 ; switch character ROM
0004          CTRLD     = $04 ; toggle display size between 25 or 26 rows
0007          BELL      = $07 ; chime
0009          TAB       = $09
000d          CR        = $0d
000e          CTRLN     = $0e ; switch to text mode
000f          CTRLO     = $0f ; set top left window corner
0011          DOWN      = $11
0012          RVS       = $12
0013          HOME      = $13
0014          DEL       = $14
0015          CTRLU     = $15
0016          CTRLV     = $16
0019          CTRLY     = $19
001b          ESC       = $1b
001d          RIGHT     = $1d
0022          QUOTE     = $22

              ; These locations contain the JMP instruction and target address of the
              ; USR command. They are initialised so that if you try to execute a USR
              ; call without changing them you will receive an ILLEGAL QUANTITY error
              ; message.

0000          Basic_USR = $00               ; initialized to $4c the code for JMP
0001          USRVEC    = $01               ; initialized to $c373 (Illegal_Quantity)

0003          CHARAC    = $03               ; search character
0004          ENDCHR    = $04               ; scan quotes flag
0005          COUNT     = $05               ; line crunch/array access/logic operators

              ; This is used as a flag by the routines that build an array or
              ; reference an existing array. It is used to determine whether a
              ; variable is in an array, whether the array has already been
              ; DIMensioned, and whether a new array should assume default size.

0006          DIMFLG    = $06               ; DIM flag

              ; This flag is used to indicate whether data being operated upon is
              ; string or numeric. A value of $FF in this location indicates string
              ; data while a $00 indicates numeric data.

0007          VALTYP    = $07               ; data type, $FF = string, $00 = numeric

              ; If the above flag indicates numeric then a $80 in this location
              ; identifies the number as an integer, and a $00 indicates a floating
              ; point number.

0008          INTFLG    = $08     ; data type flag, $80 = integer, $00 = floating pt.

              ; The garbage collection routine uses this location as a flag to
              ; indicate that garbage collection has already been tried before adding
              ; a new string. If there is still not enough memory, an OUT OF MEMORY
              ; error message will result.

              ; LIST uses this byte as a flag to let it know when it has come to a
              ; character string in quotes. It will then print the string,rather than
              ; search it for BASIC keyword tokens.

              ; This location is also used during the process of converting a line of
              ; text in the BASIC input buffer into a linked program line of BASIC
              ; keyword tokens to flag a DATA line is being processed.

0009          GARBFL    = $09     ; garbage collected/open quote/DATA flag

              ; This flag is set from the routines handling FOR, DEF and FN
              ; statements. Names for loop indices and function names must not be
              ; integer. Only identifiers of type real are allowed.

000a          SUBFLG    = $0a     ; subscript/FNx flag

              ; input mode, $00 = INPUT, $40 = GET, $80 = READ

000b          INPFLG    = $0b     ; input mode, $00 = INPUT, $40 = GET, $98 = READ

              ; This location is used to determine whether the sign of the value
              ; returned by the functions SIN, COS, ATN or TAN is positive or negative
              ; Also the comparison routines use this location to indicate the outcome
              ; of the compare. For A <=> B the value here will be $01 if A > B,
              ; $02 if A = B, and $04 if A < B. If more than one comparison operator
              ; was used to compare the two variables then the value here will be a
              ; combination of the above values.

000c          TANSGN    = $0c     ; ATN sign/comparison evaluation flag

              ; Disk status or temporary string descriptor

000d          DS_Len    = $0d     ; unused
000e          DS_Ptr    = $0e     ; unused

              ; When the default input or output device is used the value here will
              ; be a zero, and the format of prompting and output will be the standard
              ; screen output format. The location $B8 is used to decide what device
              ; actually to put input from or output to.

0010          IOPMPT    = $10     ; current I/O channel

              ; Used whenever a 16 bit integer is used e.g. the target line number for
              ; GOTO, LIST, ON, and GOSUB also the number of a BASIC line that is to
              ; be added or replaced. additionally PEEK, POKE, WAIT, and SYS use this
              ; location as a pointer to the address which is the subject of the
              ; command.

0011          LINNUM = $11        ; line number

              ; This location points to the next available slot in the temporary
              ; string descriptor stack located at TEMPST ($16-$1e).

0013          TEMPPT = $13        ; descriptor stack pointer, next free

              ; This contains information about temporary strings which have not yet
              ; been assigned to a string variable.

0014          LASTPT = $14        ; current descriptor stack item pointer

              ; Stack for temporary string descriptors
              ; String 1: $16-$18
              ; String 2: $19-$1b
              ; String 3: $1c-$1e

0016          TEMPST = $16        ; temporary descriptor stack

              ; miscellaneous pointer / word used in many BASIC routines

001f          INDEXA = $1f        ; miscellaneous pointer

              ; miscellaneous pointer / word used in many BASIC routines

0021          INDEXB = $21

              ; above address shared with RENUMBER as increment value

0021          RENINC = $21        ; RENUMBER increment value

              ; Floating point accumulator #3 (mantissa only)

0023          FAC3M1 = $23        ; mantissa byte 1 MSB
0024          FAC3M2 = $24        ; mantissa byte 2
0025          FAC3M3 = $25        ; mantissa byte 3
0026          FAC3M4 = $26        ; mantissa byte 4 LSB

0027          FAC3M5 = $27        ; unused

              ; FAC3 addresses shared with RENUMBER as start value for line numbers

0023          RENNEW = $23        ; RENUMBER new line number start

              ; Start of BASIC program - initialized to $0401

0028          TXTTAB = $28        ; Text Table

              ; Two byte pointer to the start of the BASIC variable storage area.

002a          VARTAB = $2a        ; Variable table

              ; Two byte pointer to the start of the BASIC array storage area.

002c          ARYTAB = $2c        ; Array table

              ; Two byte pointer to end of the start of free RAM.

002e          STREND = $2e        ; String end

              ; Two byte pointer to the highest address used by BASIC +1.

0030          FRETOP = $30        ; top of BASIC memory

              ; Two byte pointer to the bottom of the string text storage area.

0032          FRESPC = $32        ; bottom of string space

              ; Two byte pointer to the highest RAM address

0034          MEMSIZ = $34        ; top of RAM

              ; These locations contain the line number of the BASIC statement which
              ; is currently being executed. A value of $FF in location $3A means that
              ; BASIC is in immediate mode.

0036          CURLIN = $36        ; current line number

              ; When program execution ends or stops the last line number executed is
              ; stored here.

0038          OLDLIN = $38        ; break line number

              ; These locations contain the address of the start of the text of the
              ; BASIC statement that is being executed.  The value of the pointer to
              ; the address of the BASIC text character currently being scanned is
              ; stored here each time a new BASIC statement begins execution.

003a          OLDTXT = $3a        ; continue pointer

              ; These locations hold the line number of the current DATA statement
              ; being READ. If an error concerning the DATA occurs this number will
              ; be moved to $39/$3A so that the error message will show the line that
              ; contains the DATA statement rather than in the line that contains the
              ; READ statement.

003c          DATLIN = $3c        ; current DATA line number

              ; These locations point to the address where the next DATA will be READ
              ; from. RESTORE sets this pointer back to the address indicated by the
              ; start of BASIC pointer.

003e          DATPTR = $3e        ; DATA pointer

              ; READ, INPUT and GET all use this as a pointer to the address of the
              ; source of incoming data, such as DATA statements, or the text input
              ; buffer.

0040          INPPTR = $40        ; READ pointer

              ; Two bytes storing the name of a BASIC variable as ASCII values
              ; The combination of the two bits 7 determines the type
              ; ---------------------------------------------
              ; Real    : AB      = $41 $42 = 'A'     'B'
              ; Function: FNAB()  = $c1 $42 = 'A'+$80 'B'
              ; String  : AB$     = $41 $c2 = 'A'     'B'+$80
              ; Integer : AB%     = $c1 $c2 = 'A'+$80 'B'+$80

0042          VARNAM = $42        ; current variable name

              ; These locations point to the value of the current BASIC variable.
              ; Specifically they point to the byte just after the two-character
              ; variable name.

0044          VARPTR = $44        ; current variable address

              ; The address of the BASIC variable which is the subject of a FOR/NEXT
              ; loop is first stored here before being pushed onto the stack.

0046          FORPNT = $46        ; FOR/NEXT variable pointer

              ; The expression evaluation routine creates this to let it know whether
              ; the current comparison operation is a < $01, = $02 or > $04 comparison
              ; or combination.

0048          YSAVE  = $48        ; BASIC execute pointer temporary/precedence flag

              ; used to compare the variable type on both sides of an operator

004a          ACCSYM = $4a        ; comparison evaluation flag

              ; These locations are used as a pointer to the function that is created
              ; during function definition. During function execution it points to
              ; where the evaluation results should be saved.

004b          FUNCPT = $4b        ; FAC temp store/function/variable/garbage pointer

              ; Temporary Pointer to the current string descriptor.

004d          DESCPT = $4d        ; FAC temp store/descriptor pointer

              ; Temporary pointer used in subroutines

004f          INDEXC = $4f

              ; The first byte is the 6502 JMP instruction $4C, followed by the
              ; address of the required function taken from the table at $B000.

0051          JUMPER = $51         ; JMP opcode for functions

              ; Used as jump address for previous opcode
              ; Several uses as temporary storage in BASIC routines

0052          FUNJMP = $52         ; functions jump vector

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary pointer (block pointer, array pointer)

0054          FACTPA = $54         ; FAC temp store ($54 - $58)
0055          TMPPTA = $55         ; temp pointer A
0057          TMPPTB = $57         ; temp pointer B

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary variables

0059          FACTPB = $59         ; FAC temp store ($59 - $5d)
005a          TMPVAR = $5a         ; temporary variable
005c          TMPPTC = $5c         ; temporary pointer

              ; Floating point accumulator 1

005e          FAC1EX = $5e         ; FAC1 exponent
005f          FAC1M1 = $5f         ; FAC1 mantissa 1
0060          FAC1M2 = $60         ; FAC1 mantissa 2
0061          FAC1M3 = $61         ; FAC1 mantissa 3
0062          FAC1M4 = $62         ; FAC1 mantissa 4
0063          FAC1SI = $63         ; FAC1 sign
0064          SGNFLG = $64         ; constant count/negative flag

0065          BITS   = $65         ; unused

              ; Floating point accumulator 2

0066          FAC2EX = $66         ; FAC2 exponent
0067          FAC2M1 = $67         ; FAC2 mantissa 1
0068          FAC2M2 = $68         ; FAC2 mantissa 2
0069          FAC2M3 = $69         ; FAC2 mantissa 3
006a          FAC2M4 = $6a         ; FAC2 mantissa 4
006b          FAC2SI = $6b         ; FAC2 sign

              ; String pointer and FAC sign comparison and FAC rounding

006c          STRPTR = $6c         ; string pointer & FAC variables

              ; this address is sometimes used as high btye for the STRPTR
              ; and as rounding byte (5th. byte of mantissa) for FAC1

006d          FROUND = $6d         ; FAC1 mantissa 5 = rounding byte

              ; Temporary pointer and index used in many BASIC routines

006e          TMPPTD = $6e         ; temp BASIC execute/array pointer low byte/index

              ; Basic CHRGET (with increment) and CHRGOT (no increment) routine
              ; Also ISNUM for check if character is numeric
              ; Copied to this location from CHRGET_ROM at $d399
              ;
              ; 0070 e6 77     CHRGET    INC TXTPTR
              ; 0072 d0 02               BNE CHRGOT
              ; 0074 e6 78               INC TXTPTR+1
              ; 0076 ad 60 ea  CHRGOT    LDA $ffff       ; modified by previous code
              ; 0079 c9 3a               CMP #':'        ; check of end of statement
              ; 007b b0 0a               BCS CHRRET
              ; 007d c9 20     ISNUM     CMP #' '        ; skip blanks
              ; 007f f0 ef               BEQ CHRGET
              ; 0081 38                  SEC
              ; 0082 e9 30               SBC #'0'
              ; 0084 38                  SEC
              ; 0085 e9 d0               SBC #$d0
              ; 0087 60        CHRRET    RTS

0070          CHRGET = $70        ; Get program byte with pointer pre increment
0076          CHRGOT = $76        ; Get program byte
0077          TXTPTR = $77        ; Pointer to current program byte
007d          ISNUM  = $7d        ; Check for numeric digit

              ; Random seed, five bytes ($88 - $8c)

0088          RNDX   = $88        ; Random seed

              ; These three locations form a counter which is updated 60 times a
              ; second, and serves as a software clock which counts the number of
              ; jiffies that have elapsed since the computer was turned on.
              ; European computers running at 50 Hz add an additional count every
              ; 5th. jiffy in order to compensate the lower interrupt frequency.
              ; After 24 hours and one jiffy these locations are set back to $000000.

008d          JIFFY_CLOCK = $8d   ; Count jiffies (1/60 seconds)

              ; Vector, which may be used to redirect the interrupt routine.
              ; It is initialized to IRQ_NORMAL ($e455), which handles updating
              ; the jiffy clock, blinking the cursor and scanning the keyboard
              ; ROM's with tape routines switch this vector during tape activities
              ; to routines handling write to tape or read from tape.

0090          CINV   = $90        ; IRQ vector (IRQ_NORMAL)

              ; Vector, which may be used to redirect the break routine.
              ; The break routine is called after executing the BRK ($00) command
              ; either by intention or accidentally due to an error.
              ; It is initialized to MONITOR_BREAK ($d467), which saves the contents
              ; of all registers and starts BSM, the Bit Shifter Monitor.

0092          CBINV  = $92        ; BRK vector (MONITOR_BREAK)

              ; Vector, which may be used to redirect the Non Maskable Interrupt.
              ; It is intialized to Basic_Reday ($b3ff).

0094          NMINV  = $94        ; NMI vector (Basic_Reday)

              ; The STATUS byte is used to flag I/O errors or End-Of-Information
              ; A bit set to 1 indicates foloowing conditions:

              ; bit 0 : time out write
              ; bit 1 : time out read
              ; bit 4 : verify error
              ; bit 6 : EOI (End Of Information)
              ; bit 7 : device not present

0096          STATUS = $96        ; Status byte for I/O operations

              ; Key_Index is used in the subroutine EDIT_KEY_SCAN
              ; It holds the index for the character tables or -1 ($ff) for no key

0097          Key_Index = $97     ; Key index for character lookup

              ; The keyflags are used to select the character lookup table for
              ; NORMAL, SHIFTED or CONTROL.
              ; Flags are set by setting the corresponding bit to 0

              ; bit 7:  0 = <shift>
              ; bit 6:  0 = <control>

0098          Key_Flags = $98

              ; The power flag activates power scrolling (continuous scrolling)
              ; when set. It is active in direct mode and inactive in run mode.
              ; Bit 7 $80 activates BASIC editor scrolling
              ; Bit 6 $40 activates Monitor scrolling

0099          Power_Flag = $99    ; $00 = power srolling off

              ; The default bank holds the configuration for the bank register $FFF0
              ; If the operating system runs from ROM its value is $00
              ; Loadable BSOS runs for configuration $ec

009a          Default_Bank = $9a  ; $00 = OS running in ROM

              ; The Stop_Flag is set by the keyboard scan routine
              ; $ff = no STOP key pressed, $ef = STOP key pressed

009b          Stop_Flag = $9b     ; $ef = 1110 1111 flags STOP key pressed

              ; Originally used as variable SVXT for tape routines
              ; Mow used by Parse_DOS_Parameter

009c          Source_Unit = $9c   ; Source unit for COPY command

              ; VERCK flags LOAD (0) or VERIFY ($80) mode for the load routines
              ; MERGE uses the value $40

009d          VERCK         = $9d ; LOAD or VERIFY flag

              ; Counter for the number of keys in keyboard buffer

009e          CharsInBuffer = $9e ; number of keys buffered

              ; Flag indicating reverse mode for screen output

009f          ReverseFlag  = $9f  ; 0 = normal   non zero = reverse

              ; IEEE-488 output: deferred character flag

00a0          C3PO         = $a0  ; 0 = no character waiting, $ff = character waiting

00a1          LastInputCol = $a1  ; screen input stops reading at LastInputVol
00a3          InputRow     = $a3  ; store screen input row number (0-24)
00a4          InputCol     = $a4  ; store screen input column (0-79)

              ; The IEEE-488 output routine CIOUT delays the output by one character,
              ; which is stored in BSOUR. CIOUT checks on each call, if a character
              ; is stored in BSOUR for transmisson, by testing the flag C3PO.
              ; If C3PO is negative, the character in BSOUR is sent and the actual
              ; character is stored in BSOUR. If BSOUR is empty (C3PO == 0), the only
              ; action is storing the actual character in BSOUR and making C3PO
              ; negative. The delay in sending makes it possible  to send the
              ; EOI (End Of Information) along with the last character to transmit.

00a5          BSOUR  = $a5        ; IEEE-488  output: deferred character (buffer)

              ; The keyscan interrupt routine uses this location to indicate which key
              ; is currently being pressed. The value here is then used as an index
              ; into the appropriate keyboard table to determine which character to
              ; print when a key is struck.
              ; The correspondence between the key pressed and the number stored here
              ; is as follows:

              ; $00          $10   2      $20   4      $30   6       $40   9
              ; $01          $11  [DOWN]  $21   UE     $31   AE      $41
              ; $02   sz     $12          $22   O      $32   L       $42  [HOME]
              ; $03  [DEL]   $13   0      $23   [      $33  [RETURN] $43   7
              ; $04   9      $14   ,      $24   U      $34   J       $44   0
              ; $05   6      $15   N      $25   T      $35   G       $45   7
              ; $06   3      $16   V      $26   E      $36   D       $46   4
              ; $07   <   ]  $17   Y      $27   Q      $37   A       $47   1
              ; $08   1      $18   3      $28   ]      $38   5       $48
              ; $09          $19  [SHIFT] $29   P      $39   OE      $49
              ; $0A          $1A          $2A   I      $3A   K       $4a  [STOP]
              ; $0B  [RIGHT] $1B   .      $2B   +      $3B   #       $4b   8
              ; $0C   M      $1C   .      $2C   Z      $3C   H       $4c   ´
              ; $0D  [SPACE] $1D   B      $2D   R      $3D   F       $4d   9
              ; $0E   X      $1E   C      $2E   W      $3E   S       $4e   6
              ; $0F  [CTRL]  $1F  [SHIFT] $2F  [TAB]   $3F  [ESC]    $4f   3

00a6          SFDX   = $a6         ; which key

              ; When this flag is set to a nonzero value, it indicates to the routine
              ; that normally flashes the cursor not to do so. The cursor blink is
              ; turned off when there are characters in the keyboard buffer, or when
              ; the program is running.

00a7          BLNSW   = $a7        ; cursor enable, $00 = flash cursor

              ; The routine that blinks the cursor uses this location to tell when
              ; it's time for a blink. The number 20 is put here and decremented every
              ; jiffy until it reaches zero. Then the cursor state is changed, the
              ; number 20 is put back here, and the cycle starts all over again.

00a8          BLNCT   = $a8

              ; The cursor is formed by printing the inverse of the character that
              ; occupies the cursor position. If that characters is the letter A, for
              ; example, the flashing cursor merely alternates between printing an A
              ; and a reverse-A. This location keeps track of the normal screen code
              ; of the character that is located at the cursor position, so that it
              ; may be restored when the cursor moves on.

00a9          GDBLN  = $a9         ; character under cursor

              ; This location keeps track of whether, during the current cursor blink,
              ; the character under the cursor was reversed, or was restored to
              ; normal. This location will contain 0 if the character is reversed, and
              ; 1 if the character is not reversed.

00aa          BLNON  = $aa         ; cursor blink phase

              ; The current unit number for wedge commands is held in Wedge_Unit
              ; It is initialized to 8 and can be changed with #<unit>

00ab          Wedge_Unit = $ab     ; current device for DOS wedge commands

              ; input from keyboard or screen, $xx = input is available from the
              ; screen, $00 = input should be obtained from the keyboard

00ac          CRSW   = $ac         ; input from keyboard or screen

00ad          Target_Unit = $ad    ; used by DOS Copy

              ; The number of currently open I/O files is stored here. The maximum
              ; number that can be open at one time is ten. The number stored here is
              ; used as the index to the end of the tables that hold the file numbers,
              ; device numbers, and secondary addresses.

00ae          LDTND  = $ae         ; open file count

              ; The default value of this location is 0.

00af          DFLTN  = $af         ; input device number

              ; The default value of this location is 3.

00b0          DFLTO  = $b0         ; output device number

                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard    - input only
                                   ;  1      cassette #1 - disabled in BSOS
                                   ;  2      cassette #2 - disabled in BSOS
                                   ;  3      screen      - input / output
                                   ;  4-31   IEEE-488 bus

00b1          DOS_FC     = $b1     ; used for DOS_Copy
00b2          DOS_EOF    = $b2     ; used for DOS_Copy
00b3          PC_Adjust  = $b3     ; used in monitor
00b4          SCROLLING  = $b4     ; unused
00b5          MONCNT     = $b5     ; BSM counter variable

              ; Theses variables are used to store the value for the bank switching
              ; register while performing the RENUMBER command.

00b6          R_Bank     = $b6     ; Read  Bank value for bank switching
00b7          W_Bank     = $b7     ; Write Bank value for bank switching
00b8          ZP_b8      = $b8     ; unused
00b9          DOS_RL     = $b9     ; used for DOS_Copy
00ba          Dis_Line   = $ba     ; Disassembler
00bb          DosPtr     = $bb     ; used for DS$
00bd          Mon_Format = $bd     ; Disassembler
00be          Dis_Length = $be     ; Disassembler
00bf          Mon_A      = $bf     ; Disassembler
00c0          Mon_B      = $c0     ; Disassembler
00c1          Mon_Op     = $c1     ; Disassembler
00c2          Mon_Lo     = $c2     ; Disassembler
00c3          Mon_Hi     = $c3     ; Disassembler

              ; The Screen Pointer ScrPtr contains the screen memory address
              ; of the current cursor position

00c4          ScrPtr     = $c4      ; screen pointer ($8000 - $87cf)
00c6          CursorCol  = $c6      ; cursor column (0 - 79)

00c7          SAL        = $c7      ; used for windows scrolling
00c9          EAL        = $c9      ; used for LOAD, SAVE and BSM

00cb          Mon_Tmp    = $cb      ; Monitor temporary
00cc          Mon_ZP     = $cc      ; Monitor ZP flag

              ; A nonzero value in this location indicates that the editor is in quote
              ; mode. Quote mode is toggled every time that you type in a quotation
              ; mark on a given line, the first quote mark turns it on, the second
              ; turns it off, the third turns it on, etc.

              ; If the editor is in this mode when a cursor control character or other
              ; nonprinting character is entered, a printed equivalent will appear on
              ; the screen instead of the cursor movement or other control operation
              ; taking place. Instead, that action is deferred until the string is
              ; sent to the string by a PRINT statement, at which time the cursor
              ; movement or other control operation will take place.

              ; The exception to this rule is the DELETE key, which will function
              ; normally within quote mode. The only way to print a character which is
              ; equivalent to the DELETE key is by entering insert mode. Quote mode
              ; may be exited by printing a closing quote or by hitting the RETURN or
              ; SHIFT-RETURN or ESC keys.

00cd          QTSW   = $cd        ; quote switch non zero:inside quotes

00ce          BITTS  = $ce        ; unused (transmitter byte buffer)
00cf          EOT    = $cf        ; unused (end of tape)
00d0          ZD0    = $d0        ; unused

00d1          FNLEN  = $d1        ; Length of filename - for file open and DOS
00d2          LA     = $d2        ; Local     Address
00d3          SA     = $d3        ; Secondary Address
00d4          FA     = $d4        ; First     Address

00d5          RigMargin  = $d5    ; right margin of window (0 - 79)
00d6          TAPE1      = $d6    ; unused
00d8          CursorRow  = $d8    ; current corsor row
00d9          DATAX      = $d9    ; temprary storage
00da          FNADR      = $da    ; file name address
00dc          INSRT      = $dc    ; # of inserts outstanding
00dd          ROPRTY     = $dd    ; unused
00de          FSBLK      = $de    ; unused
00df          ScreenRows = $df    ; current screen rows - 1 (24 or 29)
00e0          TopMargin  = $e0    ; bottom margin of window (0 - screenrows-1)
00e1          BotMargin  = $e1    ; top margin of window
00e2          LefMargin  = $e2    ; left margin of window
00e3          XMAX       = $e3    ; length of keyboard buffer-1 = 9
00e4          LSTX       = $e4    ; last key pressed
00e5          KOUNT      = $e5    ; repeat speed counter
00e6          DELAY      = $e6    ; repeat delay
00e7          CHIME      = $e7    ; chime counter

              ; save the last character processed by Edit_CHROUT in PrevChar
              ; this is used to identify the seuence <HOME><HOME>, which resets
              ; the window to full screen

00e8          PrevChar   = $e8    ; used for key press repetion
00e9          SCRIV      = $e9    ; EDIT_CHRIN vector
00eb          SCROV      = $eb    ; EDIT_CHROUT vector
00f8          JIFFY6     = $f8    ; 50Hz jiffy clock compensation counter
00f9          BPTR       = $f9    ; multi purpose
00fb          STAL       = $fb    ; start address
00fd          MEMUSS     = $fd    ; end   address

              ; the bottom of the stack is used from the BASIC formatting routine
              ; which converts numbers to strings.
              ; The 4 top addresses $01fc-$01ff are used by the BASIC tokenizer
              ; for storing link and line number of an entered BASIC line,
              ; so the usable stack range is limited to $0110 - $01fb.
              ; BASIC initializes the stack pointer to $fa

0100          STACK      = $0100

              ; The input buffer accepts input lines with a maximum of 80 characters
              ; It is also used as workspace for the BASIC tokenizer.

0200          BUF        = $0200

0251          LAT        = $0251  ; Logical Address Table
025b          FAT        = $025b  ; First   Address Table (unit / device)
0265          SAT        = $0265  ; Second  Address Table
026f          KEYD       = $026f  ; keyboard buffer (10 byte)

              ; Commodore BASIC 4 used the area $027a - $0339
              ; as buffer for tape operations (TAPE1 buffer)
              ; BSOS has no TAPE routine and uses it for storing routines
              ; for accessing memory at different banks. These routines must
              ; be located at low RAM, because the ROM area is switched off
              ; while accessing High RAM.
              ; The area is used by the Monitor and RENUMBER command only.

028b          Bank_Store = Bank_Fetch + Bank_Store_Start - Bank_Fetch_Start
027a          Bank_Fetch     = $027a
02a0          Mon_Register   = $02a0
02b0          Dis_Buf_Length = $02b0
02b1          Dis_Buf        = $02b1
02c0          Ass_Buf_Length = $02c0
02c1          Ass_Buf        = $02c1
02d0          Ass_Index      = $02d0

              ; jump vector table for interception of BASIC routines
              ; position and named like the C128 table

0300          IERROR  = $0300     ; DEF_ERROR   BASIC error handler
0302          IMAIN   = $0302     ; DEF_MAIN    BASIC main loop
0304          ICRNCH  = $0304     ; DEF_CRUNCH  BASIC tokenizer
0306          IQPLOP  = $0306     ; DEF_QPLOP   BASIC statement lister
0308          IGONE   = $0308     ; DEF_GONE    BASIC interpret statement
030a          IEVAL   = $030a     ; DEF_EVAL    BASIC evaluate expression

              ; The area $033a - $03c9 was the tape buffer 2 on BASIC 2
              ; BASIC 4 uses this area for variables and buffers related to the
              ; BASIC 4 disk commands, like DOPEN, DCLOSE, DIRECTORY, etc.

033a          DOS_Tmp     = $033a
033b          DOS_Drive_1 = $033b
033c          DOS_Drive_2 = $033c
033d          DOS_Attr    = $033d

              ; DOS_flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

033e          DOS_Flags          = $033e
033f          DOS_Id             = $033f
0341          DOS_Command_Length = $0341
0342          DOS_Filename       = $0342
0353          DOS_Command_Buffer = $0353
03ad          DOS_Status         = $03ad
03ee          TABS_SET           = $03ee    ; 80 bits TAB table
03fa          Reset_Vector       = $03fa    ; set but unused
03fc          Ignore_Timeout     = $03fc

8000          SCREEN_RAM         = $8000

              ; *****************************
              ; MCS 6520 Peripheral Adapter 1
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E810 |CASR| EOI|    |    |Select Keyboard Row| PIA1_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E811 |  0 |  0 |  1 |  1 |  1 |  x |  0 |  0 | PIA1_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E812 |          Keyboard Row (8 keys)        | PIA1_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E813 |  0 |  0 |  1 |  1 |  1 |  1 |  0 |  1 | PIA1_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e810          PIA1_Port_A = $e810
e811          PIA1_Cont_A = $e811
e812          PIA1_Port_B = $e812
e813          PIA1_Cont_B = $e813

              ; *****************************
              ; MCS 6520 Peripheral Adapter 2
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E820 |             IEEE-488 DATA IN          | PIA2_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E821 |    |    |    |    |NDAC|    |    |    | PIA2_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E822 |             IEEE-488 DATA OUT         | PIA2_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E823 | SRQ|    |    |    | DAV|    |    |    | PIA2_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e820          PIA2_Port_A = $e820
e821          PIA2_Cont_A = $e821
e822          PIA2_Port_B = $e822
e823          PIA2_Cont_B = $e823

              ; ************************************
              ; MCS 6522 Versatile Interface Adapter
              ; ************************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  0| E840 | DAV|NRFD|    |    |    | ATN|NRFD|NDAC| Port_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  1| E841 |              User-Port                | Port_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  2| E842 |  0 |  0 |  0 |  1 |  1 |  1 |  1 |  0 | DDR_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  3| E843 |       User-Port Data Direction        | DDR_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  4| E844 |    |    |    |    |    |    |    |    | Timer 1 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  5| E845 |    |    |    |    |    |    |    |    | Timer 1 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  6| E846 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  7| E847 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  8| E848 |    |    |    |    |    |    |    |    | Timer 2 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  9| E849 |    |    |    |    |    |    |    |    | Timer 2 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 10| E84A |    Shift Register                     | Shift
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 11| E84B |    Auxiliary Control Register         | ACR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 12| E84C |    |    |    |    |    |    |    |    | PCR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 13| E84D |    Interrupt Flag Register            | IFR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 14| E84E |    Interrupt Enable Register          | IER
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 15| E84F |    No Handshake Register              | no_HS
              ; --+------+----+----+----+----+----+----+----+----+--------------

e840          VIA_Port_B           = $e840
e841          VIA_Port_A           = $e841  ; unused
e842          VIA_DDR_B            = $e842
e843          VIA_DDR_A            = $e843  ; unused
e844          VIA_Timer_1_Lo       = $e844
e845          VIA_Timer_1_Hi       = $e845
e846          VIA_Timer_1_Latch_Lo = $e846  ; unused
e847          VIA_Timer_1_Latch_Hi = $e847  ; unused
e848          VIA_Timer_2_Lo       = $e848
e849          VIA_Timer_2_Hi       = $e849
e84a          VIA_Shift            = $e84a

e84b          VIA_ACR              = $e84b  ; Auxiliary Control Register
              ; bit 7: Timer 1 : Output Enable    1 = continuous 0 = single
              ; bit 6: Timer 1 : Free-Run Enable  1 = PB7 pulse  0 = IRQ
              ; bit 5: Timer 2 : Control          1 = pulse      0 = single

e84c          VIA_PCR              = $e84c

e84d          VIA_IFR              = $e84d  ; Interrupt Flag Register
              ; 7        IRQ
              ;  6       T1
              ;   5      T2
              ;    4     CB1
              ;     3    CB2
              ;      2   SR
              ;       1  CA1
              ;        0 CA2

e84e          VIA_IER              = $e84e  ; Interrupt Enable Register
e84f          VIA_Port_A_no_HS     = $e84f  ; unused




e880          CRT_Address          = $e880
e881          CRT_Value            = $e881

b000          * = $b000   ; *** b000 ***  Commodore 8296


              ; *********************
b000            Basic_Statement_Table
              ; *********************

b000 c7 b7              .WORD Basic_END       - 1
b002 dd b6              .WORD Basic_FOR       - 1
b004 18 bd              .WORD Basic_NEXT      - 1
b006 82 b8              .WORD Basic_DATA      - 1
b008 a3 bb              .WORD Basic_INPUTN    - 1
b00a bd bb              .WORD Basic_INPUT     - 1
b00c 20 c1              .WORD Basic_DIM       - 1
b00e 01 bc              .WORD Basic_READ      - 1
b010 2f b9              .WORD Basic_LET       - 1
b012 2f b8              .WORD Basic_GOTO      - 1
b014 07 b8              .WORD Basic_RUN       - 1
b016 b2 b8              .WORD Basic_IF        - 1
b018 b6 b7              .WORD Basic_RESTORE   - 1
b01a 12 b8              .WORD Basic_GOSUB     - 1
b01c 5c b8              .WORD Basic_RETURN    - 1
b01e c5 b8              .WORD Basic_REM       - 1
b020 c5 b7              .WORD Basic_STOP      - 1
b022 d5 b8              .WORD Basic_ON        - 1
b024 62 c9              .WORD Basic_WAIT      - 1
b026 d4 ff              .WORD Basic_LOAD      - 1
b028 d7 ff              .WORD Basic_SAVE      - 1
b02a da ff              .WORD Basic_VERIFY    - 1
b02c db c4              .WORD Basic_DEF       - 1
b02e 59 c9              .WORD Basic_POKE      - 1
b030 87 ba              .WORD Basic_PRINTN    - 1
b032 a7 ba              .WORD Basic_PRINT     - 1
b034 ed b7              .WORD Basic_CONT      - 1
b036 2f b6              .WORD Basic_LIST      - 1
b038 ed b5              .WORD Basic_CLR       - 1
b03a 8d ba              .WORD Basic_CMD       - 1
b03c dd ff              .WORD Basic_SYS       - 1
b03e bf ff              .WORD OPEN            - 1
b040 c2 ff              .WORD CLOSE           - 1
b042 79 bb              .WORD Basic_GET       - 1
b044 d1 b5              .WORD Basic_NEW       - 1
b046 ab b7              .WORD Basic_GO        - 1
b048 92 ff              .WORD Basic_CONCAT    - 1
b04a 95 ff              .WORD Basic_DOPEN     - 1
b04c 98 ff              .WORD Basic_DCLOSE    - 1
b04e 9b ff              .WORD Basic_RECORD    - 1
b050 9e ff              .WORD Basic_HEADER    - 1
b052 a1 ff              .WORD Basic_COLLECT   - 1
b054 a4 ff              .WORD Basic_BACKUP    - 1
b056 a7 ff              .WORD Basic_COPY      - 1
b058 aa ff              .WORD Basic_APPEND    - 1
b05a ad ff              .WORD Basic_DSAVE     - 1
b05c b0 ff              .WORD Basic_DLOAD     - 1
b05e b3 ff              .WORD Basic_DIRECTORY - 1
b060 b6 ff              .WORD Basic_RENAME    - 1
b062 b9 ff              .WORD Basic_SCRATCH   - 1
b064 b3 ff              .WORD Basic_DIRECTORY - 1

b066                    .SIZE ;  102 [Basic_Statement_Table]

              ; ********************
b066            Basic_Function_Table
              ; ********************

b066 6f cd              .WORD Basic_SGN
b068 02 ce              .WORD Basic_INT
b06a 8e cd              .WORD Basic_ABS
b06c 00 00              .WORD Basic_USR
b06e a8 c4              .WORD Basic_FRE
b070 c9 c4              .WORD Basic_POS
b072 08 d1              .WORD Basic_SQR
b074 29 d2              .WORD Basic_RND
b076 20 cb              .WORD Basic_LOG
b078 84 d1              .WORD Basic_EXP
b07a 82 d2              .WORD Basic_COS
b07c 89 d2              .WORD Basic_SIN
b07e d2 d2              .WORD Basic_TAN
b080 2c d3              .WORD Basic_ATN
b082 43 c9              .WORD Basic_PEEK
b084 b2 c8              .WORD Basic_LEN
b086 8e c5              .WORD Basic_STR
b088 e3 c8              .WORD Basic_VAL
b08a c1 c8              .WORD Basic_ASC
b08c 22 c8              .WORD Basic_CHR
b08e 36 c8              .WORD Basic_LEFT
b090 62 c8              .WORD Basic_RIGHT
b092 6d c8              .WORD Basic_MID

b094                    .SIZE ;   46 [Basic_Function_Table]

              ; ********************
b094            Basic_Operator_Table
              ; ********************

b094 79 9f c9           .BYTE $79, Op_PLUS     - 1
b097 79 88 c9           .BYTE $79, Op_MINUS    - 1
b09a 7b 60 cb           .BYTE $7b, Op_MULTIPLY - 1
b09d 7b 47 cc           .BYTE $7b, Op_DIVIDE   - 1
b0a0 7f 11 d1           .BYTE $7f, Op_POWER    - 1
b0a3 50 87 c0           .BYTE $50, Op_AND      - 1
b0a6 46 85 c0           .BYTE $46, Op_OR       - 1
b0a9 7d 4a d1           .BYTE $7d, Op_NEGATE   - 1
b0ac 5a cb be           .BYTE $5a, Op_NOT      - 1
b0af 64 b5 c0           .BYTE $64, Op_COMPARE  - 1

b0b2                    .SIZE ;   30 [Basic_Operator_Table]

              ; *******************
b0b2            Basic_Keyword_Table
              ; *******************

b0b2 45 4e c4           .BYTE "END"^        ; 80
b0b5 46 4f d2           .BYTE "FOR"^        ; 81
b0b8 4e 45 58           .BYTE "NEXT"^       ; 82
b0bc 44 41 54           .BYTE "DATA"^       ; 83
b0c0 49 4e 50           .BYTE "INPUT#"^     ; 84
b0c6 49 4e 50           .BYTE "INPUT"^      ; 85
b0cb 44 49 cd           .BYTE "DIM"^        ; 86
b0ce 52 45 41           .BYTE "READ"^       ; 87
b0d2 4c 45 d4           .BYTE "LET"^        ; 88
b0d5 47 4f 54           .BYTE "GOTO"^       ; 89
b0d9 52 55 ce           .BYTE "RUN"^        ; 8a
b0dc 49 c6              .BYTE "IF"^         ; 8b
b0de 52 45 53           .BYTE "RESTORE"^    ; 8c
b0e5 47 4f 53           .BYTE "GOSUB"^      ; 8d
b0ea 52 45 54           .BYTE "RETURN"^     ; 8e
b0f0 52 45 cd           .BYTE "REM"^        ; 8f
b0f3 53 54 4f           .BYTE "STOP"^       ; 90
b0f7 4f ce              .BYTE "ON"^         ; 91
b0f9 57 41 49           .BYTE "WAIT"^       ; 92
b0fd 4c 4f 41           .BYTE "LOAD"^       ; 93
b101 53 41 56           .BYTE "SAVE"^       ; 94
b105 56 45 52           .BYTE "VERIFY"^     ; 95
b10b 44 45 c6           .BYTE "DEF"^        ; 96
b10e 50 4f 4b           .BYTE "POKE"^       ; 97
b112 50 52 49           .BYTE "PRINT#"^     ; 98
b118 50 52 49           .BYTE "PRINT"^      ; 99
b11d 43 4f 4e           .BYTE "CONT"^       ; 9a
b121 4c 49 53           .BYTE "LIST"^       ; 9b
b125 43 4c d2           .BYTE "CLR"^        ; 9c
b128 43 4d c4           .BYTE "CMD"^        ; 9d
b12b 53 59 d3           .BYTE "SYS"^        ; 9e
b12e 4f 50 45           .BYTE "OPEN"^       ; 9f
b132 43 4c 4f           .BYTE "CLOSE"^      ; a0
b137 47 45 d4           .BYTE "GET"^        ; a1
b13a 4e 45 d7           .BYTE "NEW"^        ; a2
b13d 54 41 42           .BYTE "TAB("^       ; a3
b141 54 cf              .BYTE "TO"^         ; a4
b143 46 ce              .BYTE "FN"^         ; a5
b145 53 50 43           .BYTE "SPC("^       ; a6
b149 54 48 45           .BYTE "THEN"^       ; a7
b14d 4e 4f d4           .BYTE "NOT"^        ; a8
b150 53 54 45           .BYTE "STEP"^       ; a9
b154 ab                 .BYTE "+"^          ; aa
b155 ad                 .BYTE "-"^          ; ab
b156 aa                 .BYTE "*"^          ; ac
b157 af                 .BYTE "/"^          ; ad
b158 de                 .BYTE "^"^          ; ae
b159 41 4e c4           .BYTE "AND"^        ; af
b15c 4f d2              .BYTE "OR"^         ; b0
b15e be                 .BYTE ">"^          ; b1
b15f bd                 .BYTE "="^          ; b2
b160 bc                 .BYTE "<"^          ; b3
b161 53 47 ce           .BYTE "SGN"^        ; b4
b164 49 4e d4           .BYTE "INT"^        ; b5
b167 41 42 d3           .BYTE "ABS"^        ; b6
b16a 55 53 d2           .BYTE "USR"^        ; b7
b16d 46 52 c5           .BYTE "FRE"^        ; b8
b170 50 4f d3           .BYTE "POS"^        ; b9
b173 53 51 d2           .BYTE "SQR"^        ; ba
b176 52 4e c4           .BYTE "RND"^        ; bb
b179 4c 4f c7           .BYTE "LOG"^        ; bc
b17c 45 58 d0           .BYTE "EXP"^        ; bd
b17f 43 4f d3           .BYTE "COS"^        ; be
b182 53 49 ce           .BYTE "SIN"^        ; bf
b185 54 41 ce           .BYTE "TAN"^        ; c0
b188 41 54 ce           .BYTE "ATN"^        ; c1
b18b 50 45 45           .BYTE "PEEK"^       ; c2
b18f 4c 45 ce           .BYTE "LEN"^        ; c3
b192 53 54 52           .BYTE "STR$"^       ; c4
b196 56 41 cc           .BYTE "VAL"^        ; c5
b199 41 53 c3           .BYTE "ASC"^        ; c6
b19c 43 48 52           .BYTE "CHR$"^       ; c7
b1a0 4c 45 46           .BYTE "LEFT$"^      ; c8
b1a5 52 49 47           .BYTE "RIGHT$"^     ; c9
b1ab 4d 49 44           .BYTE "MID$"^       ; ca
b1af 47 cf              .BYTE "GO"^         ; cb
b1b1 43 4f 4e           .BYTE "CONCAT"^     ; cc
b1b7 44 4f 50           .BYTE "DOPEN"^      ; cd
b1bc 44 43 4c           .BYTE "DCLOSE"^     ; ce
b1c2 52 45 43           .BYTE "RECORD"^     ; cf
b1c8 48 45 41           .BYTE "HEADER"^     ; d0
b1ce 43 4f 4c           .BYTE "COLLECT"^    ; d1
b1d5 42 41 43           .BYTE "BACKUP"^     ; d2
b1db 43 4f 50           .BYTE "COPY"^       ; d3
b1df 41 50 50           .BYTE "APPEND"^     ; d4
b1e5 44 53 41           .BYTE "DSAVE"^      ; d5
b1ea 44 4c 4f           .BYTE "DLOAD"^      ; d6
b1ef 43 41 54           .BYTE "CATALOG"^    ; d7
b1f6 52 45 4e           .BYTE "RENAME"^     ; d8
b1fc 53 43 52           .BYTE "SCRATCH"^    ; d9
b203 44 49 52           .BYTE "DIRECTORY"^  ; da
b20c 00                 .BYTE $00           ; db

b20d                    .SIZE ;  347 [Basic_Keyword_Table]

              ; *********
b20d            Msg_Start
              ; *********

b20d 4e 45 58           .BYTE "NEXT WITHOUT FOR"^
b21d 53 59 4e Msg_SYNTA .BYTE "SYNTAX"^
b223 52 45 54 Msg_GOSUB .BYTE "RETURN WITHOUT GOSUB"^
b237 4f 55 54           .BYTE "OUT OF DATA"^
b242 49 4c 4c Msg_QUANT .BYTE "ILLEGAL QUANTITY"^
b252 4f 56 45 Msg_FLOW  .BYTE "OVERFLOW"^
b25a 4f 55 54 Msg_OOM   .BYTE "OUT OF MEMORY"^
b267 55 4e 44 Msg_UNDEF .BYTE "UNDEF'D STATEMENT"^
b278 42 41 44 Msg_SUBSC .BYTE "BAD SUBSCRIPT"^
b285 52 45 44 Msg_REDIM .BYTE "REDIM'D ARRAY"^
b292 44 49 56 Msg_DIV   .BYTE "DIVISION BY ZERO"^
b2a2 49 4c 4c Msg_DIREC .BYTE "ILLEGAL DIRECT"^
b2b0 54 59 50 Msg_TYPE  .BYTE "TYPE MISMATCH"^
b2bd 53 54 52 Msg_LONG  .BYTE "STRING TOO LONG"^
b2cc 46 49 4c Msg_DATA  .BYTE "FILE DATA"^
b2d5 46 4f 52 Msg_COMPL .BYTE "FORMULA TOO COMPLEX"^
b2e8 43 41 4e           .BYTE "CAN'T CONTINUE"^
b2f6 55 4e 44 Msg_FUNC  .BYTE "UNDEF'D FUNCTION"^
b306 20 45 52 Msg_ERR   .BYTE " ERROR",0
b30d 20 49 4e Msg_IN    .BYTE " IN ",0

b312                    .SIZE ;  261 [Msg_Start]

              ; *********
b312            Msg_READY
              ; *********

b312 0d 52 45           .BYTE "\rREADY.\r",0

              ; *********
b31b            Msg_BREAK
              ; *********

b31b 0d 42 52           .BYTE "\rBREAK",0


              ; FOR TO STEP NEXT data structure on stack
              ; ========================================

              ; 00 : TXTPTR
              ; 01 : TXTPTR+1  address of loop body

              ; 02 : CURLIN+1
              ; 03 : CURLIN    line #  of loop body

              ; 04 : FAC M4
              ; 05 : FAC M3
              ; 06 : FAC M2    value after TO
              ; 07 : FAC M1
              ; 08 : FAC EX

              ; 09 : sign
              ; 0a : FAC M4
              ; 0b : FAC M3
              ; 0c : FAC M2    value after STEP
              ; 0d : FAC M1
              ; 0e : FAC EX

              ; 0f : FORPNT+1
              ; 10 : FORPNT    address of index variable

              ; 11 : 81        loop marker

              ; ***********************
b322            Find_Active_FOR ; $b322
              ; ***********************

              ; Output: X = stackpointer to loop structure
              ;         Z = found flag
              ;         FORPNT = address of index variable

b322 ba                 TSX                 ; X = stack pointer
b323 e8                 INX
b324 e8                 INX                 ; skip return address of current subroutine
b325 e8                 INX
b326 e8                 INX                 ; skip return address of calling subroutine
b327 bd 01 01 FAF_10    LDA STACK+1,X
b32a c9 81              CMP #$81            ; loop marker ?
b32c d0 21              BNE FAF_Ret
b32e a5 47              LDA FORPNT+1        ; index variable given ?
b330 d0 0a              BNE FAF_20
b332 bd 02 01           LDA STACK+2,X       ; index variable low
b335 85 46              STA FORPNT
b337 bd 03 01           LDA STACK+3,X       ; index variable high
b33a 85 47              STA FORPNT+1
b33c dd 03 01 FAF_20    CMP STACK+3,X       ; index address high match ?
b33f d0 07              BNE FAF_30
b341 a5 46              LDA FORPNT
b343 dd 02 01           CMP STACK+2,X       ; index address low  match ?
b346 f0 07              BEQ FAF_Ret         ; OK found correct data structure
b348 8a       FAF_30    TXA
b349 18                 CLC
b34a 69 12              ADC #$12            ; try outer loop
b34c aa                 TAX
b34d d0 d8              BNE FAF_10
b34f 60       FAF_Ret   RTS ;Size   46 [Find_Active_FOR]

              ; *********************
b350            Open_Up_Space ; $b350
              ; *********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ;         TMPPTA = target pointer (upper boundary)
              ;         TMPPTB = source pointer (upper boundary)
              ;         TMPPTC = source pointer (lower boundary)

b350 20 a0 b3           JSR Check_Mem_Avail ; may trigger a garbage collection
b353 85 2e              STA STREND
b355 84 2f              STY STREND+1        ; save new top of variables
b357 38                 SEC
b358 a5 57              LDA TMPPTB
b35a e5 5c              SBC TMPPTC
b35c 85 1f              STA INDEXA
b35e a8                 TAY
b35f a5 58              LDA TMPPTB+1
b361 e5 5d              SBC TMPPTC+1
b363 aa                 TAX                 ; Y/X = bytes to move
b364 e8                 INX                 ; pages + 1
b365 98                 TYA
b366 f0 23              BEQ OUS_40          ; no partial page
b368 a5 57              LDA TMPPTB
b36a 38                 SEC
b36b e5 1f              SBC INDEXA
b36d 85 57              STA TMPPTB
b36f b0 03              BCS OUS_10
b371 c6 58              DEC TMPPTB+1        ; TMPPTB = source ptr
b373 38                 SEC
b374 a5 55    OUS_10    LDA TMPPTA
b376 e5 1f              SBC INDEXA
b378 85 55              STA TMPPTA
b37a b0 08              BCS OUS_30
b37c c6 56              DEC TMPPTA+1        ; TMPPTA = target ptr
b37e 90 04              BCC OUS_30          ; branch always
b380 b1 57    OUS_20    LDA (TMPPTB),Y
b382 91 55              STA (TMPPTA),Y
b384 88       OUS_30    DEY
b385 d0 f9              BNE OUS_20
b387 b1 57              LDA (TMPPTB),Y
b389 91 55              STA (TMPPTA),Y
b38b c6 58    OUS_40    DEC TMPPTB+1
b38d c6 56              DEC TMPPTA+1
b38f ca                 DEX
b390 d0 f2              BNE OUS_30
b392 60                 RTS ;Size   67 [Open_Up_Space]

              ; *************************
b393            Check_Stack_Avail ; $b393
              ; *************************

b393 ba                 TSX
b394 e0 20              CPX #$20
b396 90 35              BCC Error_Out_Of_Memory
b398 60                 RTS ;Size    6 [Check_Stack_Avail]

              ; **************
b399            BSOS_Bank_Init
              ; **************

b399 00                 .BYTE 0             ; changed by BSOS loader

b39a 00 00 00           .FILL $b3a0-* (0) ; 6 bytes

              ; ***********************
b3a0            Check_Mem_Avail ; $b3a0
              ; ***********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ; Return if OK
              ; Jump to OOM error if not

b3a0 c4 31              CPY FRETOP+1
b3a2 90 19              BCC CMA_Ret
b3a4 d0 04              BNE CMA_10
b3a6 c5 30              CMP FRETOP
b3a8 90 13              BCC CMA_Ret
b3aa 48       CMA_10    PHA                 ; not enough space
b3ab 98                 TYA                 ; call garbage collectiom
b3ac 48                 PHA
b3ad 20 6a c6           JSR Garbage_Collection
b3b0 68                 PLA
b3b1 a8                 TAY                 ; restore new top high
b3b2 68                 PLA                 ; restore new to low
b3b3 c4 31              CPY FRETOP+1        ; compare again
b3b5 90 06              BCC CMA_Ret
b3b7 d0 14              BNE Error_Out_Of_Memory
b3b9 c5 30              CMP FRETOP
b3bb b0 10              BCS Error_Out_Of_Memory
b3bd 60       CMA_Ret   RTS ;Size   30 [Check_Mem_Avail]

b3be 00 00 00           .FILL $b3cd-* (0) ; 15 bytes

              ; ***************************
b3cd            Error_Out_Of_Memory ; $b3cd
              ; ***************************

b3cd a2 4d              LDX #[Msg_OOM - Msg_Start] ; $4d

              ; *******************
b3cf            Basic_Error ; $b3cf
              ; *******************

              ; Input:  X = Offset from Msg_Start for message

b3cf 6c 00 03           JMP (IERROR)

              ; *********
b3d2            DEF_ERROR
              ; *********

b3d2 20 cc ff           JSR CLRCHN          ; close open channels
b3d5 85 10              STA IOPMPT          ; A = 0 from CLRCHN
b3d7 20 df ba           JSR Print_CR
b3da 20 44 bb           JSR Print_Question_Mark
b3dd bd 0d b2 Berr_20   LDA Msg_Start,X
b3e0 48                 PHA
b3e1 29 7f              AND #$7f
b3e3 20 d2 ff           JSR CHROUT
b3e6 e8                 INX
b3e7 68                 PLA
b3e8 10 f3              BPL Berr_20
b3ea 20 0e b6 Berr_30   JSR Flush_BASIC_Stack
b3ed a9 06              LDA #<Msg_ERR
b3ef a0 b3              LDY #>Msg_ERR
b3f1 20 1d bb Berr_40   JSR Print_String
b3f4 a4 37              LDY CURLIN+1
b3f6 c8                 INY
b3f7 f0 06              BEQ Basic_Ready
b3f9 20 78 cf           JSR Print_IN

b3fc ea ea ea           .FILL $b3ff-* ($ea) ; 3 bytes

              ; ********************
b3ff            Basic_Ready ; $ b3ff
              ; ********************

b3ff a9 12              LDA #<Msg_READY
b401 a0 b3              LDY #>Msg_READY
b403 20 1d bb           JSR Print_String

              ; ***************************
b406            Get_Basic_Statement ; $b406
              ; ***************************

b406 6c 02 03           JMP (IMAIN)

              ; ********
b409            DEF_MAIN
              ; ********

b409 20 f2 e9           JSR Read_Power_String
b40c 86 77              STX TXTPTR
b40e 84 78              STY TXTPTR+1
b410 20 70 00           JSR CHRGET
b413 aa                 TAX
b414 f0 f0              BEQ Get_Basic_Statement; empty line
b416 a2 ff              LDX #$ff
b418 86 37              STX CURLIN+1        ; invalidate CURLIN
b41a 90 03              BCC New_Basic_Line  ; started with a line number
b41c 4c 42 f8           JMP Wedge_Parser    ; direct command

              ; **********************
b41f            New_Basic_Line ; $b41f
              ; **********************

              ; This routine uses the addresses $01fc-$01ff for constructing
              ; the link and line number for the line stored in the buffer at $0200
              ; So these bytes are not available for stack operations.
              ; That's why the Flush_Stack routine initializes the stack pointer to $fa.

b41f 20 f6 b8           JSR Scan_Linenumber ; Line number
b422 20 fb b4           JSR Tokenize_Line   ; Crunch line
b425 84 05              STY COUNT           ; new line length (incl. link & number)
b427 20 a6 b5           JSR Find_BASIC_Line ; does this line exist?
b42a 90 44              BCC NBL_30          ; if not -> create a new line
b42c a0 01              LDY #1              ; Y = 1
b42e b1 5c              LDA (TMPPTC),Y      ; link high
b430 85 20              STA INDEXA+1        ; source pointer INDEXA high
b432 a5 2a              LDA VARTAB
b434 85 1f              STA INDEXA          ; source pointer INDEXA low
b436 a5 5d              LDA TMPPTC+1
b438 85 22              STA INDEXB+1        ; target pointer INDEXB high
b43a a5 5c              LDA TMPPTC
b43c 88                 DEY                 ; Y = 0
b43d f1 5c              SBC (TMPPTC),Y      ; negative length of line
b43f 18                 CLC
b440 65 2a              ADC VARTAB          ; subtract line length from VARTAB
b442 85 2a              STA VARTAB          ; by adding the negative length to VARTAB
b444 85 21              STA INDEXB          ; move target pointer INDEXB low
b446 a5 2b              LDA VARTAB+1
b448 69 ff              ADC #$ff
b44a 85 2b              STA VARTAB+1        ; VARTAB -= length of current line
b44c e5 5d              SBC TMPPTC+1
b44e aa                 TAX                 ; pages to move
b44f 38                 SEC
b450 a5 5c              LDA TMPPTC
b452 e5 2a              SBC VARTAB          ; bytes to move
b454 a8                 TAY
b455 b0 03              BCS NBL_10
b457 e8                 INX                 ; increment pages to move
b458 c6 22              DEC INDEXB+1
b45a 18       NBL_10    CLC
b45b 65 1f              ADC INDEXA
b45d 90 03              BCC NBL_20
b45f c6 20              DEC INDEXA+1
b461 18                 CLC
b462 b1 1f    NBL_20    LDA (INDEXA),Y      ; move program code above deleted line
b464 91 21              STA (INDEXB),Y      ; downwards
b466 c8                 INY
b467 d0 f9              BNE NBL_20          ; inner loop moves 1 page
b469 e6 20              INC INDEXA+1
b46b e6 22              INC INDEXB+1
b46d ca                 DEX                 ; pages to move
b46e d0 f2              BNE NBL_20
b470 20 e9 b5 NBL_30    JSR Reset_BASIC_Execution
b473 20 b6 b4           JSR Rechain
b476 ad 00 02           LDA BUF
b479 f0 8b              BEQ Get_Basic_Statement
b47b 18                 CLC
b47c a5 2a              LDA VARTAB
b47e 85 57              STA TMPPTB
b480 65 05              ADC COUNT
b482 85 55              STA TMPPTA
b484 a4 2b              LDY VARTAB+1
b486 84 58              STY TMPPTB+1
b488 90 01              BCC NBL_40
b48a c8                 INY
b48b 84 56    NBL_40    STY TMPPTA+1
b48d 20 50 b3           JSR Open_Up_Space
b490 a5 11              LDA LINNUM
b492 a4 12              LDY LINNUM+1
b494 8d fe 01           STA BUF-2
b497 8c ff 01           STY BUF-1
b49a a5 2e              LDA STREND
b49c a4 2f              LDY STREND+1
b49e 85 2a              STA VARTAB
b4a0 84 2b              STY VARTAB+1
b4a2 a4 05              LDY COUNT
b4a4 88                 DEY
b4a5 b9 fc 01 NBL_50    LDA BUF-4,Y         ; copy buffer to program
b4a8 91 5c              STA (TMPPTC),Y
b4aa 88                 DEY
b4ab 10 f8              BPL NBL_50

              ; *************************
b4ad            Reset_And_Rechain ; $b4ad
              ; *************************

b4ad 20 e9 b5           JSR Reset_BASIC_Execution
b4b0 20 b6 b4           JSR Rechain
b4b3 4c 06 b4           JMP Get_Basic_Statement

              ; ***************
b4b6            Rechain ; $b4b6
              ; ***************

b4b6 a6 28              LDX TXTTAB
b4b8 a5 29              LDA TXTTAB+1
b4ba a0 01              LDY #1
b4bc d0 16              BNE Rech_30
b4be a0 04    Rech_10   LDY #4
b4c0 c8       Rech_20   INY
b4c1 b1 1f              LDA (INDEXA),Y
b4c3 d0 fb              BNE Rech_20         ; scan for 0
b4c5 98                 TYA
b4c6 38                 SEC                 ; + 1
b4c7 65 1f              ADC INDEXA
b4c9 aa                 TAX                 ; X = new address low
b4ca a0 00              LDY #0
b4cc 91 1f              STA (INDEXA),Y      ; store link low
b4ce 98                 TYA                 ; A = 0
b4cf 65 20              ADC INDEXA+1        ; A = new address high
b4d1 c8                 INY                 ; Y = 1
b4d2 91 1f              STA (INDEXA),Y      ; store link high
b4d4 86 1f    Rech_30   STX INDEXA
b4d6 85 20              STA INDEXA+1
b4d8 b1 1f              LDA (INDEXA),Y      ; link high
b4da d0 e2              BNE Rech_10         ; more lines
b4dc 60                 RTS ;Size   39 [Rechain]

b4dd 00 00 00           .FILL $b4e2-* (0) ; 5 bytes

              ; *******************
b4e2            Read_String ; $b4e2
              ; *******************

b4e2 a2 00              LDX #0
b4e4 20 cf ff ReaS_10   JSR CHRIN
b4e7 c9 0d              CMP #CR
b4e9 f0 0d              BEQ ReaS_20
b4eb 9d 00 02           STA BUF,X
b4ee e8                 INX
b4ef e0 51              CPX #81
b4f1 90 f1              BCC ReaS_10
b4f3 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
b4f5 4c cf b3           JMP Basic_Error
b4f8 4c d2 ba ReaS_20   JMP Terminate_BUF

              ; *********************
b4fb            Tokenize_Line ; $b4fb
              ; *********************

b4fb 6c 04 03           JMP (ICRNCH)

              ; **********
b4fe            DEF_CRUNCH
              ; **********

b4fe a6 77              LDX TXTPTR
b500 a0 04              LDY #4
b502 84 09              STY GARBFL          ; clear bits 7-4
b504 bd 00 02 ToLi_01   LDA BUF,X           ; get next char
b507 10 07              BPL ToLi_02         ; normal char
b509 c9 ff              CMP #$ff            ; Pi ?
b50b f0 4a              BEQ ToLi_08         ; treat Pi as normal char
b50d e8                 INX                 ; no action on this char
b50e d0 f4              BNE ToLi_01         ; next one
b510 c9 20    ToLi_02   CMP #' '            ; no action on blank
b512 f0 43              BEQ ToLi_08
b514 85 04              STA ENDCHR          ; save char
b516 c9 22              CMP #$22            ; quote ?
b518 f0 62              BEQ ToLi_12         ; handle string
b51a 24 09              BIT GARBFL
b51c 70 39              BVS ToLi_08
b51e c9 3f              CMP #'?'            ; short for print
b520 d0 04              BNE ToLi_03
b522 a9 99              LDA #$99            ; PRINT token
b524 d0 31              BNE ToLi_08
b526 c9 30    ToLi_03   CMP #'0'
b528 90 04              BCC ToLi_04         ; is symbol
b52a c9 3c              CMP #$3c            ; '<'
b52c 90 29              BCC ToLi_08
b52e 84 6e    ToLi_04   STY TMPPTD          ; save Y
b530 a0 00              LDY #0
b532 84 05              STY COUNT           ; keyword count
b534 86 77              STX TXTPTR          ; update pointer
b536 a9 b0              LDA #>Basic_Keyword_Table
b538 85 20              STA INDEXA+1
b53a a9 b2              LDA #<Basic_Keyword_Table
b53c 85 1f              STA INDEXA
b53e d0 07              BNE ToLi_06         ; branch always
b540 e8       ToLi_05   INX                 ; inc buffer  pointer X
b541 e6 1f              INC INDEXA          ; inc keyword pointer INDEXA
b543 d0 02              BNE ToLi_06
b545 e6 20              INC INDEXA+1
b547 bd 00 02 ToLi_06   LDA BUF,X           ; char - keyword char
b54a 38                 SEC
b54b f1 1f              SBC (INDEXA),Y
b54d f0 f1              BEQ ToLi_05         ; match, continue with next char
b54f c9 80              CMP #$80            ; match with difference $80 -> found
b551 d0 30              BNE ToLi_13
b553 05 05              ORA COUNT           ; token = $80 | count
b555 a4 6e    ToLi_07   LDY TMPPTD          ; restore Y (started with 4)
b557 e8       ToLi_08   INX                 ; point to char after parsed word
b558 c8                 INY                 ; point to token insert position - 5
b559 99 fb 01           STA BUF-5,Y         ; insert token at start of word
b55c b9 fb 01           LDA BUF-5,Y         ; reload to set flags
b55f f0 3b              BEQ ToLi_16         ; zero -> end of line
b561 38                 SEC
b562 e9 3a              SBC #':'            ; colon ?
b564 f0 04              BEQ ToLi_09         ; branch on colon
b566 c9 49              CMP #$49            ; DATA token ? ($83 = $3a + $49)
b568 d0 02              BNE ToLi_10
b56a 85 09    ToLi_09   STA GARBFL          ; store colon or $49 for DATA
b56c 38       ToLi_10   SEC
b56d e9 55              SBC #$55            ; REM token ? ($8f = $3a + $55)
b56f d0 93              BNE ToLi_01         ; no special tokens -> continue parse
b571 85 04              STA ENDCHR          ; store REM marker in ENDCHR
b573 bd 00 02 ToLi_11   LDA BUF,X
b576 f0 df              BEQ ToLi_08         ; end of parsed text
b578 c5 04              CMP ENDCHR
b57a f0 db              BEQ ToLi_08         ; end of copied text
b57c c8       ToLi_12   INY                 ; copy text in quotes or after REM or DATA
b57d 99 fb 01           STA BUF-5,Y
b580 e8                 INX
b581 d0 f0              BNE ToLi_11         ; continue copy
b583 a6 77    ToLi_13   LDX TXTPTR          ; found keyword match
b585 e6 05              INC COUNT           ; set count to next token
b587 b1 1f    ToLi_14   LDA (INDEXA),Y      ;
b589 08                 PHP                 ; save flags
b58a e6 1f              INC INDEXA          ; let INDEXA point to next token
b58c d0 02              BNE ToLi_15
b58e e6 20              INC INDEXA+1
b590 28       ToLi_15   PLP                 ; restore flags
b591 10 f4              BPL ToLi_14         ; true if not single character keyword
b593 b1 1f              LDA (INDEXA),Y      ; load 1st. char of next token keyword
b595 d0 b0              BNE ToLi_06         ; jump if not at end of table
b597 bd 00 02           LDA BUF,X           ; reread parse char
b59a 10 b9              BPL ToLi_07         ; start searching from start of table
b59c 99 fd 01 ToLi_16   STA BUF-3,Y         ; end of parse, store zeroes at end of line
b59f c6 78              DEC TXTPTR+1        ; set TXTPTR to BUF-1
b5a1 a9 ff              LDA #$ff
b5a3 85 77              STA TXTPTR
b5a5 60                 RTS ;Size  168 [DEF_CRUNCH]

              ; ***********************
b5a6            Find_BASIC_Line ; $b5a3
              ; ***********************

b5a6 a5 28              LDA TXTTAB
b5a8 a6 29              LDX TXTTAB+1

              ; **************************
b5aa            Find_BASIC_Line_AX ; $b5a7
              ; **************************

b5aa a0 01              LDY #1
b5ac 85 5c              STA TMPPTC
b5ae 86 5d              STX TMPPTC+1
b5b0 b1 5c              LDA (TMPPTC),Y      ; link high
b5b2 f0 1a              BEQ FBL_30          ; branch on EOP
b5b4 aa                 TAX                 ; X = link high
b5b5 a0 03              LDY #3
b5b7 a5 12              LDA LINNUM+1
b5b9 d1 5c              CMP (TMPPTC),Y
b5bb 90 12              BCC FBL_Ret         ; branch if beyond
b5bd d0 09              BNE FBL_10
b5bf 88                 DEY                 ; Y = 2
b5c0 a5 11              LDA LINNUM
b5c2 d1 5c              CMP (TMPPTC),Y
b5c4 f0 09              BEQ FBL_Ret         ; (C=1) found
b5c6 90 07              BCC FBL_Ret         ; (C=0) not found
b5c8 a0 00    FBL_10    LDY #0
b5ca b1 5c              LDA (TMPPTC),Y      ; Link low
b5cc b0 dc              BCS Find_BASIC_Line_AX  ; branch always
b5ce 18       FBL_30    CLC                 ; Carry clear = not found
b5cf 60       FBL_Ret   RTS ;Size   38 [Find_BASIC_Line_AX]

b5d0 00 00              .FILL $b5d2-* (0) ; 2 bytes

              ; *****************
b5d2            Basic_NEW ; $b5d2
              ; *****************

b5d2 d0 fb              BNE FBL_Ret         ; return if NEW is not a single statement

              ; ***********
b5d4            Perform_NEW
              ; ***********

b5d4 a9 00              LDA #0
b5d6 a8                 TAY
b5d7 91 28              STA (TXTTAB),Y      ; zero link
b5d9 c8                 INY
b5da 91 28              STA (TXTTAB),Y
b5dc a5 28              LDA TXTTAB
b5de 18                 CLC
b5df 69 02              ADC #2
b5e1 85 2a              STA VARTAB          ; VARTAB = TXTTAB + 2
b5e3 a5 29              LDA TXTTAB+1
b5e5 69 00              ADC #0
b5e7 85 2b              STA VARTAB+1

              ; *********************
b5e9            Reset_BASIC_Execution
              ; *********************

b5e9 20 22 b6           JSR Reset_BASIC_Exec_Pointer
b5ec a9 00              LDA #0              ; set for next condition

              ; *********
b5ee            Basic_CLR
              ; *********

b5ee d0 31              BNE FBS_Ret         ; return if not single statement

              ; **********************
b5f0            Reset_Variable_Pointer
              ; **********************

b5f0 a5 34              LDA MEMSIZ
b5f2 a4 35              LDY MEMSIZ+1
b5f4 85 30              STA FRETOP
b5f6 84 31              STY FRETOP+1
b5f8 ea                 NOP
b5f9 ea                 NOP
b5fa ea                 NOP
b5fb ea                 NOP
b5fc 20 e7 ff           JSR CLALL
b5ff a5 2a              LDA VARTAB
b601 a4 2b              LDY VARTAB+1
b603 85 2c              STA ARYTAB
b605 84 2d              STY ARYTAB+1
b607 85 2e              STA STREND
b609 84 2f              STY STREND+1
b60b 20 b7 b7 RVP_10    JSR Basic_RESTORE

              ; *************************
b60e            Flush_BASIC_Stack ; $b60e
              ; *************************

b60e a2 16              LDX #TEMPST         ; clear string descriptor stack
b610 86 13              STX TEMPPT
b612 68                 PLA
b613 a8                 TAY
b614 68                 PLA
b615 a2 fa              LDX #$fa            ; reset stackpointer
b617 9a                 TXS
b618 48                 PHA
b619 98                 TYA
b61a 48                 PHA
b61b a9 00              LDA #0
b61d 85 3b              STA OLDTXT+1
b61f 85 0a              STA SUBFLG
b621 60       FBS_Ret   RTS ;Size   20 [Flush_BASIC_Stack]

              ; ************************
b622            Reset_BASIC_Exec_Pointer
              ; ************************

b622 18                 CLC                 ; TXTPTR = TXTTAB - 1
b623 a5 28              LDA TXTTAB
b625 69 ff              ADC #$ff
b627 85 77              STA TXTPTR
b629 a5 29              LDA TXTTAB+1
b62b 69 ff              ADC #$ff
b62d 85 78              STA TXTPTR+1
b62f 60       RBEP_Ret  RTS ;Size   14 [Reset_BASIC_Exec_Pointer]

              ; **********
b630            Basic_LIST
              ; **********

b630 90 06              BCC LIST_10         ; C=0 : number after LIST
b632 f0 04              BEQ LIST_10         ; Z=1 : end of statement
b634 c9 ab              CMP #$ab            ; '-' token
b636 d0 f7              BNE RBEP_Ret        ; -> RTS
b638 20 f6 b8 LIST_10   JSR Scan_Linenumber ; starting line or 0 for non numeric
b63b 20 a6 b5           JSR Find_BASIC_Line ; setup TMPPTC
b63e 20 76 00           JSR CHRGOT          ; last character read
b641 f0 0c              BEQ LIST_15         ; no end line
b643 c9 ab              CMP #$ab            ; '-' token
b645 d0 e8              BNE RBEP_Ret        ; -> RTS
b647 20 70 00           JSR CHRGET
b64a 20 f6 b8           JSR Scan_Linenumber ; read end line
b64d d0 e0              BNE RBEP_Ret        ; more chars after end line -> RTS
b64f 68       LIST_15   PLA                 ; remove return address
b650 68                 PLA
b651 a5 11              LDA LINNUM
b653 05 12              ORA LINNUM+1
b655 d0 02              BNE LIST_20         ; end line != 0 ?
b657 c6 12              DEC LINNUM+1        ; end line  = $ff00 = 65280

              ; loop for line listing

b659 a0 01    LIST_20   LDY #1

              ; check for EOP and STOP

b65b b1 5c              LDA (TMPPTC),Y      ; link address high
b65d f0 27              BEQ LIST_50         ; -> end of program
b65f 20 e1 ff           JSR STOP            ; check STOP key
b662 20 df ba           JSR Print_CR        ; start listing with newline

              ; get line #

b665 c8                 INY                 ; Y=2
b666 b1 5c              LDA (TMPPTC),Y      ; line # lo
b668 aa                 TAX
b669 c8                 INY                 ; Y=3
b66a b1 5c              LDA (TMPPTC),Y      ; line # hi

              ; check for last line to list

b66c c5 12              CMP LINNUM+1        ; compare with end line hi
b66e d0 04              BNE LIST_25         ; not equal
b670 e4 11              CPX LINNUM          ; compare with end line lo
b672 f0 02              BEQ LIST_30         ; match -> print it
b674 b0 10    LIST_25   BCS LIST_50         ; line # > end line


              ; loop for printing characters

b676 20 89 b6 LIST_30   JSR List_Line

              ; follow link

b679 a8       LIST_60   TAY                 ; Y=0
b67a b1 5c              LDA (TMPPTC),Y      ; link low
b67c aa                 TAX
b67d c8                 INY
b67e b1 5c              LDA (TMPPTC),Y      ; link high
b680 86 5c              STX TMPPTC          ; TMPPTC = link
b682 85 5d              STA TMPPTC+1
b684 d0 d3              BNE LIST_20         ; continue with next line

              ; next line if not EOP

b686 4c ff b3 LIST_50   JMP Basic_Ready     ; LIST finished

b689                    .SIZE ;   89 [Basic_LIST]

              ; *****************
b689            List_Line ; $b689
              ; *****************

b689 20 83 cf           JSR Print_Integer_XA; print line #
b68c a9 20              LDA #' '            ; print blank after line #
b68e a0 03              LDY #3              ; before basic text

b690 20 46 bb LiLi_08   JSR Print_Char
b693 c9 22              CMP #QUOTE
b695 d0 0c              BNE LiLi_20

              ; print quoted string

b697 c8       LiLi_10   INY
b698 b1 5c              LDA (TMPPTC),Y
b69a f0 41              BEQ LiLi_Ret
b69c 20 46 bb           JSR Print_Char      ; print it
b69f c9 22              CMP #QUOTE
b6a1 d0 f4              BNE LiLi_10

              ; get next char

b6a3 c8       LiLi_20   INY                 ; Y++
b6a4 b1 5c              LDA (TMPPTC),Y      ; next character
b6a6 f0 35              BEQ LiLi_Ret
b6a8 6c 06 03           JMP (IQPLOP)        ; hook for extensions

              ; *********
b6ab            DEF_QPLOP
              ; *********

b6ab 10 e3              BPL LiLi_08         ; continue printing if not a token
b6ad c9 ff              CMP #$ff            ; is it the special char PI ?
b6af f0 df              BEQ LiLi_08         ; yes, print it

              ; print keyword from token

b6b1 aa                 TAX
b6b2 98                 TYA
b6b3 48                 PHA                 ; save Y
b6b4 a0 b0              LDY #>[Basic_Keyword_Table-1]
b6b6 84 20              STY INDEXA+1
b6b8 a0 b1              LDY #<[Basic_Keyword_Table-1]
b6ba 84 1f              STY INDEXA
b6bc a0 00              LDY #0
b6be ca       LiLi_30   DEX                 ; token--
b6bf 10 0c              BPL LiLi_60         ; count down finished
b6c1 e6 1f    LiLi_40   INC INDEXA          ; increment address to keyword table
b6c3 d0 02              BNE LiLi_50
b6c5 e6 20              INC INDEXA+1
b6c7 b1 1f    LiLi_50   LDA (INDEXA),Y      ; load next keyword char
b6c9 10 f6              BPL LiLi_40         ; -> inside keyword
b6cb 30 f1              BMI LiLi_30         ; -> end of keyword
b6cd c8       LiLi_60   INY
b6ce b1 1f              LDA (INDEXA),Y      ; next char from keyword table
b6d0 48                 PHA
b6d1 29 7f              AND #$7f
b6d3 20 46 bb           JSR Print_Char      ; print it
b6d6 68                 PLA
b6d7 10 f4              BPL LiLi_60
b6d9 68                 PLA
b6da a8                 TAY
b6db d0 c6              BNE LiLi_20
b6dd 60       LiLi_Ret  RTS ;Size   51 [DEF_QPLOP]

b6de                    .FILL $b6de-* (0) ; 0 bytes

              ; *****************
b6de            Basic_FOR ; $b6de
              ; *****************

b6de a9 80              LDA #$80
b6e0 85 0a              STA SUBFLG          ; Inhibit integer index
b6e2 20 30 b9           JSR Basic_LET       ; define index variable
b6e5 20 22 b3           JSR Find_Active_FOR
b6e8 d0 05              BNE FOR_10          ; branch if none
b6ea 8a                 TXA
b6eb 69 0f              ADC #15             ; add 16 (C=1 from Find_Active_FOR)
b6ed aa                 TAX
b6ee 9a                 TXS
b6ef 68       FOR_10    PLA                 ; remove return address
b6f0 68                 PLA                 ; now there is space for 18 bytes
b6f1 20 93 b3           JSR Check_Stack_Avail
b6f4 20 91 b8           JSR Skip_To_EOS     ; search start of loop body
b6f7 18                 CLC
b6f8 98                 TYA                 ; Y = position of delimiter (0 or ':')
b6f9 65 77              ADC TXTPTR          ; loop body low
b6fb 48                 PHA
b6fc a5 78              LDA TXTPTR+1        ; loop body high
b6fe 69 00              ADC #0
b700 48                 PHA
b701 a5 37              LDA CURLIN+1        ; line # high for body
b703 48                 PHA
b704 a5 36              LDA CURLIN          ; line # low  for body
b706 48                 PHA
b707 a9 a4              LDA #$a4            ; TO token
b709 20 f7 be           JSR Need_A
b70c 20 84 bd           JSR Eval_Numeric    ; read end value
b70f a5 63              LDA FAC1SI
b711 09 7f              ORA #$7f
b713 25 5f              AND FAC1M1
b715 85 5f              STA FAC1M1
b717 18                 CLC                 ; push without sign
b718 20 2e be           JSR Push_FAC1       ; push TO value
b71b a9 f2              LDA #<REAL_1
b71d a0 ca              LDY #>REAL_1
b71f 20 d8 cc           JSR Load_FAC1_AY    ; default 1.0 for STEP value
b722 20 76 00           JSR CHRGOT
b725 c9 a9              CMP #$a9            ; STEP token
b727 d0 06              BNE FOR_30
b729 20 70 00           JSR CHRGET
b72c 20 84 bd           JSR Eval_Numeric
b72f 20 61 cd FOR_30    JSR Get_FAC1_Sign
b732 85 63              STA FAC1SI
b734 38                 SEC                 ; push with sign
b735 20 2e be           JSR Push_FAC1       ; push STEP value
b738 a5 47              LDA FORPNT+1
b73a 48                 PHA
b73b a5 46              LDA FORPNT
b73d 48                 PHA
b73e a9 81              LDA #$81
b740 48                 PHA
b741 d0 07              BNE Execute         ; always

b743 00 00 00           .FILL $b74a-* (0) ; 7 bytes

              ; ***************
b74a            Execute ; $b74a
              ; ***************

b74a 20 43 f3           JSR Kernal_STOP
b74d a4 78              LDY TXTPTR+1
b74f c0 02              CPY #2
b751 f0 06              BEQ Exec_10
b753 a5 77              LDA TXTPTR
b755 85 3a              STA OLDTXT          ; save pointer if not direct
b757 84 3b              STY OLDTXT+1
b759 a0 00    Exec_10   LDY #0
b75b b1 77              LDA (TXTPTR),Y
b75d d0 46              BNE Inpr_40         ; branch if not at line end
b75f a0 02              LDY #2
b761 b1 77              LDA (TXTPTR),Y      ; link high
b763 18                 CLC                 ; C=0 : normal end
b764 f0 7c              BEQ END_40          ; end of program -> READY.
b766 c8                 INY                 ; Y = 3
b767 b1 77              LDA (TXTPTR),Y      ; new line # to CURLIN
b769 85 36              STA CURLIN
b76b c8                 INY
b76c b1 77              LDA (TXTPTR),Y
b76e 85 37              STA CURLIN+1
b770 98                 TYA
b771 65 77              ADC TXTPTR          ; TXTPTR = next statement
b773 85 77              STA TXTPTR
b775 90 02              BCC Start_Program
b777 e6 78              INC TXTPTR+1

              ; *************
b779            Start_Program
              ; *************

b779 6c 08 03           JMP (IGONE)

              ; ********
b77c            DEF_GONE
              ; ********

b77c 20 0f bf           JSR Any_Except_Pi   ; Pi must not start a statement
b77f 20 85 b7           JSR Interpret
b782 4c 4a b7           JMP Execute

              ; *****************
b785            Interpret ; $b785
              ; *****************

              ; Input:  A = first character of new statement
              ;         Flags set from GETCHR

b785 f0 3e              BEQ REST_Ret        ; branch on empty statement
b787 e9 80    Inpr_10   SBC #$80            ; token -> number
b789 90 17              BCC Inpr_30         ; branch to LET if not token
b78b c9 23              CMP #$23            ; $80-$a2 may start a statement
b78d 90 06              BCC Inpr_20         ; use jump table
b78f c9 4b              CMP #$4b            ; $a3-$cb are functions or operators
b791 90 16              BCC Inpr_50
b793 e9 28              SBC #$28            ; BASIC-4 token
b795 0a       Inpr_20   ASL A
b796 a8                 TAY
b797 b9 01 b0           LDA Basic_Statement_Table+1,Y
b79a 48                 PHA
b79b b9 00 b0           LDA Basic_Statement_Table,Y
b79e 48                 PHA
b79f 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
b7a2 4c 30 b9 Inpr_30   JMP Basic_LET       ; start with variable name
b7a5 c9 3a    Inpr_40   CMP #':'
b7a7 f0 d0              BEQ Start_Program
b7a9 4c 00 bf Inpr_50   JMP Syntax_Error

              ; ****************
b7ac            Basic_GO ; $b7ac
              ; ****************

b7ac 20 76 00           JSR CHRGOT          ; execute GO TO command
b7af a9 a4              LDA #$a4            ; TO token
b7b1 20 f7 be           JSR Need_A
b7b4 4c 30 b8           JMP Basic_GOTO

              ; *********************
b7b7            Basic_RESTORE ; $b7b7
              ; *********************

b7b7 38                 SEC                 ; DATPTR = TXTTAB - 1
b7b8 a5 28              LDA TXTTAB
b7ba e9 01              SBC #1
b7bc a4 29              LDY TXTTAB+1
b7be b0 01              BCS REST_10
b7c0 88                 DEY
b7c1 85 3e    REST_10   STA DATPTR
b7c3 84 3f              STY DATPTR+1
b7c5 60       REST_Ret  RTS ;Size   15 [Basic_RESTORE]

              ; ******************
b7c6            Basic_STOP ; $b7c6
              ; ******************

b7c6 b0 01              BCS END_10          ; C=1 : BREAK

              ; ****************
b7c8            Basic_END ; b7c8
              ; ****************

b7c8 18                 CLC                 ; C=0 : READY
b7c9 d0 3c    END_10    BNE CONT_Ret
b7cb a5 77              LDA TXTPTR
b7cd a4 78              LDY TXTPTR+1
b7cf a6 37              LDX CURLIN+1
b7d1 e8                 INX                 ; CURLIN+1 = $ff : undefined
b7d2 f0 0c              BEQ END_30
b7d4 85 3a              STA OLDTXT
b7d6 84 3b              STY OLDTXT+1
b7d8 a5 36    END_20    LDA CURLIN
b7da a4 37              LDY CURLIN+1
b7dc 85 38              STA OLDLIN
b7de 84 39              STY OLDLIN+1
b7e0 68       END_30    PLA
b7e1 68                 PLA
b7e2 a9 1b    END_40    LDA #<Msg_BREAK     ; $b31b
b7e4 a0 b3              LDY #>Msg_BREAK
b7e6 90 03              BCC END_50
b7e8 4c f1 b3           JMP Berr_40
b7eb 4c ff b3 END_50    JMP Basic_Ready

              ; ******************
b7ee            Basic_CONT ; $b7ee
              ; ******************

b7ee d0 17              BNE CONT_Ret
b7f0 a2 db              LDX #$db
b7f2 a4 3b              LDY OLDTXT+1
b7f4 d0 03              BNE CONT_10
b7f6 4c cf b3           JMP Basic_Error
b7f9 a5 3a    CONT_10   LDA OLDTXT
b7fb 85 77              STA TXTPTR
b7fd 84 78              STY TXTPTR+1
b7ff a5 38              LDA OLDLIN
b801 a4 39              LDY OLDLIN+1
b803 85 36              STA CURLIN
b805 84 37              STY CURLIN+1
b807 60       CONT_Ret  RTS ;Size   26 [Basic_CONT]

              ; *****************
b808            Basic_RUN ; $b808
              ; *****************

b808 d0 03              BNE RUN_20          ; branch onheck_Stack_Avail
b80a 4c e9 b5 RUN_10    JMP Reset_BASIC_Execution
b80d 20 f0 b5 RUN_20    JSR Reset_Variable_Pointer
b810 4c 25 b8           JMP GOSUB_10

              ; *******************
b813            Basic_GOSUB ; $b813
              ; *******************

b813 20 93 b3           JSR Check_Stack_Avail
b816 a5 78              LDA TXTPTR+1
b818 48                 PHA
b819 a5 77              LDA TXTPTR
b81b 48                 PHA
b81c a5 37              LDA CURLIN+1
b81e 48                 PHA
b81f a5 36              LDA CURLIN
b821 48                 PHA
b822 a9 8d              LDA #$8d            ; GOSUB token marker
b824 48                 PHA
b825 20 76 00 GOSUB_10  JSR CHRGOT
b828 20 30 b8           JSR Basic_GOTO
b82b 4c 4a b7           JMP Execute

b82e 00 00              .FILL $b830-* (0) ; 2 bytes

              ; ******************
b830            Basic_GOTO ; $b830
              ; ******************

b830 20 f6 b8           JSR Scan_Linenumber ; read LINNUM
b833 20 94 b8           JSR Skip_To_EOL     ; skip to end of line
b836 a5 37              LDA CURLIN+1
b838 c5 12              CMP LINNUM+1        ; CURLIN >= LINNUM ?
b83a b0 0b              BCS GOTO_10         ; search from start
b83c 98                 TYA                 ; EOL index
b83d 38                 SEC
b83e 65 77              ADC TXTPTR          ; (A/X) = TXTPTR + length + 1 (carry)
b840 a6 78              LDX TXTPTR+1
b842 90 07              BCC GOTO_20
b844 e8                 INX
b845 b0 04              BCS GOTO_20         ; start search from current link
b847 a5 28    GOTO_10   LDA TXTTAB
b849 a6 29              LDX TXTTAB+1
b84b 20 aa b5 GOTO_20   JSR Find_BASIC_Line_AX
b84e 90 1e              BCC RET_10          ; undefined statement
b850 a5 5c              LDA TMPPTC
b852 e9 01              SBC #1
b854 85 77              STA TXTPTR          ; TXTPTR = TMPPTC - 1
b856 a5 5d              LDA TMPPTC+1
b858 e9 00              SBC #0
b85a 85 78              STA TXTPTR+1
b85c 60       GOTO_Ret  RTS ;Size   45 [Basic_GOTO]

              ; ********************
b85d            Basic_RETURN ; $b85d
              ; ********************

b85d d0 fd              BNE GOTO_Ret        ; no raguments allowed
b85f a9 ff              LDA #$ff
b861 85 47              STA FORPNT+1        ; invalidate FORPNT
b863 20 22 b3           JSR Find_Active_FOR ; remove open loops
b866 9a                 TXS
b867 c9 8d              CMP #$8d            ; GOSUB token marker ?
b869 f0 0b              BEQ RET_30           ; yes -> perform return
b86b a2 16              LDX #[Msg_GOSUB - Msg_Start] ; $16
b86d 2c                 .BYTE $2c           ; skip next instruction
b86e a2 5a    RET_10    LDX #[Msg_UNDEF - Msg_Start] ; $5a
b870 4c cf b3           JMP Basic_Error
b873 4c 00 bf RET_20    JMP Syntax_Error
b876 68       RET_30    PLA                 ; marker
b877 68                 PLA
b878 85 36              STA CURLIN
b87a 68                 PLA
b87b 85 37              STA CURLIN+1
b87d 68                 PLA
b87e 85 77              STA TXTPTR
b880 68                 PLA
b881 85 78              STA TXTPTR+1

              ; ******************
b883            Basic_DATA ; $b883
              ; ******************

b883 20 91 b8           JSR Skip_To_EOS

              ; **********************************
b886            Add_Y_To_Execution_Pointer ; $b886
              ; **********************************

b886 98                 TYA
b887 18                 CLC
b888 65 77              ADC TXTPTR
b88a 85 77              STA TXTPTR
b88c 90 02              BCC AYEP_Ret
b88e e6 78              INC TXTPTR+1
b890 60       AYEP_Ret  RTS ;Size   11 [Add_Y_To_Execution_Pointer]

              ; *******************
b891            Skip_To_EOS ; $b891
              ; *******************

b891 a2 3a              LDX #':'            ; scan for ':' or zero
b893 2c                 .BYTE $2c

              ; *******************
b894            Skip_To_EOL ; $b894
              ; *******************

b894 a2 00              LDX #0
b896 86 03              STX CHARAC
b898 a0 00              LDY #0
b89a 84 04              STY ENDCHR
b89c a5 04    NeSt_10   LDA ENDCHR
b89e a6 03              LDX CHARAC
b8a0 85 03              STA CHARAC
b8a2 86 04              STX ENDCHR
b8a4 b1 77    NeSt_20   LDA (TXTPTR),Y
b8a6 f0 e8              BEQ AYEP_Ret
b8a8 c5 04              CMP ENDCHR
b8aa f0 e4              BEQ AYEP_Ret
b8ac c8                 INY
b8ad c9 22              CMP #QUOTE
b8af d0 f3              BNE NeSt_20
b8b1 f0 e9              BEQ NeSt_10

              ; ****************
b8b3            Basic_IF ; $b8b3
              ; ****************

b8b3 20 98 bd           JSR Eval_Expression
b8b6 20 76 00           JSR CHRGOT
b8b9 c9 89              CMP #$89            ; GOTO token
b8bb f0 05              BEQ IF_10
b8bd a9 a7              LDA #$a7            ; THEN token
b8bf 20 f7 be           JSR Need_A
b8c2 a5 5e    IF_10     LDA FAC1EX          ; IF clause != 0 (true) or 0 (false)
b8c4 d0 05              BNE REM_10          ; branch if true

              ; *****************
b8c6            Basic_REM ; $b8c6
              ; *****************

b8c6 20 94 b8           JSR Skip_To_EOL
b8c9 f0 bb              BEQ Add_Y_To_Execution_Pointer
b8cb 20 76 00 REM_10    JSR CHRGOT
b8ce b0 03              BCS REM_20
b8d0 4c 30 b8           JMP Basic_GOTO
b8d3 4c 85 b7 REM_20    JMP Interpret

              ; ********
b8d6            Basic_ON
              ; ********

b8d6 20 d4 c8           JSR Get_Byte_Value
b8d9 48                 PHA
b8da c9 8d              CMP #$8d            ; GOSUB token
b8dc f0 04              BEQ ON_20
b8de c9 89    ON_10     CMP #$89            ; GOTO token
b8e0 d0 91              BNE RET_20          ; -> syntax error
b8e2 c6 62    ON_20     DEC FAC1M4          ; ON - counter
b8e4 d0 04              BNE ON_30
b8e6 68                 PLA
b8e7 4c 87 b7           JMP Inpr_10
b8ea 20 70 00 ON_30     JSR CHRGET
b8ed 20 f6 b8           JSR Scan_Linenumber
b8f0 c9 2c              CMP #','
b8f2 f0 ee              BEQ ON_20
b8f4 68                 PLA
b8f5 60                 RTS ;Size   32 [Basic_ON]

              ; ***************
b8f6            Scan_Linenumber
              ; ***************

              ; Input:  A = 1st. character
              ; Output: LINNUM decoded (0-63999) valid range
              ;         LINNUM = 0 if (A) is not numeric (C=1)

b8f6 a2 00              LDX #0
b8f8 86 11              STX LINNUM
b8fa 86 12              STX LINNUM+1
b8fc b0 0e              BCS ScLi_Ret        ; return if (A) is not numeric
b8fe a6 12    ScLi_10   LDX LINNUM+1
b900 e0 19              CPX #25             ; $fa00 after multiplication
b902 b0 da              BCS ON_10           ; value >= 64000 -> Syntax Error
b904 20 0d b9           JSR Dec_Char
b907 20 70 00           JSR CHRGET
b90a 90 f2              BCC ScLi_10         ; next char if numeric
b90c 60       ScLi_Ret  RTS ;Size   23 [Scan_Linenumber]

              ; ********
b90d            Dec_Char
              ; ********

              ; Input:  LINNUM = 16 bit unsigned integer
              ;         A      = new value to add
              ;         X      = LINNUM+1
              ; Output: LINNUM = LINNUM * 10 + (A)

              ; check on integer overflow is done on calling routine

b90d 29 0f              AND #15             ; char -> bin
b90f 48                 PHA                 ; save value to add
b910 a5 11              LDA LINNUM
b912 0a                 ASL A               ; * 2
b913 26 12              ROL LINNUM+1
b915 0a                 ASL A               ; * 4
b916 26 12              ROL LINNUM+1
b918 65 11              ADC LINNUM          ; * 5
b91a 85 11              STA LINNUM
b91c 8a                 TXA                 ; old high byte of LINNUM
b91d 65 12              ADC LINNUM+1
b91f 85 12              STA LINNUM+1
b921 06 11              ASL LINNUM          ; * 10
b923 26 12              ROL LINNUM+1
b925 68                 PLA                 ; value to add
b926 65 11              ADC LINNUM
b928 85 11              STA LINNUM
b92a 90 02              BCC LIM_10
b92c e6 12              INC LINNUM+1
b92e 60       LIM_10    RTS ;Size   34 [Dec_Char]

b92f 00                 .FILL $b930-* (0) ; 1 bytes

              ; *****************
b930            Basic_LET ; $b930
              ; *****************

b930 20 2b c1           JSR Parse_Name
b933 85 46              STA FORPNT
b935 84 47              STY FORPNT+1
b937 a9 b2              LDA #$b2            ; '=' token
b939 20 f7 be           JSR Need_A
b93c a5 08              LDA INTFLG          ; save attributes
b93e 48                 PHA                 ; of variable
b93f a5 07              LDA VALTYP
b941 48                 PHA
b942 20 98 bd           JSR Eval_Expression ; FAC1 = value or pointer
b945 68                 PLA                 ; VALTYP
b946 2a                 ROL A               ; C=1 : string   C=0 : numeric
b947 20 8a bd           JSR Check_Var_Type
b94a d0 18              BNE LET_20          ; branch for string
b94c 68                 PLA                 ; INTFLG

              ; ***********************
b94d            Assign_Numeric_variable
              ; ***********************

b94d 10 12              BPL LET_10          ; branch for real
b94f 20 51 cd           JSR Round_FAC1
b952 20 ea c2           JSR Real_To_Integer
b955 a0 00              LDY #0
b957 a5 61              LDA FAC1M3
b959 91 46              STA (FORPNT),Y      ; integer high byte
b95b c8                 INY
b95c a5 62              LDA FAC1M4
b95e 91 46              STA (FORPNT),Y      ; integer low  byte
b960 60                 RTS ;Size   20 [Assign_Numeric_variable]
b961 4c 06 cd LET_10    JMP FAC1_To_FORPNT

b964 68       LET_20    PLA                 ; INTFLG

              ; ******************************
b965            Assign_String_Variable ; $b965
              ; ******************************

b965 a4 47              LDY FORPNT+1
b967 c0 d0              CPY #>[Float_0_5 + 2]; void string descriptor for TI$
b969 d0 4f              BNE Assign_Normal_String
b96b 20 b8 c7           JSR Free_String_FAC1
b96e c9 06              CMP #6              ; setting TI$ requires 6 digits
b970 d0 40              BNE ATSD_10
b972 a0 00              LDY #0              ; FAC1 = 0.0
b974 84 5e              STY FAC1EX
b976 84 63              STY FAC1SI
b978 84 6e    CLOCK_10  STY TMPPTD
b97a 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b97d 20 18 cc           JSR Multiply_FAC1_BY_10
b980 e6 6e              INC TMPPTD
b982 a4 6e              LDY TMPPTD
b984 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b987 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
b98a aa                 TAX                 ; number is zero ?
b98b f0 05              BEQ CLOCK_20
b98d e8                 INX
b98e 8a                 TXA                 ; FAC2 *= 2
b98f 20 23 cc           JSR Add_And_Double  ; FAC1 = (FAC1 + FAC2) * 2
b992 a4 6e    CLOCK_20  LDY TMPPTD
b994 c8                 INY
b995 c0 06              CPY #6
b997 d0 df              BNE CLOCK_10
b999 20 18 cc           JSR Multiply_FAC1_BY_10
b99c 20 d1 cd           JSR FAC1_LSR
b99f a2 02              LDX #2
b9a1 78                 SEI                 ; set jiffy clock
b9a2 b5 60    CLOCK_30  LDA FAC1M2,X
b9a4 95 8d              STA JIFFY_CLOCK,X
b9a6 ca                 DEX
b9a7 10 f9              BPL CLOCK_30
b9a9 58                 CLI
b9aa 60                 RTS ;Size   70 [Assign_String_Variable]

              ; ***************************
b9ab            Add_TI_String_Digit_To_FAC1
              ; ***************************

b9ab b1 1f              LDA (INDEXA),Y
b9ad 20 7d 00           JSR ISNUM
b9b0 90 03              BCC ATSD_20
b9b2 4c 73 c3 ATSD_10   JMP Jump_To_Illegal_Quantity
b9b5 e9 2f    ATSD_20   SBC #$2f            ; '0'-1
b9b7 4c b4 ce           JMP Add_A_To_FAC1

              ; ****************************
b9ba            Assign_Normal_String ; $b9ba
              ; ****************************

              ; 100 a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to static string in code
              ;     STRPTR = $0409
              ;     -> ANS_60 branch

              ; a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to dynamic string
              ;     STRPTR = $7ffa
              ;     -> ANS_60 branch

              ; a$ = ds$ (disk status)
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 12, pointer to dynamic string
              ;     STRPTR = $7fd6
              ;     -> ANS_50 branch

b9ba a0 01              LDY #1
b9bc b1 61              LDA (FAC1M3),Y
b9be 85 6c              STA STRPTR          ; STRPTR = string pointer
b9c0 c8                 INY
b9c1 b1 61              LDA (FAC1M3),Y
b9c3 85 6d              STA STRPTR+1        ; STRPTR = DS$ (Disk Status) ?
b9c5 c9 04              CMP #4
b9c7 90 23              BCC ANS_50          ; string is in system area (DS$)

b9c9 a5 6d    ANS_10    LDA STRPTR+1        ; STRPTR < FRETOP ?
b9cb c5 31    ANS_20    CMP FRETOP+1
b9cd 90 16              BCC ANS_40          ; branch if static
b9cf d0 06              BNE ANS_30          ; branch if higher
b9d1 a5 6c              LDA STRPTR
b9d3 c5 30              CMP FRETOP
b9d5 90 0e              BCC ANS_40          ; branch if static
b9d7 a4 62    ANS_30    LDY FAC1M4
b9d9 c4 2b              CPY VARTAB+1
b9db 90 08              BCC ANS_40          ; branch if not variable
b9dd d0 0d              BNE ANS_50
b9df a5 61              LDA FAC1M3
b9e1 c5 2a              CMP VARTAB
b9e3 b0 07              BCS ANS_50
b9e5 a5 61    ANS_40    LDA FAC1M3          ; static string
b9e7 a4 62              LDY FAC1M4
b9e9 4c 05 ba           JMP ANS_60

              ; assign string from string variable

b9ec a0 00    ANS_50    LDY #0              ; allocate & copy string
b9ee b1 61              LDA (FAC1M3),Y      ; length
b9f0 20 a6 c5           JSR Allocate_String_A
b9f3 a6 6c              LDX STRPTR
b9f5 a4 6d              LDY STRPTR+1
b9f7 20 9a c7           JSR Store_String_XY
b9fa a5 61              LDA FAC1M3
b9fc a4 62              LDY FAC1M4
b9fe 20 11 c8           JSR Pop_Descriptor_Stack
ba01 a9 5e              LDA #<FAC1EX        ; allocated descriptor
ba03 a0 00              LDY #>FAC1EX

              ; assign static string and create back reference

ba05 85 4d    ANS_60    STA DESCPT
ba07 84 4e              STY DESCPT+1
ba09 85 1f              STA INDEXA
ba0b 84 20              STY INDEXA+1
ba0d 20 11 c8           JSR Pop_Descriptor_Stack
ba10 20 3d ba           JSR Back_Reference_Position   ; from INDEXA
ba13 90 09              BCC ANS_70          ; -> no back reference
ba15 a5 47              LDA FORPNT+1
ba17 91 4f              STA (INDEXC),Y      ; Y = 1
ba19 88                 DEY
ba1a a5 46              LDA FORPNT          ; store back reference
ba1c 91 4f              STA (INDEXC),Y      ; for garbage collection

              ; invalidate old string

ba1e a5 46    ANS_70    LDA FORPNT
ba20 85 1f              STA INDEXA
ba22 a5 47              LDA FORPNT+1
ba24 85 20              STA INDEXA+1
ba26 20 3d ba           JSR Back_Reference_Position
ba29 90 08              BCC ANS_80
ba2b a9 ff              LDA #$ff            ; mark old string as obsolete
ba2d 91 4f              STA (INDEXC),Y      ; Y = 1
ba2f 88                 DEY                 ; Y = 0
ba30 8a                 TXA                 ; length
ba31 91 4f              STA (INDEXC),Y

              ; copy new value to variable

ba33 a0 02    ANS_80    LDY #2
ba35 b1 4d    ANS_90    LDA (DESCPT),Y
ba37 91 46              STA (FORPNT),Y
ba39 88                 DEY
ba3a 10 f9              BPL ANS_90
ba3c 60                 RTS ;Size  131 [Assign_Normal_String]

              ; ***********************
ba3d            Back_Reference_Position
              ; ***********************

              ; Input:  INDEXA = pointer to string descriptor
              ; Output: INDEXA = points to start of string
              ;         INDEXC = points to the end of string + 1
              ;         X = length of string
              ;         Y = 1
              ;         C = 1 : INDEXA and INDEXC set
              ;         C = 0 : nothing changed

ba3d a0 00              LDY #0
ba3f b1 1f              LDA (INDEXA),Y      ; A = length
ba41 48                 PHA                 ; push length
ba42 f0 28              BEQ BRP_no
ba44 c8                 INY
ba45 b1 1f              LDA (INDEXA),Y
ba47 aa                 TAX                 ; X = pointer low
ba48 c8                 INY
ba49 b1 1f              LDA (INDEXA),Y      ; A = pointer high
ba4b 30 1f              BMI BRP_no          ; return if not in lower RAM
ba4d c5 31              CMP FRETOP+1
ba4f 90 1b              BCC BRP_no          ; return if not dynamic string
ba51 d0 04              BNE BRP_10
ba53 e4 30              CPX FRETOP
ba55 90 15              BCC BRP_no          ; return if not dynamic string
ba57 86 1f    BRP_10    STX INDEXA          ; INDEXA = string pointer
ba59 85 20              STA INDEXA+1
ba5b 68                 PLA                 ; length
ba5c aa                 TAX                 ; return length in X
ba5d 18                 CLC
ba5e 65 1f              ADC INDEXA
ba60 85 4f              STA INDEXC
ba62 a5 20              LDA INDEXA+1
ba64 69 00              ADC #0
ba66 85 50              STA INDEXC+1        ; INDEXC = INDEXA + length
ba68 a0 01              LDY #1              ; expected by callers
ba6a 38                 SEC
ba6b 60                 RTS ;Size   47 [Back_Reference_Position]
ba6c 68       BRP_no    PLA
ba6d 18                 CLC
ba6e 60                 RTS ;Size   50 [Back_Reference_Position]

              ; This subroutines converts a real value to a 16 bit integer.
              ; There is no sign or range check in this routine. So it may
              ; be used for signed integers (-32768 to 32767) or unsigned
              ; integers (0 to 65535).

              ; ********
ba6f            FAC1_INT
              ; ********

ba6f 20 d1 cd           JSR FAC1_LSR
ba72 24 63              BIT FAC1SI
ba74 10 0b              BPL FACI_Ret
ba76 38                 SEC
ba77 98                 TYA
ba78 e5 62              SBC FAC1M4
ba7a 85 62              STA FAC1M4
ba7c 98                 TYA
ba7d e5 61              SBC FAC1M3
ba7f 85 61              STA FAC1M3
ba81 60       FACI_Ret  RTS ;Size   19 [FAC1_INT]

ba82 00 00 00           .FILL $ba88-* (0) ; 6 bytes

              ; ********************
ba88            Basic_PRINTN ; $ba88
              ; ********************

ba88 20 8e ba           JSR Basic_CMD
ba8b 4c b2 bb           JMP Set_Default_Channels

              ; *********
ba8e            Basic_CMD
              ; *********

ba8e 20 d4 c8           JSR Get_Byte_Value  ; X = value
ba91 f0 05              BEQ CMD_10          ; -> no more parameter
ba93 a9 2c              LDA #','
ba95 20 f7 be           JSR Need_A
ba98 08       CMD_10    PHP
ba99 20 c9 ff           JSR CHKOUT          ; set channel
ba9c 86 10              STX IOPMPT          ; mark output redirected
ba9e 28                 PLP
ba9f 4c a8 ba           JMP Basic_PRINT     ; do the printing


baa2 20 20 bb PRINT_10  JSR Print_String_From_Descriptor
baa5 20 76 00 PRINT_20  JSR CHRGOT

              ; ***********
baa8            Basic_PRINT
              ; ***********

baa8 f0 35              BEQ Print_CR
baaa f0 38    PRINT_30  BEQ PRINT_Ret
baac c9 a3              CMP #$a3            ; TAB(   token
baae f0 4d              BEQ Tab_Spc
bab0 c9 a6              CMP #$a6            ; SPC(   token
bab2 18                 CLC
bab3 f0 48              BEQ Tab_Spc
bab5 c9 2c              CMP #','
bab7 f0 37              BEQ Comma_Tab
bab9 c9 3b              CMP #';'
babb f0 5a              BEQ TaSp_50
babd 20 98 bd           JSR Eval_Expression
bac0 24 07              BIT VALTYP
bac2 30 de              BMI PRINT_10
bac4 20 93 cf           JSR Format_FAC1
bac7 20 b0 c5           JSR Create_String_Descriptor
baca 20 20 bb           JSR Print_String_From_Descriptor
bacd 20 3a bb           JSR Cursor_Right_Or_Space
bad0 d0 d3              BNE PRINT_20           ; always

              ; *************
bad2            Terminate_BUF
              ; *************

bad2 a9 00              LDA #0
bad4 9d 00 02           STA BUF,X
bad7 a2 ff              LDX #<[BUF-1]
bad9 a0 01              LDY #>[BUF-1]
badb a5 10              LDA IOPMPT
badd d0 05              BNE PRINT_Ret

              ; ****************
badf            Print_CR ; $badf
              ; ****************

badf a9 0d              LDA #CR
bae1 4c d2 ff           JMP CHROUT
bae4 60       PRINT_Ret RTS ;Size    6 [Print_CR]

bae5 00 00 00           .FILL $baf0-* (0) ; 11 bytes

              ; *****************
baf0            Comma_Tab ; $baf0
              ; *****************

baf0 a5 c6              LDA CursorCol
baf2 38                 SEC
baf3 e9 0a    CoTa_10   SBC #10
baf5 b0 fc              BCS CoTa_10
baf7 49 ff              EOR #$ff
baf9 69 01              ADC #1
bafb d0 10              BNE TaSp_10           ; always

              ; *******
bafd            Tab_Spc
              ; *******

bafd 08                 PHP                 ; C=1 TAB, C=0 SPC
bafe 20 d1 c8           JSR Get_Next_Byte_Value
bb01 c9 29              CMP #')'
bb03 d0 59              BNE SynErr
bb05 28                 PLP
bb06 90 06              BCC TaSp_20         ; SPC -> use X
bb08 8a                 TXA
bb09 e5 c6              SBC CursorCol       ; TAB -> use X - Col
bb0b 90 0a              BCC TaSp_50         ; branch if TAB < Col
bb0d aa       TaSp_10   TAX
bb0e e8       TaSp_20   INX
bb0f d0 03              BNE TaSp_40         ; always
bb11 20 3a bb TaSp_30   JSR Cursor_Right_Or_Space
bb14 ca       TaSp_40   DEX
bb15 d0 fa              BNE TaSp_30
bb17 20 70 00 TaSp_50   JSR CHRGET
bb1a 4c aa ba           JMP PRINT_30

              ; ********************
bb1d            Print_String ; $bb1d
              ; ********************

bb1d 20 b0 c5           JSR Create_String_Descriptor

              ; ************************************
bb20            Print_String_From_Descriptor ; $bb20
              ; ************************************

bb20 20 b8 c7           JSR Free_String_FAC1
bb23 aa                 TAX
bb24 f0 0b              BEQ PSFD_Ret        ; zero length ?
bb26 a0 00              LDY #0
bb28 b1 1f    PSFD_10   LDA (INDEXA),Y
bb2a 20 d2 ff           JSR CHROUT
bb2d c8                 INY
bb2e ca                 DEX
bb2f d0 f7              BNE PSFD_10
bb31 60       PSFD_Ret  RTS ;Size   18 [Print_String_From_Descriptor]

bb32 00 00 00           .FILL $bb3a-* (0) ; 8 bytes

              ; *****************************
bb3a            Cursor_Right_Or_Space ; $bb3a
              ; *****************************

bb3a a5 10              LDA IOPMPT
bb3c f0 03              BEQ CROS_10
bb3e a9 20              LDA #' '
bb40 2c                 .BYTE $2c
bb41 a9 1d    CROS_10   LDA #RIGHT
bb43 2c                 .BYTE $2c

              ; *******************
bb44            Print_Question_Mark
              ; *******************

bb44 a9 3f              LDA #'?'

              ; **********
bb46            Print_Char
              ; **********

bb46 4c d2 ff           JMP CHROUT

bb49 00 00 00           .FILL $bb4c-* (0) ; 3 bytes

              ; *****************
bb4c            Bad_Input ; $bb4c
              ; *****************

bb4c a5 0b              LDA INPFLG
bb4e f0 11              BEQ BaIn_30
bb50 30 04              BMI BaIn_10
bb52 a0 ff              LDY #$ff            ; invalidate CURLIN
bb54 d0 04              BNE BaIn_20
bb56 a5 3c    BaIn_10   LDA DATLIN
bb58 a4 3d              LDY DATLIN+1
bb5a 85 36    BaIn_20   STA CURLIN
bb5c 84 37              STY CURLIN+1
bb5e 4c 00 bf SynErr    JMP Syntax_Error
bb61 a5 10    BaIn_30   LDA IOPMPT
bb63 f0 05              BEQ BaIn_40
bb65 a2 bf              LDX #[Msg_DATA - Msg_Start] ; $bf
bb67 4c cf b3           JMP Basic_Error
bb6a a9 07    BaIn_40   LDA #<Msg_Redo_From_Start
bb6c a0 bd              LDY #>Msg_Redo_From_Start
bb6e 20 1d bb           JSR Print_String
bb71 a5 3a              LDA OLDTXT
bb73 a4 3b              LDY OLDTXT+1
bb75 85 77              STA TXTPTR
bb77 84 78              STY TXTPTR+1
bb79 60                 RTS ;Size   46 [Bad_Input]

              ; *****************
bb7a            Basic_GET ; $bb7a
              ; *****************

bb7a 20 cf c4           JSR Assert_Non_Direct
bb7d c9 23              CMP #'#'
bb7f d0 0e              BNE GET_10
bb81 20 70 00           JSR CHRGET
bb84 20 d4 c8           JSR Get_Byte_Value  ; channel #
bb87 20 f5 be           JSR Need_Comma
bb8a 20 c6 ff           JSR CHKIN
bb8d 86 10              STX IOPMPT
bb8f a2 01    GET_10    LDX #<[BUF+1]
bb91 a0 02              LDY #>[BUF+1]
bb93 a9 00              LDA #0
bb95 8d 01 02           STA BUF+1
bb98 a9 40              LDA #$40            ; no prompt
bb9a 20 0b bc           JSR Read_Get
bb9d a6 10              LDX IOPMPT
bb9f d0 13              BNE SDC_10
bba1 60                 RTS ;Size   40 [Basic_GET]

bba2 00 00              .FILL $bba4-* (0) ; 2 bytes

              ; ********************
bba4            Basic_INPUTN ; $bba4
              ; ********************

bba4 20 d4 c8           JSR Get_Byte_Value
bba7 20 f5 be           JSR Need_Comma
bbaa 20 c6 ff           JSR CHKIN
bbad 86 10              STX IOPMPT
bbaf 20 cd bb           JSR Input_String

              ; ********************
bbb2            Set_Default_Channels
              ; ********************

bbb2 a5 10              LDA IOPMPT
bbb4 20 cc ff SDC_10    JSR CLRCHN
bbb7 a2 00              LDX #0
bbb9 86 10              STX IOPMPT
bbbb 60                 RTS ;Size   10 [Set_Default_Channels]

bbbc 00 00              .FILL $bbbe-* (0) ; 2 bytes

              ; *******************
bbbe            Basic_INPUT ; $bbbe
              ; *******************

bbbe c9 22              CMP #QUOTE
bbc0 d0 0b              BNE Input_String
bbc2 20 b5 be           JSR Make_String_Descriptor_From_Code
bbc5 a9 3b              LDA #';'
bbc7 20 f7 be           JSR Need_A          ; prompt delimiter
bbca 20 20 bb           JSR Print_String_From_Descriptor

              ; ************
bbcd            Input_String
              ; ************

bbcd 20 cf c4           JSR Assert_Non_Direct
bbd0 a9 2c              LDA #','
bbd2 8d ff 01           STA BUF-1
bbd5 20 f5 bb InSt_10   JSR Prompt_And_Input
bbd8 a5 10              LDA IOPMPT
bbda f0 0c              BEQ InSt_20
bbdc a5 96              LDA STATUS
bbde 29 03              AND #3              ; check time out bits
bbe0 f0 06              BEQ InSt_20
bbe2 20 b2 bb           JSR Set_Default_Channels
bbe5 4c 83 b8           JMP Basic_DATA
bbe8 ad 00 02 InSt_20   LDA BUF
bbeb d0 1c              BNE READ_10
bbed 4c 19 bf           JMP Input_String_Patch
bbf0 18       InSt_30   CLC
bbf1 4c d8 b7           JMP END_20

bbf4 00                 .FILL $bbf5-* (0) ; 1 bytes

              ; ************************
bbf5            Prompt_And_Input ; $bbf5
              ; ************************

bbf5 a5 10              LDA IOPMPT
bbf7 d0 06              BNE PAI_10
bbf9 20 44 bb           JSR Print_Question_Mark
bbfc 20 3a bb           JSR Cursor_Right_Or_Space
bbff 4c e2 b4 PAI_10    JMP Read_String

              ; ******************
bc02            Basic_READ ; $bc02
              ; ******************

bc02 a6 3e              LDX DATPTR
bc04 a4 3f              LDY DATPTR+1
bc06 a9 98              LDA #$98            ; flag for READ
bc08 2c                 .BYTE $2c
bc09 a9 00    READ_10    LDA #0

              ; ********
bc0b            Read_Get
              ; ********

bc0b 85 0b              STA INPFLG
bc0d 86 40              STX INPPTR
bc0f 84 41              STY INPPTR+1

              ; loop reading variables

bc11 20 2b c1 READ_15   JSR Parse_Name      ; address of variable
bc14 85 46              STA FORPNT
bc16 84 47              STY FORPNT+1        ; FORPNT = variable pointer
bc18 a5 77              LDA TXTPTR
bc1a a4 78              LDY TXTPTR+1        ; save TXTPTR
bc1c 85 48              STA YSAVE
bc1e 84 49              STY YSAVE+1
bc20 a6 40              LDX INPPTR          ; TXTPTR = INPPTR
bc22 a4 41              LDY INPPTR+1
bc24 86 77              STX TXTPTR
bc26 84 78              STY TXTPTR+1
bc28 20 76 00           JSR CHRGOT
bc2b d0 20              BNE READ_35
bc2d 24 0b              BIT INPFLG
bc2f 50 0c              BVC READ_20         ; bit 6 set: GETIN
bc31 20 e4 ff           JSR GETIN
bc34 8d 00 02           STA BUF
bc37 a2 ff              LDX #<[BUF-1]
bc39 a0 01              LDY #>[BUF-1]
bc3b d0 0c              BNE READ_30         ; always

bc3d 30 75    READ_20   BMI READ_75         ; bit 7 set: READ
bc3f a5 10              LDA IOPMPT          ; else: INPUT
bc41 d0 03              BNE READ_25
bc43 20 44 bb           JSR Print_Question_Mark
bc46 20 f5 bb READ_25   JSR Prompt_And_Input
bc49 86 77    READ_30   STX TXTPTR
bc4b 84 78              STY TXTPTR+1

              ; loop reading character

bc4d 20 70 00 READ_35   JSR CHRGET
bc50 24 07              BIT VALTYP
bc52 10 31              BPL READ_60         ; -> numeric
bc54 24 0b              BIT INPFLG
bc56 50 09              BVC READ_40         ; -> not GET
bc58 e8                 INX
bc59 86 77              STX TXTPTR          ; GET A$
bc5b a9 00              LDA #0
bc5d 85 03              STA CHARAC
bc5f f0 0c              BEQ READ_45         ; always

              ; input or read string

bc61 85 03    READ_40   STA CHARAC
bc63 c9 22              CMP #QUOTE
bc65 f0 07              BEQ READ_50
bc67 a9 3a              LDA #':'
bc69 85 03              STA CHARAC
bc6b a9 2c              LDA #','
bc6d 18       READ_45   CLC
bc6e 85 04    READ_50   STA ENDCHR
bc70 a5 77              LDA TXTPTR
bc72 a4 78              LDY TXTPTR+1
bc74 69 00              ADC #0
bc76 90 01              BCC READ_55
bc78 c8                 INY
bc79 20 b6 c5 READ_55   JSR Create_String_Descriptor_AY
bc7c 20 18 c9           JSR Restore_Execution_Pointer
bc7f 20 65 b9           JSR Assign_String_Variable
bc82 4c 8d bc           JMP READ_65

              ; input or read number

bc85 20 29 ce READ_60   JSR Read_Real_To_FAC1
bc88 a5 08              LDA INTFLG
bc8a 20 4d b9           JSR Assign_Numeric_variable

              ; more to read ?

bc8d 20 76 00 READ_65   JSR CHRGOT
bc90 f0 07              BEQ READ_70         ; -> nothing left
bc92 c9 2c              CMP #','
bc94 f0 03              BEQ READ_70         ; comma or error
bc96 4c 4c bb           JMP Bad_Input

bc99 a5 77    READ_70   LDA TXTPTR
bc9b a4 78              LDY TXTPTR+1
bc9d 85 40              STA INPPTR          ; advance input pointer
bc9f 84 41              STY INPPTR+1
bca1 a5 48              LDA YSAVE
bca3 a4 49              LDY YSAVE+1
bca5 85 77              STA TXTPTR          ; restore text pointer
bca7 84 78              STY TXTPTR+1
bca9 20 76 00           JSR CHRGOT
bcac f0 2c              BEQ READ_85         ; -> goto loop end
bcae 20 f5 be           JSR Need_Comma
bcb1 4c 11 bc           JMP READ_15         ; -> next item

              ; READ from DATA statements

bcb4 20 91 b8 READ_75   JSR Skip_To_EOS
bcb7 c8                 INY
bcb8 aa                 TAX
bcb9 d0 12              BNE READ_80
bcbb a2 2a              LDX #$2a
bcbd c8                 INY
bcbe b1 77              LDA (TXTPTR),Y
bcc0 f0 6b              BEQ NEXT_30
bcc2 c8                 INY
bcc3 b1 77              LDA (TXTPTR),Y
bcc5 85 3c              STA DATLIN
bcc7 c8                 INY
bcc8 b1 77              LDA (TXTPTR),Y
bcca c8                 INY
bccb 85 3d              STA DATLIN+1
bccd b1 77    READ_80   LDA (TXTPTR),Y
bccf aa                 TAX
bcd0 20 86 b8           JSR Add_Y_To_Execution_Pointer
bcd3 e0 83              CPX #$83            ; DATA token
bcd5 d0 dd              BNE READ_75
bcd7 4c 4d bc           JMP READ_35
              ;

bcda a5 40    READ_85   LDA INPPTR
bcdc a4 41              LDY INPPTR+1
bcde a6 0b              LDX INPFLG
bce0 10 03              BPL READ_90
bce2 4c c1 b7           JMP REST_10
bce5 a0 00    READ_90   LDY #0
bce7 b1 40              LDA (INPPTR),Y
bce9 f0 0b              BEQ READ_Ret
bceb a5 10              LDA IOPMPT
bced d0 07              BNE READ_Ret
bcef a9 f7              LDA #<Msg_Extra_Ignored
bcf1 a0 bc              LDY #>Msg_Extra_Ignored
bcf3 4c 1d bb           JMP Print_String
bcf6 60       READ_Ret  RTS ;Size  236 [Read_Get]

bcf7                    .FILL $bcf7-* (0) ; 0 bytes

              ; *************************
bcf7            Msg_Extra_Ignored ; $bcf7
              ; *************************

bcf7 3f 45 58           .BYTE "?EXTRA IGNORED\r",0

              ; *******************
bd07            Msg_Redo_From_Start
              ; *******************

bd07 3f 52 45           .BYTE "?REDO FROM START\r",0

              ; ******************
bd19            Basic_NEXT ; $bd19
              ; ******************

bd19 d0 04              BNE NEXT_10         ; branch if index after NEXT
bd1b a0 00              LDY #0
bd1d f0 05              BEQ NEXT_20
bd1f 20 2b c1 NEXT_10   JSR Parse_Name      ; address of index
bd22 85 46              STA FORPNT
bd24 84 47    NEXT_20   STY FORPNT+1        ; address or zero if no index
bd26 20 22 b3           JSR Find_Active_FOR
bd29 f0 04              BEQ NEXT_40         ; branch if found
bd2b a2 00              LDX #0              ; index for next without for error
bd2d f0 66    NEXT_30   BEQ CVT_40           ; -> basic error
bd2f 9a       NEXT_40   TXS                 ; set stack pointer
bd30 8a                 TXA                 ; A = SP
bd31 18                 CLC
bd32 69 04              ADC #4              ; A = SP + 4 (STEP value)
bd34 48                 PHA
bd35 69 06              ADC #6
bd37 85 21              STA INDEXB          ; address TO   value low
bd39 68                 PLA                 ; address STEP value low
bd3a a0 01              LDY #>[STACK]       ; address STEP value high
bd3c 20 d8 cc           JSR Load_FAC1_AY
bd3f ba                 TSX                 ; X = SP    <-- DELETE obsolete
bd40 bd 09 01           LDA STACK+9,X       ; sign of STEP
bd43 85 63              STA FAC1SI
bd45 a5 46              LDA FORPNT
bd47 a4 47              LDY FORPNT+1           ; address of index
bd49 20 9d c9           JSR Add_Var_AY_To_FAC1 ; FAC1 = index + STEP
bd4c 20 06 cd           JSR FAC1_To_FORPNT
bd4f a0 01              LDY #>[STACK]          ; address TO value high
bd51 20 93 cd           JSR Compare_FAC1_INDEXB_Y
bd54 ba                 TSX
bd55 38                 SEC
bd56 fd 09 01           SBC STACK+9,X          ; STEP sign
bd59 f0 17              BEQ NEXT_60            ; loop finished
bd5b bd 0f 01           LDA STACK+15,X
bd5e 85 36              STA CURLIN
bd60 bd 10 01           LDA STACK+16,X
bd63 85 37              STA CURLIN+1           ; line # of loop body
bd65 bd 12 01           LDA STACK+18,X
bd68 85 77              STA TXTPTR
bd6a bd 11 01           LDA STACK+17,X
bd6d 85 78              STA TXTPTR+1           ; address of loop body
bd6f 4c 4a b7 NEXT_50   JMP Execute            ; next iteration
bd72 8a       NEXT_60   TXA
bd73 69 11              ADC #$11               ; carry was set
bd75 aa                 TAX
bd76 9a                 TXS                    ; remove loop structure from stack
bd77 20 76 00           JSR CHRGOT             ; character after NEXT
bd7a c9 2c              CMP #','               ; comma ?
bd7c d0 f1              BNE NEXT_50            ; continue with follow up statement
bd7e 20 70 00           JSR CHRGET             ; get another index
bd81 20 1f bd           JSR NEXT_10            ; perform NEXT again

              ; ********************
bd84            Eval_Numeric ; $bd84
              ; ********************

bd84 20 98 bd           JSR Eval_Expression

              ; ******************
bd87            Is_Numeric ; $bd87
              ; ******************

bd87 18                 CLC
bd88 24                 .BYTE $24

              ; *****************
bd89            Is_String ; $bd89
              ; *****************

bd89 38                 SEC

              ; **********************
bd8a            Check_Var_Type ; $bd8a
              ; **********************

bd8a 24 07              BIT VALTYP          ; $FF = string   $00 = numeric
bd8c 30 03              BMI CVT_20          ; branch on string type
bd8e b0 03              BCS CVT_30          ; string assert -> TYPE MISMATCH
bd90 60       CVT_10    RTS ;Size    7 [Check_Var_Type]
bd91 b0 fd    CVT_20    BCS CVT_10          ; looking for string, found string
bd93 a2 a3    CVT_30    LDX #[Msg_TYPE - Msg_Start] ; $a3
bd95 4c cf b3 CVT_40    JMP Basic_Error     ; want string got numeric or vice versa

              ; called from $b947 Basic_LET
              ;             $c06b Op_COMPARE

              ; ***********************
bd98            Eval_Expression ; $bd98
              ; ***********************

bd98 a6 77              LDX TXTPTR          ; TXTPTR--
bd9a d0 02              BNE EvEx_05
bd9c c6 78              DEC TXTPTR+1
bd9e c6 77    EvEx_05   DEC TXTPTR
bda0 a2 00              LDX #0
bda2 24                 .BYTE $24           ; skip next PHA
bda3 48       EvEx_10   PHA                 ; push ACCSYM (comparison op + type)
bda4 8a                 TXA
bda5 48                 PHA                 ; push X
bda6 20 93 b3           JSR Check_Stack_Avail
bda9 20 7e be           JSR Evaluate
bdac a9 00              LDA #0
bdae 85 4a              STA ACCSYM          ;clear type comparison flag
bdb0 20 76 00 EvEx_15   JSR CHRGOT
bdb3 38       EvEx_20   SEC
bdb4 e9 b1              SBC #$b1            ; > token ( start of comparison ops)
bdb6 90 16              BCC EvEx_25         ; -> binary operators
bdb8 c9 03              CMP #3              ; ( 3 comparison operators > = < )
bdba b0 12              BCS EvEx_25         ; -> function
bdbc c9 02              CMP #2              ; '>'  A = 1
bdbe 69 01              ADC #1              ; '='  A = 2
bdc0 45 4a              EOR ACCSYM          ; '<'  A = 4
bdc2 c5 4a              CMP ACCSYM
bdc4 90 61              BCC SynErr1           ; -> syntax error
bdc6 85 4a              STA ACCSYM          ; rememer comparison operator
bdc8 20 70 00           JSR CHRGET
bdcb 4c b3 bd           JMP EvEx_20         ; loop (maybe <= or >= or <>)

bdce a6 4a    EvEx_25   LDX ACCSYM
bdd0 d0 2c              BNE EvEx_50
bdd2 b0 7e              BCS Pop_FAC2        ; function ( SGN INT ... MID$ )
bdd4 69 07              ADC #7
bdd6 90 7a              BCC Pop_FAC2        ; ->
bdd8 65 07              ADC VALTYP          ; C=1               0 1 2 3 4  5  6
bdda d0 03              BNE EvEx_30         ; binary operator ( + - * / ^ AND OR )
bddc 4c 4f c7           JMP Concatenate     ; '+' with strings

bddf 69 ff    EvEx_30   ADC #$ff
bde1 85 1f              STA INDEXA          ; op code (0-9 for '+' to '<')
bde3 0a                 ASL A               ; op code * 2
bde4 65 1f              ADC INDEXA          ; op code * 3
bde6 a8                 TAY                 ; Y = index
bde7 68       EvEx_35   PLA                 ; precedence
bde8 d9 94 b0           CMP Basic_Operator_Table,Y
bdeb b0 6a              BCS PoFA_20         ; previous op has higher precedence
bded 20 87 bd           JSR Is_Numeric
bdf0 48       EvEx_40   PHA                 ; save precedence
bdf1 20 17 be EvEx_45   JSR Use_Operator
bdf4 68                 PLA                 ; restore precedence
bdf5 a4 48              LDY YSAVE           ; restore index
bdf7 10 17              BPL EvEx_60
bdf9 aa                 TAX
bdfa f0 59              BEQ PoFA_10
bdfc d0 62              BNE PoFA_40         ; always

bdfe 46 07    EvEx_50   LSR VALTYP          ; clear type
be00 8a                 TXA                 ; comparison operator
be01 2a                 ROL A               ; com op * 2
be02 a6 77              LDX TXTPTR          ; TXTPTR--
be04 d0 02              BNE EvEx_55
be06 c6 78              DEC TXTPTR+1
be08 c6 77    EvEx_55   DEC TXTPTR
be0a a0 1b              LDY #27             ; index to Op_COMPARE
be0c 85 4a              STA ACCSYM          ; com op * 2
be0e d0 d7              BNE EvEx_35
be10 d9 94 b0 EvEx_60   CMP Basic_Operator_Table,Y
be13 b0 4b              BCS PoFA_40         ; higher precedence
be15 90 d9              BCC EvEx_40         ; lower  precedence

              ; ************
be17            Use_Operator
              ; ************

be17 b9 96 b0           LDA Basic_Operator_Table+2,Y
be1a 48                 PHA
be1b b9 95 b0           LDA Basic_Operator_Table+1,Y
be1e 48                 PHA
be1f 20 2a be           JSR Push_Operand
be22 a5 4a              LDA ACCSYM
be24 4c a3 bd           JMP EvEx_10

be27 4c 00 bf SynErr1   JMP Syntax_Error

              ; ************
be2a            Push_Operand
              ; ************

be2a be 94 b0           LDX Basic_Operator_Table,Y ; operator priority
be2d 38                 SEC                        ; push with sign

              ; *********
be2e            Push_FAC1
              ; *********

be2e 68                 PLA                 ; return address-1 low
be2f 85 1f              STA INDEXA
be31 68                 PLA                 ; return address-1 high
be32 85 20              STA INDEXA+1
be34 90 03              BCC PuFA_10
be36 a5 63              LDA FAC1SI          ; sign of operand
be38 48                 PHA
be39 20 51 cd PuFA_10   JSR Round_FAC1
be3c a5 62              LDA FAC1M4
be3e 48                 PHA
be3f a5 61              LDA FAC1M3
be41 48                 PHA
be42 a5 60              LDA FAC1M2
be44 48                 PHA
be45 a5 5f              LDA FAC1M1
be47 48                 PHA
be48 a5 5e              LDA FAC1EX
be4a 48                 PHA
be4b a5 20              LDA INDEXA+1
be4d 48                 PHA
be4e a5 1f              LDA INDEXA
be50 48                 PHA
be51 60                 RTS ;Size   36 [Push_FAC1]

              ; ********
be52            Pop_FAC2
              ; ********

be52 a0 ff              LDY #$ff
be54 68                 PLA
be55 f0 23    PoFA_10   BEQ PoFA_50
be57 c9 64    PoFA_20   CMP #$64            ; precedence of Op_COMPARE
be59 f0 03              BEQ PoFA_30         ; strings may be comapred too
be5b 20 87 bd           JSR Is_Numeric
be5e 84 48    PoFA_30   STY YSAVE
be60 68       PoFA_40   PLA
be61 4a                 LSR A               ; C = VALTYPE
be62 85 0c              STA TANSGN          ; comparison operator
be64 68                 PLA
be65 85 66              STA FAC2EX
be67 68                 PLA
be68 85 67              STA FAC2M1
be6a 68                 PLA
be6b 85 68              STA FAC2M2
be6d 68                 PLA
be6e 85 69              STA FAC2M3
be70 68                 PLA
be71 85 6a              STA FAC2M4
be73 68                 PLA
be74 85 6b              STA FAC2SI
be76 45 63              EOR FAC1SI
be78 85 6c              STA STRPTR
be7a a5 5e    PoFA_50   LDA FAC1EX
be7c 60                 RTS                 ; -> use operator ;Size   43 [Pop_FAC2]

be7d 00                 .FILL $be7e-* (0) ; 1 bytes

              ; ****************
be7e            Evaluate ; $be7e
              ; ****************

be7e 6c 0a 03           JMP (IEVAL)

              ; ****************
be81            DEF_EVAL ; $be81
              ; ****************

be81 a9 00              LDA #0
be83 85 07              STA VALTYP          ; default numeric
be85 20 70 00 Eva_10    JSR CHRGET
be88 b0 03              BCS Eva_30          ; branch if not numeric
be8a 4c 29 ce Eva_20    JMP Read_Real_To_FAC1
be8d 20 b6 c1 Eva_30    JSR Is_Alpha
be90 b0 7a              BCS JMP_Get_Var     ; branch to Get_Var
be92 c9 ff              CMP #$ff            ; Pi token
be94 d0 0f              BNE Eva_40
be96 a9 a0              LDA #<Float_PI
be98 a0 be              LDY #>Float_PI
be9a 20 d8 cc           JSR Load_FAC1_AY
be9d 4c 70 00           JMP CHRGET
bea0 82 49 0f Float_PI  .REAL $82490fdaa1   ; 3.14159265254
bea5 c9 2e    Eva_40    CMP # '.'
bea7 f0 e1              BEQ Eva_20          ; real number starting with '.'
bea9 c9 ab              CMP #$ab            ; '-' token sign
beab f0 58              BEQ Negate
bead c9 aa              CMP #$aa            ; '+' token sign
beaf f0 d4              BEQ Eva_10
beb1 c9 22              CMP #QUOTE
beb3 d0 0f              BNE Eva_50

              ; ********************************
beb5            Make_String_Descriptor_From_Code
              ; ********************************

beb5 a5 77              LDA TXTPTR
beb7 a4 78              LDY TXTPTR+1
beb9 69 00              ADC #0              ; INC (A,Y)
bebb 90 01              BCC MSDF_10
bebd c8                 INY
bebe 20 b0 c5 MSDF_10   JSR Create_String_Descriptor
bec1 4c 18 c9           JMP Restore_Execution_Pointer

bec4 c9 a8    Eva_50    CMP #$a8            ; NOT token
bec6 d0 13              BNE Eva_60
bec8 a0 18              LDY #24             ; NOT index to Op Table
beca d0 3b              BNE Nega_10         ; always

              ; ******
becc            Op_NOT
              ; ******

              ; convert real in FAC1 to integer
              ; do a bitwise EOR (negate)
              ; convert result back to FAC1
              ; 0 : false, <> 0 : true

becc 20 ea c2           JSR Real_To_Integer
becf a5 62              LDA FAC1M4
bed1 49 ff              EOR #$ff
bed3 a8                 TAY
bed4 a5 61              LDA FAC1M3
bed6 49 ff              EOR #$ff
bed8 4c bc c4           JMP AY_To_Real

bedb c9 a5    Eva_60    CMP #$a5            ; FN(  token
bedd d0 03              BNE Eva_70
bedf 4c 1d c5           JMP Eval_FNX
bee2 c9 b4    Eva_70    CMP #$b4            ; SGN( token
bee4 90 03              BCC Eval_In_Parenthesis
bee6 4c 47 c0           JMP Function_Call

              ; *******************
bee9            Eval_In_Parenthesis
              ; *******************

bee9 20 f2 be           JSR Need_Left_Parenthesis
beec 20 98 bd           JSR Eval_Expression

              ; **********************
beef            Need_Right_Parenthesis
              ; **********************

beef a9 29              LDA #')'
bef1 2c                 .BYTE $2c

              ; *********************
bef2            Need_Left_Parenthesis
              ; *********************

bef2 a9 28              LDA #'('
bef4 2c                 .BYTE $2c

              ; **********
bef5            Need_Comma
              ; **********

bef5 a9 2c              LDA #','

              ; ******
bef7            Need_A
              ; ******

bef7 a0 00              LDY #0
bef9 d1 77              CMP (TXTPTR),Y
befb d0 03              BNE Syntax_Error
befd 4c 70 00           JMP CHRGET

              ; ************
bf00            Syntax_Error
              ; ************

bf00 a2 10              LDX #[Msg_SYNTA - Msg_Start]
bf02 4c cf b3           JMP Basic_Error

              ; ******
bf05            Negate
              ; ******

bf05 a0 15              LDY #21             ; index to Op_NEGATE
bf07 68       Nega_10   PLA
bf08 68                 PLA
bf09 4c f1 bd           JMP EvEx_45

              ; ***********
bf0c            JMP_Get_Var
              ; ***********

bf0c 4c 8c bf           JMP Get_Var

              ; *************
bf0f            Any_Except_Pi
              ; *************

bf0f 20 70 00           JSR CHRGET
bf12 c9 ff              CMP #$ff            ; Pi token
bf14 f0 ea              BEQ Syntax_Error
bf16 4c 76 00           JMP CHRGOT

              ; ******************
bf19            Input_String_Patch
              ; ******************

bf19 a5 10              LDA IOPMPT
bf1b d0 03              BNE InSt_40
bf1d 4c f0 bb           JMP InSt_30
bf20 a5 96    InSt_40   LDA STATUS
bf22 29 40              AND #$40            ; check EOF
bf24 d0 03              BNE InSt_50
bf26 4c d5 bb           JMP InSt_10
bf29 4c 09 bc InSt_50   JMP READ_10

              ; ************************
bf2c            Extended_Statement_Table
              ; ************************

bf2c b0 de              .WORD Renumber         - 1
bf2e 44 d4              .WORD Monitor          - 1
bf30 7c e4              .WORD Delete           - 1
bf32 a2 ed              .WORD Find_Text        - 1
bf34 59 fe              .WORD Replace          - 1
bf36 e5 f3              .WORD Merge            - 1
bf38 00 e7              .WORD OLD              - 1

              ; **********************
bf3a            Extended_Keyword_Table
              ; **********************

bf3a 52 45 4e           .BYTE "RENUMBER"^
bf42 4d 4f 4e           .BYTE "MONITOR"^
bf49 44 45 4c           .BYTE "DELETE"^
bf4f 46 49 4e           .BYTE "FIND"^
bf53 52 45 50           .BYTE "REPLACE"^
bf5a 4d 45 52           .BYTE "MERGE"^
bf5f 4f 4c c4           .BYTE "OLD"^
bf62 00                 .BYTE 0

bf63 00 00 00           .FILL $bf8c-* (0) ; 41 bytes

              ; *******
bf8c            Get_Var
              ; *******

              ; Parse_Name checks, whether the caller is Get_Var
              ; It does not create a so far unknown variable in this case

              ; Output: FAC1 a) integer value converted to real
              ;              b) real value
              ;              c) address of string (FAC1M3)

bf8c 20 2b c1           JSR Parse_Name      ; call address checked in Create_Var !
bf8f 85 61              STA FAC1M3          ; A = VARPTR
bf91 84 62              STY FAC1M4          ; Y = VARPTR+1
bf93 a5 42              LDA VARNAM
bf95 a4 43              LDY VARNAM+1
bf97 a6 07              LDX VALTYP
bf99 f0 33              BEQ Get_Numeric_Value
bf9b a6 62              LDX FAC1M4          ; VARPTR+1
bf9d 10 2e              BPL GeVa_Ret        ; is assigned: no special variables
bf9f c9 54              CMP #'T'            ; TI$ - 1st. char
bfa1 d0 18              BNE GeVa_10
bfa3 c0 c9              CPY #'I'+$80        ; TI$ - 2nd. char
bfa5 d0 14              BNE GeVa_10
bfa7 20 03 c0           JSR Load_Jiffyclock
bfaa 84 5b              STY TMPVAR+1        ; TMPVAR+1 = 0
bfac 88                 DEY
bfad 84 6e              STY TMPPTD          ; TMPPTD = $ff
bfaf a0 06              LDY #6
bfb1 84 5a              STY TMPVAR          ; # of digits
bfb3 a0 24              LDY #$24            ; index to Decimal_Conversion_Table
bfb5 20 1a d0           JSR Format_Jiffyclock
bfb8 4c 98 c5           JMP STR_10           ; create string and descriptor

bfbb c9 44    GeVa_10   CMP #'D'            ; DS$ - 1st. char
bfbd d0 0e              BNE GeVa_Ret
bfbf c0 d3              CPY #'S'+$80        ; DS$ - 2nd. char
bfc1 d0 0a              BNE GeVa_Ret
bfc3 20 91 d9           JSR Kernal_Read_DS
bfc6 a9 ad              LDA #<DOS_Status
bfc8 a0 03              LDY #>DOS_Status
bfca 4c b0 c5           JMP Create_String_Descriptor
bfcd 60       GeVa_Ret  RTS ;Size   66 [Get_Var]

              ; *****************
bfce            Get_Numeric_Value
              ; *****************

bfce a6 08              LDX INTFLG
bfd0 10 0d              BPL Load_Float
bfd2 a0 00              LDY #0
bfd4 b1 61              LDA (FAC1M3),Y
bfd6 aa                 TAX
bfd7 c8                 INY
bfd8 b1 61              LDA (FAC1M3),Y
bfda a8                 TAY
bfdb 8a                 TXA
bfdc 4c bc c4           JMP AY_To_Real

              ; **********
bfdf            Load_Float
              ; **********

bfdf a6 62              LDX FAC1M4
bfe1 10 5d              BPL Load_Float_Var
bfe3 c9 54              CMP #'T'            ; TI - 1st. char
bfe5 d0 28              BNE Check_ST_Var
bfe7 c0 49              CPY #'I'            ; TI - 2nd. char
bfe9 d0 55              BNE Load_Float_Var
bfeb 20 03 c0           JSR Load_Jiffyclock
bfee 98                 TYA                 ; FROUND := $00  FAC1SI := $00
bfef a2 a0              LDX #$a0            ; FAC1EX := $a0
bff1 4c 85 cd           JMP CITR_10           ; normalize FAC1

bff4 00 00 00           .FILL $c003-* (0) ; 15 bytes

              ; ***********************
c003            Load_Jiffyclock ; $c003
              ; ***********************

c003 a9 8b              LDA #<[JIFFY_CLOCK-2] ; load mixture of random seed
c005 a0 00              LDY #>[JIFFY_CLOCK-2] ; and jiffy clock
c007 78                 SEI
c008 20 d8 cc           JSR Load_FAC1_AY      ; FAC1M2/3/4 = Jiffy Clock
c00b 58                 CLI
c00c 84 5f              STY FAC1M1            ; FAC1M1 = 0
c00e 60                 RTS ;Size   12 [Load_Jiffyclock]

              ; ************
c00f            Check_ST_Var
              ; ************

c00f c9 53              CMP #'S'
c011 d0 09              BNE Check_DS_Var
c013 c0 54              CPY #'T'
c015 d0 05              BNE Check_DS_Var
c017 a5 96              LDA STATUS
c019 4c 72 cd           JMP A_To_FAC1

              ; ************
c01c            Check_DS_Var
              ; ************

c01c c9 44              CMP #'D'
c01e d0 20              BNE Load_Float_Var
c020 c0 53              CPY #'S'
c022 d0 1c              BNE Load_Float_Var
c024 20 91 d9           JSR Kernal_Read_DS
c027 29 0f              AND #15
c029 0a                 ASL A
c02a 85 09              STA GARBFL
c02c 0a                 ASL A
c02d 0a                 ASL A
c02e 65 09              ADC GARBFL
c030 85 09              STA GARBFL
c032 ad ae 03           LDA DOS_Status+1
c035 29 0f              AND #15
c037 65 09              ADC GARBFL
c039 4c 72 cd           JMP A_To_FAC1

c03c 00 00 00           .FILL $c040-* (0) ; 4 bytes

              ; **********************
c040            Load_Float_Var ; $c040
              ; **********************

c040 a5 61              LDA FAC1M3
c042 a4 62              LDY FAC1M4
c044 4c d8 cc           JMP Load_FAC1_AY

              ; *************
c047            Function_Call
              ; *************

              ; called from Evaluate
              ; Input:  A = function token
              ;         token  range = $b4 SGN - $ca MID$
              ;         scaled range = $68 SGN - $92 MID$

c047 0a                 ASL A               ; A = token * 2
c048 48                 PHA                 ; save
c049 aa                 TAX                 ; X = token * 2
c04a 20 70 00           JSR CHRGET
c04d e0 8f              CPX #$8f            ; limit of single numeric argument
c04f 90 20              BCC FuCa_10         ; branch if not LEFT$, RIGHT$, MID$
c051 20 f2 be           JSR Need_Left_Parenthesis
c054 20 98 bd           JSR Eval_Expression
c057 20 f5 be           JSR Need_Comma
c05a 20 89 bd           JSR Is_String       ; 1st. arg must be string
c05d 68                 PLA                 ; scaled token
c05e aa                 TAX                 ; X = $90 LEFT$, $92 RIGHT$, $94 MID$
c05f a5 62              LDA FAC1M4
c061 48                 PHA
c062 a5 61              LDA FAC1M3          ; push pointer to 1st. argUment
c064 48                 PHA
c065 8a                 TXA
c066 48                 PHA                 ; save scaled token
c067 20 d4 c8           JSR Get_Byte_Value  ; get 2nd. argument (byte value)
c06a 68                 PLA
c06b a8                 TAY                 ; Y = scaled token
c06c 8a                 TXA
c06d 48                 PHA                 ; push 2nd. argument
c06e 4c 76 c0           JMP FuCa_20
c071 20 e9 be FuCa_10   JSR Eval_In_Parenthesis
c074 68                 PLA                 ; scaled token
c075 a8                 TAY                 ; Y = index
c076 b9 fe af FuCa_20   LDA Basic_Function_Table-$68,Y
c079 85 52              STA FUNJMP
c07b b9 ff af           LDA Basic_Function_Table-$67,Y
c07e 85 53              STA FUNJMP+1
c080 20 51 00           JSR JUMPER
c083 4c 87 bd           JMP Is_Numeric

              ; *****
c086            Op_OR
              ; *****

c086 38                 SEC
c087 24                 .BYTE $24

              ; ******
c088            Op_AND
              ; ******

c088 18                 CLC
c089 66 03              ROR CHARAC          ; bit7=1:OR bit7=0:AND
c08b 20 ea c2           JSR Real_To_Integer
c08e a5 61              LDA FAC1M3
c090 48                 PHA
c091 a5 62              LDA FAC1M4
c093 48                 PHA
c094 20 32 cd           JSR FAC2_To_FAC1
c097 20 ea c2           JSR Real_To_Integer
c09a 68                 PLA
c09b 24 03              BIT CHARAC
c09d 10 09              BPL ANDOR_10
c09f 05 62              ORA FAC1M4
c0a1 a8                 TAY
c0a2 68                 PLA
c0a3 05 61              ORA FAC1M3
c0a5 4c bc c4           JMP AY_To_Real
c0a8 25 62    ANDOR_10  AND FAC1M4
c0aa a8                 TAY
c0ab 68                 PLA
c0ac 25 61              AND FAC1M3
c0ae 4c bc c4           JMP AY_To_Real

              ; ************
              ; Float_M32768
              ; ************

              ;         .REAL $9080000000   ; -32768

c0b1 00 00 00           .FILL $c0b6-* (0) ; 5 bytes

              ; ******************
c0b6            Op_COMPARE ; $c0b6
              ; ******************

              ; Input:  C = VALTYPE
              ;         TANSGN = comparison mask
              ;         FAC1 = right operand
              ;         FAC2 = left  operand

c0b6 20 8a bd           JSR Check_Var_Type
c0b9 b0 13              BCS OpCO_10         ; -> compare strings
c0bb a5 6b              LDA FAC2SI          ; transfer sign to FAC2M1
c0bd 09 7f              ORA #$7f
c0bf 25 67              AND FAC2M1
c0c1 85 67              STA FAC2M1
c0c3 a9 66              LDA #<FAC2EX
c0c5 a0 00              LDY #>FAC2EX
c0c7 20 91 cd           JSR Compare_FAC1_AY ; -1: FAC1 > FAC2  +1: FAC1 < FAC2
c0ca aa                 TAX                 ; set flags
c0cb 4c 01 c1           JMP OpCO_40
c0ce a9 00    OpCO_10   LDA #0
c0d0 85 07              STA VALTYP          ; result = numeric (-1:true, 0:false)
c0d2 c6 4a              DEC ACCSYM          ; OBSOLETE
c0d4 20 b8 c7           JSR Free_String_FAC1
c0d7 85 5e              STA FAC1EX
c0d9 86 5f              STX FAC1M1          ; 1st. string
c0db 84 60              STY FAC1M2
c0dd a5 69              LDA FAC2M3
c0df a4 6a              LDY FAC2M4
c0e1 20 bc c7           JSR Free_String_AY
c0e4 86 69              STX FAC2M3          ; 2nd. string
c0e6 84 6a              STY FAC2M4
c0e8 aa                 TAX                 ; X = length2
c0e9 38                 SEC
c0ea e5 5e              SBC FAC1EX          ; length difference
c0ec f0 08              BEQ OpCO_20         ; -> equal length
c0ee a9 01              LDA #1
c0f0 90 04              BCC OpCO_20
c0f2 a6 5e              LDX FAC1EX          ; X = length1 (shorter one)
c0f4 a9 ff              LDA #-1
c0f6 85 63    OpCO_20   STA FAC1SI          ; store length1 <=> length2 (-1,0,1)
c0f8 a0 ff              LDY #-1
c0fa e8                 INX
c0fb c8       OpCO_30   INY
c0fc ca                 DEX
c0fd d0 07              BNE OpCO_50
c0ff a6 63              LDX FAC1SI          ; equal so far
c101 30 0f    OpCO_40   BMI OpCO_60         ; left > right
c103 18                 CLC
c104 90 0c              BCC OpCO_60
c106 b1 69    OpCO_50   LDA (FAC2M3),Y
c108 d1 5f              CMP (FAC1M1),Y
c10a f0 ef              BEQ OpCO_30
c10c a2 ff              LDX #-1
c10e b0 02              BCS OpCO_60
c110 a2 01              LDX #1
c112 e8       OpCO_60   INX                 ; C=1 : string2 >= string1
c113 8a                 TXA                 ; C=0 : string2 <  string1
c114 2a                 ROL A
c115 25 0c              AND TANSGN          ; ACCSYM comparison mask
c117 f0 02              BEQ OpCO_70         ; > 1   = 2   < 4
c119 a9 ff              LDA #-1             ; true
c11b 4c 72 cd OpCO_70   JMP A_To_FAC1


c11e 20 f5 be DIM_10    JSR Need_Comma

              ; *********
c121            Basic_DIM
              ; *********

c121 aa                 TAX
c122 20 30 c1           JSR Get_Array_Address
c125 20 76 00           JSR CHRGOT
c128 d0 f4              BNE DIM_10
c12a 60                 RTS ;Size   10 [Basic_DIM]

              ; **********
c12b            Parse_Name
              ; **********

c12b a2 00              LDX #0
c12d 20 76 00           JSR CHRGOT

              ; *****************
c130            Get_Array_Address
              ; *****************

c130 86 06              STX DIMFLG

              ; **************
c132            Get_FN_Address
              ; **************

c132 85 42              STA VARNAM
c134 20 76 00           JSR CHRGOT
c137 20 b6 c1           JSR Is_Alpha
c13a b0 03              BCS Get_Address
c13c 4c 00 bf GFA_Err   JMP Syntax_Error

              ; *******************
c13f            Get_Address ; $c13f
              ; *******************

c13f a2 00              LDX #0              ; set defaults
c141 86 07              STX VALTYP          ; numeric
c143 86 08              STX INTFLG          ; real
c145 20 70 00           JSR CHRGET          ; 2nd. char of name
c148 90 05              BCC GeAd_05         ; -> branch if numeric
c14a 20 b6 c1           JSR Is_Alpha
c14d 90 0b              BCC GeAd_15         ; -> branch if not alpha
c14f aa       GeAd_05   TAX                 ; X = 2nd. char of name
c150 20 70 00 GeAd_10   JSR CHRGET          ; skip all alphanumeric characters
c153 90 fb              BCC GeAd_10         ; after the 2nd. one
c155 20 b6 c1           JSR Is_Alpha
c158 b0 f6              BCS GeAd_10
c15a c9 24    GeAd_15   CMP #'$'            ; string ?
c15c d0 06              BNE GeAd_20
c15e a9 ff              LDA #$ff            ; set string flag
c160 85 07              STA VALTYP          ; $ff = string  $00 = numeric
c162 d0 10              BNE GeAd_25         ; branch always
c164 c9 25    GeAd_20   CMP #'%'            ; integer ?
c166 d0 13              BNE GeAd_30
c168 a5 0a              LDA SUBFLG          ; integer allowed ?
c16a d0 d0              BNE GFA_Err         ; -> not in this context
c16c a9 80              LDA #$80
c16e 85 08              STA INTFLG          ; integer flag
c170 05 42              ORA VARNAM
c172 85 42              STA VARNAM          ; mark variable as integer
c174 8a       GeAd_25   TXA                 ; A = 2nd. char
c175 09 80              ORA #$80            ; set string/integer bit
c177 aa                 TAX                 ; X = 2nd. char OR $80
c178 20 70 00           JSR CHRGET          ; next char after '$' or '%'
c17b 86 43    GeAd_30   STX VARNAM+1        ; store 2nd. char of name
c17d 38                 SEC
c17e 05 0a              ORA SUBFLG          ; Or with FOR, FN flag
c180 e9 28              SBC #'('            ; array ?
c182 d0 03              BNE GeAd_35         ; -> no
c184 4c fc c2           JMP Find_Array      ; read subscripts
c187 a0 00    GeAd_35   LDY #0
c189 84 0a              STY SUBFLG          ; clear integer disable flag
c18b a5 2a              LDA VARTAB
c18d a6 2b              LDX VARTAB+1        ; (A/X) = VARTAB
c18f 86 5d    GeAd_40   STX TMPPTC+1        ; find variable in (VARTAB..ARYTAB)
c191 85 5c    GeAd_45   STA TMPPTC          ; TMPPTC = (A/X)
c193 e4 2d              CPX ARYTAB+1
c195 d0 04              BNE GeAd_50
c197 c5 2c              CMP ARYTAB
c199 f0 25              BEQ Create_Var      ; (A/X) == ARYTAB -> not found
c19b a5 42    GeAd_50   LDA VARNAM
c19d d1 5c              CMP (TMPPTC),Y      ; compare 1st. char
c19f d0 0b              BNE GeAd_60
c1a1 a5 43              LDA VARNAM+1
c1a3 c8                 INY                 ; Y = 1
c1a4 d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c1a6 d0 03              BNE GeAd_55
c1a8 4c b4 c2           JMP CrVa_80           ; -> found
c1ab 88       GeAd_55   DEY                 ; Y = 0
c1ac 18       GeAd_60   CLC
c1ad a5 5c              LDA TMPPTC
c1af 69 07              ADC #7              ; TMPPTC += 7
c1b1 90 de              BCC GeAd_45
c1b3 e8                 INX
c1b4 d0 d9              BNE GeAd_40         ; branch always

              ; ********
c1b6            Is_Alpha
              ; ********

c1b6 c9 41              CMP #'A'
c1b8 90 05              BCC IsAl_Ret
c1ba e9 5b              SBC #'Z'+1
c1bc 38                 SEC
c1bd e9 a5              SBC #$a5            ; restore original content
c1bf 60       IsAl_Ret  RTS                 ; C=1 if (A..Z) ;Size   10 [Is_Alpha]

              ; ******************
c1c0            Create_Var ; $c1c0
              ; ******************

c1c0 68                 PLA
c1c1 48                 PHA                 ; return address low
c1c2 c9 8e              CMP #<[Get_Var+2]   ; $8e called from Get_Var ?
c1c4 d0 05              BNE CrVa_10
c1c6 a9 c9    CrVa_05   LDA #<[Float_0_5 + 2]; void descriptor (0,0,0)
c1c8 a0 d0              LDY #>[Float_0_5 + 2]; or value in ROM
c1ca 60                 RTS ;Size   11 [Create_Var]
c1cb a5 42    CrVa_10   LDA VARNAM
c1cd a4 43              LDY VARNAM+1
c1cf c9 54              CMP #'T'            ; check reserved names
c1d1 d0 0b              BNE CrVa_20
c1d3 c0 c9              CPY #'I'+$80        ; TI$ = "hhmmss"  sets jiffy clock
c1d5 f0 ef              BEQ CrVa_05         ; create void descriptor
c1d7 c0 49              CPY #'I'            ; TI  (read only variable)
c1d9 d0 03              BNE CrVa_20
c1db 4c 00 bf CrVa_15   JMP Syntax_Error    ; tried to use reserved name
c1de c9 53    CrVa_20   CMP #'S'
c1e0 d0 04              BNE CrVa_25
c1e2 c0 54              CPY #'T'            ; ST  (read only variable)
c1e4 f0 f5              BEQ CrVa_15
c1e6 c9 44    CrVa_25   CMP #'D'
c1e8 d0 08              BNE CrVa_30
c1ea c0 53              CPY #'S'            ; DS  (read only variable)
c1ec f0 ed              BEQ CrVa_15
c1ee c0 d3              CPY #'S'+$80        ; DS$ (read only variable)
c1f0 f0 e9              BEQ CrVa_15
c1f2 a5 2c    CrVa_30   LDA ARYTAB
c1f4 a4 2d              LDY ARYTAB+1        ; (A/Y)  = ARYTAB
c1f6 85 5c              STA TMPPTC
c1f8 84 5d              STY TMPPTC+1        ; TMPPTC = ARYTAB
c1fa a5 2e              LDA STREND
c1fc a4 2f              LDY STREND+1        ; (A/Y)  = STREND
c1fe 85 57              STA TMPPTB
c200 84 58              STY TMPPTB+1        ; TMPPTB = STREND
c202 18                 CLC
c203 69 07              ADC #7              ; 7 bytes for a new variable
c205 90 01              BCC CrVa_35
c207 c8                 INY
c208 85 55    CrVa_35   STA TMPPTA
c20a 84 56              STY TMPPTA+1        ; TMPPTA = TMPPTB + 7
c20c 20 50 b3           JSR Open_Up_Space   ; move array space 7 bytes up
c20f a5 55              LDA TMPPTA
c211 a4 56              LDY TMPPTA+1
c213 c8                 INY
c214 85 2c              STA ARYTAB
c216 84 2d              STY ARYTAB+1        ; ARYTAB += 7
c218 85 55              STA TMPPTA
c21a 84 56              STY TMPPTA+1        ; TMPPTA = ARYTAB

              ; scan through array area and adjust all dynamic string
              ; back references to the new descriptor position

c21c a5 55    CrVa_40   LDA TMPPTA
c21e a6 56              LDX TMPPTA+1
c220 e4 2f    CrVa_45   CPX STREND+1        ; TMPPTA == STREND ?
c222 d0 04              BNE CrVa_50
c224 c5 2e              CMP STREND
c226 f0 70              BEQ CrVa_75         ; -> initialize variable
c228 85 1f    CrVa_50   STA INDEXA
c22a 86 20              STX INDEXA+1        ; INDEXA = TMPPTA
c22c a0 00              LDY #0
c22e b1 1f              LDA (INDEXA),Y
c230 aa                 TAX                 ; X = 1st. char
c231 c8                 INY                 ; Y = 1
c232 b1 1f              LDA (INDEXA),Y
c234 08                 PHP                 ; push flags of 2nd. char
c235 c8                 INY                 ; Y = 2
c236 b1 1f              LDA (INDEXA),Y      ; A = array length low
c238 65 55              ADC TMPPTA
c23a 85 55              STA TMPPTA
c23c c8                 INY                 ; Y = 3
c23d b1 1f              LDA (INDEXA),Y      ; A = array length high
c23f 65 56              ADC TMPPTA+1
c241 85 56              STA TMPPTA+1        ; TMPPTA += array length
c243 28                 PLP                 ; flags of 2nd. char
c244 10 d6              BPL CrVa_40         ; -> branch for real array
c246 8a                 TXA                 ; flags for 1st. char
c247 30 d3              BMI CrVa_40         ;-> branch for integer
c249 c8                 INY                 ; Y = 4
c24a b1 1f              LDA (INDEXA),Y      ; A = # of dimensions
c24c a0 00              LDY #0
c24e 0a                 ASL A               ; dimensions * 2
c24f 69 05              ADC #5              ; plus 5 bytes for header
c251 65 1f              ADC INDEXA
c253 85 1f              STA INDEXA
c255 90 02              BCC CrVa_55
c257 e6 20              INC INDEXA+1        ; INDEXA += header size
c259 a6 20    CrVa_55   LDX INDEXA+1
c25b e4 56              CPX TMPPTA+1        ; INDEXA == TMPPTA (end of array) ?
c25d d0 04              BNE CrVa_60
c25f c5 55              CMP TMPPTA
c261 f0 bd              BEQ CrVa_45         ; -> branch on end of array
c263 a0 00    CrVa_60   LDY #0
c265 b1 1f              LDA (INDEXA),Y      ; length
c267 f0 22              BEQ CrVa_70         ; -> next item
c269 c8                 INY                 ; Y = 1
c26a 18                 CLC
c26b 71 1f              ADC (INDEXA),Y      ; A = length + address low
c26d 85 57              STA TMPPTB
c26f aa                 TAX
c270 c8                 INY                 ; Y = 2
c271 b1 1f              LDA (INDEXA),Y      ; address high
c273 69 00              ADC #0
c275 85 58              STA TMPPTB+1        ; TMPPTB = back reference
c277 c5 31              CMP FRETOP+1
c279 90 10              BCC CrVa_70         ; -> branch if not in string area
c27b d0 04              BNE CrVa_65
c27d e4 30              CPX FRETOP
c27f 90 0a              BCC CrVa_70         ; -> branch if not in string area
c281 88       CrVa_65   DEY                 ; Y = 1
c282 a5 20              LDA INDEXA+1        ; back reference high
c284 91 57              STA (TMPPTB),Y      ; store
c286 88                 DEY                 ; Y = 0
c287 a5 1f              LDA INDEXA          ; back reference low
c289 91 57              STA (TMPPTB),Y      ; store
c28b a9 03    CrVa_70   LDA #3
c28d 18                 CLC
c28e 65 1f              ADC INDEXA
c290 85 1f              STA INDEXA
c292 90 c5              BCC CrVa_55
c294 e6 20              INC INDEXA+1        ; INDEXA += 3 (next descriptor)
c296 d0 c1              BNE CrVa_55         ; branch always

c298 a0 00    CrVa_75   LDY #0
c29a a5 42              LDA VARNAM
c29c 91 5c              STA (TMPPTC),Y      ; byte 0: 1st. char
c29e c8                 INY
c29f a5 43              LDA VARNAM+1
c2a1 91 5c              STA (TMPPTC),Y      ; byte 1: 2nd. char
c2a3 a9 00              LDA #0
c2a5 c8                 INY
c2a6 91 5c              STA (TMPPTC),Y      ; byte 2-6: 0
c2a8 c8                 INY
c2a9 91 5c              STA (TMPPTC),Y
c2ab c8                 INY
c2ac 91 5c              STA (TMPPTC),Y
c2ae c8                 INY
c2af 91 5c              STA (TMPPTC),Y
c2b1 c8                 INY
c2b2 91 5c              STA (TMPPTC),Y
c2b4 a5 5c    CrVa_80   LDA TMPPTC
c2b6 18                 CLC
c2b7 69 02              ADC #2
c2b9 a4 5d              LDY TMPPTC+1
c2bb 90 01              BCC CrVa_85
c2bd c8                 INY
c2be 85 44    CrVa_85   STA VARPTR          ; VARPTR = TMPPTC + 2
c2c0 84 45              STY VARPTR+1
c2c2 60                 RTS ;Size  259 [Create_Var]

c2c3 00 00 00           .FILL $c2c8-* (0) ; 5 bytes

              ; ******************************
c2c8            Array_Pointer_To_First ; $c2c8
              ; ******************************

c2c8 a5 05              LDA COUNT           ; # of dimensions
c2ca 0a                 ASL A               ; in bytes
c2cb 69 05              ADC #5              ; plus header size
c2cd 65 5c              ADC TMPPTC          ; plus start of array
c2cf a4 5d              LDY TMPPTC+1
c2d1 90 01              BCC APTF_10
c2d3 c8                 INY
c2d4 85 55    APTF_10   STA TMPPTA          ; pointer to first elemnt
c2d6 84 56              STY TMPPTA+1
c2d8 60                 RTS ;Size   17 [Array_Pointer_To_First]

              ; ************
c2d9            Float_M32768
              ; ************

c2d9 90 80 00           .QUAD $90800000  -1870659584

c2dd                    .FILL $c2dd-* (0) ; 0 bytes

              ; *****************************
c2dd            Eval_Positive_Integer ; $c2dd
              ; *****************************

c2dd 20 70 00           JSR CHRGET
c2e0 20 98 bd           JSR Eval_Expression

              ; ***************************
c2e3            Eval_Positive_Integer_Check
              ; ***************************

c2e3 20 87 bd           JSR Is_Numeric
c2e6 a5 63              LDA FAC1SI
c2e8 30 0d              BMI RIT_10

              ; ***********************
c2ea            Real_To_Integer ; $c2ea
              ; ***********************

c2ea a5 5e              LDA FAC1EX
c2ec c9 90              CMP #$90            ; check if -32767 >= value >= 32767
c2ee 90 09              BCC RIT_20
c2f0 a9 d9              LDA #<Float_M32768  ; check if value = -32768
c2f2 a0 c2              LDY #>Float_M32768
c2f4 20 91 cd           JSR Compare_FAC1_AY
c2f7 d0 7a    RIT_10    BNE Jump_To_Illegal_Quantity
c2f9 4c 6f ba RIT_20    JMP FAC1_INT

              ; ******************
c2fc            Find_Array ; $c2fc
              ; ******************

              ; This routine is jumped at from the Parse_Name routine
              ; after parsing the name of the array (VARNAM) and the
              ; left parenthesis '('

c2fc a5 06              LDA DIMFLG
c2fe 05 08              ORA INTFLG          ; push INTFLG (bit 7) and DIMFLG (6-0)
c300 48                 PHA
c301 a5 07              LDA VALTYP          ; push VALTYP
c303 48                 PHA
c304 a0 00              LDY #0
c306 98       FiAr_05   TYA                 ; start loop evaluating subscripts
c307 48                 PHA                 ; push Y
c308 a5 43              LDA VARNAM+1
c30a 48                 PHA
c30b a5 42              LDA VARNAM          ; push VARNAM
c30d 48                 PHA
c30e 20 dd c2           JSR Eval_Positive_Integer
c311 68                 PLA
c312 85 42              STA VARNAM
c314 68                 PLA
c315 85 43              STA VARNAM+1        ; pull VARNAM
c317 68                 PLA
c318 a8                 TAY                 ; pull Y
c319 ba                 TSX                 ; X = stack pointer
c31a bd 02 01           LDA STACK+2,X
c31d 48                 PHA                 ; push DIMFLG/INTFLG again
c31e bd 01 01           LDA STACK+1,X
c321 48                 PHA                 ; push VALTYP again
c322 a5 61              LDA FAC1M3
c324 9d 02 01           STA STACK+2,X
c327 a5 62              LDA FAC1M4          ; replace value above these flags
c329 9d 01 01           STA STACK+1,X       ; by the subscript pointer
c32c c8                 INY                 ; check next index
c32d 20 76 00           JSR CHRGOT
c330 c9 2c              CMP #','
c332 f0 d2              BEQ FiAr_05         ; evaluate next subscript
c334 84 05              STY COUNT           ; # of subscripts
c336 20 ef be           JSR Need_Right_Parenthesis
c339 68                 PLA
c33a 85 07              STA VALTYP
c33c 68                 PLA
c33d 85 08              STA INTFLG
c33f 29 7f              AND #$7f
c341 85 06              STA DIMFLG          ; restore array flags
c343 a6 2c              LDX ARYTAB
c345 a5 2d              LDA ARYTAB+1        ; start of search
c347 86 5c    FiAr_10   STX TMPPTC
c349 85 5d              STA TMPPTC+1
c34b c5 2f              CMP STREND+1
c34d d0 04              BNE FiAr_15
c34f e4 2e              CPX STREND
c351 f0 39              BEQ FiAr_30           ; not found -> create default size array
c353 a0 00    FiAr_15   LDY #0
c355 b1 5c              LDA (TMPPTC),Y
c357 c8                 INY                 ; Y = 1
c358 c5 42              CMP VARNAM          ; compare 1st. char
c35a d0 06              BNE FiAr_20
c35c a5 43              LDA VARNAM+1
c35e d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c360 f0 16              BEQ FiAr_25
c362 c8       FiAr_20   INY                 ; Y = 2
c363 b1 5c              LDA (TMPPTC),Y      ; length of header
c365 18                 CLC
c366 65 5c              ADC TMPPTC
c368 aa                 TAX
c369 c8                 INY
c36a b1 5c              LDA (TMPPTC),Y
c36c 65 5d              ADC TMPPTC+1        ; advance TMPPTC to next array
c36e 90 d7              BCC FiAr_10         ; branch always

              ; -------------
c370            Bad_Subscript
              ; -------------

c370 a2 6b              LDX #[Msg_SUBSC - Msg_Start] ; $6b
c372 2c                 .BYTE $2c

              ; ------------------------
c373            Jump_To_Illegal_Quantity
              ; ------------------------

c373 a2 35              LDX #[Msg_QUANT - Msg_Start] ; $35
c375 4c cf b3 FiAr_Err  JMP Basic_Error

              ; array already declared and dimensioned

c378 a2 78    FiAr_25   LDX #[Msg_REDIM - Msg_Start] ; $78
c37a a5 06              LDA DIMFLG          ; dimension statement ?
c37c d0 f7              BNE FiAr_Err        ; array already created
c37e 20 c8 c2           JSR Array_Pointer_To_First
c381 a5 05              LDA COUNT           ; # of subscripts
c383 a0 04              LDY #4
c385 d1 5c              CMP (TMPPTC),Y      ; compare with # of declared dimensions
c387 d0 e7              BNE Bad_Subscript   ; error if no match
c389 4c 15 c4           JMP FiAr_70

              ; create array

c38c 20 c8 c2 FiAr_30   JSR Array_Pointer_To_First
c38f 20 a0 b3           JSR Check_Mem_Avail
c392 a0 00              LDY #0
c394 84 6f              STY TMPPTD+1
c396 a2 05              LDX #5              ; # of bytes per element (default REAL)
c398 a5 42              LDA VARNAM
c39a 91 5c              STA (TMPPTC),Y      ; store 1st. char
c39c 10 01              BPL FiAr_35         ; branch if REAL or STRING
c39e ca                 DEX                 ; # of bytes = 4
c39f c8       FiAr_35   INY                 ; Y = 1
c3a0 a5 43              LDA VARNAM+1
c3a2 91 5c              STA (TMPPTC),Y      ; store 2nd. char
c3a4 10 02              BPL FiAr_40         ; branch if REAL
c3a6 ca                 DEX
c3a7 ca                 DEX                 ; # of bytes (2 INTEGER, 3 STRING)
c3a8 86 6e    FiAr_40   STX TMPPTD          ; store size of elemnts
c3aa a5 05              LDA COUNT           ; # of subscripts
c3ac c8                 INY                 ; Y = 2
c3ad c8                 INY                 ; Y = 3
c3ae c8                 INY                 ; Y = 4
c3af 91 5c              STA (TMPPTC),Y      ; store # of dimensions
c3b1 a2 0b    FiAr_45   LDX #11             ; default dimension (0..10)
c3b3 a9 00              LDA #0              ; high value
c3b5 24 06              BIT DIMFLG
c3b7 50 08              BVC FiAr_50         ; -> branch for default dimension
c3b9 68                 PLA
c3ba 18                 CLC
c3bb 69 01              ADC #1              ; add 1 because indices start at 0
c3bd aa                 TAX
c3be 68                 PLA
c3bf 69 00              ADC #0              ; (X/A) = (subscript + 1)
c3c1 c8       FiAr_50   INY                 ; Y = 5,7,...
c3c2 91 5c              STA (TMPPTC),Y      ; store dimension high
c3c4 c8                 INY                 ; Y = 6,8,...
c3c5 8a                 TXA
c3c6 91 5c              STA (TMPPTC),Y      ; store dimension low
c3c8 20 77 c4           JSR Mult_16x16
c3cb 86 6e              STX TMPPTD          ; size low
c3cd 85 6f              STA TMPPTD+1        ; size high
c3cf a4 1f              LDY INDEXA
c3d1 c6 05              DEC COUNT           ; decrement dimension counter
c3d3 d0 dc              BNE FiAr_45         ; loop for next dimension
c3d5 65 56              ADC TMPPTA+1
c3d7 b0 5d              BCS FiAr_76           ; -> out of memory
c3d9 85 56              STA TMPPTA+1
c3db a8                 TAY
c3dc 8a                 TXA
c3dd 65 55              ADC TMPPTA
c3df 90 03              BCC FiAr_55
c3e1 c8                 INY
c3e2 f0 52              BEQ FiAr_76           ; -> out of memory
c3e4 20 a0 b3 FiAr_55   JSR Check_Mem_Avail
c3e7 85 2e              STA STREND
c3e9 84 2f              STY STREND+1        ; new top of array area
c3eb a9 00              LDA #0              ; zero array content
c3ed e6 6f              INC TMPPTD+1        ; size high
c3ef a4 6e              LDY TMPPTD          ; Y = size low
c3f1 f0 05              BEQ FiAr_65
c3f3 88       FiAr_60   DEY
c3f4 91 55              STA (TMPPTA),Y      ; clear array
c3f6 d0 fb              BNE FiAr_60
c3f8 c6 56    FiAr_65   DEC TMPPTA+1
c3fa c6 6f              DEC TMPPTD+1
c3fc d0 f5              BNE FiAr_60
c3fe e6 56              INC TMPPTA+1
c400 38                 SEC
c401 a5 2e              LDA STREND
c403 e5 5c              SBC TMPPTC
c405 a0 02              LDY #2
c407 91 5c              STA (TMPPTC),Y      ; store array size low
c409 a5 2f              LDA STREND+1
c40b c8                 INY                 ; Y = 3
c40c e5 5d              SBC TMPPTC+1
c40e 91 5c              STA (TMPPTC),Y      ; store array size high
c410 a5 06              LDA DIMFLG
c412 d0 62              BNE FiAr_Ret
c414 c8                 INY                 ; Y = 4
c415 b1 5c    FiAr_70   LDA (TMPPTC),Y      ; # of dimensions
c417 85 05              STA COUNT
c419 a9 00              LDA #0
c41b 85 6e              STA TMPPTD          ; TMPPTD = 0
c41d 85 6f    FiAr_72   STA TMPPTD+1
c41f c8                 INY                 ; Y = 5,7,...
c420 68                 PLA
c421 aa                 TAX
c422 85 61              STA FAC1M3
c424 68                 PLA
c425 85 62              STA FAC1M4          ; FAC1M3/4 = subscript
c427 d1 5c              CMP (TMPPTC),Y      ; compare with dimension high
c429 90 0e              BCC FiAr_78         ; -> lower
c42b d0 06              BNE FiAr_74         ; greater -> out of range
c42d c8                 INY                 ; Y = 6,8,...
c42e 8a                 TXA
c42f d1 5c              CMP (TMPPTC),Y      ; compare with dimension low
c431 90 07              BCC FiAr_80         ; -> lower
c433 4c 70 c3 FiAr_74   JMP Bad_Subscript
c436 4c cd b3 FiAr_76   JMP Error_Out_Of_Memory
c439 c8       FiAr_78   INY                 ; Y = 6,8,...
c43a a5 6f    FiAr_80   LDA TMPPTD+1
c43c 05 6e              ORA TMPPTD
c43e 18                 CLC
c43f f0 0a              BEQ FiAr_82         ; TMPPTD == 0 ?
c441 20 77 c4           JSR Mult_16x16
c444 8a                 TXA
c445 65 61              ADC FAC1M3
c447 aa                 TAX
c448 98                 TYA
c449 a4 1f              LDY INDEXA
c44b 65 62    FiAr_82   ADC FAC1M4
c44d 86 6e              STX TMPPTD
c44f c6 05              DEC COUNT
c451 d0 ca              BNE FiAr_72         ; next subscript
c453 85 6f              STA TMPPTD+1
c455 a2 05              LDX #5              ; standard item size (REAL)
c457 a5 42              LDA VARNAM
c459 10 01              BPL FiAr_84         ; -> REAL or STRING
c45b ca                 DEX                 ; X = 4
c45c a5 43    FiAr_84   LDA VARNAM+1
c45e 10 02              BPL FiAr_86         ; -> REAL
c460 ca                 DEX
c461 ca                 DEX                 ; X = 2
c462 86 25    FiAr_86   STX FAC3M3          ; item size (I=2, S=3, R=5)
c464 a9 00              LDA #0
c466 20 80 c4           JSR Mult_16x16_A    ; # of items * item size
c469 8a                 TXA
c46a 65 55              ADC TMPPTA
c46c 85 44              STA VARPTR
c46e 98                 TYA
c46f 65 56              ADC TMPPTA+1
c471 85 45              STA VARPTR+1        ; VARPTR = array element
c473 a8                 TAY
c474 a5 44              LDA VARPTR          ; (A/Y) = VARPTR
c476 60       FiAr_Ret  RTS ;Size  379 [Find_Array]

c477                    .FILL $c477-* (0) ; 0 bytes

              ; ******************
c477            Mult_16x16 ; $c477
              ; ******************

c477 84 1f              STY INDEXA
c479 b1 5c              LDA (TMPPTC),Y
c47b 85 25              STA FAC3M3
c47d 88                 DEY
c47e b1 5c              LDA (TMPPTC),Y

              ; ************
c480            Mult_16x16_A
              ; ************

c480 85 26              STA FAC3M4          ; FAC3M3/3 = Dimension
c482 a9 10              LDA #16
c484 85 5a              STA TMPVAR          ; 16 bit multiplication
c486 a2 00              LDX #0
c488 a0 00              LDY #0
c48a 8a       Mu16_10   TXA                 ; (X/Y) = FAC3M3 * TMPPTD
c48b 0a                 ASL A
c48c aa                 TAX
c48d 98                 TYA
c48e 2a                 ROL A
c48f a8                 TAY
c490 b0 a4              BCS FiAr_76
c492 06 6e              ASL TMPPTD
c494 26 6f              ROL TMPPTD+1
c496 90 0b              BCC Mu16_20
c498 18                 CLC
c499 8a                 TXA
c49a 65 25              ADC FAC3M3
c49c aa                 TAX
c49d 98                 TYA
c49e 65 26              ADC FAC3M4
c4a0 a8                 TAY
c4a1 b0 93              BCS FiAr_76
c4a3 c6 5a    Mu16_20   DEC TMPVAR          ; next bit
c4a5 d0 e3              BNE Mu16_10
c4a7 60                 RTS ;Size   40 [Mult_16x16_A]

              ; *****************
c4a8            Basic_FRE ; $c4a8
              ; *****************

c4a8 a5 07              LDA VALTYP
c4aa f0 03              BEQ FRE_10          ; -> numeric argument
c4ac 20 b8 c7           JSR Free_String_FAC1
c4af 20 6a c6 FRE_10    JSR Garbage_Collection
c4b2 38                 SEC
c4b3 a5 30              LDA FRETOP
c4b5 e5 2e              SBC STREND
c4b7 a8                 TAY
c4b8 a5 31              LDA FRETOP+1
c4ba e5 2f              SBC STREND+1

              ; **********
c4bc            AY_To_Real
              ; **********

c4bc a2 00              LDX #0
c4be 86 07              STX VALTYP          ; numeric result
c4c0 85 5f              STA FAC1M1
c4c2 84 60              STY FAC1M2
c4c4 a2 90              LDX #$90            ; exponent
c4c6 4c 7a cd           JMP ATOF_10

              ; *****************
c4c9            Basic_POS ; $c4c9
              ; *****************

c4c9 a4 c6              LDY CursorCol

              ; **********
c4cb            Y_To_Float
              ; **********

c4cb a9 00              LDA #0
c4cd f0 ed              BEQ AY_To_Real      ; always

              ; *****************
c4cf            Assert_Non_Direct
              ; *****************

c4cf a6 37              LDX CURLIN+1
c4d1 e8                 INX
c4d2 d0 a2              BNE FiAr_Ret
c4d4 a2 95              LDX #[Msg_DIREC - Msg_Start] ; $95
c4d6 2c                 .BYTE $2c

              ; ******************
c4d7            Undefined_Function
              ; ******************

c4d7 a2 e9              LDX #[Msg_FUNC - Msg_Start] ; $e9
c4d9 4c cf b3           JMP Basic_Error

              ; *****************
c4dc            Basic_DEF ; $c4dc
              ; *****************

c4dc 20 0a c5           JSR Get_FN          ; read function name
c4df 20 cf c4           JSR Assert_Non_Direct
c4e2 20 f2 be           JSR Need_Left_Parenthesis
c4e5 a9 80              LDA #$80
c4e7 85 0a              STA SUBFLG          ; no integer function
c4e9 20 2b c1           JSR Parse_Name
c4ec 20 87 bd           JSR Is_Numeric      ; only numeric arguments
c4ef 20 ef be           JSR Need_Right_Parenthesis
c4f2 a9 b2              LDA #$b2            ; '=' token
c4f4 20 f7 be           JSR Need_A
c4f7 48                 PHA
c4f8 a5 45              LDA VARPTR+1
c4fa 48                 PHA
c4fb a5 44              LDA VARPTR          ; push function argument address
c4fd 48                 PHA
c4fe a5 78              LDA TXTPTR+1
c500 48                 PHA
c501 a5 77              LDA TXTPTR          ; push function address
c503 48                 PHA
c504 20 83 b8           JSR Basic_DATA      ; skip to next statement
c507 4c 75 c5           JMP FNX_30           ; pull and store attributes

              ; ******
c50a            Get_FN
              ; ******

c50a a9 a5              LDA #$a5            ; FN token
c50c 20 f7 be           JSR Need_A
c50f 09 80              ORA #$80
c511 85 0a              STA SUBFLG          ; no integer function
c513 20 32 c1           JSR Get_FN_Address
c516 85 4b              STA FUNCPT
c518 84 4c              STY FUNCPT+1
c51a 4c 87 bd           JMP Is_Numeric

              ; ********
c51d            Eval_FNX
              ; ********

c51d 20 0a c5           JSR Get_FN          ; address of function descriptor
c520 48                 PHA                 ; push FUNCPT
c521 98                 TYA
c522 48                 PHA                 ; push FUNCPT+1
c523 20 e9 be           JSR Eval_In_Parenthesis
c526 20 87 bd           JSR Is_Numeric      ; force numeric argument
c529 68                 PLA
c52a 85 4c              STA FUNCPT+1
c52c 68                 PLA
c52d 85 4b              STA FUNCPT          ; restore function descriptor
c52f a0 02              LDY #2
c531 b1 4b              LDA (FUNCPT),Y
c533 85 44              STA VARPTR
c535 aa                 TAX
c536 c8                 INY                 ; Y = 3
c537 b1 4b              LDA (FUNCPT),Y
c539 f0 9c              BEQ Undefined_Function
c53b 85 45              STA VARPTR+1        ; VARPTR = address of argument variable
c53d c8                 INY                 ; Y = 4
c53e b1 44    FNX_10    LDA (VARPTR),Y      ; push value of variable (5 bytes)
c540 48                 PHA
c541 88                 DEY
c542 10 fa              BPL FNX_10
c544 a4 45              LDY VARPTR+1
c546 20 0a cd           JSR FAC1_To_XY      ; (X/Y) = VARPTR - Y=0 on return
c549 a5 78              LDA TXTPTR+1
c54b 48                 PHA
c54c a5 77              LDA TXTPTR
c54e 48                 PHA                 ; push TXTPTR
c54f b1 4b              LDA (FUNCPT),Y
c551 85 77              STA TXTPTR
c553 c8                 INY                 ; Y = 1
c554 b1 4b              LDA (FUNCPT),Y
c556 85 78              STA TXTPTR+1        ; TXTPTR = function body
c558 a5 45              LDA VARPTR+1
c55a 48                 PHA
c55b a5 44              LDA VARPTR
c55d 48                 PHA                 ; push VARPTR
c55e 20 84 bd           JSR Eval_Numeric    ; execute function body
c561 68                 PLA
c562 85 4b              STA FUNCPT
c564 68                 PLA
c565 85 4c              STA FUNCPT+1        ; FUNCPT = VARPTR
c567 20 76 00           JSR CHRGOT
c56a f0 03              BEQ FNX_20
c56c 4c 00 bf           JMP Syntax_Error     ; function did not end properly
c56f 68       FNX_20    PLA
c570 85 77              STA TXTPTR
c572 68                 PLA
c573 85 78              STA TXTPTR+1         ; restore execution pointer
c575 a0 00    FNX_30    LDY #0               ; restore value of argument variable
c577 68                 PLA
c578 91 4b              STA (FUNCPT),Y
c57a 68                 PLA
c57b c8                 INY
c57c 91 4b              STA (FUNCPT),Y
c57e 68                 PLA
c57f c8                 INY
c580 91 4b              STA (FUNCPT),Y
c582 68                 PLA
c583 c8                 INY
c584 91 4b              STA (FUNCPT),Y
c586 68                 PLA
c587 c8                 INY
c588 91 4b              STA (FUNCPT),Y
c58a 60                 RTS ;Size  110 [Eval_FNX]

c58b 00 00 00           .FILL $c58e-* (0) ; 3 bytes

              ; *****************
c58e            Basic_STR ; $c58e
              ; *****************

c58e 20 87 bd           JSR Is_Numeric
c591 a0 00              LDY #0
c593 20 95 cf           JSR Format_FAC1_Y
c596 68                 PLA
c597 68                 PLA
c598 a9 ff    STR_10    LDA #<STACK-1
c59a a0 00              LDY #>STACK-1
c59c f0 12              BEQ Create_String_Descriptor

              ; ********************
c59e            Allocate_String_FAC1
              ; ********************

c59e a6 61              LDX FAC1M3
c5a0 a4 62              LDY FAC1M4
c5a2 86 4d              STX DESCPT
c5a4 84 4e              STY DESCPT+1

              ; *****************
c5a6            Allocate_String_A
              ; *****************

c5a6 20 1d c6           JSR Allocate_String_Space
c5a9 86 5f              STX FAC1M1          ; addres low
c5ab 84 60              STY FAC1M2          ; address high
c5ad 85 5e              STA FAC1EX          ; length
c5af 60                 RTS ;Size   10 [Allocate_String_A]

              ; ************************
c5b0            Create_String_Descriptor
              ; ************************

c5b0 a2 22              LDX #QUOTE          ; quote is the only valid delimiter
c5b2 86 03              STX CHARAC
c5b4 86 04              STX ENDCHR

              ; ***************************
c5b6            Create_String_Descriptor_AY
              ; ***************************

c5b6 85 6c              STA STRPTR
c5b8 84 6d              STY STRPTR+1        ; set STRPTR from (A/Y)
c5ba 85 5f              STA FAC1M1
c5bc 84 60              STY FAC1M2          ; set FAC1M1 from (A/Y)
c5be a0 ff              LDY #-1             ; start loop with 0
c5c0 c8       CSD_10    INY
c5c1 b1 6c              LDA (STRPTR),Y
c5c3 f0 0c              BEQ CSD_30          ; end of string
c5c5 c5 03              CMP CHARAC          ; closing delimiter
c5c7 f0 04              BEQ CSD_20
c5c9 c5 04              CMP ENDCHR
c5cb d0 f3              BNE CSD_10          ; loop
c5cd c9 22    CSD_20    CMP #QUOTE
c5cf f0 01              BEQ CSD_40
c5d1 18       CSD_30    CLC
c5d2 84 5e    CSD_40    STY FAC1EX          ; string length
c5d4 98                 TYA
c5d5 65 6c              ADC STRPTR          ; TMPPTD = STRPTR + strlen
c5d7 85 6e              STA TMPPTD
c5d9 a6 6d              LDX STRPTR+1
c5db 90 01              BCC CSD_50
c5dd e8                 INX
c5de 86 6f    CSD_50    STX TMPPTD+1
c5e0 a5 6d              LDA STRPTR+1
c5e2 f0 04              BEQ CSD_60          ; -> allocate if on ZP
c5e4 c9 02              CMP #2              ; -> allocate if in buffer
c5e6 d0 0b              BNE Push_String_Descriptor
c5e8 98       CSD_60    TYA                 ; A = length
c5e9 20 9e c5           JSR Allocate_String_FAC1
c5ec a6 6c              LDX STRPTR
c5ee a4 6d              LDY STRPTR+1
c5f0 20 9a c7           JSR Store_String_XY ; Copy string from (X/Y) to (FRESPC)

              ; **********************
c5f3            Push_String_Descriptor
              ; **********************

c5f3 a6 13              LDX TEMPPT
c5f5 e0 1f              CPX #TEMPST+9       ; top of temp string descriptors
c5f7 d0 05              BNE PuSD_10
c5f9 a2 c8              LDX #Msg_COMPL-Msg_Start ; $c8 FORMULA TOO COMPLEX
c5fb 4c cf b3 PuSD_Err  JMP Basic_Error
c5fe a5 5e    PuSD_10   LDA FAC1EX          ; push FAC1 descriptor
c600 95 00              STA 0,X
c602 a5 5f              LDA FAC1M1
c604 95 01              STA 1,X
c606 a5 60              LDA FAC1M2
c608 95 02              STA 2,X
c60a a0 00              LDY #0
c60c 86 61              STX FAC1M3          ; mark stack position
c60e 84 62              STY FAC1M4
c610 84 6d              STY FROUND
c612 88                 DEY                 ; Y = $ff
c613 84 07              STY VALTYP          ; type = string
c615 86 14              STX LASTPT          ; remember last used position
c617 e8                 INX
c618 e8                 INX
c619 e8                 INX
c61a 86 13              STX TEMPPT          ; increase string stack pointer
c61c 60                 RTS ;Size   42 [Push_String_Descriptor]

              ; *****************************
c61d            Allocate_String_Space ; $c61d
              ; *****************************

              ; Input:  A = length of string

              ; Output: A = length of string
              ;         X = address low
              ;         Y = address high

c61d 46 09              LSR GARBFL          ; clear bit 7 of GARBFL
c61f aa       ASS_10    TAX                 ; string length
c620 f0 38              BEQ ASS_50          ; 0 : nothing to do
c622 48                 PHA                 ; save length
c623 38                 SEC
c624 a5 30              LDA FRETOP
c626 e9 02              SBC #2
c628 85 1f              STA INDEXA
c62a a5 31              LDA FRETOP+1
c62c e9 00              SBC #0
c62e 85 20              STA INDEXA+1        ; INDEXA = FRETOP - 2
c630 a8                 TAY                 ; Y = INDEXA+1
c631 8a                 TXA                 ; A = length
c632 49 ff              EOR #$ff
c634 38                 SEC                 ; add -length
c635 65 1f              ADC INDEXA          ; (A/Y) = INDEXA - length
c637 b0 01              BCS ASS_30
c639 88                 DEY
c63a c4 2f    ASS_30    CPY STREND+1
c63c 90 1d              BCC ASS_60          ; OOM: try garbage collection
c63e d0 04              BNE ASS_40
c640 c5 2e              CMP STREND
c642 90 17              BCC ASS_60          ; OOM: try garbage collection
c644 85 32    ASS_40    STA FRESPC
c646 84 33              STY FRESPC+1        ; FRESPC = INDEXA - length
c648 a0 01              LDY #1
c64a a9 ff              LDA #$ff
c64c 91 1f              STA (INDEXA),Y      ; mark as unassigned
c64e 88                 DEY                 ; Y = 0
c64f 68                 PLA
c650 91 1f              STA (INDEXA),Y      ; store length
c652 a6 32              LDX FRESPC
c654 a4 33              LDY FRESPC+1
c656 86 30              STX FRETOP
c658 84 31              STY FRETOP+1        ; FRETOP = FRESPC
c65a 60       ASS_50    RTS ;Size   62 [Allocate_String_Space]
c65b a2 4d    ASS_60    LDX #[Msg_OOM - Msg_Start] ; $4d
c65d a5 09              LDA GARBFL
c65f 30 9a              BMI PuSD_Err           ; -> Out Of Memory
c661 20 6a c6           JSR Garbage_Collection
c664 38                 SEC
c665 66 09              ROR GARBFL          ; mark: collection done
c667 68                 PLA                 ; length
c668 d0 b5              BNE ASS_10          ; always

c66a                    .FILL $c66a-* (0) ; 0 bytes

              ; **************************
c66a            Garbage_Collection ; $c66a
              ; **************************

c66a a5 34              LDA MEMSIZ
c66c 85 32              STA FRESPC          ; new location of string
c66e 85 4b              STA FUNCPT          ; old location of string
c670 a5 35              LDA MEMSIZ+1
c672 85 33              STA FRESPC+1
c674 85 4c              STA FUNCPT+1

c676 a5 30    GaCo_05   LDA FRETOP          ; if (FRETOP >= FUNCPT)
c678 c5 4b              CMP FUNCPT
c67a a5 31              LDA FRETOP+1
c67c e5 4c              SBC FUNCPT+1
c67e b0 6b              BCS GaCo_45         ; finish

c680 a5 4b              LDA FUNCPT
c682 e9 01              SBC #1              ; subtract 2 (C=0)
c684 85 4b              STA FUNCPT
c686 b0 02              BCS GaCo_10
c688 c6 4c              DEC FUNCPT+1        ; FUNCPT -= 2

c68a a0 01    GaCo_10   LDY #1
c68c b1 4b              LDA (FUNCPT),Y      ; reference high
c68e 88                 DEY                 ; Y = 0
c68f c9 ff              CMP #$ff            ; obsolete flag
c691 d0 0c              BNE GaCo_15         ; branch to string copy
c693 a5 4b              LDA FUNCPT          ; C = 1 from CMP #$ff
c695 f1 4b              SBC (FUNCPT),Y      ; subtract length
c697 85 4b              STA FUNCPT
c699 b0 db              BCS GaCo_05         ; loop
c69b c6 4c              DEC FUNCPT+1
c69d d0 d7              BNE GaCo_05         ; loop always

c69f 85 20    GaCo_15   STA INDEXA+1        ; reference high
c6a1 b1 4b              LDA (FUNCPT),Y
c6a3 85 1f              STA INDEXA          ; reference low
c6a5 38                 SEC
c6a6 a5 4b              LDA FUNCPT
c6a8 f1 1f              SBC (INDEXA),Y      ; subtract length
c6aa 85 4b              STA FUNCPT
c6ac b0 02              BCS GaCo_20
c6ae c6 4c              DEC FUNCPT+1        ; FUNCPT -= length

c6b0 a5 32    GaCo_20   LDA FRESPC
c6b2 d0 02              BNE GaCo_25
c6b4 c6 33              DEC FRESPC+1
c6b6 c6 32    GaCo_25   DEC FRESPC          ; FRESPC--

c6b8 a5 20              LDA INDEXA+1        ; reference high
c6ba 91 32              STA (FRESPC),Y
c6bc 18                 CLC
c6bd a5 32              LDA FRESPC
c6bf f1 1f              SBC (INDEXA),Y      ; subtract length + borrow
c6c1 85 32              STA FRESPC
c6c3 b0 02              BCS GaCo_30
c6c5 c6 33              DEC FRESPC+1        ; FRESPC -= (length+1)

c6c7 c5 4b    GaCo_30   CMP FUNCPT          ; if (FRESPC == FUNCPT)
c6c9 d0 06              BNE GaCo_35         ; copy
c6cb a5 33              LDA FRESPC+1
c6cd c5 4c              CMP FUNCPT+1
c6cf f0 a5              BEQ GaCo_05         ; loop

c6d1 b1 1f    GaCo_35   LDA (INDEXA),Y      ; length
c6d3 a8                 TAY
c6d4 b1 4b    GaCo_40   LDA (FUNCPT),Y      ; copy string & low reference
c6d6 91 32              STA (FRESPC),Y
c6d8 88                 DEY
c6d9 d0 f9              BNE GaCo_40
c6db b1 4b              LDA (FUNCPT),Y
c6dd 91 32              STA (FRESPC),Y
c6df c8                 INY                 ; Y = 1
c6e0 a5 32              LDA FRESPC          ; store new reference
c6e2 91 1f              STA (INDEXA),Y
c6e4 c8                 INY
c6e5 a5 33              LDA FRESPC+1
c6e7 91 1f              STA (INDEXA),Y
c6e9 d0 8b              BNE GaCo_05         ; loop always
c6eb a5 32    GaCo_45   LDA FRESPC
c6ed 85 30              STA FRETOP
c6ef a5 33              LDA FRESPC+1
c6f1 85 31              STA FRETOP+1
c6f3 60                 RTS ;Size  138 [Garbage_Collection]

              ; ********
c6f4            FAC1_LSB
              ; ********

c6f4 a2 5e              LDX #FAC1EX
c6f6 a0 00    FACX_LSB  LDY #0
c6f8 84 65              STY BITS
c6fa c9 f9    FACB_10   CMP #-7
c6fc b0 1e              BCS FACB_Ret
c6fe a8                 TAY
c6ff b5 04              LDA 4,X
c701 85 6d              STA FROUND
c703 05 65              ORA BITS
c705 85 65              STA BITS
c707 b5 03              LDA 3,X
c709 95 04              STA 4,X
c70b b5 02              LDA 2,X
c70d 95 03              STA 3,X
c70f b5 01              LDA 1,X
c711 95 02              STA 2,X
c713 a9 00              LDA #0
c715 95 01              STA 1,X
c717 98                 TYA
c718 69 08              ADC #8
c71a d0 de              BNE FACB_10
c71c a8       FACB_Ret  TAY
c71d 60                 RTS ;Size   42 [FAC1_LSB]

c71e 00 00 00           .FILL $c74f-* (0) ; 49 bytes

              ; *******************
c74f            Concatenate ; $c74f
              ; *******************

c74f a5 62              LDA FAC1M4
c751 48                 PHA
c752 a5 61              LDA FAC1M3
c754 48                 PHA
c755 20 7e be           JSR Evaluate
c758 20 89 bd           JSR Is_String
c75b 68                 PLA
c75c 85 6c              STA STRPTR
c75e 68                 PLA
c75f 85 6d              STA STRPTR+1
c761 a0 00              LDY #0
c763 b1 6c              LDA (STRPTR),Y
c765 18                 CLC
c766 71 61              ADC (FAC1M3),Y
c768 90 05              BCC Conc_10
c76a a2 b0              LDX #Msg_LONG-Msg_Start ; $b0 STRING TOO LONG
c76c 4c cf b3           JMP Basic_Error
c76f 20 9e c5 Conc_10   JSR Allocate_String_FAC1
c772 20 8c c7           JSR Store_String_STRPTR ; store first part
c775 a5 4d              LDA DESCPT
c777 a4 4e              LDY DESCPT+1
c779 20 bc c7           JSR Free_String_AY
c77c 20 9e c7           JSR Store_String_INDEXA ; store second part
c77f a5 6c              LDA STRPTR
c781 a4 6d              LDY STRPTR+1
c783 20 bc c7           JSR Free_String_AY
c786 20 f3 c5           JSR Push_String_Descriptor
c789 4c b0 bd           JMP EvEx_15

              ; *******************
c78c            Store_String_STRPTR
              ; *******************

c78c a0 00              LDY #0
c78e b1 6c              LDA (STRPTR),Y      ; A = length
c790 48                 PHA
c791 c8                 INY
c792 b1 6c              LDA (STRPTR),Y      ; X = address low
c794 aa                 TAX
c795 c8                 INY
c796 b1 6c              LDA (STRPTR),Y      ; Y = address high
c798 a8                 TAY
c799 68                 PLA

              ; ***************
c79a            Store_String_XY
              ; ***************

c79a 86 1f              STX INDEXA
c79c 84 20              STY INDEXA+1

              ; ***************************
c79e            Store_String_INDEXA ; $c79e
              ; ***************************

c79e a8                 TAY
c79f f0 13              BEQ SSI_Ret
c7a1 48                 PHA
c7a2 88       SSI_10    DEY
c7a3 b1 1f              LDA (INDEXA),Y
c7a5 91 32              STA (FRESPC),Y
c7a7 98                 TYA
c7a8 d0 f8              BNE SSI_10
c7aa 68                 PLA
c7ab 18                 CLC
c7ac 65 32              ADC FRESPC          ; FRESPC += length
c7ae 85 32              STA FRESPC          ; (used by Concatenate)
c7b0 90 02              BCC SSI_Ret
c7b2 e6 33              INC FRESPC+1
c7b4 60       SSI_Ret   RTS ;Size   23 [Store_String_INDEXA]

              ; ****************************
c7b5            Eval_And_Free_String ; $c7b5
              ; ****************************

c7b5 20 89 bd           JSR Is_String

              ; ****************
c7b8            Free_String_FAC1
              ; ****************

c7b8 a5 61              LDA FAC1M3
c7ba a4 62              LDY FAC1M4

              ; **********************
c7bc            Free_String_AY ; $c7bc
              ; **********************

              ; Input:  (A/Y) = pointer to descriptor
              ; Output: (X/Y) = INDEXA = pointer to string
              ;         A     = length

c7bc 85 1f              STA INDEXA
c7be 84 20              STY INDEXA+1        ; INDEXA = pointer to descriptor
c7c0 20 11 c8           JSR Pop_Descriptor_Stack
c7c3 d0 28              BNE GSD_40          ; -> load if not temporary
c7c5 20 3d ba           JSR Back_Reference_Position
c7c8 90 23              BCC GSD_40          ; -> branch if not dynamic string
c7ca a9 ff              LDA #$ff
c7cc 91 4f              STA (INDEXC),Y      ; invalidate string
c7ce 88                 DEY                 ; Y = 0
c7cf 8a                 TXA
c7d0 91 4f              STA (INDEXC),Y      ; store length
c7d2 a6 1f              LDX INDEXA
c7d4 a4 20              LDY INDEXA+1
c7d6 c4 31              CPY FRETOP+1
c7d8 d0 25              BNE GSD_Ret
c7da e4 30              CPX FRETOP
c7dc d0 21              BNE GSD_Ret         ; return if INDEXA != FRETOP
c7de 48                 PHA                 ; push length
c7df a5 4f              LDA INDEXC
c7e1 69 01              ADC #1              ; add 2 (1 + carry)
c7e3 85 30              STA FRETOP
c7e5 a5 50              LDA INDEXC+1
c7e7 69 00              ADC #0
c7e9 85 31              STA FRETOP+1
c7eb 68                 PLA
c7ec 60                 RTS ;Size   49 [Free_String_AY]
c7ed a0 00    GSD_40    LDY #0              ; load descriptor from pointer
c7ef b1 1f              LDA (INDEXA),Y
c7f1 48                 PHA
c7f2 c8                 INY
c7f3 b1 1f              LDA (INDEXA),Y
c7f5 aa                 TAX
c7f6 c8                 INY
c7f7 b1 1f              LDA (INDEXA),Y
c7f9 a8                 TAY
c7fa 86 1f              STX INDEXA
c7fc 84 20              STY INDEXA+1
c7fe 68                 PLA
c7ff 60       GSD_Ret   RTS ;Size   68 [Free_String_AY]

c800 00 00 00           .FILL $c811-* (0) ; 17 bytes

              ; ****************************
c811            Pop_Descriptor_Stack ; $c811
              ; ****************************

c811 c4 15              CPY LASTPT+1
c813 d0 0c              BNE PDS_Ret
c815 c5 14              CMP LASTPT
c817 d0 08              BNE PDS_Ret
c819 85 13              STA TEMPPT
c81b e9 03              SBC #3
c81d 85 14              STA LASTPT
c81f a0 00              LDY #0
c821 60       PDS_Ret   RTS ;Size   17 [Pop_Descriptor_Stack]

              ; *********
c822            Basic_CHR
              ; *********

c822 20 d7 c8           JSR Eval_Byte       ; get byte in X
c825 8a                 TXA
c826 48                 PHA
c827 a9 01              LDA #1
c829 20 a6 c5           JSR Allocate_String_A
c82c 68                 PLA
c82d a0 00              LDY #0
c82f 91 5f              STA (FAC1M1),Y
c831 68                 PLA
c832 68                 PLA
c833 4c f3 c5           JMP Push_String_Descriptor

              ; **********
c836            Basic_LEFT
              ; **********

c836 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c839 d1 4d              CMP (DESCPT),Y      ; compare argument with length
c83b 98                 TYA                 ; A = 0
c83c 90 04    LEFT_10   BCC LEFT_20         ; branch if arg < length
c83e b1 4d              LDA (DESCPT),Y      ; get total length
c840 aa                 TAX                 ; string length
c841 98                 TYA                 ; A = 0
c842 48       LEFT_20   PHA                 ; push start index (0 for LEFT$)
c843 8a       LEFT_30   TXA                 ; A  = new length
c844 48       LEFT_40   PHA                 ; push new length
c845 20 a6 c5           JSR Allocate_String_A
c848 a5 4d              LDA DESCPT
c84a a4 4e              LDY DESCPT+1
c84c 20 bc c7           JSR Free_String_AY  ; free string argument
c84f 68                 PLA
c850 a8                 TAY                 ; Y = length
c851 68                 PLA                 ; A = start index
c852 18                 CLC
c853 65 1f              ADC INDEXA
c855 85 1f              STA INDEXA
c857 90 02              BCC LEFT_50
c859 e6 20              INC INDEXA+1        ; INDEX += start index
c85b 98       LEFT_50   TYA                 ; new length
c85c 20 9e c7           JSR Store_String_INDEXA
c85f 4c f3 c5           JMP Push_String_Descriptor

              ; ***********
c862            Basic_RIGHT
              ; ***********

c862 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c865 18                 CLC
c866 f1 4d              SBC (DESCPT),Y      ; argument - length
c868 49 ff              EOR #$ff            ; length - argument
c86a 4c 3c c8           JMP LEFT_10         ; share code with LEFT$

              ; *********
c86d            Basic_MID
              ; *********

c86d a9 ff              LDA #255            ; default value for 3rd. argument
c86f 85 62              STA FAC1M4
c871 20 76 00           JSR CHRGOT
c874 c9 29              CMP #')'
c876 f0 06              BEQ MID_10
c878 20 f5 be           JSR Need_Comma
c87b 20 d4 c8           JSR Get_Byte_Value  ; 3rd. argument to FAC1M4
c87e 20 97 c8 MID_10    JSR Pop_DESCPT      ; get string address and 2nd. argument
c881 f0 4b              BEQ ASC_Err         ; null string -> error
c883 ca                 DEX                 ; start index to offset
c884 8a                 TXA
c885 48                 PHA                 ; push offset
c886 18                 CLC
c887 a2 00              LDX #0
c889 f1 4d              SBC (DESCPT),Y      ; offset - length
c88b b0 b6              BCS LEFT_30
c88d 49 ff              EOR #$ff            ; length - offset
c88f c5 62              CMP FAC1M4
c891 90 b1              BCC LEFT_40         ; new length = rest of string
c893 a5 62              LDA FAC1M4          ; new length
c895 b0 ad              BCS LEFT_40         ; branch always

              ; **********
c897            Pop_DESCPT
              ; **********

c897 20 ef be           JSR Need_Right_Parenthesis
c89a 68                 PLA
c89b a8                 TAY                 ; return address low
c89c 68                 PLA
c89d 85 52              STA FUNJMP          ; return address high
c89f 68                 PLA
c8a0 68                 PLA
c8a1 68                 PLA
c8a2 aa                 TAX                 ; X = length
c8a3 68                 PLA
c8a4 85 4d              STA DESCPT
c8a6 68                 PLA
c8a7 85 4e              STA DESCPT+1        ; DESCPT = string address
c8a9 a5 52              LDA FUNJMP
c8ab 48                 PHA                 ; return address high
c8ac 98                 TYA
c8ad 48                 PHA                 ; return address low
c8ae a0 00              LDY #0
c8b0 8a                 TXA                 ; A = length
c8b1 60                 RTS ;Size   27 [Pop_DESCPT]

              ; *********
c8b2            Basic_LEN
              ; *********

c8b2 20 b8 c8           JSR Eval_String_Desc
c8b5 4c cb c4           JMP Y_To_Float

              ; ****************
c8b8            Eval_String_Desc
              ; ****************

c8b8 20 b5 c7           JSR Eval_And_Free_String
c8bb a2 00              LDX #0
c8bd 86 07              STX VALTYP
c8bf a8                 TAY
c8c0 60                 RTS ;Size    9 [Eval_String_Desc]

              ; *********
c8c1            Basic_ASC
              ; *********

c8c1 20 b8 c8           JSR Eval_String_Desc
c8c4 f0 05              BEQ ASC_10          ; ASC(""") was a syntax error in BASIC 4
c8c6 a0 00              LDY #0              ; here we return 0
c8c8 b1 1f              LDA (INDEXA),Y
c8ca a8                 TAY
c8cb 4c cb c4 ASC_10    JMP Y_To_Float
c8ce 4c 73 c3 ASC_Err   JMP Jump_To_Illegal_Quantity

c8d1                    .FILL $c8d1-* (0) ; 0 bytes

              ; ***************************
c8d1            Get_Next_Byte_Value ; $c8d1
              ; ***************************

c8d1 20 70 00           JSR CHRGET

              ; **************
c8d4            Get_Byte_Value
              ; **************

c8d4 20 84 bd           JSR Eval_Numeric

              ; *********
c8d7            Eval_Byte
              ; *********

c8d7 20 e3 c2           JSR Eval_Positive_Integer_Check
c8da a6 61              LDX FAC1M3
c8dc d0 f0              BNE ASC_Err
c8de a6 62              LDX FAC1M4
c8e0 4c 76 00           JMP CHRGOT

              ; *****************
c8e3            Basic_VAL ; $c8e3
              ; *****************

c8e3 20 b8 c8           JSR Eval_String_Desc
c8e6 d0 03              BNE VAL_10
c8e8 4c 2d ca           JMP Clear_FAC1
c8eb a6 77    VAL_10    LDX TXTPTR
c8ed a4 78              LDY TXTPTR+1
c8ef 86 6e              STX TMPPTD
c8f1 84 6f              STY TMPPTD+1        ; TMPPTD = TXTPTR
c8f3 a6 1f              LDX INDEXA
c8f5 86 77              STX TXTPTR
c8f7 18                 CLC
c8f8 65 1f              ADC INDEXA
c8fa 85 21              STA INDEXB
c8fc a6 20              LDX INDEXA+1
c8fe 86 78              STX TXTPTR+1        ; TXTPTR = INDEXA
c900 90 01              BCC VAL_20          ; INDEXB = INDEXA + length
c902 e8                 INX
c903 86 22    VAL_20    STX INDEXB+1
c905 a0 00              LDY #0
c907 b1 21              LDA (INDEXB),Y      ; back reference low
c909 48                 PHA
c90a 98                 TYA
c90b 91 21              STA (INDEXB),Y      ; add zero delimiter for CHRGET
c90d 20 76 00           JSR CHRGOT
c910 20 29 ce           JSR Read_Real_To_FAC1
c913 68                 PLA
c914 a0 00              LDY #0
c916 91 21              STA (INDEXB),Y      ; restore back reference low

              ; *************************
c918            Restore_Execution_Pointer
              ; *************************

c918 a6 6e              LDX TMPPTD
c91a a4 6f              LDY TMPPTD+1
c91c 86 77              STX TXTPTR
c91e 84 78              STY TXTPTR+1
c920 60                 RTS ;Size    9 [Restore_Execution_Pointer]

c921                    .FILL $c921-* (0) ; 0 bytes

              ; *************************
c921            Get_Word_And_Byte ; $c921
              ; *************************

c921 20 84 bd           JSR Eval_Numeric
c924 20 2d c9           JSR FAC1_To_LINNUM

              ; *******************
c927            Need_Comma_Get_Byte
              ; *******************

c927 20 f5 be           JSR Need_Comma
c92a 4c d4 c8           JMP Get_Byte_Value

              ; **************
c92d            FAC1_To_LINNUM
              ; **************

c92d a5 63              LDA FAC1SI
c92f 30 9d              BMI ASC_Err         ; only positive numbers
c931 a5 5e              LDA FAC1EX
c933 c9 91              CMP #$91
c935 b0 97              BCS ASC_Err         ; -> greater 65536
c937 20 d1 cd           JSR FAC1_LSR
c93a a5 61              LDA FAC1M3
c93c a4 62              LDY FAC1M4
c93e 84 11              STY LINNUM
c940 85 12              STA LINNUM+1
c942 60                 RTS ;Size   22 [FAC1_To_LINNUM]

              ; **********
c943            Basic_PEEK
              ; **********

c943 a5 12              LDA LINNUM+1
c945 48                 PHA
c946 a5 11              LDA LINNUM
c948 48                 PHA
c949 20 2d c9           JSR FAC1_To_LINNUM
c94c a0 00              LDY #0
c94e b1 11              LDA (LINNUM),Y
c950 a8                 TAY
c951 68                 PLA
c952 85 11              STA LINNUM
c954 68                 PLA
c955 85 12              STA LINNUM+1
c957 4c cb c4           JMP Y_To_Float

              ; **********
c95a            Basic_POKE
              ; **********

c95a 20 21 c9           JSR Get_Word_And_Byte
c95d 8a                 TXA
c95e a0 00              LDY #0
c960 91 11              STA (LINNUM),Y
c962 60                 RTS ;Size    9 [Basic_POKE]

              ; **********
c963            Basic_WAIT
              ; **********

c963 20 21 c9           JSR Get_Word_And_Byte
c966 86 46              STX FORPNT
c968 a2 00              LDX #0
c96a 20 76 00           JSR CHRGOT
c96d f0 03              BEQ WAIT_10
c96f 20 27 c9           JSR Need_Comma_Get_Byte
c972 86 47    WAIT_10   STX FORPNT+1
c974 a0 00              LDY #0
c976 b1 11    WAIT_20   LDA (LINNUM),Y
c978 45 47              EOR FORPNT+1
c97a 25 46              AND FORPNT
c97c f0 f8              BEQ WAIT_20
c97e 60       WAIT_Ret  RTS ;Size   28 [Basic_WAIT]

              ; ***************
c97f            Add_0_5_To_FAC1
              ; ***************

c97f a9 c7              LDA #<Float_0_5
c981 a0 d0              LDY #>Float_0_5
c983 4c 9d c9           JMP Add_Var_AY_To_FAC1

              ; *************
c986            AY_Minus_FAC1
              ; *************

c986 20 c2 cb           JSR Load_FAC2_From_AY

              ; ********
c989            Op_MINUS
              ; ********

c989 a5 63              LDA FAC1SI
c98b 49 ff              EOR #$ff
c98d 85 63              STA FAC1SI
c98f 45 6b              EOR FAC2SI
c991 85 6c              STA STRPTR          ; pos = ADD, neg = SUB
c993 a5 5e              LDA FAC1EX
c995 4c a0 c9           JMP Op_PLUS

c998 00 00 00           .FILL $c99d-* (0) ; 5 bytes

              ; ******************
c99d            Add_Var_AY_To_FAC1
              ; ******************

c99d 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***************
c9a0            Op_PLUS ; $c9a0
              ; ***************

c9a0 d0 03              BNE PLUS_10         ; -> branch if FAC1 is not 0
c9a2 4c 32 cd           JMP FAC2_To_FAC1    ; FAC1 = FAC2
c9a5 a6 6d    PLUS_10   LDX FROUND
c9a7 86 53              STX FUNJMP+1        ; copy rounding byte
c9a9 a2 66              LDX #FAC2EX         ; X points to FAC2
c9ab a5 66              LDA FAC2EX

              ; ***************************
c9ad            AddSub_FAC2_To_FAC1 ; $c9ad
              ; ***************************

              ; The mantissa of the FAC with the lower exponent is shifted
              ; right until both exponents become equal.

              ; Input:  A = exponent of FAC2
              ;         X = address  of FAC2
              ;         STRPTR ($00:Add, $80:Subtract)

              ; Output: FAC1 = FAC1 + FAC2 (for STRPTR == $00)
              ;         FAC1 = FAC1 - FAC2 (for STRPTR == $80)

c9ad a8                 TAY                 ; Y = exp 2
c9ae f0 ce              BEQ WAIT_Ret        ; return if FAC2 is zero
c9b0 38                 SEC
c9b1 e5 5e              SBC FAC1EX          ; A = exp 2 - exp 1
c9b3 f0 1b              BEQ AFTF_30         ; -> exponents are equal
c9b5 90 12              BCC AFTF_10         ; -> exp 2 < exp 1
c9b7 84 5e              STY FAC1EX          ; exp 1 = exp 2
c9b9 a4 6b              LDY FAC2SI
c9bb 84 63              STY FAC1SI          ; sign 1 = sign 2
c9bd 49 ff              EOR #$ff
c9bf 69 00              ADC #0              ; A = exp 1 - exp 2
c9c1 a0 00              LDY #0
c9c3 84 53              STY FUNJMP+1        ; clear FAC2 rounding byte
c9c5 a2 5e              LDX #FAC1EX         ; X points to FAC1
c9c7 d0 04              BNE AFTF_20         ; always
c9c9 a0 00    AFTF_10   LDY #0
c9cb 84 6d              STY FROUND          ; clear FAC1 rounding byte
c9cd 20 cf ca AFTF_20   JSR Shift_FACX_A
c9d0 24 6c    AFTF_30   BIT STRPTR          ; add or subtract ?
c9d2 10 60              BPL AFTF_60         ; -> add mantissa of FAC2 to FAC1
c9d4 a0 5e              LDY #FAC1EX
c9d6 e0 66              CPX #FAC2EX         ; if (X == FAC2) Y = FAC1
c9d8 f0 02              BEQ AFTF_40
c9da a0 66              LDY #FAC2EX         ; else           Y = FAC2
c9dc 38       AFTF_40   SEC
c9dd 49 ff              EOR #$ff            ; negate rounding byte
c9df 65 53              ADC FUNJMP+1
c9e1 85 6d              STA FROUND
c9e3 b9 04 00           LDA 4,Y
c9e6 f5 04              SBC 4,X
c9e8 85 62              STA FAC1M4
c9ea b9 03 00           LDA 3,Y
c9ed f5 03              SBC 3,X
c9ef 85 61              STA FAC1M3
c9f1 b9 02 00           LDA 2,Y
c9f4 f5 02              SBC 2,X
c9f6 85 60              STA FAC1M2
c9f8 b9 01 00           LDA 1,Y
c9fb f5 01              SBC 1,X
c9fd 85 5f              STA FAC1M1
c9ff b0 0c    AFTF_50   BCS Normalise_FAC1
ca01 20 7d ca           JSR Negate_FAC1
ca04 4c 0d ca           JMP Normalise_FAC1

ca07 00 00 00           .FILL $ca0d-* (0) ; 6 bytes

              ; **************
ca0d            Normalise_FAC1
              ; **************

ca0d a0 00              LDY #0              ; Y = 0
ca0f 98                 TYA                 ; A = 0
ca10 18                 CLC
ca11 a6 5f    NF1_10    LDX FAC1M1          ; MSB of mantissa
ca13 d0 4a              BNE AFTF_70         ; -> shift bitwise
ca15 a6 60              LDX FAC1M2          ; shift bytes
ca17 86 5f              STX FAC1M1
ca19 a6 61              LDX FAC1M3
ca1b 86 60              STX FAC1M2
ca1d a6 62              LDX FAC1M4
ca1f 86 61              STX FAC1M3
ca21 a6 6d              LDX FROUND
ca23 86 62              STX FAC1M4
ca25 84 6d              STY FROUND          ; = 0
ca27 69 08              ADC #8              ; A = shift count
ca29 c9 20              CMP #32             ; maximum shift = 32 bit
ca2b d0 e4              BNE NF1_10          ; loop

              ; **********
ca2d            Clear_FAC1
              ; **********

ca2d a9 00              LDA #0
ca2f 85 5e    CF1_10    STA FAC1EX
ca31 85 63              STA FAC1SI
ca33 60                 RTS ;Size    7 [Clear_FAC1]

ca34 65 53    AFTF_60   ADC FUNJMP+1        ; FAC1 rounding byte
ca36 85 6d              STA FROUND
ca38 a5 62              LDA FAC1M4          ; add FAC2 mantissa to FAC1
ca3a 65 6a              ADC FAC2M4
ca3c 85 62              STA FAC1M4
ca3e a5 61              LDA FAC1M3
ca40 65 69              ADC FAC2M3
ca42 85 61              STA FAC1M3
ca44 a5 60              LDA FAC1M2
ca46 65 68              ADC FAC2M2
ca48 85 60              STA FAC1M2
ca4a a5 5f              LDA FAC1M1
ca4c 65 67              ADC FAC2M1
ca4e 85 5f              STA FAC1M1
ca50 4c 6c ca           JMP Mantissa_Overflow

ca53 69 01    AFTF_65   ADC #1
ca55 06 6d              ASL FROUND
ca57 26 62              ROL FAC1M4
ca59 26 61              ROL FAC1M3
ca5b 26 60              ROL FAC1M2
ca5d 26 5f              ROL FAC1M1
ca5f 10 f2    AFTF_70   BPL AFTF_65
ca61 38                 SEC
ca62 e5 5e              SBC FAC1EX
ca64 b0 c7              BCS Clear_FAC1
ca66 49 ff              EOR #$ff
ca68 69 01              ADC #1
ca6a 85 5e              STA FAC1EX

              ; *****************
ca6c            Mantissa_Overflow
              ; *****************

ca6c 90 0e              BCC AFTF_Ret
ca6e e6 5e    AFTF_80   INC FAC1EX
ca70 f0 42              BEQ Overflow_Error
ca72 66 5f              ROR FAC1M1
ca74 66 60              ROR FAC1M2
ca76 66 61              ROR FAC1M3
ca78 66 62              ROR FAC1M4
ca7a 66 6d              ROR FROUND
ca7c 60       AFTF_Ret  RTS ;Size   17 [Mantissa_Overflow]

              ; ***********
ca7d            Negate_FAC1
              ; ***********

ca7d a5 63              LDA FAC1SI
ca7f 49 ff              EOR #$ff
ca81 85 63              STA FAC1SI

              ; ********************
ca83            Negate_FAC1_Mantissa
              ; ********************

ca83 a5 5f              LDA FAC1M1
ca85 49 ff              EOR #$ff
ca87 85 5f              STA FAC1M1
ca89 a5 60              LDA FAC1M2
ca8b 49 ff              EOR #$ff
ca8d 85 60              STA FAC1M2
ca8f a5 61              LDA FAC1M3
ca91 49 ff              EOR #$ff
ca93 85 61              STA FAC1M3
ca95 a5 62              LDA FAC1M4
ca97 49 ff              EOR #$ff
ca99 85 62              STA FAC1M4
ca9b a5 6d              LDA FROUND
ca9d 49 ff              EOR #$ff
ca9f 85 6d              STA FROUND
caa1 e6 6d              INC FROUND
caa3 d0 0e              BNE IFM_Ret

              ; *****************
caa5            Inc_FAC1_Mantissa
              ; *****************

caa5 e6 62              INC FAC1M4
caa7 d0 0a              BNE IFM_Ret
caa9 e6 61              INC FAC1M3
caab d0 06              BNE IFM_Ret
caad e6 60              INC FAC1M2
caaf d0 02              BNE IFM_Ret
cab1 e6 5f              INC FAC1M1
cab3 60       IFM_Ret   RTS ;Size   15 [Inc_FAC1_Mantissa]

              ; **************
cab4            Overflow_Error
              ; **************

cab4 a2 45              LDX #Msg_FLOW-Msg_Start ; $45 OVERFLOW
cab6 4c cf b3           JMP Basic_Error

              ; **********
cab9            Shift_FAC3
              ; **********

cab9 a5 26              LDA FAC3M4
cabb 85 6d              STA FROUND
cabd a5 25              LDA FAC3M3
cabf 85 26              STA FAC3M4
cac1 a5 24              LDA FAC3M2
cac3 85 25              STA FAC3M3
cac5 a5 23              LDA FAC3M1
cac7 85 24              STA FAC3M2
cac9 a9 00              LDA #0
cacb 85 23              STA FAC3M1
cacd 60                 RTS ;Size   21 [Shift_FAC3]

cace 00                 .FILL $cacf-* (0) ; 1 bytes

              ; perform a byte shift right on FAC X
              ; the LSB byte goes to FROUND

              ; ************
cacf            Shift_FACX_A
              ; ************

cacf 20 f6 c6           JSR FACX_LSB
cad2 a5 6d              LDA FROUND          ; byte shifted off
cad4 c0 00              CPY #0
cad6 10 0c              BPL SFA_40          ; return if done
cad8 56 01    SFA_10    LSR 1,X
cada 76 02              ROR 2,X
cadc 76 03              ROR 3,X
cade 76 04              ROR 4,X
cae0 6a                 ROR A               ; A gets bits shifted out
cae1 c8                 INY
cae2 d0 f4              BNE SFA_10
cae4 18       SFA_40    CLC
cae5 60                 RTS ;Size   23 [Shift_FACX_A]

cae6 00 00 00           .FILL $caf2-* (0) ; 12 bytes

              ; **************
caf2            REAL_1 ; $caf2
              ; **************

caf2 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000
caf7 03       VLOG_A    .BYTE $03
caf8 7f 5e 56 cb 79     .REAL $7f5e56cb79   ;    0.43425594189
cafd 80 13 9b 0b 64     .REAL $80139b0b64   ;    0.57658454124
cb02 80 76 38 93 16     .REAL $8076389316   ;    0.96180075919
cb07 82 38 aa 3b 20     .REAL $8238aa3b20   ;    2.88539007306

              ; ***********
cb0c            HALF_SQRT_2
              ; ***********

cb0c 80 35 04 f3 34     .REAL $803504f334   ;    0.70710678119
cb11 81 35 04 SQRT_2    .REAL $813504f334   ;    1.41421356238

              ; *********
cb16            MINUS_0_5
              ; *********

cb16 80 80 00 00 00     .REAL $8080000000   ;   -0.50000000000
cb1b 80 31 72 LN_2      .REAL $80317217f8   ;    0.69314718060

              ; *********
cb20            Basic_LOG
              ; *********

cb20 20 61 cd           JSR Get_FAC1_Sign
cb23 f0 02              BEQ LOG_10
cb25 10 03              BPL LOG_20
cb27 4c 73 c3 LOG_10    JMP Jump_To_Illegal_Quantity
cb2a a5 5e    LOG_20    LDA FAC1EX
cb2c e9 7f              SBC #$7f
cb2e 48                 PHA
cb2f a9 80              LDA #$80
cb31 85 5e              STA FAC1EX
cb33 a9 0c              LDA #<HALF_SQRT_2
cb35 a0 cb              LDY #>HALF_SQRT_2
cb37 20 9d c9           JSR Add_Var_AY_To_FAC1
cb3a a9 11              LDA #<SQRT_2
cb3c a0 cb              LDY #>SQRT_2
cb3e 20 45 cc           JSR AY_Divided_By_FAC1
cb41 a9 f2              LDA #<REAL_1
cb43 a0 ca              LDY #>REAL_1
cb45 20 86 c9           JSR AY_Minus_FAC1
cb48 a9 f7              LDA #<VLOG_A
cb4a a0 ca              LDY #>VLOG_A
cb4c 20 d7 d1           JSR Square_And_Series_Eval
cb4f a9 16              LDA #<MINUS_0_5
cb51 a0 cb              LDY #>MINUS_0_5
cb53 20 9d c9           JSR Add_Var_AY_To_FAC1
cb56 68                 PLA
cb57 20 b4 ce           JSR Add_A_To_FAC1
cb5a a9 1b              LDA #<LN_2
cb5c a0 cb              LDY #>LN_2

              ; *********************
cb5e            Multiply_FAC1_With_AY
              ; *********************

cb5e 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***********
cb61            Op_MULTIPLY
              ; ***********

cb61 f0 5b              BEQ MULT_Ret
cb63 20 ed cb           JSR Check_FAC
cb66 a9 00              LDA #0
cb68 85 23              STA FAC3M1
cb6a 85 24              STA FAC3M2
cb6c 85 25              STA FAC3M3
cb6e 85 26              STA FAC3M4
cb70 a5 6d              LDA FROUND
cb72 20 8c cb           JSR Mult_SubA
cb75 a5 62              LDA FAC1M4
cb77 20 8c cb           JSR Mult_SubA
cb7a a5 61              LDA FAC1M3
cb7c 20 8c cb           JSR Mult_SubA
cb7f a5 60              LDA FAC1M2
cb81 20 8c cb           JSR Mult_SubA
cb84 a5 5f              LDA FAC1M1
cb86 20 91 cb           JSR Mult_SubB
cb89 4c c5 cc           JMP FAC3_To_FAC1

              ; *********
cb8c            Mult_SubA
              ; *********

cb8c d0 03              BNE Mult_SubB       ; do multiply if A is not zero
cb8e 4c b9 ca           JMP Shift_FAC3      ; else shift FAC3 right 8 bits

              ; *********
cb91            Mult_SubB
              ; *********

cb91 4a                 LSR A
cb92 09 80              ORA #$80            ; make sure, that A remains not zero
cb94 a8       MULT_20   TAY                 ; until 8 shifts are done
cb95 90 19              BCC MULT_30
cb97 18                 CLC
cb98 a5 26              LDA FAC3M4
cb9a 65 6a              ADC FAC2M4
cb9c 85 26              STA FAC3M4
cb9e a5 25              LDA FAC3M3
cba0 65 69              ADC FAC2M3
cba2 85 25              STA FAC3M3
cba4 a5 24              LDA FAC3M2
cba6 65 68              ADC FAC2M2
cba8 85 24              STA FAC3M2
cbaa a5 23              LDA FAC3M1
cbac 65 67              ADC FAC2M1
cbae 85 23              STA FAC3M1
cbb0 66 23    MULT_30   ROR FAC3M1
cbb2 66 24              ROR FAC3M2
cbb4 66 25              ROR FAC3M3
cbb6 66 26              ROR FAC3M4
cbb8 66 6d              ROR FROUND
cbba 98                 TYA
cbbb 4a                 LSR A
cbbc d0 d6              BNE MULT_20
cbbe 60       MULT_Ret  RTS ;Size   46 [Mult_SubB]

cbbf 00 00 00           .FILL $cbc2-* (0) ; 3 bytes

              ; *************************
cbc2            Load_FAC2_From_AY ; $cbc2
              ; *************************

              ; Input:  (A/Y) = address of packed floating point value
              ; Output: FAC2  = read floating point value
              ;         A     = exponent of FAC1
              ;         Y     = 0

cbc2 85 1f              STA INDEXA
cbc4 84 20              STY INDEXA+1
cbc6 a0 04              LDY #4
cbc8 b1 1f              LDA (INDEXA),Y
cbca 85 6a              STA FAC2M4
cbcc 88                 DEY
cbcd b1 1f              LDA (INDEXA),Y
cbcf 85 69              STA FAC2M3
cbd1 88                 DEY
cbd2 b1 1f              LDA (INDEXA),Y
cbd4 85 68              STA FAC2M2
cbd6 88                 DEY
cbd7 b1 1f              LDA (INDEXA),Y      ; bit7 = sign
cbd9 85 6b              STA FAC2SI          ; transfer sign to FAC2SI bit7
cbdb 45 63              EOR FAC1SI          ; EOR with sign of FAC1
cbdd 85 6c              STA STRPTR          ; flag sign comparison
cbdf a5 6b              LDA FAC2SI          ; load sign/byte 1 of mantissa
cbe1 09 80              ORA #$80            ; replace sign with 1 (normalize)
cbe3 85 67              STA FAC2M1          ; M1 is now in unpacked mode
cbe5 88                 DEY
cbe6 b1 1f              LDA (INDEXA),Y      ; exponent
cbe8 85 66              STA FAC2EX
cbea a5 5e              LDA FAC1EX          ; return with FAC1 exp in A
cbec 60                 RTS ;Size   43 [Load_FAC2_From_AY]

              ; *********
cbed            Check_FAC
              ; *********

cbed a5 66              LDA FAC2EX
cbef f0 1c    ChFA_10   BEQ ChFA_50         ; -> set FAC1 = 0.0
cbf1 18                 CLC
cbf2 65 5e              ADC FAC1EX          ; (exp 1 + exp 2)
cbf4 90 04              BCC ChFA_20         ; -> no overflow
cbf6 30 1a              BMI ChFA_Err        ; -> overflow
cbf8 18                 CLC
cbf9 2c                 .BYTE $2c
cbfa 10 11    ChFA_20   BPL ChFA_50         ; -> underflow
cbfc 69 80              ADC #$80            ; correct bias
cbfe 85 5e              STA FAC1EX          ; exp 1 += exp 2
cc00 f0 02              BEQ ChFA_30
cc02 a5 6c              LDA STRPTR
cc04 85 63    ChFA_30   STA FAC1SI
cc06 60                 RTS ;Size   26 [Check_FAC]
cc07 a5 63    ChFA_40   LDA FAC1SI
cc09 49 ff              EOR #$ff
cc0b 30 05              BMI ChFA_Err
cc0d 68       ChFA_50   PLA
cc0e 68                 PLA
cc0f 4c 2d ca           JMP Clear_FAC1      ; underflow -> set FAC1 = 0.0
cc12 4c b4 ca ChFA_Err  JMP Overflow_Error  ; overflow  -> error

cc15 00 00 00           .FILL $cc18-* (0) ; 3 bytes

              ; ***************************
cc18            Multiply_FAC1_BY_10 ; $cc18
              ; ***************************

cc18 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2   ; FAC2 = FAC1
cc1b aa                 TAX                               ; A = Exponent
cc1c f0 10              BEQ Mul10_Ret
cc1e 18                 CLC
cc1f 69 02              ADC #2                            ; FAC2 *= 4
cc21 b0 ef              BCS ChFA_Err

              ; **************
cc23            Add_And_Double
              ; **************

cc23 a2 00              LDX #0
cc25 86 6c              STX STRPTR                        ; choose ADD
cc27 20 ad c9           JSR AddSub_FAC2_To_FAC1           ; FAC1 += FAC2   (*  5)
cc2a e6 5e              INC FAC1EX                        ; FAC1 *= 2      (* 10)
cc2c f0 e4              BEQ ChFA_Err
cc2e 60       Mul10_Ret RTS ;Size   12 [Add_And_Double]

              ; ********
cc2f            Float_10
              ; ********

cc2f 84 20 00 00 00     .REAL $8420000000   ;   10.00000000000

              ; *****************
cc34            Divide_FAC1_By_10
              ; *****************

cc34 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
cc37 a9 2f              LDA #<Float_10
cc39 a0 cc              LDY #>Float_10
cc3b a2 00              LDX #0

              ; *****************
cc3d            Divide_FAC2_By_AY
              ; *****************

cc3d 86 6c              STX STRPTR
cc3f 20 d8 cc           JSR Load_FAC1_AY
cc42 4c 48 cc           JMP Op_DIVIDE

              ; ******************
cc45            AY_Divided_By_FAC1
              ; ******************

cc45 20 c2 cb           JSR Load_FAC2_From_AY

              ; *********
cc48            Op_DIVIDE
              ; *********

cc48 f0 76              BEQ Divide_By_Zero
cc4a 20 51 cd           JSR Round_FAC1
cc4d a9 00              LDA #0
cc4f 38                 SEC
cc50 e5 5e              SBC FAC1EX
cc52 85 5e              STA FAC1EX
cc54 20 ed cb           JSR Check_FAC
cc57 e6 5e              INC FAC1EX
cc59 f0 b7              BEQ ChFA_Err
cc5b a2 fc              LDX #$fc            ; wrap around index
cc5d a9 01              LDA #1
cc5f a4 67    DIV_10    LDY FAC2M1
cc61 c4 5f              CPY FAC1M1
cc63 d0 10              BNE DIV_20
cc65 a4 68              LDY FAC2M2
cc67 c4 60              CPY FAC1M2
cc69 d0 0a              BNE DIV_20
cc6b a4 69              LDY FAC2M3
cc6d c4 61              CPY FAC1M3
cc6f d0 04              BNE DIV_20
cc71 a4 6a              LDY FAC2M4
cc73 c4 62              CPY FAC1M4
cc75 08       DIV_20    PHP
cc76 2a                 ROL A
cc77 90 09              BCC DIV_30
cc79 e8                 INX
cc7a 95 26              STA FAC3M4,X
cc7c f0 32              BEQ DIV_60
cc7e 10 34              BPL DIV_70
cc80 a9 01              LDA #1
cc82 28       DIV_30    PLP
cc83 b0 0e              BCS DIV_50
cc85 06 6a    DIV_40    ASL FAC2M4
cc87 26 69              ROL FAC2M3
cc89 26 68              ROL FAC2M2
cc8b 26 67              ROL FAC2M1
cc8d b0 e6              BCS DIV_20
cc8f 30 ce              BMI DIV_10
cc91 10 e2              BPL DIV_20
cc93 a8       DIV_50    TAY
cc94 a5 6a              LDA FAC2M4
cc96 e5 62              SBC FAC1M4
cc98 85 6a              STA FAC2M4
cc9a a5 69              LDA FAC2M3
cc9c e5 61              SBC FAC1M3
cc9e 85 69              STA FAC2M3
cca0 a5 68              LDA FAC2M2
cca2 e5 60              SBC FAC1M2
cca4 85 68              STA FAC2M2
cca6 a5 67              LDA FAC2M1
cca8 e5 5f              SBC FAC1M1
ccaa 85 67              STA FAC2M1
ccac 98                 TYA
ccad 4c 85 cc           JMP DIV_40
ccb0 a9 40    DIV_60    LDA #$40
ccb2 d0 ce              BNE DIV_30
ccb4 0a       DIV_70    ASL A
ccb5 0a                 ASL A
ccb6 0a                 ASL A
ccb7 0a                 ASL A
ccb8 0a                 ASL A
ccb9 0a                 ASL A
ccba 85 6d              STA FROUND
ccbc 28                 PLP
ccbd 4c c5 cc           JMP FAC3_To_FAC1

              ; **************
ccc0            Divide_By_Zero
              ; **************

ccc0 a2 85              LDX #Msg_DIV-Msg_Start ; $85
ccc2 4c cf b3           JMP Basic_Error

              ; ************
ccc5            FAC3_To_FAC1
              ; ************

ccc5 a5 23              LDA FAC3M1
ccc7 85 5f              STA FAC1M1
ccc9 a5 24              LDA FAC3M2
cccb 85 60              STA FAC1M2
cccd a5 25              LDA FAC3M3
cccf 85 61              STA FAC1M3
ccd1 a5 26              LDA FAC3M4
ccd3 85 62              STA FAC1M4
ccd5 4c 0d ca           JMP Normalise_FAC1

              ; ********************
ccd8            Load_FAC1_AY ; $ccd8
              ; ********************

ccd8 85 1f              STA INDEXA
ccda 84 20              STY INDEXA+1
ccdc a0 04              LDY #4
ccde b1 1f    LFAY_10   LDA (INDEXA),Y
cce0 99 5e 00           STA FAC1EX,Y
cce3 88                 DEY
cce4 10 f8              BPL LFAY_10
cce6 c8                 INY                 ; Y = 0
cce7 84 6d              STY FROUND          ; rounding byte
cce9 a5 5f              LDA FAC1M1
cceb 85 63              STA FAC1SI
cced 09 80              ORA #$80
ccef 85 5f              STA FAC1M1
ccf1 a5 5e              LDA FAC1EX
ccf3 60                 RTS ;Size   28 [Load_FAC1_AY]

              ; ********
ccf4            Set_FAC1
              ; ********

ccf4 85 5f              STA FAC1M1
ccf6 85 60              STA FAC1M2
ccf8 85 61              STA FAC1M3
ccfa 85 62              STA FAC1M4
ccfc 60                 RTS ;Size    9 [Set_FAC1]

ccfd                    .FILL $ccfd-* (0) ; 0 bytes

              ; **********************
ccfd            FAC1_To_FACTPB ; $ccfd
              ; **********************

ccfd a2 59              LDX #FACTPB ; $59
ccff 2c                 .BYTE $2c

              ; **************
cd00            FAC1_To_FACTPA
              ; **************

cd00 a2 54              LDX #<FACTPA
cd02 a0 00              LDY #>FACTPA
cd04 f0 04              BEQ FAC1_To_XY      ; always

              ; **************
cd06            FAC1_To_FORPNT
              ; **************

cd06 a6 46              LDX FORPNT
cd08 a4 47              LDY FORPNT+1

              ; **********
cd0a            FAC1_To_XY
              ; **********

cd0a 20 51 cd           JSR Round_FAC1
cd0d 86 1f              STX INDEXA
cd0f 84 20              STY INDEXA+1
cd11 a0 04              LDY #4
cd13 a5 62              LDA FAC1M4
cd15 91 1f              STA (INDEXA),Y
cd17 88                 DEY
cd18 a5 61              LDA FAC1M3
cd1a 91 1f              STA (INDEXA),Y
cd1c 88                 DEY
cd1d a5 60              LDA FAC1M2
cd1f 91 1f              STA (INDEXA),Y
cd21 88                 DEY
cd22 a5 63              LDA FAC1SI
cd24 09 7f              ORA #$7f
cd26 25 5f              AND FAC1M1
cd28 91 1f              STA (INDEXA),Y
cd2a 88                 DEY
cd2b a5 5e              LDA FAC1EX
cd2d 91 1f              STA (INDEXA),Y
cd2f 84 6d              STY FROUND
cd31 60                 RTS ;Size   40 [FAC1_To_XY]

              ; ************
cd32            FAC2_To_FAC1
              ; ************

cd32 a5 6b              LDA FAC2SI

              ; *********************
cd34            Copy_ABS_FAC2_To_FAC1
              ; *********************

cd34 85 63              STA FAC1SI
cd36 a2 05              LDX #5
cd38 b5 65    F1F2_10   LDA FAC2EX-1,X
cd3a 95 5d              STA FAC1EX-1,X
cd3c ca                 DEX
cd3d d0 f9              BNE F1F2_10
cd3f 86 6d              STX FROUND ; 0
cd41 60                 RTS ;Size   14 [Copy_ABS_FAC2_To_FAC1]

              ; ***************************
cd42            FAC1_Round_And_Copy_To_FAC2
              ; ***************************

cd42 20 51 cd           JSR Round_FAC1

              ; ************
cd45            FAC1_To_FAC2
              ; ************

cd45 a2 06              LDX #6
cd47 b5 5d    FA12_10   LDA FAC1EX-1,X
cd49 95 65              STA FAC2EX-1,X
cd4b ca                 DEX
cd4c d0 f9              BNE FA12_10
cd4e 86 6d              STX FROUND ; 0
cd50 60       FA12_Ret  RTS ;Size   12 [FAC1_To_FAC2]

              ; **********
cd51            Round_FAC1
              ; **********

cd51 a5 5e              LDA FAC1EX
cd53 f0 fb              BEQ FA12_Ret
cd55 06 6d              ASL FROUND
cd57 90 f7              BCC FA12_Ret

              ; ********
cd59            Inc_FAC1
              ; ********

cd59 20 a5 ca           JSR Inc_FAC1_Mantissa
cd5c d0 f2              BNE FA12_Ret
cd5e 4c 6e ca           JMP AFTF_80

              ; *************
cd61            Get_FAC1_Sign
              ; *************

cd61 a5 5e              LDA FAC1EX
cd63 f0 09              BEQ GFS_Ret
cd65 a5 63    GFS_10    LDA FAC1SI
cd67 2a       GFS_20    ROL A
cd68 a9 ff              LDA #$ff
cd6a b0 02              BCS GFS_Ret
cd6c a9 01              LDA #1
cd6e 60       GFS_Ret   RTS ;Size   14 [Get_FAC1_Sign]

              ; *********
cd6f            Basic_SGN
              ; *********

cd6f 20 61 cd           JSR Get_FAC1_Sign

              ; *********
cd72            A_To_FAC1
              ; *********

cd72 85 5f              STA FAC1M1
cd74 a9 00              LDA #0
cd76 85 60              STA FAC1M2
cd78 a2 88              LDX #$88
cd7a a5 5f    ATOF_10   LDA FAC1M1
cd7c 49 ff              EOR #$ff
cd7e 2a                 ROL A               ; clear carry for negative numbers

              ; ***********************
cd7f            Convert_Integer_To_Real
              ; ***********************

cd7f a9 00              LDA #0
cd81 85 62              STA FAC1M4
cd83 85 61              STA FAC1M3
cd85 86 5e    CITR_10   STX FAC1EX
cd87 85 6d              STA FROUND
cd89 85 63              STA FAC1SI
cd8b 4c ff c9           JMP AFTF_50

              ; *********
cd8e            Basic_ABS
              ; *********

cd8e 46 63              LSR FAC1SI          ; clear bit 7 (sign)
cd90 60                 RTS ;Size    3 [Basic_ABS]

              ; ***************
cd91            Compare_FAC1_AY
              ; ***************

cd91 85 21              STA INDEXB

              ; *********************
cd93            Compare_FAC1_INDEXB_Y
              ; *********************

cd93 84 22              STY INDEXB+1        ; (INDEXB) = operand 2
cd95 a0 00              LDY #0
cd97 b1 21              LDA (INDEXB),Y      ; exp 2
cd99 c8                 INY                 ; Y = 1
cd9a aa                 TAX
cd9b f0 c4              BEQ Get_FAC1_Sign   ; branch if operand 2 is zero
cd9d b1 21              LDA (INDEXB),Y      ; M1
cd9f 45 63              EOR FAC1SI          ; EOR both sign bits
cda1 30 c2              BMI GFS_10          ; branch on different signs
cda3 e4 5e              CPX FAC1EX          ; compare exponents
cda5 d0 21              BNE CFAY_10         ; branch if not equal
cda7 b1 21              LDA (INDEXB),Y      ; M1
cda9 09 80              ORA #$80            ; remove sign
cdab c5 5f              CMP FAC1M1          ; compare M1's
cdad d0 19              BNE CFAY_10
cdaf c8                 INY                 ; Y = 2
cdb0 b1 21              LDA (INDEXB),Y
cdb2 c5 60              CMP FAC1M2          ; compare M2's
cdb4 d0 12              BNE CFAY_10
cdb6 c8                 INY                 ; Y = 3
cdb7 b1 21              LDA (INDEXB),Y
cdb9 c5 61              CMP FAC1M3          ; compare M3's
cdbb d0 0b              BNE CFAY_10
cdbd c8                 INY                 ; Y = 4
cdbe a9 7f              LDA #$7f
cdc0 c5 6d              CMP FROUND          ; $7f >= FROUND ?
cdc2 b1 21              LDA (INDEXB),Y
cdc4 e5 62              SBC FAC1M4          ; compare M4's and FROUND
cdc6 f0 39              BEQ FLSR_Ret
cdc8 a5 63    CFAY_10   LDA FAC1SI
cdca 90 02              BCC CFAY_20
cdcc 49 ff              EOR #$ff
cdce 4c 67 cd CFAY_20   JMP GFS_20

              ; ********
cdd1            FAC1_LSR
              ; ********

              ; Shift FAC1 right until the exponent is at $a0.
              ; This is the value for which the four mantissa bytes
              ; represent a 32 bit integer value.

cdd1 a5 5e              LDA FAC1EX
cdd3 d0 03              BNE FLSR_20
cdd5 4c f4 cc FLSR_10   JMP Set_FAC1        ; clear mantissa for zero exp
cdd8 38       FLSR_20   SEC
cdd9 e9 a0              SBC #$a0
cddb 20 f4 c6           JSR FAC1_LSB        ; shift bytes
cdde f0 1f              BEQ FLSR_40         ; -> done
cde0 a5 65              LDA BITS            ; check integer status
cde2 f0 02              BEQ FLSR_30         ; branch on integer
cde4 a9 80              LDA #$80            ; real
cde6 46 5f    FLSR_30   LSR FAC1M1          ; do a bit shift
cde8 66 60              ROR FAC1M2
cdea 66 61              ROR FAC1M3
cdec 66 62              ROR FAC1M4
cdee 66 6d              ROR FROUND
cdf0 05 6d              ORA FROUND          ; remember bits shifted off
cdf2 c8                 INY
cdf3 d0 f1              BNE FLSR_30
cdf5 24 63              BIT FAC1SI
cdf7 10 06              BPL FLSR_40         ; positive: finished
cdf9 0a                 ASL A               ; any 1 bits shifted off ?
cdfa 90 03              BCC FLSR_40         ; -> number was exact integer
cdfc 20 a5 ca           JSR Inc_FAC1_Mantissa ; subtract 1 from negative number
cdff 84 6d    FLSR_40   STY FROUND          ; FROUND = 0
ce01 60       FLSR_Ret  RTS ;Size   49 [FAC1_LSR]

ce02                    .FILL $ce02-* (0) ; 0 bytes

              ; *****************
ce02            Basic_INT ; $ce02
              ; *****************

              ; The BASIC int function is not restricted to the 16 bit
              ; range of integer variables. Its range is 32 bit.
              ; INT does not round, it looks for the integer lower or
              ; equal to the given value. E.g: int(-1.1) results in -2.

ce02 a5 5e              LDA FAC1EX
ce04 c9 a0              CMP #$a0
ce06 b0 f9              BCS FLSR_Ret        ; -> no bits after decimal point
ce08 20 d1 cd           JSR FAC1_LSR        ; normalise to integer
ce0b a9 a0              LDA #$a0
ce0d 85 5e              STA FAC1EX          ; set exponent for integer mantissa
ce0f a5 62              LDA FAC1M4
ce11 24 63              BIT FAC1SI
ce13 10 05              BPL INT_10
ce15 38                 SEC
ce16 a9 00              LDA #0
ce18 e5 62              SBC FAC1M4
ce1a 85 03    INT_10    STA CHARAC          ; needed from Basic_EXP
ce1c 4c 0d ca           JMP Normalise_FAC1  ; normalise back to real

ce1f 00 00 00           .FILL $ce29-* (0) ; 10 bytes

              ; *************************
ce29            Read_Real_To_FAC1 ; $ce29
              ; *************************

              ; This subroutine parses a string via CHRGET and
              ; converts it into a floating point value in FAC1.

              ;         TMPVAR   = digits after decimal point
              ;         TMPVAR+1 = exponent
              ;         TMPPTC   = bit 7 : flag for '.' decimal point
              ;         TMPPTC+1 = bit 7 : flag for '-' sign

ce29 a0 00              LDY #0
ce2b a2 0a              LDX #10
ce2d 94 5a    RRTF_02   STY TMPVAR,X        ; clear TMPVAR, TMPPTC and FAC1
ce2f ca                 DEX
ce30 10 fb              BPL RRTF_02         ; X = $ff at end
ce32 90 68              BCC RRTF_34         ; -> numeric
ce34 c9 2b              CMP #'+'            ; positive sign ?
ce36 f0 06              BEQ RRTF_04         ; -> get next
ce38 c9 2d              CMP #'-'            ; negative sign ?
ce3a d0 07              BNE RRTF_06
ce3c 86 64              STX SGNFLG          ; sign flag = $ff
ce3e 20 70 00 RRTF_04   JSR CHRGET          ; next character after sign
ce41 90 59              BCC RRTF_34         ; -> numeric
ce43 c9 2e    RRTF_06   CMP #'.'            ; decimal point ?
ce45 f0 2c              BEQ RRTF_20         ; -> now the fractional part
ce47 c9 45              CMP #'E'            ; exponent ?
ce49 d0 2e              BNE RRTF_22
ce4b 20 70 00           JSR CHRGET          ; read character of exponent
ce4e 90 77              BCC RRTF_40         ; -> numeric
ce50 c9 aa              CMP #$aa            ; '+' token
ce52 f0 0e              BEQ RRTF_10
ce54 c9 2b              CMP #'+'            ; '+' sign of exponent
ce56 f0 0a              BEQ RRTF_10
ce58 c9 ab              CMP #$ab            ; '-' token
ce5a f0 04              BEQ RRTF_08
ce5c c9 2d              CMP #'-'            ; '-' sign of exponent
ce5e d0 07              BNE RRTF_12
ce60 66 5d    RRTF_08   ROR TMPPTC+1        ; flag negative sign
ce62 20 70 00 RRTF_10   JSR CHRGET          ; read character of exponent
ce65 90 60              BCC RRTF_40         ; -> numeric
ce67 24 5d    RRTF_12   BIT TMPPTC+1
ce69 10 0e              BPL RRTF_22         ; -> positive exponent
ce6b a9 00              LDA #0
ce6d 38                 SEC
ce6e e5 5b              SBC TMPVAR+1        ; -> negative exponent
ce70 4c 7b ce           JMP RRTF_24

ce73 66 5c    RRTF_20   ROR TMPPTC          ; bit 7 = flag for '.'
ce75 24 5c              BIT TMPPTC
ce77 50 c5              BVC RRTF_04         ; break if 2nd. dot read

ce79 a5 5b    RRTF_22   LDA TMPVAR+1        ; exponent read
ce7b 38       RRTF_24   SEC
ce7c e5 5a              SBC TMPVAR          ; minus # of digits after '.'
ce7e 85 5b              STA TMPVAR+1        ; effective exponent
ce80 f0 12              BEQ RRTF_30         ; -> zero exponent
ce82 10 09              BPL RRTF_28         ; -> pos. exponent

ce84 20 34 cc RRTF_26   JSR Divide_FAC1_By_10 ; neg. exponent
ce87 e6 5b              INC TMPVAR+1
ce89 d0 f9              BNE RRTF_26
ce8b f0 07              BEQ RRTF_30

ce8d 20 18 cc RRTF_28   JSR Multiply_FAC1_BY_10 ; apply positive exponent
ce90 c6 5b              DEC TMPVAR+1
ce92 d0 f9              BNE RRTF_28

ce94 a5 64    RRTF_30   LDA SGNFLG
ce96 30 01              BMI RRTF_32         ; -> negate result
ce98 60                 RTS ;Size  112 [Read_Real_To_FAC1]

ce99 4c 4b d1 RRTF_32   JMP Op_NEGATE

ce9c 48       RRTF_34   PHA                 ; result = result * 10 + digit
ce9d 24 5c              BIT TMPPTC
ce9f 10 02              BPL RRTF_36
cea1 e6 5a              INC TMPVAR          ; count digits after decimal point
cea3 20 18 cc RRTF_36   JSR Multiply_FAC1_BY_10
cea6 68                 PLA
cea7 29 0f              AND #15             ; PETSCII -> binary
cea9 20 b4 ce           JSR Add_A_To_FAC1
ceac 4c 3e ce           JMP RRTF_04

ceaf 00 00 00           .FILL $ceb4-* (0) ; 5 bytes

              ; *********************
ceb4            Add_A_To_FAC1 ; $ceb4
              ; *********************

ceb4 48                 PHA
ceb5 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
ceb8 68                 PLA
ceb9 20 72 cd           JSR A_To_FAC1
cebc a5 6b              LDA FAC2SI
cebe 45 63              EOR FAC1SI
cec0 85 6c              STA STRPTR
cec2 a6 5e              LDX FAC1EX
cec4 4c a0 c9           JMP Op_PLUS

              ; read digits for exponent

cec7 a5 5b    RRTF_40   LDA TMPVAR+1        ; exponent so far
cec9 c9 0a              CMP #10             ; alreay two digits ?
cecb 90 09              BCC RRTF_42         ; -> OK if less than 10
cecd a9 64              LDA #100            ; exponent = 100
cecf 24 5d              BIT TMPPTC+1
ced1 30 11              BMI RRTF_44         ; -> negative exponent
ced3 4c b4 ca           JMP Overflow_Error  ; max value = 37
ced6 0a       RRTF_42   ASL A               ; * 2
ced7 0a                 ASL A               ; * 4
ced8 18                 CLC
ced9 65 5b              ADC TMPVAR+1        ; * 5
cedb 0a                 ASL A               ; * 10
cedc 18                 CLC
cedd a0 00              LDY #0
cedf 71 77              ADC (TXTPTR),Y
cee1 38                 SEC
cee2 e9 30              SBC #'0'
cee4 85 5b    RRTF_44   STA TMPVAR+1        ; new value for exponent
cee6 4c 62 ce           JMP RRTF_10

              ; *********
cee9            REAL_1e8
              ; *********

cee9 9b 3e bc 20 00     .REAL $9b3ebc2000   ; 1e8

              ; *********
ceee            REAL_9x9
              ; *********

ceee 9e 6e 6b 27 fe     .REAL $9e6e6b27fe   ;  999999999.5

              ; *********
cef3            REAL_1e9
              ; *********

cef3 9e 6e 6b 28 00     .REAL $9e6e6b2800   ; 1e9

cef8 42 53 4f BSOS_TEXT .BYTE "BSOS BOOT"

              ; **********
cf01            Option_ROM
              ; **********

cf01 a2 03              LDX #3
cf03 bd 00 90 OpRO_10   LDA $9000,X         ; check $9000 ROM
cf06 dd f8 ce           CMP BSOS_TEXT,X
cf09 d0 06              BNE OpRO_20
cf0b ca                 DEX
cf0c 10 f5              BPL OpRO_10
cf0e 20 04 90           JSR $9004
cf11 a2 03    OpRO_20   LDX #3
cf13 bd 00 a0 OpRO_30   LDA $a000,X         ; check $a000 ROM
cf16 dd f8 ce           CMP BSOS_TEXT,X
cf19 d0 06              BNE OpRO_40
cf1b ca                 DEX
cf1c 10 f5              BPL OpRO_30
cf1e 4c 04 a0           JMP $a004
cf21 60       OpRO_40   RTS ;Size   33 [Option_ROM]

              ; *********
cf22            BOOT_File
              ; *********

cf22 24 98              BIT Key_Flags
cf24 10 fb              BPL OpRO_40         ; skip if SHIFT pressed
cf26 a9 f8              LDA #<BSOS_TEXT     ; look for boot file
cf28 85 da              STA FNADR
cf2a a9 ce              LDA #>BSOS_TEXT
cf2c 85 db              STA FNADR+1
cf2e a9 09              LDA #?BSOS_TEXT
cf30 85 d1              STA FNLEN
cf32 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
cf35 a9 00              LDA #0
cf37 85 d3              STA SA              ; enforce load to $0401
cf39 a5 28              LDA TXTTAB
cf3b a6 29              LDX TXTTAB+1
cf3d 85 c9              STA EAL             ; TXTTAB (normally $0401)
cf3f 86 ca              STX EAL+1
cf41 20 d0 f3           JSR Open_Load_File
cf44 a5 96              LDA STATUS
cf46 f0 06              BEQ BOFi_10
cf48 20 ae f1           JSR UNTLK           ; not there
cf4b 4c 91 d9           JMP Kernal_Read_DS  ; clear status and return
cf4e 20 8e f3 BOFi_10   JSR LoFi_30         ; load boot file
cf51 a5 c9              LDA EAL
cf53 85 2a              STA VARTAB
cf55 a5 ca              LDA EAL+1
cf57 85 2b              STA VARTAB+1
cf59 20 e9 b5           JSR Reset_BASIC_Execution
cf5c 20 b6 b4           JSR Rechain
cf5f 4c 4a b7           JMP Execute

cf62 00 00 00           .FILL $cf78-* (0) ; 22 bytes

              ; ********
cf78            Print_IN
              ; ********

cf78 a9 0d              LDA #<Msg_IN
cf7a a0 b3              LDY #>Msg_IN
cf7c 20 90 cf           JSR To_Print_String
cf7f a5 37              LDA CURLIN+1
cf81 a6 36              LDX CURLIN

              ; ****************
cf83            Print_Integer_XA
              ; ****************

cf83 85 5f              STA FAC1M1
cf85 86 60              STX FAC1M2
cf87 a2 90              LDX #$90
cf89 38                 SEC
cf8a 20 7f cd           JSR Convert_Integer_To_Real
cf8d 20 93 cf           JSR Format_FAC1

              ; ***************
cf90            To_Print_String
              ; ***************

cf90 4c 1d bb           JMP Print_String

              ; *******************
cf93            Format_FAC1 ; $cf93
              ; *******************

cf93 a0 01              LDY #1              ; start of string storage

              ; =====================
cf95            Format_FAC1_Y ; $cf95
              ; =====================

              ; Format floating point number in FAC1
              ; The string is stored starting at $ff for Y=0
              ; and extending into the bottom of the stack

cf95 a9 00              LDA #0
cf97 85 5a              STA TMPVAR          ; 10's exponent

              ; the first character is blank for positive or '-'
              ; for negative numbers

cf99 a9 20              LDA #' '
cf9b 24 63              BIT FAC1SI
cf9d 10 02              BPL FoFA_02
cf9f a9 2d              LDA #'-'
cfa1 99 ff 00 FoFA_02   STA STACK-1,Y       ; 1.st char ' ' or '-'
cfa4 85 63              STA FAC1SI          ; delete sign info from FAC1
cfa6 84 6e              STY TMPPTD          ; save Y
cfa8 c8                 INY                 ; next string position
cfa9 a9 30              LDA #'0'            ; default for value zero

              ; if the value is zero, store '0' and finish

cfab a6 5e              LDX FAC1EX
cfad d0 03              BNE FoFA_04         ; -> non zero
cfaf 4c b6 d0           JMP FoFA_94         ; store '0' and finish

              ; if the value is less than 1.0, scale it with 1.0e+9
              ; and store the scaled 10's exponent (-9) in TMPVAR
              ; this saves 9 iterations in loop FoFA_08

cfb2 a9 00    FoFA_04   LDA #0
cfb4 e0 81              CPX #$81            ; exponent for >= 1.0
cfb6 b0 09              BCS FoFA_06
cfb8 a9 f3              LDA #<REAL_1e9
cfba a0 ce              LDY #>REAL_1e9
cfbc 20 5e cb           JSR Multiply_FAC1_With_AY
cfbf a9 f7              LDA #-9
cfc1 85 5a    FoFA_06   STA TMPVAR          ; current 10's exponent

              ; scale FAC1 up until the number has more than 8 digits

cfc3 a9 e9    FoFA_08   LDA #<REAL_1e8
cfc5 a0 ce              LDY #>REAL_1e8
cfc7 20 91 cd           JSR Compare_FAC1_AY
cfca 10 0c              BPL FoFA_12         ; FAC1 >= REAL_1e8 ->
cfcc 20 18 cc           JSR Multiply_FAC1_BY_10
cfcf c6 5a              DEC TMPVAR          ; decrement 10's exponent
cfd1 d0 f0              BNE FoFA_08         ; always

              ; scale FAC1 down until the number has less than 10 digits

cfd3 20 34 cc FoFA_10   JSR Divide_FAC1_By_10
cfd6 e6 5a              INC TMPVAR          ; increment 10's exponent
cfd8 a9 ee    FoFA_12   LDA #<REAL_9x9
cfda a0 ce              LDY #>REAL_9x9      ; 999999999.5
cfdc 20 91 cd           JSR Compare_FAC1_AY
cfdf 10 f2              BPL FoFA_10         ; FAC1 > REAL_9x9 -> continue scaling

              ; scaling is done - now convert the digits before the decimal
              ; point into a 32 bit integer

cfe1 20 7f c9           JSR Add_0_5_To_FAC1 ; add 0.5 for rounding
cfe4 20 d1 cd           JSR FAC1_LSR        ; convert to integer

              ; choose fixed point format if -2 < exp < 10
              ; else format in exponential format

cfe7 a2 01              LDX #1
cfe9 a5 5a              LDA TMPVAR          ; current 10's exponent
cfeb 18                 CLC
cfec 69 0a              ADC #10             ; exp difference
cfee 30 09              BMI FoFA_14         ; value < 1.0
cff0 c9 0b              CMP #11
cff2 b0 06              BCS FoFA_16         ; value >= 1e9
cff4 69 ff              ADC #$ff
cff6 aa                 TAX                 ; X = exp + 9
cff7 a9 02              LDA #2              ; fixed point
cff9 38       FoFA_14   SEC
cffa e9 02    FoFA_16   SBC #2
cffc 85 5b              STA TMPVAR+1        ; exp print = 0 or exp+8
cffe 86 5a              STX TMPVAR          ; digits before decimal point
d000 8a                 TXA
d001 f0 02              BEQ FoFA_18         ; -> if no digits before point
d003 10 13              BPL FoFA_22
d005 a4 6e    FoFA_18   LDY TMPPTD
d007 a9 2e              LDA #'.'
d009 c8                 INY
d00a 99 ff 00           STA STACK-1,Y       ; insert decimal point
d00d 8a                 TXA
d00e f0 06              BEQ FoFA_20
d010 a9 30              LDA #'0'
d012 c8                 INY
d013 99 ff 00           STA STACK-1,Y       ; insert '0'
d016 84 6e    FoFA_20   STY TMPPTD
d018 a0 00    FoFA_22   LDY #0

              ; =================
d01a            Format_Jiffyclock
              ; =================

d01a a2 80              LDX #$80
d01c 18       FoFA_78   CLC
d01d a5 62              LDA FAC1M4
d01f 79 cf d0           ADC Decimal_Conversion_Table+3,Y
d022 85 62              STA FAC1M4
d024 a5 61              LDA FAC1M3
d026 79 ce d0           ADC Decimal_Conversion_Table+2,Y
d029 85 61              STA FAC1M3
d02b a5 60              LDA FAC1M2
d02d 79 cd d0           ADC Decimal_Conversion_Table+1,Y
d030 85 60              STA FAC1M2
d032 a5 5f              LDA FAC1M1
d034 79 cc d0           ADC Decimal_Conversion_Table,Y
d037 85 5f              STA FAC1M1
d039 e8                 INX
d03a b0 04              BCS FoFA_80
d03c 10 de              BPL FoFA_78
d03e 30 02              BMI FoFA_82

d040 30 da    FoFA_80   BMI FoFA_78
d042 8a       FoFA_82   TXA
d043 90 04              BCC FoFA_84
d045 49 ff              EOR #$ff
d047 69 0a              ADC #10
d049 69 2f    FoFA_84   ADC #'0'-1
d04b c8                 INY
d04c c8                 INY
d04d c8                 INY
d04e c8                 INY                 ; Y += 4
d04f 84 44              STY VARPTR          ; save index to table
d051 a4 6e              LDY TMPPTD          ; get index to string
d053 c8                 INY
d054 aa                 TAX
d055 29 7f              AND #$7f
d057 99 ff 00           STA STACK-1,Y       ; store digit
d05a c6 5a              DEC TMPVAR          ; # of digits
d05c d0 06              BNE FoFA_86         ; -> if not zero
d05e a9 2e              LDA #'.'
d060 c8                 INY
d061 99 ff 00           STA STACK-1,Y       ; store decimal point
d064 84 6e    FoFA_86   STY TMPPTD          ; save string index
d066 a4 44              LDY VARPTR          ; get table index
d068 8a                 TXA
d069 49 ff              EOR #$ff
d06b 29 80              AND #$80
d06d aa                 TAX
d06e c0 24              CPY #$24            ; end of decimal table ?
d070 f0 04              BEQ FoFA_88
d072 c0 3c              CPY #$3c            ; end of jiffy table ?
d074 d0 a6              BNE FoFA_78

              ; remove trailing zeroes

d076 a4 6e    FoFA_88   LDY TMPPTD          ; get string index
d078 b9 ff 00 FoFA_90   LDA STACK-1,Y
d07b 88                 DEY
d07c c9 30              CMP #'0'
d07e f0 f8              BEQ FoFA_90
d080 c9 2e              CMP #'.'
d082 f0 01              BEQ FoFA_91
d084 c8                 INY
d085 a9 2b    FoFA_91   LDA #'+'            ; default sign for exponent
d087 a6 5b              LDX TMPVAR+1
d089 f0 2e              BEQ FoFA_95         ; -> no exponent
d08b 10 08              BPL FoFA_92         ; -> positive exponent
d08d a9 00              LDA #0
d08f 38                 SEC
d090 e5 5b              SBC TMPVAR+1        ; negate exponent
d092 aa                 TAX
d093 a9 2d              LDA #'-'            ; negative sign for exponent
d095 99 01 01 FoFA_92   STA STACK+1,Y
d098 a9 45              LDA #'E'
d09a 99 00 01           STA STACK,Y
d09d 8a                 TXA
d09e a2 2f              LDX #'0'-1
d0a0 38                 SEC
d0a1 e8       FoFA_93   INX
d0a2 e9 0a              SBC #10
d0a4 b0 fb              BCS FoFA_93
d0a6 69 3a              ADC #'0'+10
d0a8 99 03 01           STA STACK+3,Y
d0ab 8a                 TXA
d0ac 99 02 01           STA STACK+2,Y
d0af a9 00              LDA #0
d0b1 99 04 01           STA STACK+4,Y
d0b4 f0 08              BEQ FoFA_96         ; always

d0b6 99 ff 00 FoFA_94   STA STACK-1,Y
d0b9 a9 00    FoFA_95   LDA #0
d0bb 99 00 01           STA STACK,Y
d0be a9 00    FoFA_96   LDA #0
d0c0 a0 01              LDY #1
d0c2 60                 RTS ;Size  304 [Format_FAC1]

d0c3 00 00 00           .FILL $d0c7-* (0) ; 4 bytes

              ; *****************
d0c7            Float_0_5 ; $d0c7
              ; *****************

d0c7 80 00 00 00 00     .REAL $8000000000   ;    0.50000000000

              ; ************************
d0cc            Decimal_Conversion_Table
              ; ************************

d0cc fa 0a 1f           .QUAD $fa0a1f00     ; -100000000
d0d0 00 98 96           .QUAD $00989680     ;   10000000
d0d4 ff f0 bd           .QUAD $fff0bdc0     ;   -1000000
d0d8 00 01 86           .QUAD $000186a0     ;     100000
d0dc ff ff d8           .QUAD $ffffd8f0     ;     -10000
d0e0 00 00 03           .QUAD $000003e8     ;       1000
d0e4 ff ff ff           .QUAD $ffffff9c     ;       -100
d0e8 00 00 00           .QUAD $0000000a     ;         10
d0ec ff ff ff           .QUAD $ffffffff     ;         -1

              ; **********************
d0f0            Jiffy_Conversion_Table
              ; **********************

d0f0 ff df 0a           .QUAD $ffdf0a80     ;   -2160000
d0f4 00 03 4b           .QUAD $00034bc0     ;     216000
d0f8 ff ff 73           .QUAD $ffff7360     ;     -36000
d0fc 00 00 0e           .QUAD $00000e10     ;       3600
d100 ff ff fd           .QUAD $fffffda8     ;       -600
d104 00 00 00           .QUAD $0000003c     ;         60

              ; *****************
d108            Basic_SQR ; $d108
              ; *****************

d108 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d10b a9 c7              LDA #<Float_0_5
d10d a0 d0              LDY #>Float_0_5
d10f 20 d8 cc           JSR Load_FAC1_AY    ; perform (arg)^0.5

              ; ********
d112            Op_POWER
              ; ********

d112 f0 70              BEQ Basic_EXP       ; -> FAC1 == 0
d114 a5 66              LDA FAC2EX
d116 d0 03              BNE PWR_10
d118 4c 2f ca           JMP CF1_10
d11b a2 4b    PWR_10    LDX #<FUNCPT
d11d a0 00              LDY #>FUNCPT
d11f 20 0a cd           JSR FAC1_To_XY
d122 a5 6b              LDA FAC2SI
d124 10 0f              BPL PWR_20
d126 20 02 ce           JSR Basic_INT
d129 a9 4b              LDA #<FUNCPT
d12b a0 00              LDY #>FUNCPT
d12d 20 91 cd           JSR Compare_FAC1_AY
d130 d0 03              BNE PWR_20
d132 98                 TYA
d133 a4 03              LDY CHARAC
d135 20 34 cd PWR_20    JSR Copy_ABS_FAC2_To_FAC1
d138 98                 TYA
d139 48                 PHA
d13a 20 20 cb           JSR Basic_LOG
d13d a9 4b              LDA #<FUNCPT
d13f a0 00              LDY #>FUNCPT
d141 20 5e cb           JSR Multiply_FAC1_With_AY
d144 20 84 d1           JSR Basic_EXP
d147 68                 PLA
d148 4a                 LSR A
d149 90 0a              BCC NEGA_Ret

              ; *********
d14b            Op_NEGATE
              ; *********

d14b a5 5e              LDA FAC1EX
d14d f0 06              BEQ NEGA_Ret
d14f a5 63              LDA FAC1SI
d151 49 ff              EOR #$ff            ; change sign
d153 85 63              STA FAC1SI
d155 60       NEGA_Ret  RTS ;Size   11 [Op_NEGATE]

              ; *********
d156            REV_LOG_2
              ; *********

d156 81 38 aa 3b 29     .REAL $8138aa3b29   ;    1.44269504072
d15b 07       VAR_EXP   .BYTE $07
d15c 71 34 58 3e 56     .REAL $7134583e56   ;    0.00002149876
d161 74 16 7e b3 1b     .REAL $74167eb31b   ;    0.00014352314
d166 77 2f ee e3 85     .REAL $772feee385   ;    0.00134226348
d16b 7a 1d 84 1c 2a     .REAL $7a1d841c2a   ;    0.00961401701
d170 7c 63 59 58 0a     .REAL $7c6359580a   ;    0.05550512686
d175 7e 75 fd e7 c6     .REAL $7e75fde7c6   ;    0.24022638460
d17a 80 31 72 18 10     .REAL $8031721810   ;    0.69314718619
d17f 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; *********
d184            Basic_EXP
              ; *********

d184 a9 56              LDA #<REV_LOG_2
d186 a0 d1              LDY #>REV_LOG_2
d188 20 5e cb           JSR Multiply_FAC1_With_AY
d18b a5 6d              LDA FROUND
d18d 69 50              ADC #$50
d18f 90 03              BCC EXP_10
d191 20 59 cd           JSR Inc_FAC1
d194 85 53    EXP_10    STA FUNJMP+1        ; FROUND + $50
d196 20 45 cd           JSR FAC1_To_FAC2
d199 a5 5e              LDA FAC1EX
d19b c9 88              CMP #$88
d19d 90 03              BCC EXP_30          ; -> value < 128
d19f 20 07 cc EXP_20    JSR ChFA_40         ; Floating Point Exception
d1a2 20 02 ce EXP_30    JSR Basic_INT       ; convert to integer
d1a5 a5 03              LDA CHARAC
d1a7 49 80              EOR #$80
d1a9 48                 PHA
d1aa a2 05              LDX #5
d1ac b5 66    EXP_40    LDA FAC2EX,X
d1ae b4 5e              LDY FAC1EX,X
d1b0 95 5e              STA FAC1EX,X
d1b2 94 66              STY FAC2EX,X
d1b4 ca                 DEX
d1b5 10 f5              BPL EXP_40
d1b7 a5 53              LDA FUNJMP+1
d1b9 85 6d              STA FROUND
d1bb 20 89 c9           JSR Op_MINUS
d1be 20 4b d1           JSR Op_NEGATE
d1c1 a9 5b              LDA #<VAR_EXP
d1c3 a0 d1              LDY #>VAR_EXP
d1c5 20 ed d1           JSR Eval_Series_AY
d1c8 a9 00              LDA #0
d1ca 85 6c              STA STRPTR
d1cc 68                 PLA
d1cd 20 ef cb           JSR ChFA_10
d1d0 60                 RTS ;Size   77 [Basic_EXP]

d1d1 00 00 00           .FILL $d1d7-* (0) ; 6 bytes

              ; ******************************
d1d7            Square_And_Series_Eval ; $d1d7
              ; ******************************

d1d7 85 6e              STA TMPPTD
d1d9 84 6f              STY TMPPTD+1
d1db 20 00 cd           JSR FAC1_To_FACTPA
d1de a9 54              LDA #<FACTPA        ; Y = 0
d1e0 20 5e cb           JSR Multiply_FAC1_With_AY
d1e3 20 f1 d1           JSR Eval_Series
d1e6 a9 54              LDA #<FACTPA
d1e8 a0 00              LDY #>FACTPA
d1ea 4c 5e cb           JMP Multiply_FAC1_With_AY

              ; **************
d1ed            Eval_Series_AY
              ; **************

d1ed 85 6e              STA TMPPTD
d1ef 84 6f              STY TMPPTD+1

              ; ***********
d1f1            Eval_Series
              ; ***********

d1f1 20 fd cc           JSR FAC1_To_FACTPB
d1f4 b1 6e              LDA (TMPPTD),Y
d1f6 85 64              STA SGNFLG          ; # of terms
d1f8 a4 6e              LDY TMPPTD
d1fa c8                 INY
d1fb 98                 TYA
d1fc d0 02              BNE EvSe_10
d1fe e6 6f              INC TMPPTD+1
d200 85 6e    EvSe_10   STA TMPPTD
d202 a4 6f              LDY TMPPTD+1
d204 20 5e cb EvSe_20   JSR Multiply_FAC1_With_AY
d207 a5 6e              LDA TMPPTD
d209 a4 6f              LDY TMPPTD+1
d20b 18                 CLC
d20c 69 05              ADC #5              ; advance polynomial pointer
d20e 90 01              BCC EvSe_30
d210 c8                 INY
d211 85 6e    EvSe_30   STA TMPPTD
d213 84 6f              STY TMPPTD+1
d215 20 9d c9           JSR Add_Var_AY_To_FAC1
d218 a9 59              LDA #<FACTPB
d21a a0 00              LDY #>FACTPB
d21c c6 64              DEC SGNFLG
d21e d0 e4              BNE EvSe_20         ; -> next polynomial
d220 60                 RTS ;Size   48 [Eval_Series]

d221 98 35 44 RND_VA    .QUAD $9835447a     ; -1741339526
d225 68 28 b1 RND_VB    .QUAD $6828b146     ;  1747497286

              ; *********
d229            Basic_RND
              ; *********

              ; The random factor argument from RND(arg) is interpreted:
              ; arg < 0 : use argument as random seed
              ; arg = 0 : use timer 1 and 2 for random seed
              ; arg > 0 : start with fixed random seed from ROM

d229 20 61 cd           JSR Get_FAC1_Sign
d22c 30 2e              BMI RND_20
d22e d0 17              BNE RND_10
d230 ad 44 e8           LDA VIA_Timer_1_Lo  ; timer seed
d233 85 5f              STA FAC1M1
d235 ad 48 e8           LDA VIA_Timer_2_Lo
d238 85 60              STA FAC1M2
d23a ad 45 e8           LDA VIA_Timer_1_Hi
d23d 85 61              STA FAC1M3
d23f ad 49 e8           LDA VIA_Timer_2_Hi
d242 85 62              STA FAC1M4
d244 4c 6c d2           JMP RND_30
d247 a9 88    RND_10    LDA #<RNDX          ; fixed seed
d249 a0 00              LDY #>RNDX
d24b 20 d8 cc           JSR Load_FAC1_AY
d24e a9 21              LDA #<RND_VA
d250 a0 d2              LDY #>RND_VA
d252 20 5e cb           JSR Multiply_FAC1_With_AY
d255 a9 25              LDA #<RND_VB
d257 a0 d2              LDY #>RND_VB
d259 20 9d c9           JSR Add_Var_AY_To_FAC1
d25c a6 62    RND_20    LDX FAC1M4          ; argument seed
d25e a5 5f              LDA FAC1M1
d260 85 62              STA FAC1M4
d262 86 5f              STX FAC1M1
d264 a6 60              LDX FAC1M2
d266 a5 61              LDA FAC1M3
d268 85 60              STA FAC1M2
d26a 86 61              STX FAC1M3
d26c a9 00    RND_30    LDA #0
d26e 85 63              STA FAC1SI
d270 a5 5e              LDA FAC1EX
d272 85 6d              STA FROUND
d274 a9 80              LDA #$80
d276 85 5e              STA FAC1EX
d278 20 0d ca           JSR Normalise_FAC1
d27b a2 88              LDX #<RNDX
d27d a0 00              LDY #>RNDX
d27f 4c 0a cd           JMP FAC1_To_XY

              ; *********
d282            Basic_COS
              ; *********

d282 a9 fe              LDA #<PI_Half
d284 a0 d2              LDY #>PI_Half
d286 20 9d c9           JSR Add_Var_AY_To_FAC1

              ; *****************
d289            Basic_SIN ; $d289
              ; *****************

d289 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d28c a9 03              LDA #<Two_PI
d28e a0 d3              LDY #>Two_PI
d290 a6 6b              LDX FAC2SI
d292 20 3d cc           JSR Divide_FAC2_By_AY ; arg / (2 pi)
d295 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d298 20 02 ce           JSR Basic_INT
d29b a9 00              LDA #0
d29d 85 6c              STA STRPTR
d29f 20 89 c9           JSR Op_MINUS
d2a2 a9 08              LDA #<Float_0_25
d2a4 a0 d3              LDY #>Float_0_25
d2a6 20 86 c9           JSR AY_Minus_FAC1
d2a9 a5 63              LDA FAC1SI
d2ab 48                 PHA
d2ac 10 0d              BPL SIN_10
d2ae 20 7f c9           JSR Add_0_5_To_FAC1
d2b1 a5 63              LDA FAC1SI
d2b3 30 09              BMI SIN_20
d2b5 a5 0c              LDA TANSGN
d2b7 49 ff              EOR #$ff
d2b9 85 0c              STA TANSGN
d2bb 20 4b d1 SIN_10    JSR Op_NEGATE
d2be a9 08    SIN_20    LDA #<Float_0_25
d2c0 a0 d3              LDY #>Float_0_25
d2c2 20 9d c9           JSR Add_Var_AY_To_FAC1
d2c5 68                 PLA
d2c6 10 03              BPL SIN_30
d2c8 20 4b d1           JSR Op_NEGATE
d2cb a9 0d    SIN_30    LDA #<VAR_SIN
d2cd a0 d3              LDY #>VAR_SIN
d2cf 4c d7 d1           JMP Square_And_Series_Eval

              ; *********
d2d2            Basic_TAN
              ; *********

d2d2 20 00 cd           JSR FAC1_To_FACTPA
d2d5 a9 00              LDA #0
d2d7 85 0c              STA TANSGN
d2d9 20 89 d2           JSR Basic_SIN
d2dc a2 4b              LDX #<FUNCPT
d2de a0 00              LDY #>FUNCPT
d2e0 20 0a cd           JSR FAC1_To_XY
d2e3 a9 54              LDA #<FACTPA
d2e5 a0 00              LDY #>FACTPA
d2e7 20 d8 cc           JSR Load_FAC1_AY
d2ea a9 00              LDA #0
d2ec 85 63              STA FAC1SI
d2ee a5 0c              LDA TANSGN
d2f0 20 fa d2           JSR TAN_10
d2f3 a9 4b              LDA #<FUNCPT
d2f5 a0 00              LDY #>FUNCPT
d2f7 4c 45 cc           JMP AY_Divided_By_FAC1

              ; ******
d2fa            TAN_10
              ; ******

d2fa 48                 PHA
d2fb 4c bb d2           JMP SIN_10
d2fe 81 49 0f PI_Half   .REAL $81490fdaa2   ;    1.57079632673
d303 83 49 0f Two_PI    .REAL $83490fdaa2   ;    6.28318530694

              ; **********
d308            Float_0_25
              ; **********

d308 7f 00 00 00 00     .REAL $7f00000000   ;    0.25000000000
d30d 05       VAR_SIN   .BYTE $05
d30e 84 e6 1a 2d 1b     .REAL $84e61a2d1b   ;  -14.38139067218
d313 86 28 07 fb f8     .REAL $862807fbf8   ;   42.00779712200
d318 87 99 68 89 01     .REAL $8799688901   ;  -76.70417025685
d31d 87 23 35 df e1     .REAL $872335dfe1   ;   81.60522368550
d322 86 a5 5d e7 28     .REAL $86a55de728   ;  -41.34170210361
d327 83 49 0f da a2     .REAL $83490fdaa2   ;    6.28318530694

              ; *****************
d32c            Basic_ATN ; $d32c
              ; *****************

d32c a5 63              LDA FAC1SI
d32e 48                 PHA                 ; save sign
d32f a9 00              LDA #0
d331 85 63              STA FAC1SI          ; use symmetry of arctangent
d333 a5 5e              LDA FAC1EX
d335 c9 81              CMP #$81
d337 08                 PHP                 ; save flags
d338 90 07              BCC ATN_20          ; -> arg < 1.0
d33a a9 f2              LDA #<REAL_1
d33c a0 ca              LDY #>REAL_1
d33e 20 45 cc           JSR AY_Divided_By_FAC1
d341 a9 5c    ATN_20    LDA #<VAR_ATN
d343 a0 d3              LDY #>VAR_ATN
d345 20 d7 d1           JSR Square_And_Series_Eval
d348 28                 PLP                 ; restore comparison flags
d349 90 07              BCC ATN_30          ; -> arg < 1.0
d34b a9 fe              LDA #<PI_Half
d34d a0 d2              LDY #>PI_Half
d34f 20 86 c9           JSR AY_Minus_FAC1
d352 68       ATN_30    PLA
d353 85 63              STA FAC1SI          ; use same sign as arguemnt
d355 60                 RTS ;Size   42 [Basic_ATN]

d356 00 00 00           .FILL $d35c-* (0) ; 6 bytes

              ; ***************
d35c            VAR_ATN ; $d35c
              ; ***************

d35c 0b                 .BYTE $0b
d35d 76 b3 83 bd d3     .REAL $76b383bdd3   ;   -0.00068479391
d362 79 1e f4 a6 f5     .REAL $791ef4a6f5   ;    0.00485094216
d367 7b 83 fc b0 10     .REAL $7b83fcb010   ;   -0.01611170184
d36c 7c 0c 1f 67 ca     .REAL $7c0c1f67ca   ;    0.03420963805
d371 7c de 53 cb c1     .REAL $7cde53cbc1   ;   -0.05427913276
d376 7d 14 64 70 4c     .REAL $7d1464704c   ;    0.07245719654
d37b 7d b7 ea 51 7a     .REAL $7db7ea517a   ;   -0.08980239538
d380 7d 63 30 88 7e     .REAL $7d6330887e   ;    0.11093241343
d385 7e 92 44 99 3a     .REAL $7e9244993a   ;   -0.14283980767
d38a 7e 4c cc 91 c7     .REAL $7e4ccc91c7   ;    0.19999912049
d38f 7f aa aa aa 13     .REAL $7faaaaaa13   ;   -0.33333331568
d394 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; **********
d399            CHRGET_ROM
              ; **********

d399 e6 77              INC TXTPTR
d39b d0 02              BNE CHRG_10
d39d e6 78              INC TXTPTR+1
d39f ad 60 ea CHRG_10   LDA $ea60           ; dummy address
d3a2 c9 3a              CMP #':'
d3a4 b0 0a              BCS CHRG_20
d3a6 c9 20              CMP #' '
d3a8 f0 ef              BEQ CHRGET_ROM
d3aa 38                 SEC
d3ab e9 30              SBC #'0'
d3ad 38                 SEC
d3ae e9 d0              SBC #$d0
d3b0 60       CHRG_20   RTS ;Size   24 [CHRGET_ROM]

d3b1 80 4f c7 52 58     .REAL $804fc75258   ;    0.81163515709

              ; **********************
d3b6            Init_BASIC_RAM_Vectors
              ; **********************

d3b6 20 0e b6           JSR Flush_BASIC_Stack
d3b9 a9 4c              LDA #$4c            ; JMP code
d3bb 85 51              STA JUMPER
d3bd 85 00              STA Basic_USR
d3bf a9 73              LDA #<Jump_To_Illegal_Quantity
d3c1 a0 c3              LDY #>Jump_To_Illegal_Quantity
d3c3 85 01              STA USRVEC
d3c5 84 02              STY USRVEC+1
d3c7 a2 1c              LDX #$1c
d3c9 bd 98 d3 IBRV_10   LDA CHRGET_ROM-1,X
d3cc 95 6f              STA CHRGET-1,X
d3ce ca                 DEX
d3cf d0 f8              BNE IBRV_10         ; X=0 on exit
d3d1 86 10              STX IOPMPT          ; 0
d3d3 86 15              STX LASTPT+1        ; 0
d3d5 8e 00 04           STX $0400           ; BASIC start
d3d8 a0 04              LDY #4              ; X=0  Y=4
d3da 84 29              STY TXTTAB+1        ; >$0401
d3dc 86 11              STX LINNUM
d3de 84 12              STY LINNUM+1        ; $0400
d3e0 a9 08              LDA #8
d3e2 85 ab              STA Wedge_Unit
d3e4 a0 01              LDY #1              ; start RAM test at $0401
d3e6 84 28              STY TXTTAB          ; (TXTTAB) = $0401
d3e8 b1 11    IBRV_20   LDA (LINNUM),Y
d3ea aa                 TAX                 ; save content
d3eb a9 55              LDA #$55            ; test pattern
d3ed 91 11              STA (LINNUM),Y
d3ef d1 11              CMP (LINNUM),Y
d3f1 d0 11              BNE IBRV_30         ; failed
d3f3 0a                 ASL A               ; shift pattern
d3f4 91 11              STA (LINNUM),Y
d3f6 d1 11              CMP (LINNUM),Y
d3f8 d0 0a              BNE IBRV_30         ; failed
d3fa 8a                 TXA                 ; restore content
d3fb 91 11              STA (LINNUM),Y
d3fd c8                 INY                 ; next address
d3fe d0 e8              BNE IBRV_20         ; loop
d400 e6 12              INC LINNUM+1
d402 10 e4              BPL IBRV_20         ; loop for LINNUM < $8000
d404 a5 12    IBRV_30   LDA LINNUM+1
d406 84 34              STY MEMSIZ
d408 85 35              STA MEMSIZ+1        ; top of RAM + 1
d40a 84 30              STY FRETOP
d40c 85 31              STA FRETOP+1
d40e 20 77 fb           JSR Init_RAM_Vectors
d411 a9 9d              LDA #<Start_Message
d413 a0 de              LDY #>Start_Message
d415 20 1d bb           JSR Print_String
d418 a5 34              LDA MEMSIZ
d41a 38                 SEC
d41b e5 28              SBC TXTTAB
d41d aa                 TAX
d41e a5 35              LDA MEMSIZ+1
d420 e5 29              SBC TXTTAB+1
d422 20 83 cf           JSR Print_Integer_XA
d425 a9 38              LDA #<Bytes_Free_Message
d427 a0 d4              LDY #>Bytes_Free_Message
d429 20 1d bb           JSR Print_String
d42c 20 d4 b5           JSR Perform_NEW
d42f 20 01 cf           JSR Option_ROM
d432 20 22 cf           JSR BOOT_File
d435 4c ff b3           JMP Basic_Ready

              ; ******************
d438            Bytes_Free_Message
              ; ******************

d438 20 42 59           .BYTE " BYTES FREE\r",0

              ; *******
d445            Monitor
              ; *******
d445 a9 b4              LDA #>[Basic_Ready+1]
d447 48                 PHA
d448 a9 00              LDA #<[Basic_Ready+1]
d44a 48                 PHA
d44b a9 00              LDA #0              ; clear if not already 0
d44d 48                 PHA                 ; Y
d44e 48                 PHA                 ; X
d44f 48                 PHA                 ; A
d450 48                 PHA                 ; SR

              ; *************
d451            MONITOR_BREAK
              ; *************

d451 d8                 CLD
d452 a2 01              LDX #1              ; 1 for BRK
d454 c9 20              CMP #$20            ; T2 single step IRQ
d456 d0 01              BNE MOBR_05
d458 ca                 DEX                 ; 0 for STEP IRQ
d459 86 b3    MOBR_05   STX PC_Adjust
d45b 20 a6 f2           JSR Kernal_CLRCHN
d45e 68                 PLA
d45f 8d a7 02           STA Mon_Register+7  ; Y
d462 68                 PLA
d463 8d a6 02           STA Mon_Register+6  ; X
d466 68                 PLA
d467 8d a5 02           STA Mon_Register+5  ; A
d46a 68                 PLA
d46b 8d a4 02           STA Mon_Register+4  ; SR
d46e 20 6e ec           JSR Install_Bank_Access ; Carry = 1
d471 68                 PLA
d472 e5 b3              SBC PC_Adjust
d474 8d a1 02           STA Mon_Register+1  ; PC lo
d477 68                 PLA
d478 e9 00              SBC #0
d47a 8d a0 02           STA Mon_Register    ; PC hi
d47d a5 90              LDA CINV
d47f 8d a3 02           STA Mon_Register+3  ; IRQ lo
d482 a5 91              LDA CINV+1
d484 8d a2 02           STA Mon_Register+2  ; IRQ hi
d487 ba                 TSX
d488 8e a8 02           STX Mon_Register+8  ; SP
d48b a5 b6              LDA R_Bank
d48d 8d a9 02           STA Mon_Register+9  ; RB
d490 a5 b7              LDA W_Bank
d492 8d aa 02           STA Mon_Register+10 ; WB
d495 58                 CLI
d496 a6 b3              LDX PC_Adjust
d498 f0 0e              BEQ MOBR_20         ; no greetings on single step mode
d49a a0 ff              LDY #-1
d49c c8       MOBR_10   INY
d49d b9 2a d5           LDA Mon_Start,Y
d4a0 f0 06              BEQ MOBR_20
d4a2 20 02 e2           JSR EDIT_CHROUT
d4a5 4c 9c d4           JMP MOBR_10
d4a8 a9 52    MOBR_20   LDA #'R'
d4aa d0 15              BNE Mon_20          ; always

              ; *********
d4ac            Mon_Error
              ; *********

d4ac a9 3f              LDA #'?'
d4ae 20 02 e2           JSR EDIT_CHROUT

              ; ********
d4b1            Mon_Main
              ; ********

d4b1 20 25 d5           JSR Mon_Print_CR
d4b4 a9 40              LDA #$40
d4b6 85 99              STA Power_Flag      ; activate power scrolling
d4b8 20 f4 d8 Mon_10    JSR Mon_CHRIN
d4bb f0 f4              BEQ Mon_Main
d4bd c9 20              CMP #' '
d4bf f0 f7              BEQ Mon_10
d4c1 a2 18    Mon_20    LDX #24
d4c3 ca       Mon_30    DEX
d4c4 30 e6              BMI Mon_Error
d4c6 dd 35 d5           CMP Mon_Commands,X
d4c9 d0 f8              BNE Mon_30
d4cb bd 4d d5           LDA Mon_Sub_Hi,X
d4ce 48                 PHA
d4cf bd 64 d5           LDA Mon_Sub_Lo,X
d4d2 48                 PHA
d4d3 60                 RTS ;Size   35 [Mon_Main]

              ; **********************
d4d4            Mon_Print_A_Hex_Values
              ; **********************

d4d4 85 b5              STA MONCNT
d4d6 a0 00              LDY #0
d4d8 20 22 d5 MPAH_10   JSR Mon_Print_Blank
d4db 20 7a 02           JSR Bank_Fetch
d4de 20 5b d7           JSR Print_Hex_Byte
d4e1 c8                 INY
d4e2 c0 08              CPY #8
d4e4 d0 03              BNE MPAH_12
d4e6 20 22 d5           JSR Mon_Print_Blank
d4e9 c4 b5    MPAH_12   CPY MONCNT
d4eb 90 eb              BCC MPAH_10
d4ed 20 22 d5           JSR Mon_Print_Blank
d4f0 a5 b5              LDA MONCNT
d4f2 c9 10              CMP #16
d4f4 d0 20              BNE MPAH_Ret
d4f6 a0 00              LDY #0
d4f8 20 7a 02 MPAH_20   JSR Bank_Fetch
d4fb 29 7f              AND #$7f
d4fd c9 20              CMP #$20
d4ff 90 04              BCC MPAH_30
d501 c9 60              CMP #$60
d503 90 02              BCC MPAH_40
d505 a9 2e    MPAH_30   LDA #'.'
d507 20 02 e2 MPAH_40   JSR EDIT_CHROUT
d50a c8                 INY
d50b c0 08              CPY #8
d50d d0 03              BNE MPAH_42
d50f 20 22 d5           JSR Mon_Print_Blank
d512 c4 b5    MPAH_42   CPY MONCNT
d514 90 e2              BCC MPAH_20
d516 60       MPAH_Ret  RTS ;Size   67 [Mon_Print_A_Hex_Values]

              ; *****************
d517            Mon_STAL_Register
              ; *****************

d517 a9 a4              LDA #<[Mon_Register+4]
d519 85 fb              STA STAL
d51b a9 02              LDA #>[Mon_Register+4]
d51d 85 fc              STA STAL+1
d51f a9 07              LDA #7              ; 7 bytes to display
d521 60                 RTS ;Size   11 [Mon_STAL_Register]

              ; ***************
d522            Mon_Print_Blank
              ; ***************

d522 a9 20              LDA #$20            ; ' '
d524 2c                 .BYTE $2c

              ; ************
d525            Mon_Print_CR
              ; ************

d525 a9 0d              LDA #CR
d527 4c 02 e2           JMP EDIT_CHROUT


d52a 42 53 20   Mon_Start .BYTE "BS MONITOR "

              ; ************
d535            Mon_Commands
              ; ************

d535 23 24 2e           .BYTE "#$./:;@ABCDFGHLMNRSTUWX",0

              ; **********
d54d            Mon_Sub_Hi
              ; **********

d54d fd                 .BYTE >[Mon_Unit-1]           ; #
d54e fb                 .BYTE >[Mon_Dir-1]            ; $
d54f fa                 .BYTE >[Assemble-1]           ; .
d550 d6                 .BYTE >[Mon_Load-1]           ; /
d551 d6                 .BYTE >[Modify_Memory-1]      ; :
d552 d6                 .BYTE >[Modify_Register-1]    ; ;
d553 fb                 .BYTE >[Mon_Wedge-1]          ; @
d554 fa                 .BYTE >[Assemble-1]           ; A
d555 d8                 .BYTE >[Mon_Set_Bank-1]       ; B
d556 fb                 .BYTE >[Mon_Compare-1]        ; C
d557 f5                 .BYTE >[Disassemble-1]        ; D
d558 e5                 .BYTE >[Mon_Fill-1]           ; F
d559 d6                 .BYTE >[Mon_Go-1]             ; G
d55a fc                 .BYTE >[Mon_Hunt-1]           ; H
d55b d6                 .BYTE >[Mon_Load-1]           ; L
d55c d5                 .BYTE >[Display_Memory-1]     ; M
d55d fd                 .BYTE >[Mon_Next]             ; N
d55e d5                 .BYTE >[Display_Register-1]   ; R
d55f d6                 .BYTE >[Mon_Save-1]           ; S
d560 fc                 .BYTE >[Mon_Transfer-1]       ; T
d561 e5                 .BYTE >[Mon_Disk-1]           ; U
d562 d8                 .BYTE >[Mon_Write_Bank-1]     ; W
d563 d6                 .BYTE >[Mon_Exit-1]           ; X

              ; **********
d564            Mon_Sub_Lo
              ; **********

d564 50                 .BYTE <[Mon_Unit-1]           ; #
d565 58                 .BYTE <[Mon_Dir-1]            ; $
d566 41                 .BYTE <[Assemble-1]           ; .
d567 d4                 .BYTE <[Mon_Load-1]           ; /
d568 5f                 .BYTE <[Modify_Memory-1]      ; :
d569 45                 .BYTE <[Modify_Register-1]    ; ;
d56a 37                 .BYTE <[Mon_Wedge-1]          ; @
d56b 41                 .BYTE <[Assemble-1]           ; A
d56c e3                 .BYTE <[Mon_Set_Bank-1]       ; B
d56d e3                 .BYTE <[Mon_Compare-1]        ; C
d56e c1                 .BYTE <[Disassemble-1]        ; D
d56f 3e                 .BYTE <[Mon_Fill-1]           ; F
d570 8a                 .BYTE <[Mon_Go-1]             ; G
d571 7f                 .BYTE <[Mon_Hunt-1]           ; H
d572 d4                 .BYTE <[Mon_Load-1]           ; L
d573 fa                 .BYTE <[Display_Memory-1]     ; M
d574 6e                 .BYTE <[Mon_Next]             ; N
d575 82                 .BYTE <[Display_Register-1]   ; R
d576 d7                 .BYTE <[Mon_Save-1]           ; S
d577 15                 .BYTE <[Mon_Transfer-1]       ; T
d578 a6                 .BYTE <[Mon_Disk-1]           ; U
d579 eb                 .BYTE <[Mon_Write_Bank-1]     ; W
d57a c4                 .BYTE <[Mon_Exit-1]           ; X

              ; **********
d57b            Mon_Prompt
              ; **********

d57b 48                 PHA
d57c 20 25 d5           JSR Mon_Print_CR
d57f 68                 PLA
d580 4c 02 e2           JMP EDIT_CHROUT

              ; ****************
d583            Display_Register
              ; ****************

d583 a2 00              LDX #0
d585 bd fb e4 DiRe_10   LDA Mon_Message,X
d588 20 02 e2           JSR EDIT_CHROUT
d58b e8                 INX
d58c e0 2a              CPX #42
d58e d0 f5              BNE DiRe_10
d590 a5 b6              LDA R_Bank
d592 8d a9 02           STA Mon_Register+9
d595 a5 b7              LDA W_Bank
d597 8d aa 02           STA Mon_Register+10
d59a a9 3b              LDA #';'
d59c 20 7b d5           JSR Mon_Prompt
d59f 20 22 d5           JSR Mon_Print_Blank
d5a2 ad a0 02           LDA Mon_Register    ; display PC
d5a5 20 5b d7           JSR Print_Hex_Byte
d5a8 ad a1 02           LDA Mon_Register+1
d5ab 20 5b d7           JSR Print_Hex_Byte
d5ae 20 22 d5           JSR Mon_Print_Blank
d5b1 ad a2 02           LDA Mon_Register+2  ; display IRQ vector
d5b4 20 5b d7           JSR Print_Hex_Byte
d5b7 ad a3 02           LDA Mon_Register+3
d5ba 20 5b d7           JSR Print_Hex_Byte
d5bd 20 17 d5           JSR Mon_STAL_Register
d5c0 20 d4 d4           JSR Mon_Print_A_Hex_Values
d5c3 ad a4 02           LDA Mon_Register+4  ; SR
d5c6 85 b5              STA MONCNT
d5c8 a2 08              LDX #8
d5ca a9 30    DiRe_20   LDA #'0'
d5cc 06 b5              ASL MONCNT
d5ce 69 00              ADC #0
d5d0 20 02 e2           JSR EDIT_CHROUT
d5d3 ca                 DEX
d5d4 d0 f4              BNE DiRe_20
d5d6 a5 b3              LDA PC_Adjust
d5d8 d0 42              BNE To_Mon_Main     ; branch if not stepping
d5da ad a1 02           LDA Mon_Register+1
d5dd 85 fb              STA STAL
d5df ad a0 02           LDA Mon_Register
d5e2 85 fc              STA STAL+1
d5e4 4c cf f5           JMP Disa_15


              ; ************
d5e7            Mon_Cmp_Addr
              ; ************

d5e7 a5 ba              LDA Dis_Line        ; negative: compare addresses
d5e9 30 07              BMI Cmp_STAL_MEMUSS
d5eb e6 ba              INC Dis_Line
d5ed a9 10              LDA #16
d5ef c5 ba              CMP Dis_Line        ; line count > 16 ?
d5f1 60                 RTS ;Size   11 [Mon_Cmp_Addr]

              ; ***************
d5f2            Cmp_STAL_MEMUSS
              ; ***************

d5f2 a5 fd              LDA MEMUSS          ; end addr >= start addr ?
d5f4 c5 fb              CMP STAL
d5f6 a5 fe              LDA MEMUSS+1
d5f8 e5 fc              SBC STAL+1
d5fa 60                 RTS ;Size    9 [Cmp_STAL_MEMUSS]

              ; **************
d5fb            Display_Memory
              ; **************

d5fb 20 1f d6           JSR Mon_Get_Addr
d5fe 20 35 f3 DiMe_10   JSR Check_STOP_Key  ; STOP key pressed?
d601 f0 19              BEQ To_Mon_Main
d603 20 e7 d5           JSR Mon_Cmp_Addr
d606 90 14              BCC To_Mon_Main     ; STAL > MEMUSS ?
d608 a9 3a              LDA #':'
d60a 20 7b d5           JSR Mon_Prompt
d60d 20 54 d7           JSR Mon_Print_STAL
d610 a9 10              LDA #16             ; dump 16 bytes per line
d612 20 d4 d4           JSR Mon_Print_A_Hex_Values
d615 a9 10              LDA #16
d617 20 15 fb           JSR Add_STAL
d61a d0 e2              BNE DiMe_10
d61c          To_Mon_Main
d61c 4c b1 d4           JMP Mon_Main

              ; ************
d61f            Mon_Get_Addr
              ; ************

d61f a0 00              LDY #0              ; reset line count
d621 84 ba              STY Dis_Line
d623 88                 DEY                 ; Y = $ff
d624 84 fd              STY MEMUSS
d626 84 fe              STY MEMUSS+1        ; default end address = $ffff
d628 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d62b f0 13              BEQ MGA_Ret         ; use last value for STAL
d62d 20 71 d7           JSR Hex_To_STAL     ; read start address to STAL
d630 90 0f              BCC MGA_Err
d632 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d635 f0 09              BEQ MGA_Ret
d637 a2 fd              LDX #MEMUSS
d639 20 73 d7           JSR Read_Hex_Word  ; read end address
d63c 90 03              BCC MGA_Err
d63e c6 ba              DEC Dis_Line        ; disable line count
d640 60       MGA_Ret   RTS ;Size   34 [Mon_Get_Addr]
d641 68       MGA_Err   PLA
d642 68                 PLA
d643          To_Mon_Err
d643 4c ac d4           JMP Mon_Error

              ; ***************
d646            Modify_Register
              ; ***************

d646 a2 00              LDX #0
d648 20 80 d7 MoRe_10   JSR Read_Hex
d64b 9d a0 02           STA Mon_Register,X
d64e e8                 INX
d64f e0 0b              CPX #11
d651 90 f5              BCC MoRe_10
d653 ad a9 02           LDA Mon_Register+9
d656 85 b6              STA R_Bank
d658 ad aa 02           LDA Mon_Register+10
d65b 85 b7              STA W_Bank
d65d 4c b1 d4           JMP Mon_Main

              ; *************
d660            Modify_Memory
              ; *************

d660 20 71 d7           JSR Hex_To_STAL
d663 90 de              BCC To_Mon_Err
d665 a9 10              LDA #16
d667 85 b5    MoMe_10   STA MONCNT
d669 a5 fb              LDA STAL
d66b 85 f9              STA BPTR
d66d a5 fc              LDA STAL+1
d66f 85 fa              STA BPTR+1
d671 a0 00              LDY #0
d673 20 80 d7 MoMe_20   JSR Read_Hex
d676 90 cb              BCC To_Mon_Err
d678 85 cb              STA Mon_Tmp
d67a 20 8b 02           JSR Bank_Store
d67d 20 7a 02           JSR Bank_Fetch
d680 c5 cb              CMP Mon_Tmp
d682 d0 bf              BNE To_Mon_Err      ; not RAM
d684 c8       MoMe_30   INY
d685 c4 b5              CPY MONCNT
d687 90 ea              BCC MoMe_20
d689 b0 91              BCS To_Mon_Main

              ; ******
d68b            Mon_Go
              ; ******

d68b 20 f4 d8           JSR Mon_CHRIN
d68e f0 10              BEQ MoGo_10
d690 c9 20              CMP #' '
d692 d0 af              BNE To_Mon_Err
d694 20 80 d7           JSR Read_Hex
d697 8d a0 02           STA Mon_Register
d69a 20 80 d7           JSR Read_Hex
d69d 8d a1 02           STA Mon_Register+1
d6a0 78       MoGo_10   SEI
d6a1 ad a2 02           LDA Mon_Register+2  ; IRQ
d6a4 85 91              STA CINV+1
d6a6 ad a3 02           LDA Mon_Register+3
d6a9 85 90              STA CINV

              ; ********
d6ab            Mon_Step
              ; ********

d6ab ae a8 02           LDX Mon_Register+8  ; SP
d6ae 9a                 TXS
d6af ad a0 02           LDA Mon_Register    ; PC high
d6b2 48                 PHA
d6b3 ad a1 02           LDA Mon_Register+1  ; PC low
d6b6 48                 PHA
d6b7 ad a4 02           LDA Mon_Register+4  ; SR
d6ba 48                 PHA
d6bb ad a5 02           LDA Mon_Register+5
d6be ae a6 02           LDX Mon_Register+6
d6c1 ac a7 02           LDY Mon_Register+7
d6c4 40                 RTI

              ; ********
d6c5            Mon_Exit
              ; ********

d6c5 ae a8 02           LDX Mon_Register+8  ; SP
d6c8 9a                 TXS
d6c9 4c ff b3           JMP Basic_Ready

              ; *************
d6cc            Set_DOS_FNADR
              ; *************

d6cc a9 42              LDA #<DOS_Filename
d6ce 85 da              STA FNADR
d6d0 a9 03              LDA #>DOS_Filename
d6d2 85 db              STA FNADR+1
d6d4 60                 RTS ;Size    9 [Set_DOS_FNADR]

              ; ********
d6d5            Mon_Load
              ; ********

d6d5 a9 00              LDA #0              ; load flag
d6d7 2c                 .BYTE $2c           ; skip 2 bytes

              ; ********
d6d8            Mon_Save
              ; ********

d6d8 a9 80              LDA #$80            ; save flag
d6da 85 9d              STA VERCK           ; (0) LOAD, ($80) SAVE
d6dc a0 01              LDY #1
d6de 84 d3              STY SA              ; use file load address
d6e0 88                 DEY                 ; Y = 0
d6e1 20 cc d6           JSR Set_DOS_FNADR
d6e4 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
d6e7 20 f4 d8 MLS_10    JSR Mon_CHRIN
d6ea f0 14              BEQ MLS_Err         ; filename required
d6ec c9 22              CMP #QUOTE          ; filename must be quoted
d6ee d0 f7              BNE MLS_10          ; skip until leading quote
d6f0 20 f4 d8 MLS_20    JSR Mon_CHRIN       ; next char in string
d6f3 f0 0b              BEQ MLS_Err         ; no ending quote
d6f5 c9 22              CMP #QUOTE          ; ending quote?
d6f7 f0 14              BEQ MLS_50
d6f9 91 da              STA (FNADR),Y       ; append to filename
d6fb c8                 INY                 ; next
d6fc c0 10              CPY #16
d6fe 90 f0              BCC MLS_20          ; loop
d700 4c ac d4 MLS_Err   JMP Mon_Error

d703 24 9d    MLS_30    BIT VERCK           ; LOAD or SAVE ?
d705 30 f9    MLS_35    BMI MLS_Err         ; SAVE needs range
d707 20 56 f3           JSR Load_File
d70a 4c b1 d4           JMP Mon_Main        ; OK - done

d70d 84 d1    MLS_50    STY FNLEN
d70f 20 f4 d8           JSR Mon_CHRIN       ; parameter after filename
d712 f0 ef              BEQ MLS_30
d714 c9 2c              CMP #','            ; comma needed
d716 d0 f5              BNE MLS_50
d718 20 80 d7           JSR Read_Hex        ; read device
d71b 85 d4              STA FA
d71d 20 f4 d8           JSR Mon_CHRIN
d720 f0 e1              BEQ MLS_30          ; no range -> LOAD
d722 c9 2c              CMP #','            ; comma needed
d724 d0 da              BNE MLS_Err
d726 20 71 d7           JSR Hex_To_STAL     ; STAL = start address
d729 a9 00              LDA #0
d72b 85 d3              STA SA              ; relocate to EAL
d72d 20 f4 d8           JSR Mon_CHRIN
d730 c9 2c              CMP #','
d732 d0 cc              BNE MLS_Err
d734 a2 c9              LDX #EAL
d736 20 73 d7           JSR Read_Hex_Word   ; EAL  = end address
d739 90 c5              BCC MLS_Err
d73b 24 9d              BIT VERCK           ; (0) LOAD or ($80) SAVE
d73d 10 c1              BPL MLS_Err
d73f 20 e3 f6           JSR Save_File
d742 4c b1 d4           JMP Mon_Main

              ; *************
d745            Make_Hex_Byte
              ; *************

d745 48                 PHA
d746 4a                 LSR A
d747 4a                 LSR A
d748 4a                 LSR A
d749 4a                 LSR A
d74a 20 67 d7           JSR Nibble_To_Hex
d74d aa                 TAX
d74e 68                 PLA
d74f 29 0f              AND #15
d751 4c 67 d7           JMP Nibble_To_Hex

              ; **************
d754            Mon_Print_STAL
              ; **************

d754 a5 fc              LDA STAL+1
d756 20 5b d7           JSR Print_Hex_Byte
d759 a5 fb              LDA STAL

              ; **************
d75b            Print_Hex_Byte
              ; **************

d75b 20 45 d7           JSR Make_Hex_Byte

              ; ************
d75e            Mon_Print_XA
              ; ************

d75e 48                 PHA
d75f 8a                 TXA
d760 20 02 e2           JSR EDIT_CHROUT
d763 68                 PLA
d764 4c 02 e2           JMP EDIT_CHROUT

              ; *************
d767            Nibble_To_Hex
              ; *************

d767 18                 CLC
d768 69 f6              ADC #$f6
d76a 90 02              BCC NTH_10
d76c 69 06              ADC #6
d76e 69 3a    NTH_10    ADC #$3a
d770 60                 RTS ;Size   10 [Nibble_To_Hex]

              ; ***********
d771            Hex_To_STAL
              ; ***********

d771 a2 fb              LDX #STAL

              ; *************
d773            Read_Hex_Word
              ; *************

d773 20 80 d7           JSR Read_Hex        ; X points to word address
d776 90 07              BCC RHW_Ret
d778 95 01              STA 1,X             ; high byte
d77a 20 80 d7           JSR Read_Hex
d77d 95 00              STA 0,X             ; low  byte
d77f 60       RHW_Ret   RTS ;Size   13 [Read_Hex_Word]

              ; ********
d780            Read_Hex
              ; ********

              ; read a two digit hex number, allow leading blanks

d780 20 f4 d8           JSR Mon_CHRIN
d783 c9 20              CMP #' '
d785 f0 f9              BEQ Read_Hex
d787          Read_Hex_A
d787 20 11 d9           JSR Is_Hex
d78a 90 17              BCC ReHe_Ret         ; error
d78c 20 fa d8           JSR Hex_To_Bin
d78f 0a                 ASL A
d790 0a                 ASL A
d791 0a                 ASL A
d792 0a                 ASL A
d793 85 cb              STA Mon_Tmp
d795 20 f4 d8           JSR Mon_CHRIN
d798 20 11 d9           JSR Is_Hex
d79b 90 06              BCC ReHe_Ret         ; error
d79d 20 fa d8           JSR Hex_To_Bin
d7a0 05 cb              ORA Mon_Tmp
d7a2 38                 SEC
d7a3 60       ReHe_Ret  RTS ;Size   36 [Read_Hex]


d7a4 00 00 00           .FILL $d7af - * (0) ; 11 bytes

              ; *************
d7af            Kernal_RECORD
              ; *************

d7af a9 01              LDA #1
d7b1 8d 3a 03           STA DOS_Tmp         ; default for position
d7b4 20 76 00           JSR CHRGOT
d7b7 a9 23              LDA #'#'
d7b9 20 f7 be           JSR Need_A
d7bc 20 8a de           JSR DOS_Get_Byte    ; get lfn
d7bf e0 00              CPX #0
d7c1 f0 3e              BEQ RECO_40
d7c3 86 d2              STX LA
d7c5 20 f5 be           JSR Need_Comma
d7c8 f0 3e              BEQ DOS_JMP_Syntax_Error
d7ca 90 0f              BCC RECO_10         ; -> numeric
d7cc 20 f2 be           JSR Need_Left_Parenthesis
d7cf 20 98 bd           JSR Eval_Expression
d7d2 20 2d c9           JSR FAC1_To_LINNUM
d7d5 20 ef be           JSR Need_Right_Parenthesis
d7d8 4c e1 d7           JMP RECO_20
d7db 20 98 bd RECO_10   JSR Eval_Expression ; get record #
d7de 20 2d c9           JSR FAC1_To_LINNUM
d7e1 20 76 00 RECO_20   JSR CHRGOT
d7e4 f0 18              BEQ RECO_30
d7e6 20 f5 be           JSR Need_Comma
d7e9 f0 1d              BEQ DOS_JMP_Syntax_Error
d7eb 20 8a de           JSR DOS_Get_Byte    ; get position
d7ee e0 00              CPX #0
d7f0 f0 0f              BEQ RECO_40
d7f2 e0 ff              CPX #$ff
d7f4 f0 0b              BEQ RECO_40
d7f6 8e 3a 03           STX DOS_Tmp
d7f9 20 76 00           JSR CHRGOT
d7fc d0 0a              BNE DOS_JMP_Syntax_Error
d7fe 4c 31 da RECO_30   JMP Build_Record_Command
d801 4c 27 de RECO_40   JMP DOS_JMP_Illegal_Quantity

              ; *************************
d804            Allow_Drive_Unit_Filename
              ; *************************

d804 29 e6              AND #$e6
d806 f0 03              BEQ Check_Filename_Given

              ; ********************
d808            DOS_JMP_Syntax_Error
              ; ********************

d808 4c 00 bf           JMP Syntax_Error

              ; ********************
d80b            Check_Filename_Given
              ; ********************

d80b ad 3e 03           LDA DOS_Flags
d80e 29 01              AND #1
d810 c9 01              CMP #1
d812 d0 f4              BNE DOS_JMP_Syntax_Error
d814 ad 3e 03           LDA DOS_Flags
d817 60                 RTS ;Size   13 [Check_Filename_Given]

              ; ********************
d818            Allow_Drive_And_Unit
              ; ********************

d818 29 e7              AND #$e7
d81a d0 ec              BNE DOS_JMP_Syntax_Error
d81c 60                 RTS ;Size    5 [Allow_Drive_And_Unit]

              ; ************
d81d            No_WL_Record
              ; ************

d81d 29 c4              AND #$c4
d81f d0 e7              BNE DOS_JMP_Syntax_Error
d821 ad 3e 03           LDA DOS_Flags

              ; *********************
d824            Check_Filename_Syntax
              ; *********************

d824 29 03              AND #3
d826 c9 03              CMP #3
d828 d0 de              BNE DOS_JMP_Syntax_Error
d82a ad 3e 03           LDA DOS_Flags
d82d 60                 RTS ;Size   10 [Check_Filename_Syntax]

              ; *******************
d82e            Check_Record_Syntax
              ; *******************

d82e 29 05              AND #5
d830 c9 05              CMP #5
d832 d0 d4              BNE DOS_JMP_Syntax_Error
d834 ad 3e 03           LDA DOS_Flags
d837 60                 RTS ;Size   10 [Check_Record_Syntax]

              ; ***************
d838            DOS_Build_Table
              ; ***************

d838 ff                 .BYTE $ff
                        ;-------------------- directory $00
d839 24                 .BYTE "$"
d83a d1                 .BYTE $d1           ; drive 1

                        ;-------------------- dopen     $02
d83b d1                 .BYTE $d1           ; drive 1
d83c 3a                 .BYTE ":"
d83d f1                 .BYTE $f1           ; file 1
d83e 2c                 .BYTE ","
d83f e1                 .BYTE $e1           ; L,S,W
d840 2c                 .BYTE ","
d841 e0                 .BYTE $e0           ; Record length

                        ;-------------------- append    $09
d842 d1                 .BYTE $d1           ; drive 1
d843 3a                 .BYTE ":"
d844 f1                 .BYTE $f1           ; file 1
d845 2c 41              .BYTE ",A"

                        ;-------------------- header    $0e
d847 4e                 .BYTE "N"
d848 d1                 .BYTE $d1           ; drive 1
d849 3a                 .BYTE ":"
d84a f1                 .BYTE $f1           ; file 1
d84b 2c                 .BYTE ","
d84c d0                 .BYTE $d0           ; ID

                        ;-------------------- collect   $14
d84d 56                 .BYTE "V"
d84e d1                 .BYTE $d1           ; drive 1

                        ;-------------------- backup    $16
d84f 44                 .BYTE "D"
d850 d2                 .BYTE $d2           ; drive 2
d851 3d                 .BYTE "="
d852 d1                 .BYTE $d1           ; drive 1

                        ;-------------------- copy      $1a
d853 43                 .BYTE "C"
d854 d2                 .BYTE $d2           ; drive 2
d855 3a                 .BYTE ":"
d856 f2                 .BYTE $f2           ; file 2
d857 3d                 .BYTE "="
d858 d1                 .BYTE $d1           ; drive 1
d859 3a                 .BYTE ":"
d85a f1                 .BYTE $f1           ; file 1

                        ;-------------------- concat    $22
d85b 43                 .BYTE "C"
d85c d2                 .BYTE $d2           ; drive 2
d85d 3a                 .BYTE ":"
d85e f2                 .BYTE $f2           ; file 2
d85f 3d                 .BYTE "="
d860 d2                 .BYTE $d2           ; drive 2
d861 3a                 .BYTE ":"
d862 f2                 .BYTE $f2           ; file 2
d863 2c                 .BYTE ","
d864 d1                 .BYTE $d1           ; drive 1
d865 3a                 .BYTE ":"
d866 f1                 .BYTE $f1           ; file 1

                        ;-------------------- rename    $2e
d867 52                 .BYTE "R"
d868 d1                 .BYTE $d1           ; drive 1
d869 3a                 .BYTE ":"
d86a f2                 .BYTE $f2           ; file 2
d86b 3d                 .BYTE "="
d86c d1                 .BYTE $d1           ; drive 1
d86d 3a                 .BYTE ":"
d86e f1                 .BYTE $f1           ; file 1

                        ;-------------------- scratch   $36
d86f 53                 .BYTE "S"
d870 d1                 .BYTE $d1           ; drive 1
d871 3a                 .BYTE ":"
d872 f1                 .BYTE $f1           ; file 1

              ; ****************
d873            Kernal_DIRECTORY
              ; ****************

d873 20 68 dc           JSR Parse_DOS_Parameter
d876 20 18 d8           JSR Allow_Drive_And_Unit
d879 a0 00              LDY #0
d87b a2 01              LDX #1
d87d ad 3e 03           LDA DOS_Flags
d880 29 10              AND #16
d882 f0 01              BEQ DIRE_10
d884 e8                 INX                 ; drive given
d885 8a       DIRE_10   TXA
d886 20 fa db           JSR Build_DOS_Command

              ; **************
d889            Wedge_Call_Dir
              ; **************

d889 a9 60              LDA #$60            ; secondary address 0 for LOAD
d88b 85 d3              STA SA
d88d a9 0e              LDA #14             ; logical address used for loading directory
d88f 85 d2              STA LA
d891 20 b9 f1           JSR UNLSN
d894 20 65 f5           JSR Open_File
d897 a2 0e              LDX #14
d899 20 af f7           JSR Kernal_CHKIN    ; input from floppy
d89c a0 03              LDY #3              ; 1st time: skip load address + next line link
d89e 20 c0 f1 WCD_10    JSR ACPTR           ; read until length in blocks read
d8a1 aa                 TAX                 ; file size low in X
d8a2 a5 96              LDA STATUS
d8a4 d0 36              BNE WCD_80          ; abort if status bad
d8a6 20 c0 f1           JSR ACPTR           ; file size high in A
d8a9 88                 DEY
d8aa d0 f2              BNE WCD_10          ; if not done
d8ac 20 83 cf           JSR Print_Integer_XA; output number of blocks
d8af a9 20              LDA #' '            ; output separator space
d8b1 20 02 e2           JSR EDIT_CHROUT
d8b4 20 c0 f1 WCD_20    JSR ACPTR           ; get char
d8b7 f0 1a              BEQ WCD_40          ; branch if end of line
d8b9 a6 96              LDX STATUS          ; get status
d8bb d0 1f              BNE WCD_80          ; abort if bad status
d8bd 20 02 e2           JSR EDIT_CHROUT
d8c0 20 35 f3           JSR Check_STOP_Key  ; abort if STOP key pressed
d8c3 f0 17              BEQ WCD_80
d8c5 20 0d f2           JSR GETIN_10        ; read keyboard
d8c8 c9 20              CMP #' '
d8ca d0 e8              BNE WCD_20          ; continue if not SPACE pressed
d8cc 20 0d f2 WCD_30    JSR GETIN_10        ; read keyboard
d8cf f0 fb              BEQ WCD_30          ; loop until any key pressed
d8d1 d0 e1              BNE WCD_20          ; branch always: continue reading dir characters

d8d3 a9 0d    WCD_40    LDA #CR             ; end of line: output CR
d8d5 20 02 e2           JSR EDIT_CHROUT
d8d8 a0 02              LDY #2              ; further passes: skip line link only
d8da d0 c2              BNE WCD_10          ; branch always

d8dc 20 a6 f2 WCD_80    JSR Kernal_CLRCHN   ; exit: clear channel
d8df a9 0e              LDA #14             ; close directory
d8e1 4c e2 f2           JMP Close_LA_in_A

              ; ************
d8e4            Mon_Set_Bank
              ; ************

d8e4 20 80 d7           JSR Read_Hex
d8e7 85 b6              STA R_Bank
d8e9 4c b1 d4           JMP Mon_Main

              ; **************
d8ec            Mon_Write_Bank
              ; **************

d8ec 20 80 d7           JSR Read_Hex
d8ef 85 b7              STA W_Bank
d8f1 4c b1 d4           JMP Mon_Main

              ; *********
d8f4            Mon_CHRIN
              ; *********

d8f4 20 15 f2           JSR Kernal_CHRIN
d8f7 c9 0d              CMP #CR
d8f9 60                 RTS ;Size    6 [Mon_CHRIN]

              ; **********
d8fa            Hex_To_Bin
              ; **********

d8fa c9 3a              CMP #$3a
d8fc 08                 PHP
d8fd 29 0f              AND #15
d8ff 28                 PLP
d900 90 02              BCC HTB_Ret
d902 69 08              ADC #8
d904 60       HTB_Ret   RTS ;Size   11 [Hex_To_Bin]

              ; ******
d905            Is_Int
              ; ******

d905 c9 24              CMP #'$'
d907 f0 18              BEQ IH_True
d909 c9 2b              CMP #'+'
d90b f0 14              BEQ IH_True
d90d c9 2d              CMP #'-'
d90f f0 10              BEQ IH_True

              ; ******
d911            Is_Hex
              ; ******

d911 c9 47              CMP #'F'+1
d913 b0 0e              BCS IH_False
d915 c9 41              CMP #'A'
d917 b0 08              BCS IH_True

              ; ******
d919            Is_Dec
              ; ******

d919 c9 30              CMP #'0'
d91b 90 06              BCC IH_False
d91d c9 3a              CMP #'9'+1
d91f b0 02              BCS IH_False
d921 38       IH_True   SEC
d922 60                 RTS                 ; carry 1 : true ;Size   10 [Is_Dec]
d923 18       IH_False  CLC
d924 60                 RTS                 ; carry 0 : false ;Size   12 [Is_Dec]

d925 00 00 00           .FILL $d92f - * (0) ; 10 bytes

              ; **************
d92f            Select_Free_SA
              ; **************

d92f a0 61              LDY #$61            ; start with SA = $62
d931 c8       SFSA_10   INY
d932 98                 TYA
d933 a6 ae              LDX LDTND           ; # of open files
d935 ca       SFSA_20   DEX
d936 30 07              BMI SFSA_30         ; -> not in use : take this SA
d938 dd 65 02           CMP SAT,X
d93b f0 f4              BEQ SFSA_10         ; -> in use: try next
d93d d0 f6              BNE SFSA_20
d93f 84 d3    SFSA_30   STY SA
d941 60                 RTS ;Size   19 [Select_Free_SA]

              ; ********************
d942            Kernal_DOPEN ; $d942
              ; ********************

d942 20 68 dc           JSR Parse_DOS_Parameter
d945 20 2e d8           JSR Check_Record_Syntax
d948 29 22              AND #$22            ; 2nd. filename or drive ?
d94a d0 20              BNE DOPEN_Err
d94c 20 2f d9           JSR Select_Free_SA  ; choose free secondary address
d94f a2 00              LDX #0              ; buffer index
d951 a9 03              LDA #3              ; length of build string (open read)
d953 2c 3e 03           BIT DOS_Flags
d956 50 04              BVC DOPEN_20        ; -> not a write file
d958 08                 PHP                 ; save flags
d959 a9 07              LDA #7              ; length of build string (open write)
d95b 28                 PLP                 ; restore flags
d95c 10 06    DOPEN_20  BPL DOPEN_30        ; -> not a replacement
d95e a0 40              LDY #'@'            ; insert save & replace command
d960 8c 53 03           STY DOS_Command_Buffer
d963 e8                 INX                 ; advance buffer index
d964 a0 02    DOPEN_30  LDY #2              ; start  of build string (open)
d966 20 fc db           JSR Build_DOS_Command_X
d969 4c 63 f5           JMP Mf563
d96c 4c 00 bf DOPEN_Err JMP Syntax_Error

d96f                    .SIZE ;   45 [Kernal_DOPEN]

d96f 00 00 00           .FILL $d977-* (0) ; 8 bytes

              ; *********************
d977            Kernal_APPEND ; $d977
              ; *********************

d977 20 68 dc           JSR Parse_DOS_Parameter
d97a 20 2e d8           JSR Check_Record_Syntax
d97d 29 e2              AND #$e2            ; @,W,L,drive 2 or file 2 ?
d97f d0 eb              BNE DOPEN_Err
d981 20 2f d9           JSR Select_Free_SA
d984 a0 09              LDY #9              ; start  of build string (append)
d986 a9 05              LDA #5              ; length of build string (append)
d988 20 fa db           JSR Build_DOS_Command
d98b 4c 63 f5           JMP Mf563

d98e 00 00 00           .FILL $d991-* (0) ; 3 bytes

              ; **********************
d991            Kernal_Read_DS ; $d991
              ; **********************

d991 a5 d4              LDA FA
d993 d0 04              BNE KRD_10
d995 a9 08              LDA #8              ; default 8 if not set
d997 85 d4              STA FA
d999 20 d2 f0 KRD_10    JSR TALK
d99c a9 6f              LDA #$6f
d99e 85 d3              STA SA
d9a0 20 93 f1           JSR TKSA
d9a3 a2 00              LDX #0
d9a5 20 c0 f1 KDR_20    JSR ACPTR
d9a8 9d ad 03           STA DOS_Status,X
d9ab e8                 INX
d9ac c9 20              CMP #' '
d9ae 90 04              BCC KDR_30          ; end (normally CR)
d9b0 e0 29              CPX #41             ; buffer length
d9b2 90 f1              BCC KDR_20
d9b4 a9 00    KDR_30    LDA #0
d9b6 9d ad 03           STA DOS_Status,X
d9b9 20 ae f1           JSR UNTLK
d9bc ad ad 03           LDA DOS_Status      ; load first character
d9bf 60                 RTS ;Size   47 [Kernal_Read_DS]

d9c0 00 00 00           .FILL $d9d2-* (0) ; 18 bytes

              ; *********************
d9d2            Kernal_HEADER ; $d9d2
              ; *********************

d9d2 20 68 dc           JSR Parse_DOS_Parameter
d9d5 20 04 d8           JSR Allow_Drive_Unit_Filename
d9d8 29 11              AND #$11
d9da c9 11              CMP #$11            ; name & drive set ?
d9dc d0 8e              BNE DOPEN_Err
d9de 20 1b da           JSR Close_All_Device_Files
d9e1 20 9e db           JSR Are_You_Sure
d9e4 b0 1f              BCS HEAD_20         ; cancel if not 'YES'
d9e6 a0 0e              LDY #14             ; start  of build string
d9e8 a9 04              LDA #4              ; length of build string
d9ea ae 3f 03           LDX DOS_Id          ; ID given ?
d9ed f0 02              BEQ HEAD_10
d9ef a9 06              LDA #6              ; command includes ID
d9f1 20 98 da HEAD_10   JSR Put_DOS_Command
d9f4 20 91 d9           JSR Kernal_Read_DS
d9f7 c9 32              CMP #'2'
d9f9 90 0a              BCC HEAD_20         ; status < 20 are warnings
d9fb 20 51 f3           JSR In_Direct_Mode
d9fe d0 05              BNE HEAD_20
da00 a0 c5              LDY #<MSG_BAD_DISK  ; $c5
da02 4c 85 f1           JMP Display_Kernal_Message
da05 60       HEAD_20   RTS ;Size   52 [Kernal_HEADER]

da06 00                 .FILL $da07-* (0) ; 1 bytes

              ; *********************
da07            Kernal_DCLOSE ; $da07
              ; *********************

da07 20 68 dc           JSR Parse_DOS_Parameter
da0a 29 f3              AND #$f3            ; allow lfn only
da0c f0 03              BEQ CLOSE_10
da0e 4c 00 bf           JMP Syntax_Error
da11 20 e1 db CLOSE_10  JSR Clear_Status
da14 a5 d2              LDA LA
da16 f0 03              BEQ Close_All_Device_Files
da18 4c e2 f2           JMP Close_LA_in_A

              ; ******************************
da1b            Close_All_Device_Files ; $da1b
              ; ******************************

da1b a5 d4              LDA FA              ; Close all open files on device FA
da1d a6 ae              LDX LDTND
da1f ca       CLOSE_20  DEX
da20 30 0e              BMI CLOSE_Ret
da22 dd 5b 02           CMP FAT,X
da25 d0 f8              BNE CLOSE_20
da27 bd 51 02           LDA LAT,X
da2a 20 e7 f2           JSR Close_File_A
da2d b8                 CLV
da2e 50 eb              BVC Close_All_Device_Files
da30 60       CLOSE_Ret RTS ;Size   22 [Close_All_Device_Files]

              ; ****************************
da31            Build_Record_Command ; $da31
              ; ****************************

da31 a5 d2              LDA LA
da33 20 c1 f2           JSR LOOKUP_LA
da36 f0 05              BEQ BRC_10
da38 a0 17              LDY #<MSG_FILE_NOT_O; $17
da3a 4c af f5           JMP Handle_IO_Error
da3d 20 cd f2 BRC_10    JSR Set_LFS_From_X
da40 20 e1 db           JSR Clear_Status

              ; *********************
da43            DOS_Record_No ; $da43
              ; *********************

da43 a9 50              LDA #'P'
da45 8d 53 03           STA DOS_Command_Buffer
da48 a5 d3              LDA SA
da4a 8d 54 03           STA DOS_Command_Buffer+1
da4d a5 11              LDA LINNUM
da4f 8d 55 03           STA DOS_Command_Buffer+2
da52 a5 12              LDA LINNUM+1
da54 8d 56 03           STA DOS_Command_Buffer+3
da57 ad 3a 03           LDA DOS_Tmp
da5a 8d 57 03           STA DOS_Command_Buffer+4
da5d a2 05              LDX #5
da5f 20 4c dc           JSR DOS_SETNAM
da62 4c 9b da           JMP PDC_10

              ; **********************
da65            Kernal_COLLECT ; $da65
              ; **********************

da65 20 68 dc           JSR Parse_DOS_Parameter
da68 20 18 d8           JSR Allow_Drive_And_Unit
da6b 20 1b da           JSR Close_All_Device_Files
da6e a0 14              LDY #$14
da70 a2 01              LDX #1
da72 ad 3e 03           LDA DOS_Flags
da75 29 10              AND #16             ; drive set ?
da77 f0 01              BEQ COLL_10
da79 e8                 INX
da7a 8a       COLL_10   TXA
da7b 4c 98 da           JMP Put_DOS_Command

              ; *************
da7e            Kernal_BACKUP
              ; *************

da7e 20 68 dc           JSR Parse_DOS_Parameter
da81 29 30              AND #$30
da83 c9 30              CMP #$30            ; two drives set ?
da85 f0 03              BEQ BACK_10
da87 4c 00 bf BACK_Err  JMP Syntax_Error
da8a ad 3e 03 BACK_10   LDA DOS_Flags
da8d 29 c7              AND #$c7
da8f d0 f6              BNE BACK_Err
da91 20 1b da           JSR Close_All_Device_Files
da94 a0 16              LDY #$16
da96 a9 04              LDA #4

              ; ***************
da98            Put_DOS_Command
              ; ***************

da98 20 fa db           JSR Build_DOS_Command
da9b 20 d5 f0 PDC_10    JSR LISTEN
da9e a9 6f              LDA #$6f            ; SA #15
daa0 4c ba f4           JMP Send_DOS_Command

daa3 00 00 00           .FILL $daa7-* (0) ; 4 bytes

              ; *******************
daa7            Kernal_COPY ; $daa7
              ; *******************

daa7 20 68 dc           JSR Parse_DOS_Parameter
daaa a5 9c              LDA Source_Unit     ; check source unit
daac f0 07              BEQ KECO_10         ; not specified
daae c5 d4              CMP FA              ; same as target ?
dab0 f0 03              BEQ KECO_10         ; yes, stay here
dab2 4c 65 ee           JMP DOS_Copy        ; -> extended COPY
dab5 a0 1a    KECO_10   LDY #$1a            ; offset
dab7 a9 08              LDA #8              ; command length
dab9 4c 98 da           JMP Put_DOS_Command

dabc 00 00 00           .FILL $dac7 - * (0) ; 11 bytes

              ; *********************
dac7            Kernal_CONCAT ; $dac7
              ; *********************

dac7 20 68 dc           JSR Parse_DOS_Parameter
daca 20 1d d8           JSR No_WL_Record
dacd a0 22              LDY #$22
dacf a9 0c              LDA #12
dad1 4c 98 da           JMP Put_DOS_Command

              ; ***************************
dad4            Copy_Filename_To_DOS_Buffer
              ; ***************************

dad4 a5 d1              LDA FNLEN
dad6 8d 3a 03           STA DOS_Tmp
dad9 a5 da              LDA FNADR
dadb 85 fd              STA MEMUSS
dadd a5 db              LDA FNADR+1
dadf 85 fe              STA MEMUSS+1

              ; *************************
dae1            Copy_MEMUSS_To_DOS_Buffer
              ; *************************

dae1 98                 TYA
dae2 48                 PHA
dae3 ac 3a 03           LDY DOS_Tmp
dae6 f0 10              BEQ CMDB_20
dae8 a0 00              LDY #0
daea b1 fd    CMDB_10   LDA (MEMUSS),Y
daec 9d 53 03           STA DOS_Command_Buffer,X
daef e8                 INX
daf0 c8                 INY
daf1 cc 3a 03           CPY DOS_Tmp
daf4 d0 f4              BNE CMDB_10
daf6 f0 01              BEQ CMDB_30
daf8 ca       CMDB_20   DEX
daf9 68       CMDB_30   PLA
dafa a8                 TAY
dafb 38                 SEC
dafc 60                 RTS ;Size   28 [Copy_MEMUSS_To_DOS_Buffer]

              ; *************
dafd            Insert_DOS_Id
              ; *************

dafd ad 3f 03           LDA DOS_Id
db00 9d 53 03           STA DOS_Command_Buffer,X
db03 e8                 INX
db04 ad 40 03           LDA DOS_Id+1
db07 9d 53 03           STA DOS_Command_Buffer,X
db0a e8                 INX
db0b 8a                 TXA
db0c 60                 RTS ;Size   16 [Insert_DOS_Id]

              ; ********************
db0d            Kernal_DSAVE ; $db0d
              ; ********************

db0d 20 68 dc           JSR Parse_DOS_Parameter
db10 20 0b d8           JSR Check_Filename_Given
db13 29 66              AND #$66            ; no 2nd. file ?
db15 f0 03              BEQ DSAVE_10
db17 4c 00 bf           JMP Syntax_Error
db1a a0 02    DSAVE_10  LDY #2
db1c ad 3e 03           LDA DOS_Flags
db1f 29 80              AND #$80
db21 f0 0f              BEQ DSAVE_20
db23 a9 40              LDA #'@'            ; save & replace
db25 8d 53 03           STA DOS_Command_Buffer
db28 a2 01              LDX #1
db2a a9 03              LDA #3
db2c 20 fc db           JSR Build_DOS_Command_X
db2f 4c e0 f6           JMP Mf6e0
db32 a9 03    DSAVE_20  LDA #3
db34 20 fa db           JSR Build_DOS_Command
db37 4c e0 f6           JMP Mf6e0

              ; ********************
db3a            Kernal_DLOAD ; $db3a
              ; ********************

db3a 20 68 dc           JSR Parse_DOS_Parameter
db3d 20 0b d8           JSR Check_Filename_Given
db40 29 e6              AND #$e6
db42 f0 03              BEQ DLOAD_20
db44 4c 00 bf DLOAD_10  JMP Syntax_Error
db47 a0 02    DLOAD_20  LDY #2
db49 a9 03              LDA #3
db4b 20 fa db           JSR Build_DOS_Command
db4e a9 00              LDA #0
db50 85 9d              STA VERCK
db52 4c 1d f4           JMP Load_Verify_Params_Set

              ; *********************
db55            Kernal_RENAME ; $db55
              ; *********************

db55 20 68 dc           JSR Parse_DOS_Parameter
db58 20 24 d8           JSR Check_Filename_Syntax
db5b 29 e4              AND #$e4
db5d d0 e5              BNE DLOAD_10
db5f a0 2e              LDY #$2e
db61 a9 08              LDA #8
db63 4c 98 da           JMP Put_DOS_Command

              ; **********************
db66            Kernal_SCRATCH ; $db66
              ; **********************

db66 20 68 dc           JSR Parse_DOS_Parameter
db69 20 04 d8           JSR Allow_Drive_Unit_Filename
db6c 20 9e db           JSR Are_You_Sure
db6f b0 21              BCS DiSt_Ret
db71 a0 36              LDY #$36
db73 a9 04              LDA #4
db75 20 98 da           JSR Put_DOS_Command
db78 20 51 f3           JSR In_Direct_Mode
db7b d0 15              BNE DiSt_Ret
db7d 20 91 d9           JSR Kernal_Read_DS
db80 a9 0d              LDA #CR
db82 20 02 e2           JSR EDIT_CHROUT

              ; **************
db85            Display_Status
              ; **************

db85 a0 00              LDY #0
db87 b9 ad 03 DiSt_10   LDA DOS_Status,Y
db8a c8                 INY
db8b 20 02 e2           JSR EDIT_CHROUT
db8e c9 20              CMP #' '            ; check for end
db90 b0 f5              BCS DiSt_10
db92 60       DiSt_Ret  RTS ;Size   14 [Display_Status]

db93 00 00 00           .FILL $db9e-* (0) ; 11 bytes

              ; ********************
db9e            Are_You_Sure ; $db9e
              ; ********************

db9e 20 51 f3           JSR In_Direct_Mode
dba1 d0 32              BNE AYS_20
dba3 a0 b6              LDY #<MSG_SURE      ; $b6
dba5 20 85 f1           JSR Display_Kernal_Message
dba8 20 a6 f2           JSR Kernal_CLRCHN
dbab 20 15 f2           JSR Kernal_CHRIN
dbae c9 59              CMP #'Y'
dbb0 d0 19              BNE AYS_10
dbb2 20 15 f2           JSR Kernal_CHRIN
dbb5 c9 0d              CMP #CR
dbb7 f0 1c              BEQ AYS_20
dbb9 c9 45              CMP #'E'
dbbb d0 0e              BNE AYS_10
dbbd 20 15 f2           JSR Kernal_CHRIN
dbc0 c9 53              CMP #'S'
dbc2 d0 07              BNE AYS_10
dbc4 20 15 f2           JSR Kernal_CHRIN
dbc7 c9 0d              CMP #CR
dbc9 f0 0a              BEQ AYS_20
dbcb c9 0d    AYS_10    CMP #CR
dbcd 38                 SEC
dbce f0 06              BEQ AYS_Ret
dbd0 20 15 f2           JSR Kernal_CHRIN
dbd3 d0 f6              BNE AYS_10
dbd5 18       AYS_20    CLC
dbd6 60       AYS_Ret   RTS ;Size   57 [Are_You_Sure]

dbd7 00 00 00           .FILL $dbe1-* (0) ; 10 bytes

              ; ********************
dbe1            Clear_Status ; $dbe1
              ; ********************

dbe1 a9 00              LDA #0
dbe3 85 96              STA STATUS          ; clear STATUS
dbe5 60                 RTS ;Size    5 [Clear_Status]

dbe6 00 00 00           .FILL $dbfa-* (0) ; 20 bytes

              ; *************************
dbfa            Build_DOS_Command ; $dbfa
              ; *************************

dbfa a2 00              LDX #0

              ; *******************
dbfc            Build_DOS_Command_X
              ; *******************

dbfc 8d 41 03           STA DOS_Command_Length
dbff 20 e1 db           JSR Clear_Status
dc02 ce 41 03 BDC_10    DEC DOS_Command_Length
dc05 30 45              BMI DOS_SETNAM      ; -> finished
dc07 c8                 INY
dc08 b9 38 d8           LDA DOS_Build_Table,Y
dc0b 10 39              BPL BDC_90          ; -> insert
dc0d c9 f1              CMP #$f1            ; insert file 1
dc0f d0 03              BNE BDC_20
dc11 20 d4 da           JSR Copy_Filename_To_DOS_Buffer
dc14 c9 f2    BDC_20    CMP #$f2            ; insert file 2
dc16 d0 03              BNE BDC_30
dc18 20 e1 da           JSR Copy_MEMUSS_To_DOS_Buffer
dc1b c9 e0    BDC_30    CMP #$e0            ; insert 2nd. attribute
dc1d d0 05              BNE BDC_40          ; W,S or R,record length
dc1f ad 3d 03           LDA DOS_Attr        ; record length
dc22 d0 22              BNE BDC_90          ; always
dc24 c9 d0    BDC_40    CMP #$d0            ; insert ID
dc26 d0 03              BNE BDC_50
dc28 20 fd da           JSR Insert_DOS_Id
dc2b c9 e1    BDC_50    CMP #$e1            ; insert 1st. attribute
dc2d d0 05              BNE BDC_60
dc2f 20 57 dc           JSR Write_Attribute
dc32 d0 12              BNE BDC_90
dc34 c9 d1    BDC_60    CMP #$d1            ; insert drive 1
dc36 d0 05              BNE BDC_70
dc38 ad 3b 03           LDA DOS_Drive_1
dc3b 10 07              BPL BDC_80
dc3d c9 d2    BDC_70    CMP #$d2            ; insert drive 2
dc3f d0 c1              BNE BDC_10
dc41 ad 3c 03           LDA DOS_Drive_2
dc44 09 30    BDC_80    ORA #'0'
dc46 9d 53 03 BDC_90    STA DOS_Command_Buffer,X
dc49 e8                 INX
dc4a d0 b6              BNE BDC_10

              ; **********
dc4c            DOS_SETNAM
              ; **********

dc4c 86 d1              STX FNLEN
dc4e a9 53              LDA #<DOS_Command_Buffer
dc50 85 da              STA FNADR
dc52 a9 03              LDA #>DOS_Command_Buffer
dc54 85 db              STA FNADR+1
dc56 60                 RTS ;Size   11 [DOS_SETNAM]

              ; ***************
dc57            Write_Attribute
              ; ***************

dc57 ad 3d 03           LDA DOS_Attr
dc5a f0 04              BEQ WrAt_10
dc5c a9 4c              LDA #'L'            ; L,record length
dc5e d0 07              BNE WrAt_Ret
dc60 a9 53    WrAt_10   LDA #'S'            ; W,S
dc62 8d 3d 03           STA DOS_Attr
dc65 a9 57              LDA #'W'
dc67 60       WrAt_Ret  RTS ;Size   17 [Write_Attribute]

              ; This is the universal DOS parser
              ; It is called by all BASIC 4 DOS commands and scans and stores

              ; LA              = logical address
              ; FA              = primary address (UNIT)
              ; DOS_Drive_1     = source drive
              ; DOS_Drive_2     = target drive
              ; FNADR, FNLEN    = source filename
              ; MEMUSS, DOS_Tmp = target filename
              ; Access  mode
              ; Replace mode

              ; DOS_Flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

              ; The routine returns with the flags stored in DOS_Flags
              ; and in the accumulator.

              ; ***************************
dc68            Parse_DOS_Parameter ; $dc68
              ; ***************************

dc68 a2 00              LDX #0              ; clear:
dc6a 8e 3e 03           STX DOS_Flags       ; all flags
dc6d 86 d2              STX LA              ; logical address
dc6f 8e 3d 03           STX DOS_Attr        ; attribute
dc72 8e 3b 03           STX DOS_Drive_1     ; source drive
dc75 8e 3c 03           STX DOS_Drive_2     ; target drive
dc78 86 d1              STX FNLEN           ; filename length
dc7a 8e 3a 03           STX DOS_Tmp         ; temporary storage
dc7d 8e 3f 03           STX DOS_Id          ; ID
dc80 86 9c              STX Source_Unit     ; for cross UNIT copy
dc82 a2 08              LDX #8              ; preset DOS device
dc84 86 d4              STX FA              ; with unit 8
dc86 20 76 00           JSR CHRGOT          ; start parsing
dc89 d0 03              BNE PDP_02          ; continue
dc8b 4c f9 dd           JMP PDP_68          ; finish

dc8e c9 23    PDP_02    CMP #'#'            ; logical address ?
dc90 f0 2a              BEQ PDP_10
dc92 c9 57              CMP #'W'            ; write mode ?
dc94 f0 3e              BEQ PDP_12
dc96 c9 4c              CMP #'L'            ; relative file ?
dc98 f0 45              BEQ PDP_14
dc9a c9 52              CMP #'R'            ; read mode ?
dc9c d0 03              BNE PDP_04
dc9e 4c 4a dd           JMP PDP_37

dca1 c9 44    PDP_04    CMP #'D'            ; Drive ?
dca3 f0 63              BEQ PDP_26          ; parse drive #
dca5 c9 91              CMP #$91            ; ON token
dca7 f0 4f              BEQ PDP_22          ; parse unit D(value)
dca9 c9 55              CMP #'U'            ; Unit ?
dcab f0 53              BEQ PDP_24          ; parse unit value
dcad c9 22              CMP #QUOTE
dcaf f0 44              BEQ PDP_20
dcb1 c9 49              CMP #'I'            ; ID parameter on HEADER ?
dcb3 f0 72              BEQ PDP_30
dcb5 c9 28              CMP #'('
dcb7 f0 3c              BEQ PDP_20
dcb9 4c 00 bf PDP_08    JMP Syntax_Error    ; parse error

dcbc ad 3e 03 PDP_10    LDA DOS_Flags       ; get logical address
dcbf 29 04              AND #4              ; test if set already
dcc1 d0 f6              BNE PDP_08          ; error if set
dcc3 20 87 de           JSR DOS_Parse_Value ; get logical address
dcc6 e0 00              CPX #0              ; is address equal zero ?
dcc8 f0 5a              BEQ PDP_28          ; -> illegal quantity
dcca 86 d2              STX LA              ; store logical address
dccc a9 04              LDA #4              ; logical address defined
dcce 20 fd dd           JSR Set_DOS_Flags
dcd1 4c 72 dd           JMP PDP_44

dcd4 2c 3e 03 PDP_12    BIT DOS_Flags       ; process W parameter
dcd7 70 e0              BVS PDP_08          ; bit 6 already set ?
dcd9 20 70 00           JSR CHRGET          ; skip 'W'
dcdc 4c ed dc           JMP PDP_16          ; continue

dcdf 20 87 de PDP_14    JSR DOS_Parse_Value ; get record length
dce2 e0 00              CPX #0              ; is it zero ?
dce4 f0 3e              BEQ PDP_28          ; -> illegal quantity
dce6 e0 ff              CPX #$ff            ; ist it 255 ?
dce8 f0 3a              BEQ PDP_28          ; -> illegal quantity
dcea 8e 3d 03           STX DOS_Attr        ; store record length

dced a9 40    PDP_16    LDA #$40            ; mark W or L set
dcef 20 fd dd           JSR Set_DOS_Flags
dcf2 4c 72 dd           JMP PDP_44

dcf5 4c 50 dd PDP_20    JMP PDP_38

dcf8 20 2c de PDP_22    JSR DOS_Parse_Unit
dcfb 86 9c              STX Source_Unit
dcfd 4c 72 dd           JMP PDP_44
dd00 20 33 de PDP_24    JSR Get_Unit_Value
dd03 86 9c              STX Source_Unit
dd05 4c 72 dd           JMP PDP_44
dd08 ad 3e 03 PDP_26    LDA DOS_Flags
dd0b 29 10              AND #16             ; drive # already set ?
dd0d d0 aa              BNE PDP_08          ; error if so
dd0f 20 87 de           JSR DOS_Parse_Value
dd12 e0 0a              CPX #10             ; original ROM had CPX #2 (D0 and D1 only)
dd14 b0 0e              BCS PDP_28          ; error for drive # > 9
dd16 8e 3b 03           STX DOS_Drive_1     ; store drive #
dd19 8e 3c 03           STX DOS_Drive_2     ; store drive #
dd1c a9 10              LDA #16             ; mark drive # set
dd1e 20 fd dd           JSR Set_DOS_Flags
dd21 4c 72 dd           JMP PDP_44
dd24 4c 27 de PDP_28    JMP DOS_JMP_Illegal_Quantity
dd27 ad 3d 03 PDP_30    LDA DOS_Attr        ; test DOS_Attr
dd2a 29 ff              AND #$ff            ; this is needless
dd2c f0 03              BEQ PDP_32          ; continue if zero
dd2e 4c 00 bf           JMP Syntax_Error    ; error if not zero
dd31 a0 00    PDP_32    LDY #0              ; parse ID string for HEADER
dd33 a2 00              LDX #0
dd35 e6 77    PDP_34    INC TXTPTR          ; advance TXTPTR
dd37 d0 02              BNE PDP_36
dd39 e6 78              INC TXTPTR+1
dd3b b1 77    PDP_36    LDA (TXTPTR),Y      ; get ID string
dd3d 9d 3f 03           STA DOS_Id,X
dd40 e8                 INX
dd41 e0 02              CPX #2              ; maximum 2 characters
dd43 90 f0              BCC PDP_34
dd45 a9 ff              LDA #$ff
dd47 8d 3d 03           STA DOS_Attr        ; mark ID defined
dd4a 20 70 00 PDP_37    JSR CHRGET          ; advance to next character
dd4d 4c 72 dd           JMP PDP_44
dd50 ad 3e 03 PDP_38    LDA DOS_Flags
dd53 29 01              AND #1              ; error if filename defined
dd55 20 49 de           JSR DOS_Parse_Filename
dd58 85 d1              STA FNLEN
dd5a 8d 41 03           STA DOS_Command_Length
dd5d 20 cc d6           JSR Set_DOS_FNADR
dd60 a0 00              LDY #0
dd62 b1 1f    PDP_40    LDA (INDEXA),Y      ; copy string to filename
dd64 99 42 03           STA DOS_Filename,Y  ; store filename
dd67 c8                 INY
dd68 cc 41 03           CPY DOS_Command_Length
dd6b 90 f5              BCC PDP_40
dd6d a9 01              LDA #1              ; mark filename defined
dd6f 20 fd dd           JSR Set_DOS_Flags
dd72 20 76 00 PDP_44    JSR CHRGOT          ; next character to parse
dd75 d0 03              BNE PDP_46          ; there is more
dd77 4c f9 dd           JMP PDP_68          ; finish parsing
dd7a c9 2c    PDP_46    CMP #','            ; comma ?
dd7c d0 06              BNE PDP_48          ; look for tokens
dd7e 20 70 00           JSR CHRGET          ; next character after comma
dd81 4c 8e dc           JMP PDP_02          ; parse next sequence
dd84 c9 91    PDP_48    CMP #$91            ; ON token
dd86 d0 03              BNE PDP_50
dd88 4c f8 dc           JMP PDP_22          ; parse unit
dd8b c9 a4    PDP_50    CMP #$a4            ; TO token
dd8d f0 03              BEQ PDP_52
dd8f 4c 00 bf           JMP Syntax_Error
dd92 20 70 00 PDP_52    JSR CHRGET
dd95 c9 44              CMP #'D'
dd97 f0 13              BEQ PDP_56          ; parse target drive
dd99 c9 91              CMP #$91            ; ON token
dd9b f0 28              BEQ PDP_58          ; get UNIT
dd9d c9 55              CMP #'U'
dd9f f0 2a              BEQ PDP_60          ; get UNIT value
dda1 c9 22              CMP #QUOTE
dda3 f0 2c              BEQ PDP_62
dda5 c9 28              CMP #'('
dda7 f0 28              BEQ PDP_62
dda9 4c 00 bf PDP_54    JMP Syntax_Error
ddac ad 3e 03 PDP_56    LDA DOS_Flags
ddaf 29 20              AND #$20            ; Drive 2 defined ?
ddb1 d0 f6              BNE PDP_54          ; error if so
ddb3 20 87 de           JSR DOS_Parse_Value
ddb6 e0 0a              CPX #10             ; original ROM: CPX #2 (D0 and D1 only)
ddb8 b0 6d              BCS DOS_JMP_Illegal_Quantity
ddba 8e 3c 03           STX DOS_Drive_2
ddbd a9 20              LDA #$20            ; mark drive 2 defined
ddbf 20 fd dd           JSR Set_DOS_Flags
ddc2 4c e5 dd           JMP PDP_64
ddc5 20 2c de PDP_58    JSR DOS_Parse_Unit
ddc8 4c e5 dd           JMP PDP_64
ddcb 20 33 de PDP_60    JSR Get_Unit_Value
ddce 4c e5 dd           JMP PDP_64
ddd1 ad 3e 03 PDP_62    LDA DOS_Flags
ddd4 29 02              AND #2              ; error if target filename there
ddd6 20 49 de           JSR DOS_Parse_Filename
ddd9 8d 3a 03           STA DOS_Tmp         ; length of target filename
dddc 86 fd              STX MEMUSS          ; save descriptor in MEMUSS
ddde 84 fe              STY MEMUSS+1
dde0 a9 02              LDA #2              ; mark target filename parsed
dde2 20 fd dd           JSR Set_DOS_Flags
dde5 20 76 00 PDP_64    JSR CHRGOT          ; current character
dde8 f0 0f              BEQ PDP_68          ; finish
ddea c9 2c              CMP #','            ; another comma
ddec f0 a4              BEQ PDP_52          ; continue
ddee c9 91              CMP #$91            ; ON token
ddf0 f0 d3              BEQ PDP_58          ; continue
ddf2 c9 55              CMP #'U'
ddf4 f0 d5              BEQ PDP_60          ; get UNIT
ddf6 4c 00 bf PDP_66    JMP Syntax_Error
ddf9 ad 3e 03 PDP_68    LDA DOS_Flags
ddfc 60                 RTS ;Size  405 [Parse_DOS_Parameter]

              ; *************
ddfd            Set_DOS_Flags
              ; *************

ddfd 0d 3e 03           ORA DOS_Flags
de00 8d 3e 03           STA DOS_Flags
de03 60                 RTS ;Size    7 [Set_DOS_Flags]

de04 00 00 00           .FILL $de27 - * (0) ; 35 bytes

              ; ************************
de27            DOS_JMP_Illegal_Quantity
              ; ************************

de27 a2 35              LDX #Msg_QUANT-Msg_Start ; $35
de29 4c cf b3           JMP Basic_Error

              ; **************
de2c            DOS_Parse_Unit
              ; **************

de2c 20 70 00           JSR CHRGET
de2f c9 55              CMP #'U'
de31 d0 c3              BNE PDP_66

              ; **************
de33            Get_Unit_Value
              ; **************

de33 20 87 de           JSR DOS_Parse_Value
de36 e0 20              CPX #32
de38 b0 ed              BCS DOS_JMP_Illegal_Quantity
de3a e0 03              CPX #3
de3c 90 e9              BCC DOS_JMP_Illegal_Quantity
de3e 86 d4              STX FA
de40 a9 08              LDA #8
de42 4c fd dd           JMP Set_DOS_Flags

de45 00 00 00           .FILL $de49 - * (0) ; 4 bytes

              ; ******************
de49            DOS_Parse_Filename
              ; ******************

de49 d0 ab              BNE PDP_66
de4b 20 98 bd           JSR Eval_Expression
de4e 20 b5 c7           JSR Eval_And_Free_String
de51 aa                 TAX                 ; string length
de52 f0 d3              BEQ DOS_JMP_Illegal_Quantity
de54 a0 00              LDY #0
de56 b1 1f              LDA (INDEXA),Y
de58 c9 40              CMP #'@'            ; replace character
de5a d0 14              BNE DPF_30
de5c 2c 3e 03           BIT DOS_Flags       ; @ already used ?
de5f 10 03              BPL DPF_10
de61 4c 00 bf           JMP Syntax_Error
de64 e6 1f    DPF_10    INC INDEXA          ; skip @
de66 d0 02              BNE DPF_20
de68 e6 20              INC INDEXA+1
de6a ca       DPF_20    DEX                 ; length - @
de6b a9 80              LDA #$80
de6d 20 fd dd           JSR Set_DOS_Flags
de70 8a       DPF_30    TXA                 ; string length
de71 f0 b4              BEQ DOS_JMP_Illegal_Quantity
de73 c9 11              CMP #17
de75 90 05              BCC DPF_40
de77 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
de79 4c cf b3           JMP Basic_Error
de7c a6 1f    DPF_40    LDX INDEXA          ; string address low
de7e a4 20              LDY INDEXA+1        ; string address high
de80 60                 RTS ;Size   56 [DOS_Parse_Filename]

de81 00 00 00           .FILL $de87 - * (0) ; 6 bytes

              ; ***************
de87            DOS_Parse_Value
              ; ***************

de87 20 70 00           JSR CHRGET

              ; ************
de8a            DOS_Get_Byte
              ; ************

de8a d0 03              BNE DGB_10
de8c 4c 00 bf           JMP Syntax_Error
de8f 90 09    DGB_10    BCC DGB_20
de91 20 f2 be           JSR Need_Left_Parenthesis
de94 20 d4 c8           JSR Get_Byte_Value
de97 4c ef be           JMP Need_Right_Parenthesis
de9a 4c d4 c8 DGB_20    JMP Get_Byte_Value

              ; *************
de9d            Start_Message
              ; *************

de9d 2a 2a 2a           .PET '*** BSOS 8296 ***\r\r',0

              ; ********
deb1            Renumber
              ; ********

              ; check for arguments: RENUMBER new start, increment, old start

deb1 a9 0a              LDA #10
deb3 85 21              STA RENINC          ; preset increment low
deb5 85 23              STA RENNEW          ; preset start low
deb7 a9 00              LDA #0
deb9 85 22              STA RENINC+1
debb 85 24              STA RENNEW+1
debd 20 76 00           JSR CHRGOT
dec0 b0 4d              BCS Renu_15         ; no arguments
dec2 20 f6 b8           JSR Scan_Linenumber
dec5 a5 11              LDA LINNUM
dec7 85 23              STA RENNEW          ; start low
dec9 05 12              ORA LINNUM+1
decb d0 03              BNE Renu_10
decd 4c 73 c3 Renu_Err  JMP Jump_To_Illegal_Quantity
ded0 a5 12    Renu_10   LDA LINNUM+1
ded2 85 24              STA RENNEW+1        ; start high
ded4 20 76 00           JSR CHRGOT
ded7 c9 2c              CMP #','
ded9 d0 34              BNE Renu_15
dedb 20 70 00           JSR CHRGET
dede 20 f6 b8           JSR Scan_Linenumber
dee1 a5 11              LDA LINNUM
dee3 85 21              STA RENINC          ; inc low
dee5 05 12              ORA LINNUM+1
dee7 f0 e4              BEQ Renu_Err
dee9 a5 12              LDA LINNUM+1
deeb 85 22              STA RENINC+1        ; inc high
deed 20 76 00           JSR CHRGOT
def0 c9 2c              CMP #','
def2 d0 1b              BNE Renu_15
def4 20 70 00           JSR CHRGET
def7 20 f6 b8           JSR Scan_Linenumber ; get old start
defa 20 0f eb           JSR Find_Power_Line ; find start line
defd a0 02              LDY #2
deff b1 57              LDA (TMPPTB),Y      ; previous # low
df01 c5 23              CMP RENNEW
df03 c8                 INY
df04 b1 57              LDA (TMPPTB),Y      ; previous # high
df06 e5 24              SBC RENNEW+1
df08 b0 c3              BCS Renu_Err        ; New line # would be less than previous
df0a 20 55 ed           JSR Reset_BPTR
df0d d0 03              BNE Renu_20         ; always

              ; phase 1: build table of old and new numbers

df0f 20 4d ed Renu_15   JSR Reset_Renumber_Pointer
df12 20 6e ec Renu_20   JSR Install_Bank_Access
df15 a9 80              LDA #$80
df17 85 b6              STA R_Bank
df19 85 b7              STA W_Bank

              ; start of new line numbers

df1b a0 01    Renu_25   LDY #1
df1d b1 5c              LDA (TMPPTC),Y      ; link high
df1f f0 34              BEQ Renu_30         ; finished
df21 c8                 INY                 ; Y = 2

              ; next table entry

df22 b1 5c              LDA (TMPPTC),Y      ; old line low
df24 20 8b 02           JSR Bank_Store
df27 c8                 INY                 ; Y = 3
df28 b1 5c              LDA (TMPPTC),Y      ; old line high
df2a 20 8b 02           JSR Bank_Store
df2d a0 01              LDY #1
df2f a5 24              LDA RENNEW+1        ; new line high
df31 20 8b 02           JSR Bank_Store
df34 88                 DEY                 ; Y = 0
df35 a5 23              LDA RENNEW          ; new line low
df37 20 8b 02           JSR Bank_Store

              ; increment new line

df3a 18                 CLC
df3b a5 23              LDA RENNEW
df3d 65 21              ADC RENINC
df3f 85 23              STA RENNEW
df41 a5 24              LDA RENNEW+1
df43 65 22              ADC RENINC+1
df45 85 24              STA RENNEW+1
df47 c9 fa              CMP #$fa            ; > 64000
df49 b0 82              BCS Renu_Err        ; line # overflow

              ; increment table pointer

df4b a9 04              LDA #4
df4d 20 21 fb           JSR Add_BPTR

              ; next basic line

df50 20 5e ed           JSR Update_Link
df53 d0 c6              BNE Renu_25         ; branch if link is not zero

              ; table finished

df55 a0 03    Renu_30   LDY #3
df57 a9 ff              LDA #$ff            ; end marker
df59 20 8b 02 Renu_35   JSR Bank_Store
df5c 88                 DEY
df5d 10 fa              BPL Renu_35

              ; phase 2: build a renumbered copy in bank 2

df5f a9 8c              LDA #$8c
df61 85 b7              STA W_Bank
df63 20 4d ed           JSR Reset_Renumber_Pointer

              ; copy link - will be recalculated at end

df66 a0 00    Renu_40   LDY #0
df68 b1 5c              LDA (TMPPTC),Y      ; link low
df6a 20 8b 02           JSR Bank_Store
df6d c8                 INY
df6e b1 5c              LDA (TMPPTC),Y      ; link high
df70 20 8b 02           JSR Bank_Store
df73 f0 2b              BEQ Renu_45         ; finished

              ; exchange line number from table or copy if not found

df75 c8                 INY
df76 b1 5c              LDA (TMPPTC),Y      ; line # low
df78 aa                 TAX
df79 c8                 INY
df7a b1 5c              LDA (TMPPTC),Y      ; line # high
df7c 20 32 ec           JSR Find_Entry
df7f a0 02              LDY #2
df81 a5 11              LDA LINNUM
df83 20 8b 02           JSR Bank_Store
df86 c8                 INY
df87 a5 12              LDA LINNUM+1
df89 20 8b 02           JSR Bank_Store
df8c 20 a9 ec           JSR Xfer_Line
df8f c8                 INY                 ; Add Y + 1
df90 98                 TYA
df91 20 21 fb           JSR Add_BPTR
df94 20 5e ed           JSR Update_Link
df97 a5 fa              LDA BPTR+1
df99 c9 fb              CMP #$fb
df9b 90 c9              BCC Renu_40
df9d 4c cd b3           JMP Error_Out_Of_Memory

              ; copy new program from bank 2 to BASIC memory

dfa0 a9 8c    Renu_45   LDA #$8c            ; bank 1
dfa2 85 b6              STA R_Bank
dfa4 18                 CLC
dfa5 a5 f9              LDA BPTR
dfa7 69 03              ADC #3
dfa9 85 23              STA RENNEW          ; end address low
dfab a5 fa              LDA BPTR+1
dfad 69 00              ADC #0
dfaf aa                 TAX                 ; end address high
dfb0 a9 00              LDA #0
dfb2 85 fb              STA STAL
dfb4 a9 80              LDA #$80
dfb6 85 fc              STA STAL+1
dfb8 20 4d ed           JSR Reset_Renumber_Pointer
dfbb a0 00              LDY #0
dfbd 20 7a 02 Renu_50   JSR Bank_Fetch
dfc0 91 5c              STA (TMPPTC),Y
dfc2 c4 23              CPY RENNEW
dfc4 d0 04              BNE Renu_55
dfc6 e4 fc              CPX STAL+1
dfc8 f0 09              BEQ Renu_60
dfca c8       Renu_55   INY
dfcb d0 f0              BNE Renu_50
dfcd e6 5d              INC TMPPTC+1
dfcf e6 fc              INC STAL+1
dfd1 d0 ea              BNE Renu_50
dfd3 a5 5d    Renu_60   LDA TMPPTC+1
dfd5 84 2a    Renu_90   STY VARTAB          ; entry for Delete routine
dfd7 85 2b              STA VARTAB+1
dfd9 20 e9 b5           JSR Reset_BASIC_Execution
dfdc 20 b6 b4           JSR Rechain
dfdf 4c ff b3           JMP Basic_Ready

dfe2 00 00 00           .FILL $e000-* (0) ; 30 bytes

              ; *****************
e000            EDITOR_JUMP_TABLE
              ; *****************

e000 4c 37 e0           JMP EDIT_RESET
e003 4c a7 e0           JMP EDIT_GETIN
e006 4c 16 e1           JMP EDIT_CHRIN
e009 4c 02 e2           JMP EDIT_CHROUT
e00c 4c 42 e4           JMP IRQ_MAIN
e00f 4c 55 e4           JMP IRQ_NORMAL
e012 4c 77 e4           JMP IRQ_END
e015 4c 3d e0           JMP EDIT_CLEAR
e018 4c d6 e9           JMP EDIT_CHARSET_TEXT
e01b 4c e4 e9           JMP EDIT_CHARSET_GRAPHICS
e01e 4c d3 e9           JMP EDIT_RESET_CRT
e021 4c 17 e4           JMP EDIT_SCROLL_DOWN
e024 4c 29 e4           JMP EDIT_SCROLL_UP
e027 4c 24 e9           JMP EDIT_KEY_SCAN
e02a 4c 8d e6           JMP EDIT_BEEP
e02d 4c 8d e6           JMP EDIT_BEEP
e030 4c ca e1           JMP EDIT_TOP_LEFT
e033 4c c5 e1           JMP EDIT_BOTTOM_RIGHT
e036 60                 RTS ; EDIT_REPEAT ;Size   55 [EDITOR_JUMP_TABLE]

              ; **********
e037            EDIT_RESET
              ; **********

e037 20 06 e6           JSR Edit_Init
e03a 20 d3 e9           JSR EDIT_RESET_CRT

              ; **********
e03d            EDIT_CLEAR
              ; **********

e03d a6 e0              LDX TopMargin
e03f 20 c9 e6 EDCL_10   JSR Cursor_BOL
e042 20 aa e1           JSR Edit_Erase_To_EOL
e045 e4 e1              CPX BotMargin
e047 e8                 INX
e048 90 f5              BCC EDCL_10         ; fall

              ; *********
e04a            EDIT_HOME
              ; *********

e04a a6 e0              LDX TopMargin
e04c 86 d8              STX CursorRow       ; fall

              ; *********************
e04e            Edit_Goto_Left_Margin
              ; *********************

e04e a4 e2              LDY LefMargin
e050 84 c6              STY CursorCol       ; fall

              ; ******************
e052            Edit_Use_CursorRow
              ; ******************

e052 a6 d8              LDX CursorRow
e054 4c cb e6           JMP Update_ScrPtr

              ; ************
e057            EDIT_SET_CRT
              ; ************

              ; Input:  A = table low
              ;         X = table high
              ;         Y = # of registers

e057 85 c7              STA SAL
e059 86 c8              STX SAL+1
e05b b1 c7    ESC_10    LDA (SAL),Y
e05d 8c 80 e8           STY CRT_Address
e060 8d 81 e8           STA CRT_Value
e063 88                 DEY
e064 10 f5              BPL ESC_10
e066 60                 RTS ;Size   16 [EDIT_SET_CRT]


              ; *****************
e067            Edit_Program_Rows
              ; *****************

              ; Input:  A = maximum raster address (7 or 9)
              ;         Y = screen rows (30 or 25)

e067 84 df              STY ScreenRows
e069 c8                 INY
e06a a2 06              LDX #6
e06c 8e 80 e8           STX CRT_Address
e06f 8c 81 e8           STY CRT_Value
e072 a2 09              LDX #9
e074 8e 80 e8           STX CRT_Address
e077 8d 81 e8           STA CRT_Value
e07a 60                 RTS ;Size   20 [Edit_Program_Rows]

e07b 00 00 00           .FILL $e0a7-* (0) ; 44 bytes

              ; ******************
e0a7            EDIT_GETIN ; $e0a7
              ; ******************

e0a7 ac 6f 02           LDY KEYD            ; get next character
e0aa a2 00              LDX #0              ; scroll keyboard buffer
e0ac bd 70 02 EDGE_10   LDA KEYD+1,X
e0af 9d 6f 02           STA KEYD,X
e0b2 e8                 INX
e0b3 e4 9e              CPX CharsInBuffer
e0b5 90 f5              BCC EDGE_10
e0b7 c6 9e              DEC CharsInBuffer
e0b9 98                 TYA                 ; return character in (A)
e0ba 58                 CLI
e0bb 60                 RTS ;Size   21 [EDIT_GETIN]

              ; *************
e0bc            Edit_Get_Line
              ; *************

e0bc 20 02 e2           JSR EDIT_CHROUT
e0bf a5 9e    EGL_10    LDA CharsInBuffer
e0c1 85 a7              STA BLNSW           ; empty buffer -> blink cursor
e0c3 f0 fa              BEQ EGL_10          ; loop until char in buffer
e0c5 78                 SEI                 ; disable IRQ while working with buffer
e0c6 a5 aa              LDA BLNON           ; blink phase
e0c8 f0 0d              BEQ EGL_20          ; normal ?
e0ca a0 00              LDY #0
e0cc 84 aa              STY BLNON           ; blink phase normal
e0ce c8                 INY
e0cf 84 a8              STY BLNCT           ; start with visible cursor
e0d1 a5 a9              LDA GDBLN           ; character under cursor
e0d3 a4 c6              LDY CursorCol
e0d5 91 c4              STA (ScrPtr),Y
e0d7 20 a7 e0 EGL_20    JSR EDIT_GETIN
e0da c9 83              CMP #$83            ; RUN key ?
e0dc d0 0f              BNE EGL_40
e0de a2 08              LDX #8
e0e0 86 9e              STX CharsInBuffer
e0e2 bd dc e6 EGL_30    LDA RUN_String-1,X  ; DLOAD"*" RUN
e0e5 9d 6e 02           STA KEYD-1,X
e0e8 ca                 DEX
e0e9 d0 f7              BNE EGL_30
e0eb f0 d2              BEQ EGL_10          ; always
e0ed c9 0d    EGL_40    CMP #CR             ; RETURN ?
e0ef d0 cb              BNE Edit_Get_Line
e0f1 a4 d5              LDY RigMargin
e0f3 84 ac              STY CRSW            ; not 0 -> Screen Input
e0f5 a9 20              LDA #' '            ; Ignore trailing blanks
e0f7 d1 c4    EGL_50    CMP (ScrPtr),Y
e0f9 d0 03              BNE EGL_60
e0fb 88                 DEY
e0fc d0 f9              BNE EGL_50
e0fe c8       EGL_60    INY
e0ff 84 a1              STY LastInputCol    ; position after last non blank char
e101 20 b4 e1           JSR Edit_To_Left_Margin
e104 84 cd              STY QTSW            ; = 0 (off)
e106 a5 a3              LDA InputRow
e108 c5 d8              CMP CursorRow
e10a d0 15              BNE Edit_CHRIN_Screen
e10c a5 a4              LDA InputCol
e10e 85 c6              STA CursorCol
e110 c5 a1              CMP LastInputCol
e112 90 0d              BCC Edit_CHRIN_Screen
e114 b0 36              BCS ECS_40

e116                    .SIZE ;   90 [Edit_Get_Line]

e116                    .FILL $e116-* (0) ; 0 bytes

              ; ******************
e116            EDIT_CHRIN ; $e116
              ; ******************

e116 98                 TYA
e117 48                 PHA
e118 8a                 TXA
e119 48                 PHA
e11a 6c e9 00           JMP (SCRIV)         ; default: jump to next statement

              ; *******************
e11d            Edit_CHRIN_Standard
              ; *******************

e11d a5 ac              LDA CRSW
e11f f0 9e              BEQ EGL_10

              ; *****************
e121            Edit_CHRIN_Screen
              ; *****************

e121 a4 c6              LDY CursorCol
e123 b1 c4              LDA (ScrPtr),Y      ; get char at cursor position
e125 c9 74              CMP #$74            ; code for Pi
e127 d0 04              BNE ECS_05
e129 a9 ff              LDA #$ff
e12b d0 16              BNE ECS_30
e12d 85 d9    ECS_05    STA DATAX           ; save it in DATAX
e12f 29 3f              AND #$3f            ; lower case, symbols and digits
e131 06 d9              ASL DATAX           ; reverse bit 7 -> carry
e133 24 d9              BIT DATAX           ; uppercase or graphics ?
e135 10 02              BPL ECS_10          ; branch if not
e137 09 80              ORA #$80            ; convert upper case to PETSCII
e139 90 04    ECS_10    BCC ECS_20          ; branch if not reversed
e13b a6 cd              LDX QTSW            ; quote mode ?
e13d d0 04              BNE ECS_30          ; no conversion in quote mode
e13f 70 02    ECS_20    BVS ECS_30          ; no conversion for graphics
e141 09 40              ORA #$40            ; display code to PETSCII
e143 e6 c6    ECS_30    INC CursorCol       ; advance cursor
e145 20 64 e1           JSR Edit_Quote_Toggle
e148 c4 a1              CPY LastInputCol    ; at end of input ?
e14a 90 0f              BCC ECS_50          ; return if not
e14c a9 00    ECS_40    LDA #0
e14e 85 ac              STA CRSW            ; switch input to keyboard
e150 a9 0d              LDA #CR             ; load CR
e152 a2 03              LDX #3              ; screen channel
e154 e4 b0              CPX DFLTO           ; output = screen ?
e156 f0 03              BEQ ECS_50          ; don't echo CR
e158 20 02 e2           JSR EDIT_CHROUT
e15b 85 d9    ECS_50    STA DATAX           ; save character in DATAX
e15d 68                 PLA
e15e aa                 TAX                 ; restore X
e15f 68                 PLA
e160 a8                 TAY                 ; restore Y
e161 a5 d9              LDA DATAX
e163 60       ECS_Ret   RTS ;Size   67 [Edit_CHRIN_Screen]

              ; *****************
e164            Edit_Quote_Toggle
              ; *****************

e164 c9 22              CMP #QUOTE
e166 d0 06              BNE EQT_Ret
e168 e5 cd              SBC QTSW
e16a 85 cd              STA QTSW
e16c a9 22              LDA #QUOTE
e16e 60       EQT_Ret   RTS ;Size   11 [Edit_Quote_Toggle]

              ; *****************
e16f            Edit_Display_Char
              ; *****************

e16f a6 9f              LDX ReverseFlag
e171 f0 02              BEQ EDC_10
e173 09 80              ORA #$80
e175 a6 dc    EDC_10    LDX INSRT        ;  3  ; # of inserts outstanding
e177 f0 02              BEQ EDC_20       ;  3
e179 c6 dc              DEC INSRT
e17b 91 c4    EDC_20    STA (ScrPtr),Y   ;  6
e17d a9 01              LDA #1           ;  2
e17f 85 a8              STA BLNCT        ;  3
e181 c4 d5              CPY RigMargin    ;  3
e183 c8                 INY              ;  2
e184 90 05              BCC EDC_30       ;  3 = 28 [total 85]

              ; ************************
e186           Edit_Chrout_Epilog_Return
              ; ************************

e186 20 e1 e3           JSR Edit_Cursor_Down
e189 a4 e2              LDY LefMargin
e18b 84 c6    EDC_30    STY CursorCol    ;  3

              ; ******************
e18d            Edit_Chrout_Epilog
              ; ******************

e18d 68                 PLA              ;  4
e18e a8                 TAY              ;  2 ; restore Y
e18f 68                 PLA              ;  4
e190 aa                 TAX              ;  2 ; restore X
e191 68                 PLA              ;  4
e192 85 e8              STA PrevChar     ;  3 ; save last used character
e194 58                 CLI              ;  2
e195 60                 RTS              ;  6 = 27 [total 112] ;Size    9 [Edit_Chrout_Epilog]

              ; **************
e196            Edit_Wrap_Back
              ; **************

e196 a4 e2              LDY LefMargin
e198 a6 e0              LDX TopMargin
e19a e4 d8              CPX CursorRow
e19c b0 07              BCS EWB_10          ; don't wrap on top row
e19e a4 d5              LDY RigMargin
e1a0 c6 d8              DEC CursorRow
e1a2 20 52 e0           JSR Edit_Use_CursorRow
e1a5 84 c6    EWB_10    STY CursorCol
e1a7 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *****************
e1aa            Edit_Erase_To_EOL
              ; *****************

e1aa a9 20              LDA #' '
e1ac 91 c4    EETE_10   STA (ScrPtr),Y
e1ae c4 d5              CPY RigMargin
e1b0 c8                 INY
e1b1 90 f9              BCC EETE_10
e1b3 60                 RTS ;Size   10 [Edit_Erase_To_EOL]

              ; *******************
e1b4            Edit_To_Left_Margin
              ; *******************

e1b4 a4 e2              LDY LefMargin
e1b6 84 c6              STY CursorCol
e1b8 a0 00              LDY #0
e1ba 60                 RTS ;Size    7 [Edit_To_Left_Margin]

              ; ****************
e1bb            Edit_Full_Screen
              ; ****************

e1bb a9 00              LDA #0
e1bd 85 e0              STA TopMargin
e1bf 85 e2              STA LefMargin
e1c1 a5 df              LDA ScreenRows      ; bottom margin
e1c3 a2 4f              LDX #79             ; right  margin

              ; *****************
e1c5            EDIT_BOTTOM_RIGHT
              ; *****************

e1c5 85 e1              STA BotMargin
e1c7 86 d5              STX RigMargin
e1c9 60                 RTS ;Size    5 [EDIT_BOTTOM_RIGHT]

              ; *************
e1ca            EDIT_TOP_LEFT
              ; *************

e1ca 85 e0              STA TopMargin
e1cc 86 e2              STX LefMargin
e1ce 60                 RTS ;Size    5 [EDIT_TOP_LEFT]

e1cf 4c 16 e3 CO_Shift  JMP Edit_CHROUT_Shifted

              ; ******
e1d2            CO_Tab
              ; ******

e1d2 a4 c6              LDY CursorCol
e1d4 c4 d5              CPY RigMargin
e1d6 b0 11              BCS EdDC_05         ; CO_Exit
e1d8 e6 c6              INC CursorCol
e1da 20 25 e5           JSR IS_TAB
e1dd f0 f3              BEQ CO_Tab
e1df 4c 66 e2           JMP CO_Exit

e1e2                    .SIZE ;   16 [CO_Tab]

e1e2 4c e2 e2 CO_Size   JMP Edit_Screen_25

              ; ****************
e1e5            Edit_Delete_Char
              ; ****************

e1e5 a6 e2              LDX LefMargin
e1e7 e4 c6              CPX CursorCol
e1e9 b0 7b    EdDC_05   BCS CO_Exit        ; no delete on left margin
e1eb c6 c6              DEC CursorCol
e1ed b1 c4    EdDC_10   LDA (ScrPtr),Y
e1ef 88                 DEY
e1f0 91 c4              STA (ScrPtr),Y
e1f2 c8                 INY
e1f3 c4 d5              CPY RigMargin
e1f5 c8                 INY
e1f6 90 f5              BCC EdDC_10
e1f8 88                 DEY
e1f9 a9 20              LDA #' '
e1fb 91 c4              STA (ScrPtr),Y
e1fd d0 67              BNE CO_Exit

e1ff                    .SIZE ;   26 [Edit_Delete_Char]

e1ff 00 00 00           .FILL $e202-* (0) ; 3 bytes

              ; *******************
e202            EDIT_CHROUT ; $e202
              ; *******************

e202 48                 PHA            ;  3
e203 85 d9              STA DATAX      ;  3
e205 8a                 TXA            ;  2
e206 48                 PHA            ;  3
e207 98                 TYA            ;  2
e208 48                 PHA            ;  3
e209 6c eb 00           JMP (SCROV)    ;  5    ; -> Edit_CHROUT_Standard
                                       ; 19

              ; ****************************
e20c            Edit_CHROUT_Standard ; $e20c
              ; ****************************

e20c a9 00              LDA #0         ;  2
e20e 85 ac              STA CRSW       ;  3 ; input from keyboard
e210 a4 c6              LDY CursorCol  ;  3
e212 a5 d9              LDA DATAX      ;  3 ; char to display (PETSCII)
e214 30 b9              BMI CO_Shift   ;  2
e216 c9 20              CMP #' '       ;  2 ; printable ?
e218 b0 4f              BCS CO_Normal  ;  3 = 16 [total 35]
e21a c9 0d              CMP #CR             ; RETURN
e21c f0 71              BEQ CO_Return
e21e c9 1b              CMP #ESC            ; ESCAPE
e220 f0 70              BEQ CO_Escape
e222 a6 dc              LDX INSRT           ; insert mode ?
e224 d0 76              BNE CO_Rev
e226 c9 14              CMP #DEL            ; DELETE
e228 f0 bb              BEQ Edit_Delete_Char
e22a a6 cd              LDX QTSW            ; quote mode ?
e22c d0 6e              BNE CO_Rev
e22e c9 1d              CMP #RIGHT          ; cursor RIGHT
e230 f0 3f              BEQ CO_Right
e232 c9 11              CMP #DOWN           ; cursor DOWN
e234 f0 44              BEQ CO_Down
e236 c9 12              CMP #RVS            ; REVERSE
e238 f0 45              BEQ CO_RVS
e23a c9 07              CMP #BELL           ; ring bell
e23c f0 47              BEQ CO_Bell
e23e c9 0e              CMP #CTRLN          ; select text character set
e240 f0 48              BEQ CO_ChText
e242 c9 02              CMP #CTRLB          ; select new character set
e244 f0 4f              BEQ CO_ChNew
e246 c9 0f              CMP #CTRLO          ; set top left window corner
e248 f0 57              BEQ CO_Top
e24a c9 09              CMP #TAB            ; TAB
e24c f0 84              BEQ CO_Tab
e24e c9 19              CMP #CTRLY          ; scroll window up
e250 f0 5a              BEQ CO_ScUp
e252 c9 16              CMP #CTRLV          ; Delete to EOL
e254 f0 61              BEQ CO_DEOL
e256 c9 15              CMP #CTRLU          ; delete line
e258 f0 68              BEQ CO_DLine
e25a c9 04              CMP #CTRLD          ; toggle screen size
e25c f0 84              BEQ CO_Size
e25e c9 13              CMP #HOME           ; HOME
e260 f0 6d              BEQ CO_Home
e262 c9 01              CMP #CTRLA          ; scroll window down
e264 f0 43              BEQ CO_ScDown
e266 4c 8d e1 CO_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Standard

e269 29 3f    CO_Normal AND #$3f               ;  2 ; PETSCII -> display code
e26b 20 64 e1           JSR Edit_Quote_Toggle  ; 17
e26e 4c 6f e1           JMP Edit_Display_Char  ;  3 = 22 [total 57]

e271 c4 d5    CO_Right  CPY RigMargin
e273 e6 c6              INC CursorCol
e275 90 ef              BCC CO_Exit
e277 4c 86 e1           JMP Edit_Chrout_Epilog_Return

e27a 20 e1 e3 CO_Down   JSR Edit_Cursor_Down
e27d d0 e7              BNE CO_Exit         ; always

e27f a9 80    CO_RVS    LDA #$80
e281 85 9f              STA ReverseFlag
e283 d0 e1              BNE CO_Exit         ; always

e285 20 8d e6 CO_Bell   JSR EDIT_BEEP
e288 f0 dc              BEQ CO_Exit         ; always

e28a 20 d6 e9 CO_ChText JSR EDIT_CHARSET_TEXT
e28d 30 d7              BMI CO_Exit         ; always

e28f 4c f4 e3 CO_Return JMP CO_Screen_Return

e292 4c ff e3 CO_Escape JMP CO_JMP_Escape

e295 a9 10    CO_ChNew  LDA #$10
e297 20 ca e9 CO_Switch JSR Edit_Switch_Char_ROM
e29a d0 ca              BNE CO_Exit         ; always

e29c 09 80    CO_Rev    ORA #$80
e29e 4c 6f e1           JMP Edit_Display_Char

e2a1 a6 d8    CO_Top    LDX CursorRow
e2a3 86 e0              STX TopMargin
e2a5 84 e2              STY LefMargin
e2a7 10 bd              BPL CO_Exit         ; always

e2a9 4c b5 e3 CO_ScDown JMP CS_ScDown

e2ac 20 29 e4 CO_ScUp   JSR EDIT_SCROLL_UP
e2af 20 39 ea           JSR Power_Scroll_Up
e2b2 20 52 e0           JSR Edit_Use_CursorRow
e2b5 d0 af              BNE CO_Exit         ; always

e2b7 a9 20    CO_DEOL   LDA #' '
e2b9 91 c4    CODE_10   STA (ScrPtr),Y
e2bb c4 d5              CPY RigMargin
e2bd c8                 INY
e2be 90 f9              BCC CODE_10
e2c0 b0 a4              BCS CO_Exit

e2c2 a5 e0    CO_DLine  LDA TopMargin
e2c4 48                 PHA
e2c5 a5 d8              LDA CursorRow
e2c7 85 e0              STA TopMargin
e2c9 20 29 e4           JSR EDIT_SCROLL_UP
e2cc 4c d8 e3           JMP TM_Epi

e2cf c5 e8    CO_Home   CMP PrevChar             ; twice pressed ?
e2d1 d0 03              BNE COHo_10
e2d3 20 bb e1 CoHo_05   JSR Edit_Full_Screen     ; 2nd. <HOME> resets margins
e2d6 20 4a e0 COHo_10   JSR EDIT_HOME
e2d9 4c 8d e1           JMP Edit_Chrout_Epilog

e2dc          Edit_Screen_30
e2dc a9 07              LDA #7              ; maximum raster address
e2de a0 1d              LDY #29             ; 30 rows
e2e0 d0 04              BNE Edit_Screen_Program
e2e2          Edit_Screen_25
e2e2 a9 09              LDA #9              ; maximum raster address
e2e4 a0 18              LDY #24             ; 25 rows (default)
e2e6          Edit_Screen_Program
e2e6 20 67 e0           JSR Edit_Program_Rows
e2e9 20 bb e1           JSR Edit_Full_Screen
e2ec 4c 79 e3           JMP CS_Clear

e2ef 4c f4 e3 CS_Return JMP CO_Screen_Return

              ; ****************
e2f2            Edit_Insert_Char
              ; ****************

e2f2 a4 d5              LDY RigMargin
e2f4 b1 c4              LDA (ScrPtr),Y
e2f6 c9 20              CMP #' '
e2f8 d0 66              BNE CS_Exit       ; right most char not blank
e2fa 88       InCh_10   DEY
e2fb c4 c6              CPY CursorCol     ; clc if left from cursor
e2fd b1 c4              LDA (ScrPtr),Y
e2ff c8                 INY
e300 90 05              BCC InCh_20
e302 91 c4              STA (ScrPtr),Y
e304 88                 DEY
e305 d0 f3              BNE InCh_10       ; at first column
e307 a9 20    InCh_20   LDA #' '
e309 91 c4              STA (ScrPtr),Y
e30b 98                 TYA
e30c 65 dc              ADC INSRT
e30e c5 d5              CMP RigMargin
e310 b0 4e              BCS CS_Exit
e312 e6 dc              INC INSRT
e314 d0 4a              BNE CS_Exit         ; always

e316                    .SIZE ;   36 [Edit_Insert_Char]

              ; *******************
e316            Edit_CHROUT_Shifted
              ; *******************

e316 29 7f              AND #$7f
e318 c9 7f              CMP #$7f            ; Pi
e31a f0 4a              BEQ CS_Pi
e31c c9 20              CMP #' '            ; printable ?
e31e b0 49              BCS CS_Print
e320 c9 0d              CMP #CR             ; shifted RETURN
e322 f0 cb              BEQ CS_Return
e324 a6 cd              LDX QTSW            ; quote mode
e326 d0 46              BNE CS_Rev
e328 c9 14              CMP #DEL            ; INSERT
e32a f0 c6              BEQ Edit_Insert_Char
e32c a6 dc              LDX INSRT           ; insert mode ?
e32e d0 3e              BNE CS_Rev
e330 c9 1d              CMP #RIGHT          ; cursor LEFT
e332 f0 5d              BEQ CS_Left
e334 c9 11              CMP #DOWN           ; cursor UP
e336 f0 73              BEQ CS_Up
e338 c9 12              CMP #RVS            ; REVERSE OFF
e33a f0 37              BEQ CS_RVS
e33c c9 13              CMP #HOME           ; CLEAR
e33e f0 39              BEQ CS_Clear
e340 c9 09              CMP #TAB            ; shifted TAB
e342 f0 58              BEQ CS_Tab
e344 c9 16              CMP #CTRLV          ; shifted Ctrl-V
e346 f0 79              BEQ CS_Delete_BOL
e348 c9 02              CMP #CTRLB          ; select old character set
e34a f0 32              BEQ CS_ChOld
e34c c9 19              CMP #CTRLY          ; scroll window down
e34e f0 65              BEQ CS_ScDown
e350 c9 0f              CMP #CTRLO          ; set window bottom right
e352 f0 2f              BEQ CS_Bottom
e354 c9 0e              CMP #CTRLN          ; select graphics character set
e356 f0 33              BEQ CS_Graph
e358 c9 15              CMP #CTRLU          ; shifted Ctrl-U
e35a f0 72              BEQ CS_Insert_Line
e35c c9 04              CMP #CTRLD          ; switch to 26 row screen
e35e f0 03              BEQ CS_Size
e360 4c 8d e1 CS_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Shifted

e363 4c dc e2 CS_Size   JMP Edit_Screen_30
e366 a9 74    CS_Pi     LDA #$74
e368 2c                 .BYTE $2c
e369 09 40    CS_Print  ORA #$40            ; PETSCII to display
e36b 4c 6f e1           JMP Edit_Display_Char

e36e 09 c0    CS_Rev    ORA #$c0            ; reverse upper case
e370 4c 6f e1           JMP Edit_Display_Char

e373 a9 00    CS_RVS    LDA #0
e375 85 9f              STA ReverseFlag
e377 f0 e7              BEQ CS_Exit         ; always

e379 20 3d e0 CS_Clear  JSR EDIT_CLEAR
e37c d0 e2              BNE CS_Exit         ; always

e37e a9 30    CS_ChOld  LDA #$30
e380 4c 97 e2           JMP CO_Switch

e383 a5 d8    CS_Bottom LDA CursorRow
e385 85 e1              STA BotMargin
e387 84 d5              STY RigMargin
e389 10 d5              BPL CS_Exit       ; always

e38b 20 e4 e9 CS_Graph  JSR EDIT_CHARSET_GRAPHICS
e38e 4c 8d e1           JMP Edit_Chrout_Epilog

e391 a4 e2    CS_Left   LDY LefMargin
e393 c4 c6              CPY CursorCol
e395 c6 c6              DEC CursorCol
e397 90 c7              BCC CS_Exit
e399 4c 96 e1           JMP Edit_Wrap_Back

e39c 20 25 e5 CS_Tab    JSR IS_TAB
e39f bd ee 03           LDA TABS_SET,X
e3a2 59 37 e5           EOR BITPOS,Y        ; toggle TAB bit
e3a5 9d ee 03           STA TABS_SET,X
e3a8 4c 8d e1           JMP Edit_Chrout_Epilog

e3ab a6 e0    CS_Up     LDX TopMargin
e3ad e4 d8              CPX CursorRow
e3af b0 04              BCS CS_ScDown
e3b1 c6 d8              DEC CursorRow
e3b3 10 06              BPL COSW_10         ; always

e3b5 20 17 e4 CS_ScDown JSR EDIT_SCROLL_DOWN
e3b8 20 9c ea           JSR Power_Scroll_Down
e3bb 20 52 e0 COSW_10   JSR Edit_Use_CursorRow
e3be 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *************
e3c1            CS_Delete_BOL
              ; *************

e3c1 a9 20              LDA #' '
e3c3 a4 e2              LDY LefMargin
e3c5 c4 c6    CSDB_10   CPY CursorCol
e3c7 b0 97              BCS CS_Exit
e3c9 91 c4              STA (ScrPtr),Y
e3cb c8                 INY
e3cc d0 f7              BNE CSDB_10

e3ce                    .SIZE ;   13 [CS_Delete_BOL]

              ; **************
e3ce            CS_Insert_Line
              ; **************

e3ce a5 e0              LDA TopMargin
e3d0 48                 PHA
e3d1 a5 d8              LDA CursorRow
e3d3 85 e0              STA TopMargin
e3d5 20 17 e4           JSR EDIT_SCROLL_DOWN
e3d8 68       TM_Epi    PLA
e3d9 85 e0              STA TopMargin
e3db 20 4e e0           JSR Edit_Goto_Left_Margin
e3de 4c 8d e1           JMP Edit_Chrout_Epilog

e3e1                    .SIZE ;   19 [CS_Insert_Line]

              ; ****************
e3e1            Edit_Cursor_Down
              ; ****************

e3e1 46 a3              LSR InputRow        ; invalidate InputRow
e3e3 a6 d8              LDX CursorRow
e3e5 e4 e1              CPX BotMargin
e3e7 90 06              BCC CSCD_10
e3e9 20 29 e4           JSR EDIT_SCROLL_UP
e3ec 4c 39 ea           JMP Power_Scroll_Up
e3ef e6 d8    CSCD_10   INC CursorRow
e3f1 4c 52 e0           JMP Edit_Use_CursorRow

e3f4                    .SIZE ;   19 [Edit_Cursor_Down]

              ; ****************
e3f4            CO_Screen_Return
              ; ****************

e3f4 a0 00              LDY #0
e3f6 84 99              STY Power_Flag
e3f8 a4 e2              LDY LefMargin
e3fa 84 c6              STY CursorCol
e3fc 20 e1 e3           JSR Edit_Cursor_Down

              ; *************
e3ff            CO_JMP_Escape
              ; *************

e3ff a9 00              LDA #0
e401 85 dc              STA INSRT           ; clear insert mode
e403 85 9f              STA ReverseFlag     ; clear reverse mode
e405 85 cd              STA QTSW            ; clear quote mode
e407 4c 8d e1           JMP Edit_Chrout_Epilog

              ; ***********
e40a            Edit_Scroll
              ; ***********

e40a 20 b7 e6           JSR Set_Screen_SAL  ; 25
e40d b1 c7    ES_10     LDA (SAL),Y         ;  5
e40f 91 c4              STA (ScrPtr),Y      ;  6
e411 c4 d5              CPY RigMargin       ;  3
e413 c8                 INY                 ;  2
e414 90 f7              BCC ES_10           ;  3
e416 60                 RTS ;Size   13 [Edit_Scroll]
                                            ; total = 25 + 80 * 19 + 2 = 1547

              ; ****************
e417            EDIT_SCROLL_DOWN
              ; ****************

e417 a6 e1              LDX BotMargin       ;    3
e419 20 c9 e6 ESD_10    JSR Cursor_BOL      ;   28
e41c e4 e0              CPX TopMargin       ;    3
e41e f0 06              BEQ ESD_30          ;    2
e420 ca                 DEX                 ;    2
e421 20 0a e4           JSR Edit_Scroll     ; 1552
e424 b0 f3              BCS ESD_10          ;    3
e426 4c aa e1 ESD_30    JMP Edit_Erase_To_EOL  ; total = 1100 + 24 * 1590 = 39260

e429                    .SIZE ;   18 [EDIT_SCROLL_DOWN]

              ; **************
e429            EDIT_SCROLL_UP
              ; **************

e429 a6 e0              LDX TopMargin
e42b 20 c9 e6 ESU_10    JSR Cursor_BOL
e42e e4 e1              CPX BotMargin
e430 b0 06              BCS ESU_30
e432 e8                 INX
e433 20 0a e4           JSR Edit_Scroll
e436 b0 f3              BCS ESU_10
e438 4c aa e1 ESU_30    JMP Edit_Erase_To_EOL

e43b                    .SIZE ;   18 [EDIT_SCROLL_UP]

e43b 00 00 00           .FILL $e442-* (0) ; 7 bytes

              ; ********
e442            IRQ_MAIN
              ; ********

e442 48                 PHA
e443 8a                 TXA
e444 48                 PHA
e445 98                 TYA
e446 48                 PHA
e447 ba                 TSX
e448 bd 04 01           LDA STACK+4,X
e44b 29 10              AND #16
e44d f0 03              BEQ IRQ_05
e44f 6c 92 00           JMP (CBINV)
e452 6c 90 00 IRQ_05    JMP (CINV)

              ; **********
e455            IRQ_NORMAL
              ; **********

e455 20 68 f7           JSR Kernal_UDTIM    ; increment jiffy clock
e458 a5 a7              LDA BLNSW           ; software cursor
e45a d0 18              BNE IRQ_20          ; branch if not visible
e45c c6 a8              DEC BLNCT           ; blink count down
e45e d0 14              BNE IRQ_20
e460 a9 14              LDA #20             ; reset blink count down
e462 85 a8              STA BLNCT
e464 a4 c6              LDY CursorCol
e466 46 aa              LSR BLNON           ; BLNON = 0 : C = old value
e468 b1 c4              LDA (ScrPtr),Y
e46a b0 04              BCS IRQ_10
e46c e6 aa              INC BLNON           ; BLNON = 1 : reverse character
e46e 85 a9              STA GDBLN           ; save character under cursor
e470 49 80    IRQ_10    EOR #$80
e472 91 c4              STA (ScrPtr),Y      ; invert character
e474 20 24 e9 IRQ_20    JSR EDIT_KEY_SCAN
e477 68       IRQ_END   PLA
e478 a8                 TAY
e479 68                 PLA
e47a aa                 TAX
e47b 68                 PLA
e47c 40                 RTI

              ; ******
e47d            Delete
              ; ******

e47d 20 76 00           JSR CHRGOT
e480 20 f6 b8           JSR Scan_Linenumber ; start #
e483 20 a6 b5           JSR Find_BASIC_Line
e486 a5 5c              LDA TMPPTC
e488 85 21              STA RENINC
e48a a5 5d              LDA TMPPTC+1
e48c 85 22              STA RENINC+1
e48e 20 76 00           JSR CHRGOT
e491 c9 2d              CMP #'-'
e493 d0 30              BNE DelErr
e495 20 70 00           JSR CHRGET
e498 20 f6 b8           JSR Scan_Linenumber ; end #
e49b a5 11              LDA LINNUM
e49d 05 12              ORA LINNUM+1
e49f d0 02              BNE Del_10
e4a1 c6 12              DEC LINNUM+1        ; end number = $ff00
e4a3 20 a6 b5 Del_10    JSR Find_BASIC_Line
e4a6 90 03              BCC Del_20          ; -> not found
e4a8 20 5e ed           JSR Update_Link     ; First line after DELETE range
e4ab a6 2b    Del_20    LDX VARTAB+1
e4ad a0 00              LDY #0              ; Y = 0
e4af b1 5c    Del_30    LDA (TMPPTC),Y      ; copy upper part of program
e4b1 91 21              STA (RENINC),Y      ; into area to delete
e4b3 c8                 INY
e4b4 d0 f9              BNE Del_30
e4b6 e6 22              INC RENINC+1
e4b8 e6 5d              INC TMPPTC+1
e4ba e4 5d              CPX TMPPTC+1        ; reached VARTAB ?
e4bc b0 f1              BCS Del_30
e4be a4 21              LDY RENINC
e4c0 a5 22              LDA RENINC+1
e4c2 4c d5 df           JMP Renu_90         ; set VARTAB, reset BASIC
e4c5 4c 73 c3 DelErr    JMP Jump_To_Illegal_Quantity
e4c8                    .SIZE ;   75 [Delete]

              ; ***************
e4c8            Get_Record_Size
              ; ***************

e4c8 a0 00              LDY #0
e4ca 84 96              STY STATUS
e4cc 20 af f4           JSR Send_Filename
e4cf 20 91 d9           JSR Kernal_Read_DS
e4d2 a9 6d              LDA #$6d
e4d4 85 d3              STA SA
e4d6 ad ad 03           LDA DOS_Status
e4d9 c9 35              CMP #'5'
e4db d0 1d              BNE GRS_90
e4dd c6 b9              DEC DOS_RL
e4df a9 9d              LDA #$9d
e4e1 20 d2 ff           JSR CHROUT
e4e4 20 d2 ff           JSR CHROUT
e4e7 a5 b9              LDA DOS_RL
e4e9 20 5b d7           JSR Print_Hex_Byte
e4ec a5 b9              LDA DOS_RL
e4ee c9 02              CMP #2
e4f0 90 08              BCC GRS_90
e4f2 a4 d1              LDY FNLEN
e4f4 88                 DEY
e4f5 91 da              STA (FNADR),Y       ; try next record length
e4f7 4c c8 e4           JMP Get_Record_Size
e4fa 60       GRS_90    RTS ;Size   51 [Get_Record_Size]

              ; ***********
e4fb            Mon_Message
              ; ***********

e4fb 0d 20 20           .BYTE "\r   PC  IRQ  SR AC XR YR SP RB WB SV-BDIZC"

              ; ******
e525            IS_TAB
              ; ******

e525 a5 c6              LDA CursorCol
e527 29 07              AND #7
e529 a8                 TAY                 ; bit position
e52a a5 c6              LDA CursorCol
e52c 4a                 LSR A
e52d 4a                 LSR A
e52e 4a                 LSR A               ; Column / 8
e52f aa                 TAX                 ; word index
e530 b9 37 e5           LDA BITPOS,Y
e533 3d ee 03           AND TABS_SET,X
e536 60                 RTS ;Size   18 [IS_TAB]

              ; ******
e537            BITPOS
              ; ******

e537 80 40 20           .BYTE $80,$40,$20,$10,$08,$04,$02,$01

              ; ********
e53f            Mon_Fill
              ; ********

e53f a2 f9              LDX #BPTR           ; start address
e541 20 73 d7           JSR Read_Hex_Word
e544 90 26              BCC MoFi_Err
e546 a2 fd              LDX #MEMUSS         ; end   address
e548 20 73 d7           JSR Read_Hex_Word
e54b 90 1f              BCC MoFi_Err
e54d 20 80 d7           JSR  Read_Hex       ; fill byte
e550 90 1a              BCC MoFi_Err
e552 aa                 TAX
e553 a0 00              LDY #0
e555 a5 fd    MoFi_10   LDA MEMUSS
e557 c5 f9              CMP BPTR            ; set or clear carry
e559 a5 fe              LDA MEMUSS+1
e55b e5 fa              SBC BPTR+1
e55d 90 0a              BCC MoFi_End        ; BPTR > MEMUSS ?
e55f 8a                 TXA
e560 20 8b 02           JSR Bank_Store
e563 20 1f fb           JSR Inc_BPTR
e566 4c 55 e5           JMP MoFi_10
e569 4c b1 d4 MoFi_End  JMP Mon_Main
e56c 4c ac d4 MoFi_Err  JMP Mon_Error

e56f                    .SIZE ;   48 [Mon_Fill]


              ; ****************
e56f            Open_Disk_Buffer
              ; ****************

e56f 20 ae e7           JSR Preset_U1
e572 20 15 f2           JSR Kernal_CHRIN
e575 8d 54 03           STA DOS_Command_Buffer+1
e578 20 71 d7           JSR Hex_To_STAL
e57b 20 15 f2           JSR Kernal_CHRIN    ; skip blank
e57e a2 05              LDX #5
e580 20 f4 d8 ODB_20    JSR Mon_CHRIN
e583 9d 53 03           STA DOS_Command_Buffer,X
e586 e8                 INX
e587 e0 28              CPX #40
e589 b0 04              BCS ODB_30
e58b c9 20              CMP #' '
e58d b0 f1              BCS ODB_20
e58f 20 4c dc ODB_30    JSR DOS_SETNAM
e592 20 c7 f8           JSR Wedge_Prepare   ; set FA, clear status
e595 85 ba              STA Dis_Line        ; Dis_Line = 0
e597 20 d5 f0           JSR LISTEN          ; open fa,9,"#"
e59a a9 f9              LDA #$f9            ; sa = 9
e59c 20 43 f1           JSR SECOND
e59f a9 23              LDA #'#'            ; open buffer
e5a1 20 9e f1           JSR CIOUT
e5a4 4c b9 f1           JMP UNLSN


              ; ********
e5a7            Mon_Disk
              ; ********

              ;         U1 1000 0 18 01 - memory,drive,track,sector

e5a7 20 6f e5           JSR Open_Disk_Buffer
e5aa ad 54 03           LDA DOS_Command_Buffer+1
e5ad c9 32              CMP #'2'
e5af f0 20              BEQ Mon_Output_Block
e5b1 20 ba e7           JSR Mon_Disk_Comm
e5b4 20 d2 f0           JSR TALK
e5b7 a9 69              LDA #$69
e5b9 85 d3              STA SA
e5bb 20 93 f1           JSR TKSA
e5be a0 00              LDY #0
e5c0 20 c0 f1 MIB_30    JSR ACPTR
e5c3 91 fb              STA (STAL),Y
e5c5 c8                 INY
e5c6 d0 f8              BNE MIB_30
e5c8 20 ae f1           JSR UNTLK
e5cb 20 2a f7           JSR Close_Disk_File
e5ce 4c fe d5           JMP DiMe_10         ; display loaded block

              ; ****************
e5d1            Mon_Output_Block
              ; ****************

              ;         U2 1000 0 18 01 - memory,drive,track,sector

e5d1 20 9b e7           JSR Reset_BP
e5d4 20 d5 f0           JSR LISTEN
e5d7 a9 69              LDA #$69
e5d9 85 d3              STA SA
e5db 20 43 f1           JSR SECOND
e5de a0 00              LDY #0
e5e0 b1 fb    MOB_10    LDA (STAL),Y
e5e2 20 9e f1           JSR CIOUT
e5e5 c8                 INY
e5e6 d0 f8              BNE MOB_10
e5e8 20 b9 f1           JSR UNLSN
e5eb 20 ba e7           JSR Mon_Disk_Comm
e5ee 20 2a f7           JSR Close_Disk_File
e5f1 4c fe d5           JMP DiMe_10         ; display output block

e5f4 00 00 00           .FILL $e606-* (0) ; 18 bytes

              ; *********
e606            Edit_Init
              ; *********

e606 a9 7f              LDA #$7f
e608 8d 4e e8           STA VIA_IER         ; disable all interrupts
e60b a2 6d              LDX #$6d
e60d a9 00              LDA #0
e60f 85 e8              STA PrevChar        ; clear # of HOME key pressed
e611 95 8d    EdIn_10   STA JIFFY_CLOCK,X   ; clear all kernal variables
e613 ca                 DEX
e614 10 fb              BPL EdIn_10
e616 86 98              STX Key_Flags       ; $FF = Clear all flags
e618 ad 99 b3           LDA BSOS_Bank_Init
e61b 85 9a              STA Default_Bank
e61d a9 55              LDA #<IRQ_NORMAL    ; set default IRQ vector
e61f 85 90              STA CINV
e621 a9 e4              LDA #>IRQ_NORMAL
e623 85 91              STA CINV+1
e625 a9 09              LDA #9
e627 85 e3              STA XMAX            ; size of keyboard bufferX
e629 a9 03              LDA #3
e62b 85 b0              STA DFLTO           ; standard output channel
e62d a9 0f              LDA #15
e62f 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e632 0a                 ASL A
e633 8d 40 e8           STA VIA_Port_B
e636 8d 42 e8           STA VIA_DDR_B
e639 8e 22 e8           STX PIA2_Port_B
e63c 8e 45 e8           STX VIA_Timer_1_Hi  ; Timer 1 latch hi = $ff
e63f a9 3d              LDA #$3d
e641 8d 13 e8           STA PIA1_Cont_B
e644 2c 12 e8           BIT PIA1_Port_B     ; Keyboard row
e647 a9 3c              LDA #$3c
e649 8d 21 e8           STA PIA2_Cont_A
e64c 8d 23 e8           STA PIA2_Cont_B
e64f 8d 11 e8           STA PIA1_Cont_A
e652 8e 22 e8           STX PIA2_Port_B
e655 a9 0e              LDA #14
e657 85 a8              STA BLNCT
e659 85 a7              STA BLNSW
e65b 85 e6              STA DELAY
e65d 85 e5              STA KOUNT
e65f 8d 4e e8           STA VIA_IER         ; enable CA1, SR, CB2 interrupt
e662 a9 18              LDA #24
e664 85 df              STA ScreenRows
e666 20 bb e1           JSR Edit_Full_Screen
e669 a2 0c              LDX #12
e66b a9 00              LDA #0
e66d 9d ee 03 EdIn_20   STA TABS_SET,X
e670 ca                 DEX
e671 10 fa              BPL EdIn_20
e673 a9 1d              LDA #<Edit_CHRIN_Standard
e675 a2 e1              LDX #>Edit_CHRIN_Standard
e677 85 e9              STA SCRIV
e679 86 ea              STX SCRIV+1
e67b a9 0c              LDA #<Edit_CHROUT_Standard
e67d a2 e2              LDX #>Edit_CHROUT_Standard
e67f 85 eb              STA SCROV
e681 86 ec              STX SCROV+1
e683 a9 10              LDA #16
e685 85 e7              STA CHIME
e687 20 8a e6           JSR Double_Beep

              ; ***********
e68a            Double_Beep
              ; ***********

e68a 20 8d e6           JSR EDIT_BEEP

              ; *********
e68d            EDIT_BEEP
              ; *********

e68d a4 e7              LDY CHIME
e68f f0 25              BEQ BEEP_Ret
e691 a9 10              LDA #16             ; shift out - rate controlled by timer 2
e693 8d 4b e8           STA VIA_ACR         ; free running mode
e696 a9 0f              LDA #15
e698 8d 4a e8           STA VIA_Shift       ; set shift pattern 0000 1111
e69b a2 07              LDX #7
e69d bd 4d e7 BEEP_10   LDA SOUND_TAB-1,X
e6a0 8d 48 e8           STA VIA_Timer_2_Lo  ; set sustain time
e6a3 a5 e7              LDA CHIME
e6a5 88       BEEP_20   DEY
e6a6 d0 fd              BNE BEEP_20           ; inner wait loop
e6a8 38                 SEC
e6a9 e9 01              SBC #1
e6ab d0 f8              BNE BEEP_20           ; outer wait loop
e6ad ca                 DEX
e6ae d0 ed              BNE BEEP_10           ; next note
e6b0 8e 4a e8           STX VIA_Shift       ; x=0 clear shift register
e6b3 8e 4b e8           STX VIA_ACR         ; x=0 clear access control register
e6b6 60       BEEP_Ret  RTS ;Size   42 [EDIT_BEEP]

              ; **************
e6b7            Set_Screen_SAL
              ; **************

e6b7 8a                 TXA
e6b8 48                 PHA
e6b9 29 0f              AND #15
e6bb aa                 TAX
e6bc bd 55 e7           LDA Line_Addr_Lo,X
e6bf 85 c7              STA SAL
e6c1 68                 PLA
e6c2 aa                 TAX
e6c3 bd 6e e7           LDA Line_Addr_Hi,X
e6c6 85 c8              STA SAL+1
e6c8 60                 RTS ;Size   18 [Set_Screen_SAL]

              ; **********
e6c9            Cursor_BOL
              ; **********

              ; Input:  X       = cursor row (0 - 24)
              ; Output: ScrPtr  = screen address of row X
              ;         Y       = left margin

e6c9 a4 e2              LDY LefMargin

              ; *************
e6cb            Update_ScrPtr
              ; *************

e6cb 8a                 TXA
e6cc 48                 PHA
e6cd 29 0f              AND #15             ; Line lo repeats after 16 lines
e6cf aa                 TAX
e6d0 bd 55 e7           LDA Line_Addr_Lo,X
e6d3 85 c4              STA ScrPtr
e6d5 68                 PLA
e6d6 aa                 TAX
e6d7 bd 6e e7           LDA Line_Addr_Hi,X
e6da 85 c5              STA ScrPtr+1
e6dc 60                 RTS ;Size   18 [Update_ScrPtr]

              ; **********
e6dd            RUN_String
              ; **********

              ;               dL"*<CR>rU<CR>
e6dd 44 cc 22           .BYTE $44,$cc,$22,$2a,$0d,$52,$d5,$0d

              ; ********
e6e5            CRT_TEXT
              ; ********

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6e5 3a                 .BYTE  58           ;  0: Horizontal Total
e6e6 28                 .BYTE  40           ;  1: Horizontal Displayed
e6e7 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6e8 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6e9 20                 .BYTE  32           ;  4: Vertical Total
e6ea 09                 .BYTE   9           ;  5: Vertical Total Adjust
e6eb 19                 .BYTE  25           ;  6: Vertical Displayed
e6ec 1e                 .BYTE  30           ;  7: Vertical Sync position
e6ed 00                 .BYTE   0           ;  8: Interlace and Skew
e6ee 09                 .BYTE   9           ;  9: Maximum Raster Address
e6ef 00                 .BYTE   0           ; 10: Cursor Start Raster
e6f0 00                 .BYTE   0           ; 11: Cursor End Raster
e6f1 10                 .BYTE $10           ; 12: Display Start Address (High)
e6f2 00                 .BYTE $00           ; 13: Display Start Address (Low)
e6f3 00                 .BYTE $00           ; 14: Cursor Address (High)
e6f4 00                 .BYTE $00           ; 15: Cursor Address (Low)
e6f5 00                 .BYTE $00           ; 16: Light Pen Address (High)
e6f6 00                 .BYTE $00           ; 17: Light Pen Address (Low)


              ; ************
e6f7            CRT_GRAPHICS
              ; ************

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6f7 3a                 .BYTE  58           ;  0: Horizontal Total
e6f8 28                 .BYTE  40           ;  1: Horizontal Displayed
e6f9 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6fa 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6fb 29                 .BYTE  41           ;  4: Vertical Total                  !!!
e6fc 03                 .BYTE   3           ;  5: Vertical Total Adjust           !!!
e6fd 19                 .BYTE  25           ;  6: Vertical Displayed
e6fe 22                 .BYTE  34           ;  7: Vertical Sync position          !!!
e6ff 00                 .BYTE   0           ;  8: Interlace and Skew
e700 07                 .BYTE   7           ;  9: Maximum Raster Address          !!!


              ; ***
e701            OLD
              ; ***
e701 a9 01              LDA #1
e703 a8                 TAY
e704 91 28              STA (TXTTAB),Y      ; non zero link
e706 88                 DEY
e707 91 28              STA (TXTTAB),Y
e709 20 b6 b4           JSR Rechain         ; restore all links
e70c 18                 CLC
e70d a5 1f              LDA INDEXA
e70f 69 02              ADC #2
e711 a8                 TAY
e712 a5 20              LDA INDEXA+1
e714 69 00              ADC #0
e716 4c d5 df           JMP Renu_90         ; set VARTAB and reset BASIC

e719 00 00 00           .FILL $e74e-* (0) ; 53 bytes

              ; ****************
e74e            SOUND_TAB ; e74e
              ; ****************

e74e 0e 1e 3e           .BYTE $0e,$1e,$3e,$7e,$3e,$1e,$0e

              ; ********************
e755            Line_Addr_Lo ; $e755
              ; ********************

e755 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e75d 80 d0 20           .BYTE $80,$d0,$20,$70,$c0,$10,$60,$b0
e765 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e76d 80                 .BYTE $80

              ; ********************
e76e            Line_Addr_Hi ; $e76e
              ; ********************

e76e 80 80 80           .BYTE $80,$80,$80,$80,$81,$81,$81,$82 ;  0 -  7
e776 82 82 83           .BYTE $82,$82,$83,$83,$83,$84,$84,$84 ;  8 - 15
e77e 85 85 85           .BYTE $85,$85,$85,$85,$86,$86,$86,$87 ; 16 - 23
e786 87 87 88           .BYTE $87,$87,$88,$88,$88,$89,$89,$89 ; 24 - 31

e78e 42 2d 50 B_P_0     .BYTE "B-P 9 0\r"
e796 55 31 3a U1        .BYTE "U1:9 "

              ; ********
e79b            Reset_BP
              ; ********

e79b 20 2b fb           JSR DOS_Open_Comm_Write
e79e a0 00              LDY #0
e7a0 b9 8e e7 RBP_30    LDA B_P_0,Y
e7a3 20 9e f1           JSR CIOUT
e7a6 c8                 INY
e7a7 c0 08              CPY #?B_P_0
e7a9 90 f5              BCC RBP_30
e7ab 4c b9 f1           JMP UNLSN

              ; *********
e7ae            Preset_U1
              ; *********

e7ae a2 04              LDX #4
e7b0 bd 96 e7 PU1_10    LDA U1,X
e7b3 9d 53 03           STA DOS_Command_Buffer,X
e7b6 ca                 DEX
e7b7 10 f7              BPL PU1_10
e7b9 60                 RTS ;Size   12 [Preset_U1]

              ; *************
e7ba            Mon_Disk_Comm
              ; *************

e7ba 20 2b fb           JSR DOS_Open_Comm_Write
e7bd a2 00              LDX #0
e7bf bd 53 03 MDC_10    LDA DOS_Command_Buffer,X
e7c2 e8                 INX
e7c3 20 9e f1           JSR CIOUT
e7c6 c9 20              CMP #' '
e7c8 b0 f5              BCS MDC_10
e7ca 4c b9 f1           JMP UNLSN

e7cd 00 00 00           .FILL $e800-* (0) ; 51 bytes

e800 48 41 4c           .BYTE "HALL OF FAME:"
e80d 43 48 55           .BYTE "CHUCK PEDDLE - "
e81c 42 49 4c           .BYTE "BILL MENSCH - "
e82a 4a 41 43           .BYTE "JACK TRAMIEL - "
e839 49 52 41           .BYTE "IRA VELINSKY - "
e848 4a 4f 48           .BYTE "JOHN FEAGANS - "
e857 42 49 4c           .BYTE "BILL GATES - "
e864 4a 49 4d           .BYTE "JIM BUTTERFIELD - "
e876 42 52 41           .BYTE "BRAD TEMPLETON - "
e887 4a 49 4d           .BYTE "JIM CONELLEY - "
e896 4e 49 4c           .BYTE "NILS EILERS - "
e8a4 56 49 43           .BYTE "VICE TEAM - "


e8b0 00 00 00           .FILL $e924-* (0) ; 116 bytes

              ; *************
e924            EDIT_KEY_SCAN
              ; *************

              ; Initialize

e924 ad 10 e8           LDA PIA1_Port_A     ; Keyboard row select
e927 29 f0              AND #%11110000      ; Select row 0
e929 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e92c a5 98              LDA Key_Flags
e92e 09 c0              ORA #%11000000      ; 7 no <shift> and 6 no <ctrl>
e930 85 98              STA Key_Flags
e932 a9 ff              LDA #$ff
e934 85 97              STA Key_Index       ; invalidate Key_Index
e936 85 a6              STA SFDX            ; invalidate SFDX
e938 a2 4f              LDX #$4f            ; check key 79 -> 0

              ; Load next keyboard row int oaccumulator

e93a ad 12 e8 ScKbd_02  LDA PIA1_Port_B     ; Keyboard row
e93d cd 12 e8           CMP PIA1_Port_B     ; Keyboard row
e940 d0 f8              BNE ScKbd_02        ; repeat until no bounce

              ; Rotate accumulator for all 8 keys of this row

e942 a0 08              LDY #8              ; Test the 8 keys of the row
e944 4a       ScKbd_04  LSR A               ; next key -> carry
e945 b0 1a              BCS ScKbd_10        ; 1 -> not pressed
e947 48                 PHA                 ; Save scanned row

              ; Test for right or left shift key

e948 a9 7f              LDA #%01111111      ; mask for <shift> pressed
e94a e0 19              CPX #$19            ; Right Shift ?
e94c f0 0e              BEQ ScKbd_06        ; -> pressed
e94e e0 1f              CPX #$1f            ; Left Shift ?
e950 f0 0a              BEQ ScKbd_06        ; -> pressed

              ; Test for control key (RVS on older keyboards)

e952 a9 bf              LDA #%10111111      ; mask for <ctrl> pressed
e954 e0 0f              CPX #15             ; <RVS = CTRL> ?
e956 f0 04              BEQ ScKbd_06        ; -> pressed

              ; normal key, save key index

e958 86 97              STX Key_Index
e95a d0 04              BNE ScKbd_08        ; branch always

              ; flag shift or control in Key_Flags

e95c 25 98    ScKbd_06  AND Key_Flags
e95e 85 98              STA Key_Flags       ; save shift and control status

              ; continue with next index

e960 68       ScKbd_08  PLA                 ; restore row
e961 ca       ScKbd_10  DEX                 ; next key index
e962 30 08              BMI ScKbd_12        ; finished

              ; next key in this row

e964 88                 DEY                 ; next column
e965 d0 dd              BNE ScKbd_04

              ; row scan finished -> next row

e967 ee 10 e8           INC PIA1_Port_A     ; next keyboard row
e96a d0 ce              BNE ScKbd_02        ; Branch always

              ; keyboard scan finished - check if a keypress occured

e96c a6 97    ScKbd_12  LDX Key_Index       ; any key ?
e96e 10 03              BPL ScKbd_13        ; branch on key press
e970 86 e4              STX LSTX            ; invalidate last key pressed
e972 60       ScKbd_22  RTS ;Size   79 [EDIT_KEY_SCAN]

              ; is it the same key index as in the last scan ?

e973 e4 e4    ScKbd_13  CPX LSTX            ; still holding the same key ?
e975 d0 18              BNE ScKbd_16        ; other key
e977 a4 e6              LDY DELAY
e979 f0 04              BEQ ScKbd_14        ; branch if delay expired
e97b c6 e6              DEC DELAY           ; else decrement repeat delay counter
e97d d0 f3              BNE ScKbd_22        ; branch if delay not expired
e97f c6 e5    ScKbd_14  DEC KOUNT           ; decrement repeat speed counter
e981 d0 ef              BNE ScKbd_22        ; branch if repeat speed count not expired
e983 a0 04              LDY #4              ; set for 4/60ths of a second
e985 e0 0b              CPX #$0b            ; index for cursor <- ->
e987 d0 02              BNE ScKbd_15        ; normaö repeat speed
e989 a0 02              LDY #2              ; cursor left right repeat faster
e98b 84 e5    ScKbd_15  STY KOUNT           ; set repeat speed counter
e98d d0 06              BNE ScKbd_18        ; branch always

              ; new key press - reset delay

e98f 86 e4    ScKbd_16  STX LSTX            ; save key index
e991 a9 15              LDA #21
e993 85 e6              STA DELAY           ; set repeat delay count
e995 20 b4 e9 ScKbd_18  JSR Lookup_Keycode
e998 e0 0f              CPX #15
e99a f0 15              BEQ ScKbd_30        ; <CONTROL> doesn't go into buffer
e99c a6 9e              LDX CharsInBuffer
e99e e4 e3              CPX XMAX
e9a0 b0 05              BCS ScKbd_26        ; buffer full

              ; add key to keyboard buffer

e9a2 9d 6f 02 ScKbd_24  STA KEYD,X
e9a5 e6 9e              INC CharsInBuffer   ; put key into buffer

              ; check for STOP key

e9a7 a0 ff    ScKbd_26  LDY #$ff            ; Clear STOP flag
e9a9 c9 03              CMP #3              ; <STOP>
e9ab d0 02              BNE ScKbd_28
e9ad a0 ef              LDY #$ef            ; Set STOP flag
e9af 84 9b    ScKbd_28  STY Stop_Flag
e9b1 85 a6    ScKbd_30  STA SFDX
e9b3 60                 RTS ;Size  144 [EDIT_KEY_SCAN]

              ; **************
e9b4            Lookup_Keycode
              ; **************

e9b4 bd e1 eb           LDA KEYBOARD_CONTROL,X
e9b7 24 98              BIT Key_Flags
e9b9 70 05              BVS LoKe_20         ; no control
e9bb 30 02              BMI LoKe_10
e9bd 09 80              ORA #$80            ; shift control
e9bf 60       LoKe_10   RTS ;Size   12 [Lookup_Keycode]
e9c0 30 04    LoKe_20   BMI LoKe_30         ; no shift
e9c2 bd 90 eb           LDA KEYBOARD_SHIFTED,X
e9c5 60                 RTS ;Size   18 [Lookup_Keycode]
e9c6 bd 40 eb LoKe_30   LDA KEYBOARD_NORMAL,X
e9c9 60                 RTS ;Size   22 [Lookup_Keycode]

              ; ********************
e9ca            Edit_Switch_Char_ROM
              ; ********************

              ; Input:   A = $10 (new charset)   $30 (old charset)

e9ca a0 0c               LDY #12
e9cc 8c 80 e8            STY CRT_Address
e9cf 8d 81 e8            STA CRT_Value
e9d2 60                  RTS ;Size    9 [Edit_Switch_Char_ROM]


              ; **************
e9d3            EDIT_RESET_CRT
              ; **************

e9d3 a0 11              LDY #17
e9d5 2c                 .BYTE $2c           ; skip next instruction

              ; *****************
e9d6            EDIT_CHARSET_TEXT
              ; *****************

e9d6 a0 09              LDY #9
e9d8 a9 0e              LDA #14
e9da 8d 4c e8           STA VIA_PCR
e9dd a9 e5              LDA #<CRT_TEXT
e9df a2 e6              LDX #>CRT_TEXT
e9e1 4c 57 e0           JMP EDIT_SET_CRT

              ; *********************
e9e4            EDIT_CHARSET_GRAPHICS
              ; *********************

e9e4 a0 09              LDY #9
e9e6 a9 0c              LDA #12
e9e8 8d 4c e8           STA VIA_PCR
e9eb a9 f7              LDA #<CRT_GRAPHICS
e9ed a2 e6              LDX #>CRT_GRAPHICS
e9ef 4c 57 e0           JMP EDIT_SET_CRT

              ; *****************
e9f2            Read_Power_String
              ; *****************

e9f2 a9 80              LDA #$80            ; activate power scrolling
e9f4 85 99              STA Power_Flag
e9f6 20 e2 b4           JSR Read_String
e9f9 06 99              ASL Power_Flag      ; deactivate power scrolling
e9fb 60                 RTS ;Size   10 [Read_Power_String]

              ; ****************
e9fc            Check_Linenumber
              ; ****************

e9fc 8a                 TXA                 ; X = Row
e9fd 48                 PHA
e9fe 48                 PHA
e9ff 29 0f              AND #15
ea01 aa                 TAX
ea02 18                 CLC
ea03 bd 55 e7           LDA Line_Addr_Lo,X
ea06 65 e2              ADC LefMargin
ea08 85 77              STA TXTPTR
ea0a 68                 PLA
ea0b aa                 TAX
ea0c bd 6e e7           LDA Line_Addr_Hi,X
ea0f 69 00              ADC #0
ea11 85 78              STA TXTPTR+1
ea13 20 76 00           JSR CHRGOT
ea16 b0 04              BCS ChLi_Ret        ; no  number
ea18 20 f6 b8           JSR Scan_Linenumber
ea1b 18                 CLC                 ; has number
ea1c 68       ChLi_Ret  PLA
ea1d aa                 TAX
ea1e 60                 RTS ;Size   35 [Check_Linenumber]

              ; ******************
ea1f            Check_Line_Upwards
              ; ******************

ea1f a6 e1              LDX BotMargin
ea21 e4 e0    CLU_10    CPX TopMargin
ea23 f0 06              BEQ CLU_Ret         ; carry set -> no number
ea25 ca                 DEX
ea26 20 fc e9           JSR Check_Linenumber
ea29 b0 f6              BCS CLU_10
ea2b 60       CLU_Ret   RTS ;Size   13 [Check_Line_Upwards]

              ; ********************
ea2c            Check_Line_Downwards
              ; ********************

ea2c a6 e0              LDX TopMargin
ea2e e4 e1    CLD_10    CPX BotMargin
ea30 f0 06              BEQ CLD_Ret         ; carry set -> no number
ea32 e8                 INX
ea33 20 fc e9           JSR Check_Linenumber
ea36 b0 f6              BCS CLD_10
ea38 60       CLD_Ret   RTS ;Size   13 [Check_Line_Downwards]

              ; ***************
ea39            Power_Scroll_Up
              ; ***************

ea39 a5 99              LDA Power_Flag      ; active ?
ea3b f0 5e              BEQ PSU_Ret         ; -> neither BASIC nor monitor
ea3d a5 d8              LDA CursorRow       ; save row
ea3f 48                 PHA
ea40 a5 c6              LDA CursorCol
ea42 48                 PHA                 ; save col
ea43 a6 e1              LDX BotMargin
ea45 ca                 DEX
ea46 20 c9 e6           JSR Cursor_BOL      ; one row above bottom line
ea49 a9 20              LDA #' '            ; check, if this line is blank
ea4b d1 c4    PSU_10    CMP (ScrPtr),Y
ea4d d0 43              BNE PSU_30          ; don't list on non empty line
ea4f c8                 INY
ea50 c4 d5              CPY RigMargin
ea52 90 f7              BCC PSU_10
ea54 86 d8              STX CursorRow
ea56 24 99              BIT Power_Flag
ea58 30 27              BMI PSU_15          ; -> BASIC MODE

ea5a ca                 DEX                 ; line above
ea5b 20 c9 e6           JSR Cursor_BOL
ea5e b1 c4              LDA (ScrPtr),Y
ea60 c9 3a              CMP #':'            ; memory display
ea62 d0 2e              BNE PSU_30
ea64 c6 d8              DEC CursorRow
ea66 20 7b d5           JSR Mon_Prompt
ea69 20 54 d7           JSR Mon_Print_STAL
ea6c a9 10              LDA #16
ea6e 20 d4 d4           JSR Mon_Print_A_Hex_Values
ea71 a9 10              LDA #16
ea73 20 15 fb           JSR Add_STAL
ea76 a9 00              LDA #0
ea78 85 cd              STA QTSW
ea7a a9 40              LDA #$40
ea7c 85 99              STA Power_Flag      ; keep it active
ea7e 4c 92 ea           JMP PSU_30

ea81 20 1f ea PSU_15    JSR Check_Line_Upwards
ea84 b0 0c              BCS PSU_30
ea86 e6 11              INC LINNUM
ea88 d0 02              BNE PSU_20
ea8a e6 12              INC LINNUM+1
ea8c 20 0f eb PSU_20    JSR Find_Power_Line
ea8f 20 f9 ea           JSR List_BASIC_Line
ea92 68       PSU_30    PLA
ea93 85 c6              STA CursorCol
ea95 68                 PLA
ea96 85 d8              STA CursorRow       ; restore row
ea98 4c 52 e0           JMP Edit_Use_CursorRow
ea9b 60       PSU_Ret   RTS ;Size   99 [Power_Scroll_Up]

              ; *****************
ea9c            Power_Scroll_Down
              ; *****************

ea9c 24 99              BIT Power_Flag
ea9e 10 fb              BPL PSU_Ret
eaa0 a5 d8              LDA CursorRow       ; save row
eaa2 48                 PHA
eaa3 a5 c6              LDA CursorCol
eaa5 48                 PHA                 ; save col
eaa6 20 2c ea           JSR Check_Line_Downwards
eaa9 b0 e7              BCS PSU_30
eaab 20 0f eb           JSR Find_Power_Line
eaae a5 5c              LDA TMPPTC
eab0 c5 28              CMP TXTTAB
eab2 d0 06              BNE PSD_20
eab4 a5 5d              LDA TMPPTC+1
eab6 c5 29              CMP TXTTAB+1
eab8 f0 d8              BEQ PSU_30
eaba a5 57    PSD_20    LDA TMPPTB
eabc 85 5c              STA TMPPTC
eabe a5 58              LDA TMPPTB+1
eac0 85 5d              STA TMPPTC+1
eac2 20 4a e0           JSR EDIT_HOME
eac5 20 f9 ea           JSR List_BASIC_Line
eac8 a6 d8              LDX CursorRow
eaca e4 e0              CPX TopMargin
eacc f0 c4              BEQ PSU_30
eace a4 c6              LDY CursorCol       ; Basic line was oversize
ead0 a9 20              LDA #' '            ; erase to EOL and scroll again
ead2 91 c4    PSD_30    STA (ScrPtr),Y
ead4 c4 d5              CPY RigMargin
ead6 c8                 INY
ead7 90 f9              BCC PSD_30
ead9 a5 e0              LDA TopMargin
eadb 48                 PHA
eadc e8                 INX
eadd 86 e0              STX TopMargin
eadf 20 17 e4           JSR EDIT_SCROLL_DOWN
eae2 68                 PLA
eae3 85 e0              STA TopMargin
eae5 a0 01              LDY #1
eae7 b1 5c              LDA (TMPPTC),Y      ; link hi
eae9 aa                 TAX
eaea 88                 DEY
eaeb b1 5c              LDA (TMPPTC),Y      ; link lo
eaed 85 5c              STA TMPPTC
eaef 86 5d              STX TMPPTC+1
eaf1 e6 d8              INC CursorRow
eaf3 20 f9 ea           JSR List_BASIC_Line
eaf6 4c 92 ea           JMP PSU_30          ; always

eaf9                    .SIZE ;   93 [Power_Scroll_Down]

              ; ***************
eaf9            List_BASIC_Line
              ; ***************

eaf9 20 4e e0           JSR Edit_Goto_Left_Margin
eafc a0 01              LDY #1
eafe b1 5c              LDA (TMPPTC),Y      ; check link for valid line
eb00 f0 0c              BEQ LBL_Ret
eb02 c8                 INY
eb03 b1 5c              LDA (TMPPTC),Y      ; line # lo
eb05 aa                 TAX
eb06 c8                 INY
eb07 b1 5c              LDA (TMPPTC),Y      ; line # hi
eb09 20 89 b6           JSR List_Line       ; returns A=0
eb0c 85 cd              STA QTSW
eb0e 60       LBL_Ret   RTS ;Size   22 [List_BASIC_Line]

              ; ***************
eb0f            Find_Power_Line
              ; ***************

eb0f a5 28              LDA TXTTAB
eb11 a6 29              LDX TXTTAB+1
eb13 85 57              STA TMPPTB
eb15 86 58              STX TMPPTB+1
eb17 85 5c    FPL_10    STA TMPPTC
eb19 86 5d              STX TMPPTC+1
eb1b a0 01              LDY #1
eb1d b1 5c              LDA (TMPPTC),Y      ; link hi
eb1f f0 1e              BEQ FPL_40
eb21 c8                 INY                 ; Y = 2
eb22 b1 5c              LDA (TMPPTC),Y      ; line # lo
eb24 c5 11              CMP LINNUM
eb26 c8                 INY                 ; Y = 3
eb27 b1 5c              LDA (TMPPTC),Y      ; line # hi
eb29 e5 12              SBC LINNUM+1
eb2b b0 12              BCS FPL_40          ; >= LINNUM
eb2d a5 5c              LDA TMPPTC
eb2f 85 57              STA TMPPTB
eb31 a6 5d              LDX TMPPTC+1        ; last ptr
eb33 86 58              STX TMPPTB+1
eb35 88                 DEY                 ; Y = 2
eb36 88                 DEY                 ; Y = 1
eb37 b1 5c              LDA (TMPPTC),Y      ; link hi
eb39 aa                 TAX
eb3a 88                 DEY                 ; Y = 0
eb3b b1 5c              LDA (TMPPTC),Y      ; link lo
eb3d 90 d8              BCC FPL_10          ; branch always
eb3f 60       FPL_40    RTS ;Size   49 [Find_Power_Line]

              ; ***************
eb40            KEYBOARD_NORMAL
              ; ***************

              ; The keyboard table has 80 ($50) entries scanned backwards
              ; The map is organized in 10 rows x 8 columns
              ; Val = Scancode assigned to this key
              ; X   = Index of this key
              ; R   = Physical row on keyboard (1-5)
              ; C   = Physical column on keyboard (1-16 and k1-k3 for keypad)
              ; Key = Description

              ;               Val     X  R  C Key
              ;         --------------------------------
eb40 16                 .PET $16  ; 00  -  - Ctrl V
eb41 00                 .PET $00  ; 01  -  -
eb42 be                 .PET $be  ; 02  1 12 SZ  ?
0000 TRUE     #if BSOS_KBD
eb43 14                 .PET $14  ; 03  1 16 DEL INST
              #else
SKIP                    .PET $13  ; 03  1 16 HOME CLR
              #endif
eb44 39                 .PET '9'  ; 04  1 10 9   )
eb45 36                 .PET '6'  ; 05  1  7 6   &
eb46 33                 .PET '3'  ; 06  1  4 3   Paragraph
eb47 3c                 .PET '<'  ; 07  1  1 <   >

eb48 31                 .PET '1'  ; 08  3 k1 1
eb49 2d                 .PET '-'  ; 09  4 12 -   _
eb4a 15                 .PET $15  ; 0a  -  - Ctrl U
0000 TRUE     #if BSOS_KBD
eb4b 1d                 .PET $1d  ; 0b  4 15 RIGHT LEFT
              #else
SKIP                    .PET $14  ; 0b  4 15 DEL INST
              #endif
eb4c 4d                 .PET 'm'  ; 0c  4  9 m
eb4d 20                 .PET ' '  ; 0d  5  1 SPACE
eb4e 58                 .PET 'x'  ; 0e  4  4 x
eb4f 00                 .PET $00  ; 0f  4  1 CTRL (used by index)

eb50 32                 .PET '2'  ; 10  3 k2 2
0000 TRUE     #if BSOS_KBD
eb51 11                 .PET $11  ; 11  4 14 DOWN UP
              #else
SKIP                    .PET $03  ; 11  4 14 STOP RUN
              #endif
eb52 0f                 .PET $0f  ; 12  -  - Ctrl O
eb53 30                 .PET '0'  ; 13  4 k1 0
eb54 2c                 .PET ','  ; 14  4 10 ,
eb55 4e                 .PET 'n'  ; 15  4  8 n
eb56 56                 .PET 'v'  ; 16  4  6 v
eb57 59                 .PET 'y'  ; 17  4  3 y

eb58 33                 .PET '3'  ; 18  3 k3 3
eb59 00                 .PET $00  ; 19  4 13 Right SHIFT (used by index)
eb5a 19                 .PET $19  ; 1a  -  - Ctrl Y
eb5b 2e                 .PET '.'  ; 1b  4 11 .
eb5c 2e                 .PET '.'  ; 1c  4 k2 .
eb5d 42                 .PET 'b'  ; 1d  4  7 b
eb5e 43                 .PET 'c'  ; 1e  4  5 c
eb5f 00                 .PET $00  ; 1f  4  2 Left SHIFT (used by index)

eb60 34                 .PET '4'  ; 20  2 k1 4
eb61 bd                 .PET $bd  ; 21  2 12 u umlaut
eb62 4f                 .PET 'o'  ; 22  2 10 o
eb63 5b                 .PET '['  ; 23  2 14 [   ^
eb64 55                 .PET 'u'  ; 24  2  8 u
eb65 54                 .PET 't'  ; 25  2  6 t
eb66 45                 .PET 'e'  ; 26  2  4 e
eb67 51                 .PET 'q'  ; 27  2  2 q

eb68 5d                 .PET ']'  ; 28  2 15 ]   \
eb69 50                 .PET 'p'  ; 29  2 11 p
eb6a 49                 .PET 'i'  ; 2a  2  9 i
eb6b 2b                 .PET '+'  ; 2b  2 13 +
eb6c 5a                 .PET 'z'  ; 2c  2  7 z
eb6d 52                 .PET 'r'  ; 2d  2  5 r
eb6e 57                 .PET 'w'  ; 2e  2  3 w
eb6f 09                 .PET $09  ; 2f  2  1 TAB

eb70 36                 .PET '6'  ; 30  2 k3 6
eb71 bb                 .PET $bb  ; 31  3 13 a umlaut
eb72 4c                 .PET 'l'  ; 32  3 11 l
eb73 0d                 .PET $0d  ; 33  3 15 RETURN
eb74 4a                 .PET 'j'  ; 34  3  9 j
eb75 47                 .PET 'g'  ; 35  3  7 g
eb76 44                 .PET 'd'  ; 36  3  5 d
eb77 41                 .PET 'a'  ; 37  3  3 a

eb78 35                 .PET '5'  ; 38  2 k2 5
eb79 bc                 .PET $bc  ; 39  3 12 o umlaut
eb7a 4b                 .PET 'k'  ; 3a  3 10 k
eb7b 23                 .PET '#'  ; 3b  3 14 #
eb7c 48                 .PET 'h'  ; 3c  3  8 h
eb7d 46                 .PET 'f'  ; 3d  3  6 f
eb7e 53                 .PET 's'  ; 3e  3  4 s
eb7f 1b                 .PET $1b  ; 3f  3  1 ESC

eb80 39                 .PET '9'  ; 40  1 k3 9
eb81 00                 .PET $00  ; 41  -  -
0000 TRUE     #if BSOS_KBD
eb82 13                 .PET $13  ; 42  1 16 HOME
              #else
SKIP                    .PET $11  ; 42  1 16 DOWN UP
              #endif
eb83 37                 .PET '7'  ; 43  1 k1 7
eb84 30                 .PET '0'  ; 44  1 11 0
eb85 37                 .PET '7'  ; 45  1  8 7
eb86 34                 .PET '4'  ; 46  1  5 4
eb87 31                 .PET '1'  ; 47  1  2 1

eb88 00                 .PET $00  ; 48  -  -
eb89 0e                 .PET $0e  ; 49  -  - Ctrl N
0000 TRUE     #if BSOS_KBD
eb8a 03                 .PET $03  ; 4a  1 15 STOP (RUN)
              #else
SKIP                    .PET $1d  ; 4a  1 15 RIGHT LEFT
              #endif
eb8b 38                 .PET '8'  ; 4b  1 k2 Keypad 8
eb8c af                 .PET $af  ; 4c  1 13 ACUTE (GRAVE)
eb8d 38                 .PET '8'  ; 4d  1  9
eb8e 35                 .PET '5'  ; 4e  1  6
eb8f 32                 .PET '2'  ; 4f  1  3

              ; ****************
eb90            KEYBOARD_SHIFTED
              ; ****************

eb90 96                 .PET $96  ; 00    Shift Ctrl V
eb91 00                 .PET $00  ; 01
eb92 3f                 .PET '?'  ; 02
0000 TRUE     #if BSOS_KBD
eb93 94                 .PET $94  ; 03    INST
              #else
SKIP                    .PET $93  ; 03    CLR
              #endif
eb94 29                 .PET ')'  ; 04    )
eb95 26                 .PET '&'  ; 05    &
eb96 40                 .PET '@'  ; 06    Paragraph
eb97 3e                 .PET '>'  ; 07    >

eb98 a2                 .PET $a2  ; 08    Graph a2  KP 1
eb99 5f                 .PET '_'  ; 09    UNDERLINE
eb9a 95                 .PET $95  ; 0a    Shift Ctrl U
0000 TRUE     #if BSOS_KBD
eb9b 9d                 .PET $9d  ; 0b    LEFT
              #else
SKIP                    .PET $94  ; 0b    INST
              #endif
eb9c cd                 .PET 'M'  ; 0c    M
eb9d a0                 .PET $a0  ; 0d    SHIFT SPACE
eb9e d8                 .PET 'X'  ; 0e    X
eb9f 00                 .PET $00  ; 0f    CTRL (used by index)

eba0 a3                 .PET $a3  ; 10    Graph a3
0000 TRUE     #if BSOS_KBD
eba1 91                 .PET $91  ; 11    Cursor UP
              #else
SKIP                    .PET $93  ; 11    RUN
              #endif
eba2 8f                 .PET $8f  ; 12    Shift Ctrl O
eba3 a1                 .PET $a1  ; 13    Graph a1  KP 0
eba4 3b                 .PET ';'  ; 14    ;
eba5 ce                 .PET 'N'  ; 15    N
eba6 d6                 .PET 'V'  ; 16    V
eba7 d9                 .PET 'Y'  ; 17    Y

eba8 a4                 .PET $a4  ; 18    Graph a4   KP 3
eba9 00                 .PET $00  ; 19    Right SHIFT (used by index)
ebaa 99                 .PET $99  ; 1a    Shift Ctrl Y
ebab ff                 .PET $ff  ; 1b    KP . Pi
ebac 3a                 .PET ':'  ; 1c    :
ebad c2                 .PET 'B'  ; 1d    B
ebae c3                 .PET 'C'  ; 1e    C
ebaf 00                 .PET $00  ; 1f    Left SHIFT (used by index)

ebb0 a5                 .PET $a5  ; 20    Graph a5   KP 4
ebb1 f3                 .PET $f3  ; 21    U umlaut
ebb2 cf                 .PET 'O'  ; 22    O
ebb3 5e                 .PET '^'  ; 23    Circumflex
ebb4 d5                 .PET 'U'  ; 24    U
ebb5 d4                 .PET 'T'  ; 25    T
ebb6 c5                 .PET 'E'  ; 26    E
ebb7 d1                 .PET 'Q'  ; 27    Q

ebb8 5c                 .PET $5c  ; 28    Backslash
ebb9 d0                 .PET 'P'  ; 29    P
ebba c9                 .PET 'I'  ; 2a    I
ebbb 2a                 .PET '*'  ; 2b    *
ebbc da                 .PET 'Z'  ; 2c    Z
ebbd d2                 .PET 'R'  ; 2d    R
ebbe d7                 .PET 'W'  ; 2e    W
ebbf 89                 .PET $89  ; 2f    Shift TAB

ebc0 a7                 .PET $a7  ; 30    Graph a7   KP 6
ebc1 f1                 .PET $f1  ; 31    A umlaut
ebc2 cc                 .PET 'L'  ; 32    L
ebc3 8d                 .PET $8d  ; 33    SHIFT RETURN
ebc4 ca                 .PET 'J'  ; 34    J
ebc5 c7                 .PET 'G'  ; 35    G
ebc6 c4                 .PET 'D'  ; 36    D
ebc7 c1                 .PET 'A'  ; 37    A

ebc8 a6                 .PET $a6  ; 38    Graph a6   KP 5
ebc9 f2                 .PET $f2  ; 39    O umlaut
ebca cb                 .PET 'K'  ; 3a    K
ebcb 27                 .PET $27  ; 3b    '
ebcc c8                 .PET 'H'  ; 3c    H
ebcd c6                 .PET 'F'  ; 3d    F
ebce d3                 .PET 'S'  ; 3e    S
ebcf 1b                 .PET $1b  ; 3f    ESC

ebd0 aa                 .PET $aa  ; 40    Graph aa   KP 9
ebd1 00                 .PET $00  ; 41
0000 TRUE     #if BSOS_KBD
ebd2 93                 .PET $93  ; 42    CLR
              #else
SKIP                    .PET $91  ; 42    CURSOR UP
              #endif
ebd3 a8                 .PET $a8  ; 43    Graph a8   KP 7
ebd4 3d                 .PET '='  ; 44    =
ebd5 2f                 .PET '/'  ; 45    /
ebd6 24                 .PET '$'  ; 46    $
ebd7 21                 .PET '!'  ; 47    !

ebd8 00                 .PET $00  ; 48
ebd9 8e                 .PET $8e  ; 49    Shift Ctrl N
0000 TRUE     #if BSOS_KBD
ebda 83                 .PET $83  ; 4a    RUN
              #else
SKIP                    .PET $9d  ; 4a    CURSOR LEFT
              #endif
ebdb a9                 .PET $a9  ; 4b    Graph a9   KP 8
ebdc c0                 .PET $c0  ; 4c    GRAVE
ebdd 28                 .PET '('  ; 4d    (
ebde 25                 .PET '%'  ; 4e    %
ebdf 22                 .PET '"'  ; 4f    "

ebe0 00                 .PET 0

              ; ****************
ebe1            KEYBOARD_CONTROL
              ; ****************

ebe1 00                 .BYTE $00           ;                                  10h  -------
ebe2 00                 .BYTE $00           ; SHIFT                            10g  LEFT SHIFT
ebe3 00                 .BYTE $00           ; ?                                10f  SZ ?
ebe4 00                 .BYTE $00           ; INS                              10e  DEL INST
ebe5 dd                 .BYTE $dd           ; }                                10d  9 )
ebe6 00                 .BYTE $00           ; &                                10c  6 &
ebe7 00                 .BYTE $00           ; `                                10b  3 Paragraph
ebe8 00                 .BYTE $00           ; >                                10a  < >

ebe9 00                 .BYTE $00           ; Graph a2                         9h  KP 1
ebea 00                 .BYTE $00           ; UNDERLINE                        9g  - _
ebeb 00                 .BYTE $00           ; Shift Ctrl U                     9f  -------
ebec 00                 .BYTE $00           ; LEFT                             9e  CURSOR <->
ebed 00                 .BYTE $00           ; M                                9d  M
ebee 00                 .BYTE $00           ; SHIFT SPC                        9c  SPACE
ebef 18                 .BYTE $18           ; X                                9b  X
ebf0 00                 .BYTE $00           ; Control                          9a  CTRL (by index)

ebf1 00                 .BYTE $00           ; Graph a3                         8h  KP 2
ebf2 00                 .BYTE $00           ; 8g  CURSOR V^
ebf3 00                 .BYTE $00           ; Shift Ctrl O                     8f  -------
ebf4 00                 .BYTE $00           ; Graph a1                         8e  KP 0
ebf5 00                 .BYTE $00           ; ;                                8d  ,
ebf6 0e                 .BYTE $0e           ; N                                8c  N
ebf7 16                 .BYTE $16           ; V                                8b  V
ebf8 19                 .BYTE $19           ; Y                                8a  Y

ebf9 00                 .BYTE $00           ; Graph a4                         7h  KP 3
ebfa 00                 .BYTE $00           ; SHIFT                            7g  RIGHT SHIFT
ebfb 00                 .BYTE $00           ; Shift Ctrl Y                     7f  -------
ebfc de                 .BYTE $de           ; ~                                7e  KP . Pi
ebfd 00                 .BYTE $00           ; :                                7d  . :
ebfe 02                 .BYTE $02           ; B                                7c  B
ebff 03                 .BYTE $03           ; C                                7b  C
ec00 00                 .BYTE $00           ; SHIFT                            7a  LEFT SHIFT

ec01 00                 .BYTE $00           ; Graph a5                         6h  KP 4
ec02 00                 .BYTE $00           ;                                  6g  UE
ec03 0f                 .BYTE $0f           ; O                                6f  O
ec04 00                 .BYTE $00           ; ARROW UP                         6e  Arrow up
ec05 15                 .BYTE $15           ; U                                6d  U
ec06 14                 .BYTE $14           ; T                                6c  T
ec07 05                 .BYTE $05           ; E                                6b  E
ec08 11                 .BYTE $11           ; Q                                6a  Q

ec09 00                 .BYTE $00           ; 5h  ] Backslash
ec0a 10                 .BYTE $10           ; P                                5g  P
ec0b 09                 .BYTE $09           ; I                                5f  I
ec0c 00                 .BYTE $00           ; *                                5e  + *
ec0d 1a                 .BYTE $1a           ; Z                                5d  Z
ec0e 12                 .BYTE $12           ; R                                5c  R
ec0f 17                 .BYTE $17           ; W                                5b  W
ec10 00                 .BYTE $00           ; SET TAB                          5a  TAB

ec11 00                 .BYTE $00           ; Graph a7                         4h  KP 6
ec12 00                 .BYTE $00           ;                                  4g  AE
ec13 0c                 .BYTE $0c           ; L                                4f  L
ec14 00                 .BYTE $00           ; SHIFT RET                        4e  RETURN
ec15 0a                 .BYTE $0a           ; J                                4d  J
ec16 07                 .BYTE $07           ; G                                4c  G
ec17 04                 .BYTE $04           ; D                                4b  D
ec18 01                 .BYTE $01           ; A                                4a  A

ec19 00                 .BYTE $00           ; Graph a6                         3h  KP 5
ec1a 00                 .BYTE $00           ;                                  3g  OE
ec1b 0b                 .BYTE $0b           ; K                                3f  K
ec1c 00                 .BYTE $00           ; '                                3e  # '
ec1d 08                 .BYTE $08           ; H                                3d  H
ec1e 06                 .BYTE $06           ; F                                3c  F
ec1f 13                 .BYTE $13           ; S                                3b  S
ec20 1b                 .BYTE $1b           ; ESC                              3a  ESC

ec21 00                 .BYTE $00           ; Graph aa                         2h  KP 9
ec22 00                 .BYTE $00           ; SHIFT                            2g  -------
ec23 00                 .BYTE $00           ; CLR                              2f  HOME CLR
ec24 00                 .BYTE $00           ; Graph a8                         2e  KP 7
ec25 00                 .BYTE $00           ; =                                2d  0 =
ec26 dc                 .BYTE $dc           ; |                                2c  7 /
ec27 00                 .BYTE $00           ; $                                2b  4 $
ec28 00                 .BYTE $00           ; !                                2a  1 !

ec29 00                 .BYTE $00           ; SHIFT                            1h  -------
ec2a 00                 .BYTE $00           ; Shift Ctrl N                     1g  -------
ec2b 00                 .BYTE $00           ; 1f  [ \
ec2c 00                 .BYTE $00           ; Graph a9                         1e  KP 8
ec2d 00                 .BYTE $00           ;                                  1d  ACUTE GRAVE
ec2e db                 .BYTE $db           ; {                                1c  8 (
ec2f 00                 .BYTE $00           ; %                                1b  5 %
ec30 00                 .BYTE $00           ; "                                1a  2 "
ec31 00                 .BYTE $00           ; SHIFT

              ; **********
ec32            Find_Entry
              ; **********

ec32 86 11              STX LINNUM          ; save old #
ec34 85 12              STA LINNUM+1

              ; ***********
ec36            Find_LINNUM
              ; ***********

ec36 98                 TYA
ec37 48                 PHA
ec38 a0 00              LDY #0
ec3a 84 fb              STY STAL            ; STAL = $8000
ec3c a9 80              LDA #$80
ec3e 85 fc              STA STAL+1
ec40 85 b6              STA R_Bank
ec42 a0 03    FiEn_10   LDY #3              ; old line high
ec44 20 7a 02           JSR Bank_Fetch
ec47 c9 ff              CMP #$ff            ; EOT
ec49 f0 18              BEQ FiEn_20
ec4b c5 12              CMP LINNUM+1
ec4d d0 17              BNE FiEn_30
ec4f 88                 DEY                 ; old line low
ec50 20 7a 02           JSR Bank_Fetch
ec53 c5 11              CMP LINNUM
ec55 d0 0f              BNE FiEn_30
ec57 88                 DEY                 ; new line high
ec58 20 7a 02           JSR Bank_Fetch
ec5b 85 12              STA LINNUM+1
ec5d 88                 DEY                 ; new line low
ec5e 20 7a 02           JSR Bank_Fetch
ec61 85 11              STA LINNUM
ec63 68       FiEn_20   PLA
ec64 a8                 TAY
ec65 60                 RTS ;Size   48 [Find_LINNUM]
ec66 a9 04    FiEn_30   LDA #4
ec68 20 15 fb           JSR Add_STAL
ec6b d0 d5              BNE FiEn_10
ec6d 60                 RTS ;Size   56 [Find_LINNUM]

              ; *******************
ec6e            Install_Bank_Access
              ; *******************

ec6e a2 00              LDX #0
ec70 bd 7c ec FSC_10    LDA Bank_Fetch_Start,X
ec73 9d 7a 02           STA Bank_Fetch,X
ec76 e8                 INX
ec77 e0 24              CPX #[Bank_Store_End - Bank_Fetch_Start]
ec79 90 f5              BCC FSC_10
ec7b 60                 RTS ;Size   14 [Install_Bank_Access]

              ; ****************
ec7c            Bank_Fetch_Start
              ; ****************

ec7c a5 b6              LDA R_Bank
ec7e 78                 SEI
ec7f 8d f0 ff           STA $FFF0
ec82 b1 fb              LDA (STAL),Y
ec84 48                 PHA
ec85 a5 9a              LDA Default_Bank
ec87 8d f0 ff           STA $FFF0
ec8a 58                 CLI
ec8b 68                 PLA
ec8c 60                 RTS ;Size   17 [Bank_Fetch_Start]

              ; **************
ec8d            Bank_Fetch_End
              ; **************

              ; ****************
ec8d            Bank_Store_Start
              ; ****************

ec8d 48                 PHA
ec8e a5 b7              LDA W_Bank
ec90 78                 SEI
ec91 8d f0 ff           STA $FFF0
ec94 68                 PLA
ec95 91 f9              STA (BPTR),Y
ec97 48                 PHA
ec98 a5 9a              LDA Default_Bank
ec9a 8d f0 ff           STA $FFF0
ec9d 58                 CLI
ec9e 68                 PLA
ec9f 60                 RTS ;Size   19 [Bank_Store_Start]

              ; **************
eca0            Bank_Store_End
              ; **************


              ; ********
eca0            Get_Next
              ; ********

eca0 e6 77              INC TXTPTR
eca2 d0 02              BNE GeNe_10
eca4 e6 78              INC TXTPTR+1
eca6 a1 77    GeNe_10   LDA (TXTPTR,X)      ; X = 0
eca8 60                 RTS ;Size    9 [Bank_Store_End]

              ; *********
eca9            Xfer_Line
              ; *********

              ; copy BASIC line and adjust targets for

              ; GOTO
              ; GOSUB
              ; THEN
              ; GO TO
              ; RUN

              ; Set TXTPTR to start of BASIC line

eca9 18                 CLC
ecaa a5 5c              LDA TMPPTC
ecac 69 03              ADC #3
ecae 85 77              STA TXTPTR
ecb0 a5 5d              LDA TMPPTC+1
ecb2 69 00              ADC #0
ecb4 85 78              STA TXTPTR+1
ecb6 a2 00              LDX #0              ; source index
ecb8 a0 03              LDY #3              ; destination index
ecba c8       XfLi_10   INY
ecbb 20 a0 ec           JSR Get_Next        ; next byte
ecbe 20 8b 02           JSR Bank_Store      ; store
ecc1 f0 4d              BEQ XfLi_Ret        ; finished
ecc3 c9 22              CMP #QUOTE
ecc5 d0 0f              BNE XfLi_30
ecc7 c8       XfLi_20   INY
ecc8 20 a0 ec           JSR Get_Next        ; inside string
eccb 20 8b 02           JSR Bank_Store      ; store
ecce f0 40              BEQ XfLi_Ret        ; finished
ecd0 c9 22              CMP #QUOTE
ecd2 d0 f3              BNE XfLi_20         ; continue string copy
ecd4 f0 e4              BEQ XfLi_10         ; reenter normal loop
ecd6 c9 8f    XfLi_30   CMP #$8f            ; REM token
ecd8 d0 0a              BNE XfLi_50
ecda c8       XfLi_40   INY
ecdb 20 a0 ec           JSR Get_Next        ; after REM
ecde 20 8b 02           JSR Bank_Store      ; store
ece1 d0 f7              BNE XfLi_40
ece3 60                 RTS ;Size   59 [Xfer_Line]
ece4 c9 89    XfLi_50   CMP #$89            ; GOTO token
ece6 90 d2              BCC XfLi_10         ; no further action
ece8 f0 1f              BEQ XfLi_70
ecea c9 8a              CMP #$8a            ; RUN token
ecec f0 1b              BEQ XfLi_70
ecee c9 8d              CMP #$8d            ; GOSUB token
ecf0 f0 17              BEQ XfLi_70
ecf2 c9 a7              CMP #$a7            ; THEN token
ecf4 f0 13              BEQ XfLi_70
ecf6 c9 cb              CMP #$cb            ; GO token
ecf8 d0 0b              BNE XfLi_60
ecfa c8       XfLi_55   INY
ecfb 20 a0 ec           JSR Get_Next
ecfe 20 8b 02           JSR Bank_Store
ed01 c9 20              CMP #' '            ; skip blanks after GO
ed03 f0 f5              BEQ XfLi_55
ed05 c9 a4    XfLi_60   CMP #$a4            ; TO token
ed07 d0 b1              BNE XfLi_10         ; continue
ed09 20 11 ed XfLi_70   JSR Exchange_Number
ed0c c9 00              CMP #0
ed0e d0 d4              BNE XfLi_50         ; continue if not EOL
ed10 60       XfLi_Ret  RTS ;Size  104 [Xfer_Line]


              ; ***************
ed11            Exchange_Number
              ; ***************

ed11 c8                 INY                 ; char after token
ed12 20 70 00           JSR CHRGET
ed15 b0 29              BCS ExNu_20         ; no number e.g. after THEN
ed17 20 f6 b8           JSR Scan_Linenumber
ed1a 20 36 ec           JSR Find_LINNUM
ed1d 98                 TYA
ed1e 48                 PHA
ed1f a5 11              LDA LINNUM
ed21 85 60              STA FAC1M2
ed23 a5 12              LDA LINNUM+1
ed25 85 5f              STA FAC1M1
ed27 a2 90              LDX #$90
ed29 38                 SEC
ed2a 20 7f cd           JSR Convert_Integer_To_Real
ed2d 20 93 cf           JSR Format_FAC1
ed30 68                 PLA
ed31 a8                 TAY
ed32 a2 01              LDX #1
ed34 bd 00 01 ExNu_10   LDA STACK,X
ed37 f0 07              BEQ ExNu_20
ed39 20 8b 02           JSR Bank_Store
ed3c c8                 INY
ed3d e8                 INX
ed3e d0 f4              BNE ExNu_10
ed40 a2 00    ExNu_20   LDX#0
ed42 20 76 00           JSR CHRGOT          ; char after target
ed45 20 8b 02           JSR Bank_Store
ed48 c9 2c              CMP #','            ; on .. goto or on .. gosub ?
ed4a f0 c5              BEQ Exchange_Number
ed4c 60       ExNu_Ret  RTS ;Size   60 [Exchange_Number]

              ; **********************
ed4d            Reset_Renumber_Pointer
              ; **********************

              ; read basic program with pointer TMPPTC

ed4d a5 28              LDA TXTTAB
ed4f 85 5c              STA TMPPTC
ed51 a5 29              LDA TXTTAB+1
ed53 85 5d              STA TMPPTC+1

              ; **********
ed55            Reset_BPTR
              ; **********

ed55 a9 00              LDA #0
ed57 85 f9              STA BPTR
ed59 a9 80              LDA #$80
ed5b 85 fa              STA BPTR+1
ed5d 60                 RTS ;Size    9 [Reset_BPTR]

              ; ***********
ed5e            Update_Link
              ; ***********

ed5e a0 00              LDY #0
ed60 b1 5c              LDA (TMPPTC),Y      ; link low
ed62 aa                 TAX
ed63 c8                 INY                 ; Y = 1
ed64 b1 5c              LDA (TMPPTC),Y      ; link high
ed66 86 5c              STX TMPPTC
ed68 85 5d              STA TMPPTC+1        ; Z flag set if link high is zero
ed6a 60                 RTS ;Size   13 [Update_Link]


              ; ****************
ed6b            Extended_Command
              ; ****************

ed6b a0 00              LDY #0
ed6d 84 05              STY COUNT           ; count command #
ed6f 88       ExCo_10   DEY
ed70 a6 77              LDX TXTPTR
ed72 ca                 DEX
ed73 e8       ExCo_20   INX
ed74 c8                 INY
ed75 bd 00 02           LDA BUF,X
ed78 38                 SEC
ed79 f9 3a bf           SBC Extended_Keyword_Table,Y
ed7c f0 f5              BEQ ExCo_20         ; character match
ed7e c9 80              CMP #$80            ; match with difference $80 -> OK
ed80 d0 13              BNE ExCo_30         ; not this keyword
ed82 68                 PLA                 ; remove CALL
ed83 68                 PLA
ed84 86 77              STX TXTPTR
ed86 a5 05              LDA COUNT           ; command #
ed88 0a                 ASL A
ed89 a8                 TAY
ed8a b9 2d bf           LDA Extended_Statement_Table+1,Y
ed8d 48                 PHA
ed8e b9 2c bf           LDA Extended_Statement_Table,Y
ed91 48                 PHA
ed92 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
ed95 e6 05    ExCo_30   INC COUNT           ; try next keyword
ed97 c8       ExCo_40   INY
ed98 b9 39 bf           LDA Extended_Keyword_Table-1,Y
ed9b 10 fa              BPL ExCo_40
ed9d b9 2c bf           LDA Extended_Statement_Table,Y
eda0 d0 cd              BNE ExCo_10         ; next keyword if not end of table
eda2 60                 RTS                 ; finished scan ;Size   56 [Extended_Command]


              ; *********
eda3            Find_Text
              ; *********

eda3 20 fb b4           JSR Tokenize_Line
eda6 20 70 00           JSR CHRGET
eda9 85 23              STA RENNEW          ; delimiter
edab 20 4d ed           JSR Reset_Renumber_Pointer
edae a0 03    FiTe_10   LDY #3
edb0 84 24              STY RENNEW+1
edb2 20 c5 ed           JSR Contains_Pattern
edb5 d0 06              BNE FiTe_20
edb7 20 f9 ea           JSR List_BASIC_Line
edba 20 25 d5           JSR Mon_Print_CR
edbd 20 5e ed FiTe_20   JSR Update_Link
edc0 d0 ec              BNE FiTe_10
edc2 4c ff b3           JMP Basic_Ready

              ; ****************
edc5            Contains_Pattern
              ; ****************

edc5 a6 77    CoPa_10   LDX TXTPTR          ; text to find - 1
edc7 a4 24              LDY RENNEW+1
edc9 c8       CoPa_20   INY
edca e8                 INX
edcb bd 00 02           LDA BUF,X           ; next pattern
edce f0 10              BEQ CoPa_Ret        ; match
edd0 c5 23              CMP RENNEW          ; delimiter
edd2 f0 0c              BEQ CoPa_Ret        ; match
edd4 d1 5c              CMP (TMPPTC),Y      ; next program byte
edd6 f0 f1              BEQ CoPa_20         ; continue compare
edd8 e6 24              INC RENNEW+1        ; advance search pos
edda b1 5c              LDA (TMPPTC),Y
eddc d0 e7              BNE CoPa_10
edde a9 01              LDA #1
ede0 60       CoPa_Ret  RTS ;Size   28 [Contains_Pattern]

              ; **************
ede1            Load_Directory
              ; **************

ede1 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
ede4 a4 2f              LDY STREND+1        ; load directory into free RAM
ede6 c8                 INY
ede7 84 ca              STY EAL+1
ede9 a0 00              LDY #0
edeb 84 c9              STY EAL
eded 84 96              STY STATUS
edef a0 02              LDY #2              ; header start
edf1 a6 ca    LoDi_10   LDX EAL+1           ; next page
edf3 e8                 INX
edf4 e4 31              CPX FRETOP+1        ; end of free RAM
edf6 90 03              BCC LoDi_20         ; branch if OK
edf8 4c cd b3           JMP Error_Out_Of_Memory
edfb 86 ca    LoDi_20   STX EAL+1
edfd 20 c0 f1 LoDi_30   JSR ACPTR           ; read next byte
ee00 91 c9              STA (EAL),Y
ee02 a5 96              LDA STATUS
ee04 d0 05              BNE LoDi_40         ; branch on EOI
ee06 c8                 INY
ee07 d0 f4              BNE LoDi_30         ; loop
ee09 f0 e6              BEQ LoDi_10         ; increment page
ee0b 4c c1 f3 LoDi_40   JMP LoFi_70         ; Untalk & Close

              ; *****************
ee0e            DOS_Get_Dir_Entry
              ; *****************

              ; Read directory entry from loaded $ file
              ; and store results in FNLEN and DOS_FC
              ; Store filename address in FNADR
              ; X = 0 flags no entry found on exit

ee0e 18                 CLC                 ; advance to next entry
ee0f a5 bb              LDA DosPtr          ; start address
ee11 69 20              ADC #32
ee13 85 bb              STA DosPtr
ee15 90 02              BCC DGDE_05
ee17 e6 bc              INC DosPtr+1

ee19 a0 03    DGDE_05   LDY #3              ; scan after size word

ee1b c8       DGDE_10   INY
ee1c b1 bb              LDA (DosPtr),Y
ee1e c9 22              CMP #QUOTE
ee20 90 f9              BCC DGDE_10         ; skip blanks before filename
ee22 d0 3a              BNE DGDE_80         ; no quote -> blocks free
ee24 88                 DEY                 ; byte for drive
ee25 88                 DEY                 ; byte for 'S' command
ee26 98                 TYA
ee27 05 bb              ORA DosPtr          ; set FNADR
ee29 85 da              STA FNADR
ee2b a5 bc              LDA DosPtr+1
ee2d 85 db              STA FNADR+1
ee2f a0 00              LDY #0              ; prepare scratch command
ee31 a9 53              LDA #'S'
ee33 91 da              STA (FNADR),Y
ee35 c8                 INY
ee36 ad 3c 03           LDA DOS_Drive_2     ; target drive
ee39 09 30              ORA #'0'
ee3b 91 da              STA (FNADR),Y
ee3d c8                 INY
ee3e a9 3a              LDA #':'
ee40 91 da              STA (FNADR),Y       ; overwrite opening quote

ee42 c8       DGDE_20   INY
ee43 b1 da              LDA (FNADR),Y
ee45 c9 22              CMP #QUOTE          ; closing quote
ee47 f0 04              BEQ DGDE_40
ee49 c0 13              CPY #19             ; max length + "S0:"
ee4b 90 f5              BCC DGDE_20

ee4d 84 d1    DGDE_40   STY FNLEN           ; length of filename

ee4f c8       DGDE_60   INY
ee50 b1 da              LDA (FNADR),Y
ee52 c9 20              CMP #' '            ; skip blanks
ee54 f0 f9              BEQ DGDE_60
ee56 c9 2a              CMP #'*'            ; splat file ?
ee58 f0 b4              BEQ DOS_Get_Dir_Entry
ee5a 85 b1              STA DOS_FC          ; PRG, SEQ, USR, REL
ee5c a0 00              LDY #0              ; flag success

ee5e 60       DGDE_80   RTS                 ; Y != 0 for no file ;Size   81 [DOS_Get_Dir_Entry]

              ; *************
ee5f            DOS_Add_Comma
              ; *************

ee5f a9 2c              LDA #','
ee61 91 da              STA (FNADR),Y
ee63 c8                 INY
ee64 60                 RTS ;Size    6 [DOS_Add_Comma]

              ; DOS_Copy is an enhancement of the BASIC 4 COPY command.
              ; It is called from the original COPY if Source Unit and
              ; Target unit differ
              ; DOS_Copy uses the free RAM between variable storage and
              ; string storage (STREND - FRETOP)
              ; First a call to the Garbage_Collection maximises the
              ; free RAM area. The first 256 byte block after STREND is
              ; used as a transfer buffer. The area STREND + 256 is used
              ; to store the directory of the source unit. If the
              ; remaining space is not sufficient to load the directory
              ; an OOM (Out Of Memory) error occurs.

              ; ********
ee65            DOS_Copy
              ; ********

ee65 20 6a c6           JSR Garbage_Collection
ee68 a5 d4              LDA FA              ; target unit
ee6a 85 ad              STA Target_Unit     ; save it
ee6c a5 9c              LDA Source_Unit
ee6e 85 d4              STA FA
ee70 a9 24              LDA #'$'            ; directory command
ee72 8d 53 03           STA DOS_Command_Buffer
ee75 a9 03              LDA #3              ; 3 parameter
ee77 a2 01              LDX #1              ; write after $
ee79 a0 02              LDY #2              ; build d1:f1
ee7b 20 fc db           JSR Build_DOS_Command_X
ee7e 20 e1 ed           JSR Load_Directory
ee81 a9 00              LDA #0              ; start of directory
ee83 85 bb              STA DosPtr
ee85 a6 2f              LDX STREND+1
ee87 e8                 INX
ee88 e8                 INX
ee89 86 bc              STX DosPtr+1

ee8b 20 0e ee DOSC_10   JSR DOS_Get_Dir_Entry
ee8e 98                 TYA                 ; 0: success
ee8f f0 01              BEQ DOSC_15
ee91 60                 RTS ;Size   45 [DOS_Copy]

ee92 84 b9    DOSC_15   STY DOS_RL          ; record length
ee94 84 11              STY LINNUM          ; initialize record #
ee96 84 12              STY LINNUM+1
ee98 c8                 INY
ee99 8c 3a 03           STY DOS_Tmp         ; pos in record# = 1
ee9c a4 d1              LDY FNLEN
ee9e 20 5f ee           JSR DOS_Add_Comma
eea1 a5 b1              LDA DOS_FC          ; Filetype
eea3 c9 52              CMP #'R'            ; REL file ?
eea5 d0 0e              BNE DOSC_20
eea7 a9 4c              LDA #'L'            ; REL type
eea9 91 da              STA (FNADR),Y
eeab c8                 INY
eeac 20 5f ee           JSR DOS_Add_Comma   ; "St:FILENAME,L,CHR$(RL)"
eeaf a9 fe              LDA #254            ; max record length
eeb1 85 b9              STA DOS_RL
eeb3 d0 08              BNE DOSC_25         ; branch always

eeb5 91 da    DOSC_20   STA (FNADR),Y       ; "St:FILENAME,S"
eeb7 c8                 INY
eeb8 20 5f ee           JSR DOS_Add_Comma
eebb a9 57              LDA #'W'

eebd 91 da    DOSC_25   STA (FNADR),Y       ; "St:FILENAME,S,W"

              ; Scratch target file (avoid @ syntax)

eebf a5 ad              LDA Target_Unit
eec1 85 d4              STA FA
eec3 20 9b da           JSR PDC_10          ; send DOS command

              ; Remove 'S' from Scratch command

eec6 e6 da              INC FNADR           ; always inside page

              ; Add ",S" ",P" ",U" or ",L,CHR$(RL)"

eec8 e6 d1              INC FNLEN           ; "t:FILENAME,S"
eeca a5 b9              LDA DOS_RL          ; REL file ?
eecc f0 04              BEQ DOSC_35         ; branch if not
eece e6 d1              INC FNLEN           ; "t:FILENAME,L,"
eed0 e6 d1              INC FNLEN           ; "t:FILENAME,L,(RL)"

              ; print filename

eed2 20 88 ef DOSC_35   JSR Print_Filename
eed5 20 b2 ef           JSR Open_Read_File

              ; Open write file

eed8 a5 b9    DOSC_47   LDA DOS_RL
eeda d0 04              BNE DOSC_50
eedc e6 d1              INC FNLEN           ; "s:FILENAME,S,W"
eede e6 d1              INC FNLEN

eee0 20 cf ef DOSC_50   JSR Open_Write_File

              ; Copy file

eee3 a5 9c    DOSC_55   LDA Source_Unit
eee5 85 d4              STA FA
eee7 20 d2 f0           JSR TALK
eeea a9 6d              LDA #$6d
eeec 85 d3              STA SA
eeee 20 93 f1           JSR TKSA
eef1 a0 00              LDY #0
eef3 84 96              STY STATUS

eef5 20 c0 f1 DOSC_60   JSR ACPTR
eef8 91 2e              STA (STREND),Y
eefa c8                 INY
eefb a5 96              LDA STATUS
eefd 85 b2              STA DOS_EOF
eeff d0 04              BNE DOSC_65
ef01 c4 b9              CPY DOS_RL          ; copy max DOS_RL bytes
ef03 d0 f0              BNE DOSC_60         ; DOS_RL=0 -> copy 256 bytes

ef05 84 b1    DOSC_65   STY DOS_FC          ; Byte count
ef07 20 ae f1           JSR UNTLK
ef0a a5 b9              LDA DOS_RL
ef0c f0 07              BEQ DOSC_66
ef0e 20 91 d9           JSR Kernal_Read_DS
ef11 c9 30              CMP #'0'
ef13 d0 41              BNE DOSC_75

ef15 a5 ad    DOSC_66   LDA Target_Unit
ef17 85 d4              STA FA
ef19 a9 6e              LDA #$6e
ef1b 85 d3              STA SA
ef1d a0 00              LDY #0
ef1f 84 96              STY STATUS
ef21 a5 b9              LDA DOS_RL
ef23 f0 03              BEQ DOSC_67
ef25 20 77 ef           JSR Send_Record_No

ef28 20 d5 f0 DOSC_67   JSR LISTEN
ef2b a9 6e              LDA #$6e
ef2d 85 d3              STA SA
ef2f 20 43 f1           JSR SECOND

ef32 b1 2e    DOSC_70   LDA (STREND),Y
ef34 20 9e f1           JSR CIOUT
ef37 a5 96              LDA STATUS
ef39 d0 1b              BNE DOSC_75
ef3b c8                 INY
ef3c c4 b1              CPY DOS_FC
ef3e d0 f2              BNE DOSC_70
ef40 20 b9 f1           JSR UNLSN
ef43 a5 b2              LDA DOS_EOF
ef45 f0 9c              BEQ DOSC_55
ef47 a5 b9              LDA DOS_RL
ef49 f0 0b              BEQ DOSC_75
ef4b 20 91 d9           JSR Kernal_Read_DS
ef4e c9 30              CMP #'0'
ef50 f0 91              BEQ DOSC_55
ef52 c9 35              CMP #'5'            ; ignore record not present
ef54 f0 8d              BEQ DOSC_55

ef56 20 b9 f1 DOSC_75   JSR UNLSN
ef59 a5 ad              LDA Target_Unit
ef5b 85 d4              STA FA
ef5d a9 6e              LDA #$6e
ef5f 85 d3              STA SA
ef61 20 2a f7           JSR Close_Disk_File ; close write file
ef64 a9 0d              LDA #CR
ef66 20 d2 ff           JSR CHROUT
ef69 a5 9c              LDA Source_Unit
ef6b 85 d4              STA FA
ef6d a9 6d              LDA #$6d
ef6f 85 d3              STA SA
ef71 20 2a f7           JSR Close_Disk_File ; close read file
ef74 4c 8b ee           JMP DOSC_10         ; next file

              ; **************
ef77            Send_Record_No
              ; **************

ef77 e6 11              INC LINNUM
ef79 d0 02              BNE SRN_10
ef7b e6 12              INC LINNUM+1
ef7d 20 43 da SRN_10    JSR DOS_Record_No
ef80 20 91 d9           JSR Kernal_Read_DS
ef83 a0 00              LDY #0
ef85 84 96              STY STATUS
ef87 60                 RTS ;Size   17 [Send_Record_No]

              ; **************
ef88            Print_Filename
              ; **************

ef88 20 51 f3           JSR In_Direct_Mode
ef8b d0 24              BNE PrFi_90
ef8d a0 00              LDY #0
ef8f b1 da    PrFi_10   LDA (FNADR),Y
ef91 c8                 INY
ef92 20 d2 ff           JSR CHROUT
ef95 c9 4c              CMP #'L'
ef97 d0 14              BNE PrFi_20
ef99 b1 da              LDA (FNADR),Y
ef9b c9 2c              CMP#','
ef9d d0 0e              BNE PrFi_20
ef9f 20 d2 ff           JSR CHROUT
efa2 a9 24              LDA #'$'
efa4 20 d2 ff           JSR CHROUT
efa7 c8                 INY
efa8 b1 da              LDA (FNADR),Y
efaa 4c 5b d7           JMP Print_Hex_Byte
efad c4 d1    PrFi_20   CPY FNLEN
efaf 90 de              BCC PrFi_10
efb1 60       PrFi_90   RTS ;Size   42 [Print_Filename]

              ; **************
efb2            Open_Read_File
              ; **************

efb2 a5 9c              LDA Source_Unit
efb4 85 d4              STA FA
efb6 a9 6d              LDA #$6d            ; channel 13
efb8 85 d3              STA SA
efba a0 00              LDY #0
efbc 84 96              STY STATUS          ; clear status
efbe ad 3b 03           LDA DOS_Drive_1     ; source drive
efc1 09 30              ORA #'0'
efc3 91 da              STA (FNADR),Y       ; into filename
efc5 a5 b9              LDA DOS_RL          ; REL file ?
efc7 f0 03              BEQ ORF_10          ; branch if not
efc9 4c c8 e4           JMP Get_Record_Size
efcc 4c af f4 ORF_10    JMP Send_Filename

              ; ***************
efcf            Open_Write_File
              ; ***************

efcf a5 ad              LDA Target_Unit
efd1 85 d4              STA FA
efd3 a9 6e              LDA #$6e
efd5 85 d3              STA SA
efd7 a0 00              LDY #0
efd9 84 96              STY STATUS
efdb ad 3c 03           LDA DOS_Drive_2
efde 09 30              ORA #'0'
efe0 91 da              STA (FNADR),Y
efe2 4c af f4           JMP Send_Filename


efe5 00 00 00           .FILL $f000 - * (0) ; 27 bytes

              ; ***************
f000            KERNAL_MESSAGES
              ; ***************

f000 54 4f 4f MSG_TOO_MANY    .BYTE "TOO MANY FILES"^
f00e 46 49 4c MSG_FILE_OPEN   .BYTE "FILE OPEN"^
f017 46 49 4c MSG_FILE_NOT_O  .BYTE "FILE NOT OPEN"^
f024 46 49 4c MSG_FILE_NOT_F  .BYTE "FILE NOT FOUND"^
f032 0d 53 45 MSG_SEARCHING   .BYTE "\rSEARCHING "^
f03d 46 4f 52 MSG_FOR         .BYTE "FOR "^
f041 0d 50 52 MSG_PRESS       .BYTE "\rPRESS PLAY "^
f04d 26 20 52 MSG_RECORD      .BYTE "& RECORD "^
f056 4f 4e 20 MSG_ON_TAPE     .BYTE "ON TAPE #"^
f05f 0d 4c 4f MSG_LOAD        .BYTE "\rLOAD"^
f064 0d 57 52 MSG_WRITING     .BYTE "\rWRITING "^
f06d 0d 56 45 MSG_VERIFY      .BYTE "\rVERIFY"^
f074 44 45 56 MSG_DEVICE_NOT  .BYTE "DEVICE NOT PRESENT"^
f086 4e 4f 54 MSG_NOT_INPUT   .BYTE "NOT INPUT FILE"^
f094 4e 4f 54 MSG_NOT_OUTPUT  .BYTE "NOT OUTPUT FILE"^
f0a3 0d 46 4f MSG_FOUND       .BYTE "\rFOUND "^
f0aa 0d 4f 4b MSG_OK          .BYTE "\rOK\r"^
f0ae 0d 52 45 MSG_READY       .BYTE "\rREADY.\r"^
f0b6 0d 41 52 MSG_SURE        .BYTE "\rARE YOU SURE ?"^
f0c5 0d 3f 20 MSG_BAD_DISK    .BYTE "\r? BAD DISK \r"^

              ; ****
f0d2            TALK
              ; ****

f0d2 a9 40              LDA #%01000000      ; TALK cmd: $40..$5e
f0d4 2c                 .BYTE $2c           ; skip next statement

              ; ******
f0d5            LISTEN
              ; ******

f0d5 a9 20              LDA #%00100000      ; LISTEN cmd: $20..$3e

              ; *******
f0d7            TALI_10
              ; *******

f0d7 48                 PHA                 ; save talk or listen bit
f0d8 ad 40 e8           LDA VIA_Port_B
f0db 09 02              ORA #%00000010      ; $02
f0dd 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f0e0 a9 3c              LDA #%00111100      ; $3c
f0e2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f0e5 24 a0              BIT C3PO            ; data in output buffer ?
f0e7 f0 11              BEQ TALI_20         ; branch if not
f0e9 a9 34              LDA #%00110100      ; $34
f0eb 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) low
f0ee 20 09 f1           JSR Send_IEEE_Byte  ; flush buffer (BSOUR)
f0f1 a9 00              LDA #0
f0f3 85 a0              STA C3PO            ; clear buffer flag
f0f5 a9 3c              LDA #%00111100      ; $3c
f0f7 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) high
f0fa 68       TALI_20   PLA                 ; restore talk or listen bit
f0fb 05 d4              ORA FA              ; combine signal with adress
f0fd 85 a5              STA BSOUR           ; store in output buffer
f0ff ad 40 e8 TALI_30   LDA VIA_Port_B      ; load signals
f102 10 fb              BPL TALI_30         ; wait until DAV high
f104 29 fb              AND #%11111011      ; $fb
f106 8d 40 e8           STA VIA_Port_B      ; set ATN (bit 2) low

              ; **************
f109            Send_IEEE_Byte
              ; **************

f109 a9 3c              LDA #%00111100      ; $3c
f10b 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f10e ad 40 e8           LDA VIA_Port_B      ; loadsignals
f111 29 41              AND #%01000001      ; mask NRFD & NDAC
f113 c9 41              CMP #%01000001      ; both high ?
f115 f0 55              BEQ Device_Not_Present
f117 a5 a5              LDA BSOUR           ; load byte to send
f119 49 ff              EOR #$ff            ; invert it
f11b 8d 22 e8           STA PIA2_Port_B     ; DATA OUT
f11e 2c 40 e8 SIB_10    BIT VIA_Port_B      ; test signals
f121 50 fb              BVC SIB_10          ; wait until NRFD high
f123 a9 34              LDA #%00110100      ; $34
f125 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) low
f128 a9 ff    SIB_20    LDA #$ff            ; set timer to MAX
f12a 8d 45 e8           STA VIA_Timer_1_Hi
f12d ad 40 e8 SIB_30    LDA VIA_Port_B      ; load signals
f130 2c 4d e8           BIT VIA_IFR         ; check timer, expect NDAC high in ca. 65 ms
f133 70 1c              BVS Time_Out_Writing
f135 4a                 LSR A               ; NDAC -> carry
f136 90 f5              BCC SIB_30          ; repeat until NDAC high
f138 a9 3c    tby6      LDA #%00111100      ; $3c
f13a 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f13d a9 ff              LDA #$ff            ; release data lines
f13f 8d 22 e8           STA PIA2_Port_B
f142 60                 RTS ;Size   58 [Send_IEEE_Byte]

              ; ******
f143            SECOND
              ; ******

f143 85 a5              STA BSOUR           ; output buffer
f145 20 09 f1           JSR Send_IEEE_Byte  ; send it

              ; *******
f148            Set_ATN
              ; *******

f148 ad 40 e8           LDA VIA_Port_B
f14b 09 04              ORA #%00000100      ; $04
f14d 8d 40 e8           STA VIA_Port_B      ; set ATN high
f150 60                 RTS ;Size    9 [Set_ATN]

              ; ****************
f151            Time_Out_Writing
              ; ****************

f151 ad fc 03           LDA Ignore_Timeout  ; load timeout flag (addr. 1020, bit 7)
f154 10 0f              BPL Timo_W          ; timeout if flag cleared (default value)
f156 20 43 f3           JSR Kernal_STOP
f159 d0 cd              BNE SIB_20          ; restart timer and try again to transmit

              ; ****************
f15b            Time_Out_Reading
              ; ****************

f15b ad fc 03           LDA Ignore_Timeout
f15e 10 10              BPL Timo_R
f160 20 43 f3           JSR Kernal_STOP
f163 d0 68              BNE Acptr_10
f165 a9 01    Timo_W    LDA #1              ; flag time out on writing
f167 20 c4 fb Timo_S    JSR Set_STATUS
f16a d0 cc              BNE tby6            ; branch always

              ; ******************
f16c            Device_Not_Present
              ; ******************

f16c a9 80              LDA #$80
f16e 30 f7              BMI Timo_S
f170 a9 02    Timo_R    LDA #2              ; flag time out reading
f172 20 c4 fb           JSR Set_STATUS

              ; *****************
f175            Set_NRFD_NDAC_low
              ; *****************

f175 ad 40 e8           LDA VIA_Port_B
f178 29 fd              AND #%11111101      ; $fd
f17a 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f17d a9 34              LDA #%00110100      ; $34
f17f 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f182 a9 0d              LDA #CR             ; load CR
f184 60                 RTS ;Size   16 [Set_NRFD_NDAC_low]

              ; **********************
f185            Display_Kernal_Message
              ; **********************

f185 b9 00 f0           LDA KERNAL_MESSAGES,Y  ; Y = offset for string
f188 08                 PHP                 ; save status (possible end marker)
f189 29 7f              AND #$7f            ; clear bit 7
f18b 20 02 e2           JSR EDIT_CHROUT     ; dispay it
f18e c8                 INY                 ; next character
f18f 28                 PLP                 ; restore status
f190 10 f3              BPL Display_Kernal_Message
f192 60                 RTS                 ; bit 7 = end marker ;Size   14 [Display_Kernal_Message]

              ; ****
f193            TKSA
              ; ****

f193 85 a5              STA BSOUR           ; SA (A) to Buffer
f195 20 09 f1           JSR Send_IEEE_Byte  ; send it
f198 20 75 f1           JSR Set_NRFD_NDAC_low
f19b 4c 48 f1           JMP Set_ATN

              ; *****
f19e            CIOUT
              ; *****

f19e 24 a0              BIT C3PO            ; C3PO = 0 flags empty buffer
f1a0 30 04              BMI Ciout_10        ; branch if not empty
f1a2 c6 a0              DEC C3PO            ; set flag for not empty
f1a4 d0 05              BNE Ciout_20        ; branch always
f1a6 48       Ciout_10  PHA                 ; save current byte
f1a7 20 09 f1           JSR Send_IEEE_Byte  ; send byte from buffer
f1aa 68                 PLA                 ; restore current byte
f1ab 85 a5    Ciout_20  STA BSOUR           ; put it into buffer
f1ad 60                 RTS ;Size   16 [CIOUT]

              ; *****
f1ae            UNTLK
              ; *****

f1ae ad 40 e8           LDA VIA_Port_B
f1b1 29 fb              AND #%11111011      ; $fb
f1b3 8d 40 e8           STA VIA_Port_B      ; set ATN low
f1b6 a9 5f              LDA #%01011111      ; $5f
f1b8 2c                 .BYTE $2c           ; skip next statement

              ; *****
f1b9            UNLSN
              ; *****

f1b9 a9 3f              LDA #%00111111      ; $3f
f1bb 20 d7 f0           JSR TALI_10
f1be d0 88              BNE Set_ATN         ; branch always

              ; *****
f1c0            ACPTR
              ; *****

f1c0 a9 34              LDA #%00110100      ; $34
f1c2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f1c5 ad 40 e8           LDA VIA_Port_B
f1c8 09 02              ORA #%00000010      ; $02
f1ca 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f1cd a9 ff    Acptr_10  LDA #$ff
f1cf 8d 45 e8           STA VIA_Timer_1_Hi  ; set timer
f1d2 2c 4d e8 Acptr_20  BIT VIA_IFR
f1d5 70 84              BVS Time_Out_Reading; timeout after 65 ms
f1d7 2c 40 e8           BIT VIA_Port_B      ; test DAV (bit 7)
f1da 30 f6              BMI Acptr_20        ; loop until DAV (bit 7) low
f1dc ad 40 e8           LDA VIA_Port_B
f1df 29 fd              AND #%11111101      ; $fd
f1e1 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f1e4 2c 10 e8           BIT PIA1_Port_A     ; test for EOI
f1e7 70 05              BVS Acptr_30        ; branch if not
f1e9 a9 40              LDA #%01000000      ; set EOI flag
f1eb 20 c4 fb           JSR Set_STATUS
f1ee ad 20 e8 Acptr_30  LDA PIA2_Port_A     ; read data byte
f1f1 49 ff              EOR #$ff            ; invert it
f1f3 48                 PHA                 ; save read byte
f1f4 a9 3c              LDA #%00111100      ; $3c
f1f6 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f1f9 2c 40 e8 Acptr_40  BIT VIA_Port_B      ; test DAV
f1fc 10 fb              BPL Acptr_40        ; loop until DAV (bit 7) high
f1fe a9 34              LDA #%00110100      ; $34
f200 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f203 68                 PLA                 ; restore read byte
f204 60                 RTS ;Size   69 [ACPTR]

              ; ************
f205            Kernal_GETIN
              ; ************

f205 a9 00              LDA #0
f207 85 96              STA STATUS          ; clear status
f209 a5 af              LDA DFLTN           ; current input device
f20b d0 17              BNE KeIn_10         ; branch if not keyboard
f20d a5 9e    GETIN_10  LDA CharsInBuffer   ; test keyboard queue
f20f f0 26              BEQ KeIn_30         ; return if empty
f211 78                 SEI                 ; disable interrupt
f212 4c a7 e0           JMP EDIT_GETIN      ; get character from keyboard queue

              ; ************
f215            Kernal_CHRIN
              ; ************

f215 a5 af              LDA DFLTN           ; current input device
f217 d0 0b              BNE KeIn_10         ; branch if not keyboard
f219 a5 c6              LDA CursorCol       ; get current cursor column
f21b 85 a4              STA InputCol        ; start input here
f21d a5 d8              LDA CursorRow       ; get current cursor row
f21f 85 a3              STA InputRow        ; start input here
f221 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f224 c9 04    KeIn_10   CMP #4              ; test device number
f226 b0 09              BCS KeIn_20         ; branch if IEEE-488 device
f228 85 ac              STA CRSW            ; device is screen (3)
f22a a5 d5              LDA RigMargin       ; limit input column
f22c 85 a1              STA LastInputCol    ; at right margin
f22e 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f231 a5 96    KeIn_20   LDA STATUS          ; It's IEEE-488 input
f233 f0 03              BEQ KeIn_40         ; continue at ACPTR if status is OK
f235 a9 0d              LDA #CR             ; status flags some error, return CR
f237 60       KeIn_30   RTS                 ; return ;Size   35 [Kernal_CHRIN]
f238 4c c0 f1 KeIn_40   JMP ACPTR           ; continue at ACPTR

f23b 00 00 00           .FILL $f266 - * (0) ; 43 bytes

              ; *************
f266            Kernal_CHROUT
              ; *************

f266 48                 PHA                 ; save character
f267 a5 b0              LDA DFLTO           ; load current output device
f269 c9 04              CMP #4              ; 4 = start of IEEE-488 devices
f26b 68                 PLA                 ; restore character
f26c b0 03              BCS KeCH_10         ; branch if IEEE-488 device
f26e 4c 02 e2           JMP EDIT_CHROUT     ; continue at display on screen
f271 4c 9e f1 KeCH_10   JMP CIOUT           ; continue on IEEE-488 output

f274 00 00 00           .FILL $f2a2 - * (0) ; 46 bytes

              ; ************
f2a2            Kernal_CLALL
              ; ************

f2a2 a9 00              LDA #0
f2a4 85 ae              STA LDTND           ; set # of open files to zero

              ; *************
f2a6            Kernal_CLRCHN
              ; *************

f2a6 a5 b0              LDA DFLTO           ; default output device
f2a8 c9 04              CMP #4              ; screen or IEEE-488 ?
f2aa 90 03              BCC KeCL_10         ; branch if screen
f2ac 20 b9 f1           JSR UNLSN           ; send unlisten
f2af a5 af    KeCL_10   LDA DFLTN           ; default input device
f2b1 c9 04              CMP #4              ; IEEE-488 or not ?
f2b3 90 03              BCC Set_Default_IO
f2b5 20 ae f1           JSR UNTLK           ; send untalk

              ; **************
f2b8            Set_Default_IO
              ; **************

f2b8 a9 03              LDA #3
f2ba 85 b0              STA DFLTO
f2bc a9 00              LDA #0
f2be 85 af              STA DFLTN
f2c0 60                 RTS ;Size    9 [Set_Default_IO]

              ; *********
f2c1            LOOKUP_LA
              ; *********

f2c1 a6 ae              LDX LDTND           ; # of open files
f2c3 ca       LOOK_10   DEX
f2c4 30 05              BMI LOOK_Ret        ; -> not found
f2c6 dd 51 02           CMP LAT,X
f2c9 d0 f8              BNE LOOK_10
f2cb 60       LOOK_Ret  RTS ;Size   11 [LOOKUP_LA]

f2cc 00                 .FILL $f2cd-* (0) ; 1 bytes

              ; **********************
f2cd            Set_LFS_From_X ; $f2cd
              ; **********************

              ; Input:  X = index to file
              ; Output: A = FA

f2cd bd 51 02           LDA LAT,X
f2d0 85 d2              STA LA
f2d2 bd 65 02           LDA SAT,X
f2d5 85 d3              STA SA
f2d7 bd 5b 02           LDA FAT,X
f2da 85 d4              STA FA
f2dc 60                 RTS ;Size   16 [Set_LFS_From_X]

              ; ************
f2dd            Kernal_CLOSE
              ; ************

f2dd 20 0d f5           JSR Get_Open_Close_Parameter
f2e0 a5 d2              LDA LA

              ; *************
f2e2            Close_LA_in_A
              ; *************

f2e2 20 c1 f2           JSR LOOKUP_LA
f2e5 d0 24              BNE ClFi_20

              ; ************
f2e7            Close_File_A
              ; ************

f2e7 20 cd f2           JSR Set_LFS_From_X
f2ea c9 04              CMP #4
f2ec 90 03              BCC ClFi_10         ; keyboard or screen
f2ee 20 2a f7           JSR Close_Disk_File
f2f1 c6 ae    ClFi_10   DEC LDTND
f2f3 e4 ae              CPX LDTND
f2f5 f0 14              BEQ ClFi_20
f2f7 a4 ae              LDY LDTND
f2f9 b9 51 02           LDA LAT,Y
f2fc 9d 51 02           STA LAT,X
f2ff b9 5b 02           LDA FAT,Y
f302 9d 5b 02           STA FAT,X
f305 b9 65 02           LDA SAT,Y
f308 9d 65 02           STA SAT,X
f30b 60       ClFi_20   RTS ;Size   37 [Close_File_A]

f30c 00 00 00           .FILL $f335 - * (0) ; 41 bytes

              ; **************
f335            Check_STOP_Key
              ; **************

f335 a5 9b              LDA Stop_Flag
f337 c9 ef              CMP #$ef
f339 d0 07              BNE ChST_Ret
f33b 08                 PHP
f33c 20 a6 f2           JSR Kernal_CLRCHN
f33f 85 9e              STA CharsInBuffer
f341 28                 PLP
f342 60       ChST_Ret  RTS ;Size   14 [Check_STOP_Key]

              ; ***********
f343            Kernal_STOP
              ; ***********

f343 20 35 f3           JSR Check_STOP_Key
f346 4c c6 b7           JMP Basic_STOP

              ; ************************
f349            Kernal_Message_If_Direct
              ; ************************

f349 20 51 f3           JSR In_Direct_Mode
f34c d0 f4              BNE ChST_Ret
f34e 4c 85 f1           JMP Display_Kernal_Message

              ; **************
f351            In_Direct_Mode
              ; **************

f351 a5 78              LDA TXTPTR+1
f353 c9 02              CMP #2
f355 60                 RTS ;Size    5 [In_Direct_Mode]

              ; *********
f356            Load_File
              ; *********

f356 a5 d4              LDA FA              ; primary device address
f358 c9 04              CMP #4              ; start of IEEE-488 devices
f35a b0 03              BCS LoFi_15
f35c 4c 00 bf LoFi_10   JMP Syntax_Error    ; no loading from devices 0-3
f35f a4 d1    LoFi_15   LDY FNLEN
f361 f0 f9              BEQ LoFi_10         ; error for zero length filenames
f363 a6 d3              LDX SA              ; 1: use load address from file
f365 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
f368 e0 00              CPX #0              ; ignore load address ?
f36a f0 04              BEQ LoFi_20
f36c 84 c9              STY EAL
f36e 85 ca              STA EAL+1
f370 a5 96    LoFi_20   LDA STATUS          ; check time out bit
f372 f0 03              BEQ LoFi_25         ; no time out -> continue
f374 4c ad f5           JMP Display_File_Not_Found
f377 20 51 f3 LoFi_25   JSR In_Direct_Mode
f37a d0 12              BNE LoFi_30
f37c 20 6d f4           JSR Display_Load_Or_Verify
f37f a5 ca              LDA EAL+1
f381 20 5b d7           JSR Print_Hex_Byte
f384 a5 c9              LDA EAL
f386 20 5b d7           JSR Print_Hex_Byte
f389 a9 2d              LDA #'-'
f38b 20 02 e2           JSR EDIT_CHROUT
f38e a0 00    LoFi_30   LDY #0              ; remains zero for loop
f390 84 96    LoFi_35   STY STATUS          ; clear status bits
f392 20 43 f3 LoFi_40   JSR Kernal_STOP     ; STOP key pressed?
f395 20 c0 f1           JSR ACPTR           ; read next byte
f398 24 9d              BIT VERCK           ; load (0) or verify ($80)
f39a 10 0b              BPL LoFi_45         ; branch if loading
f39c d1 c9              CMP (EAL),Y         ; verify
f39e f0 0f              BEQ LoFi_55         ; branch if OK
f3a0 a9 10              LDA #%00010000      ; flag verify error $10
f3a2 20 c4 fb           JSR Set_STATUS      ; and stop verifying
f3a5 d0 1a              BNE LoFi_70         ; branch always
f3a7 91 c9    LoFi_45   STA (EAL),Y         ; store byte
f3a9 b1 c9    LoFi_50   LDA (EAL),Y         ; this comparison is false for an
f3ab d1 c9              CMP (EAL),Y         ; unfinished write cycle to EEPROM
f3ad d0 fa              BNE LoFi_50         ; repeat until EEPROM bit toggle ceased
f3af e6 c9    LoFi_55   INC EAL             ; increment write address
f3b1 d0 0a              BNE LoFi_60
f3b3 e6 ca              INC EAL+1
f3b5 20 51 f3           JSR In_Direct_Mode
f3b8 d0 03              BNE LoFi_60
f3ba 20 40 f4           JSR Print_EAL
f3bd 24 96    LoFi_60   BIT STATUS          ; Get EOF marker in bit 6
f3bf 50 d1              BVC LoFi_40         ; repeat until EOF
f3c1 20 ae f1 LoFi_70   JSR UNTLK
f3c4 20 2a f7           JSR Close_Disk_File
f3c7 20 51 f3           JSR In_Direct_Mode
f3ca f0 01              BEQ LoFi_80
f3cc 60                 RTS ;Size  119 [Load_File]
f3cd 4c 40 f4 LoFi_80   JMP Print_EAL

              ; **************
f3d0            Open_Load_File
              ; **************

f3d0 a9 60              LDA #$60            ; secondary address for loading
f3d2 85 d3              STA SA
f3d4 20 af f4           JSR Send_Filename
f3d7 20 d2 f0           JSR TALK            ; send primary address
f3da a5 d3              LDA SA
f3dc 20 93 f1           JSR TKSA            ; send secondary address
f3df 20 c0 f1           JSR ACPTR           ; load address low
f3e2 a8                 TAY                 ; Y = load address low
f3e3 4c c0 f1           JMP ACPTR           ; A = load address high

              ; *****
f3e6            Merge
              ; *****

f3e6 a9 40              LDA #$40            ; load and merge file
f3e8 d0 19              BNE KeLO_10         ; always

f3ea 00 00 00           .FILL $f401 - * (0) ; 23 bytes

              ; ***********
f401            Kernal_LOAD
              ; ***********

f401 a9 00              LDA #0
f403 85 9d    KeLO_10   STA VERCK

              ; ***********
f405            Load_Verify
              ; ***********

f405 20 7d f4           JSR Get_File_Parameter
f408 24 9d              BIT VERCK
f40a 50 11              BVC Load_Verify_Params_Set
f40c 38                 SEC
f40d a5 2a              LDA VARTAB          ; set merge address
f40f e9 02              SBC #2
f411 85 c9              STA EAL
f413 a5 2b              LDA VARTAB+1
f415 e9 00              SBC #0
f417 85 ca              STA EAL+1
f419 a9 00              LDA #0
f41b 85 d3              STA SA

              ; **********************
f41d            Load_Verify_Params_Set
              ; **********************

f41d 20 56 f3           JSR Load_File       ; load file into RAM
f420 24 9d              BIT VERCK           ; (0) LOAD, ($80) VERIFY
f422 30 1b              BMI LVPS_Ret        ; done for verify
f424 a0 ae              LDY #<MSG_READY     ; $ae
f426 20 49 f3           JSR Kernal_Message_If_Direct
f429 20 51 f3           JSR In_Direct_Mode
f42c d0 0b              BNE LVPS_20
f42e a5 ca              LDA EAL+1
f430 85 2b              STA VARTAB+1        ; update VARPTR
f432 a5 c9              LDA EAL
f434 85 2a              STA VARTAB
f436 4c ad b4           JMP Reset_And_Rechain
f439 20 22 b6 LVPS_20   JSR Reset_BASIC_Exec_Pointer
f43c 4c 0b b6           JMP RVP_10
f43f 60       LVPS_Ret  RTS ;Size   35 [Load_Verify_Params_Set]

              ; *********
f440            Print_EAL
              ; *********

f440 a5 ca              LDA EAL+1
f442 20 5b d7           JSR Print_Hex_Byte
f445 a5 c9              LDA EAL
f447 20 5b d7           JSR Print_Hex_Byte
f44a a2 04              LDX #4
f44c a9 9d              LDA #$9d            ; cursor left
f44e 20 02 e2 PrEA_10   JSR EDIT_CHROUT
f451 ca                 DEX
f452 d0 fa              BNE PrEA_10
f454 60       PrEA_Ret  RTS ;Size   21 [Print_EAL]

f455 00 00 00           .FILL $f46d - * (0) ; 24 bytes

              ; **********************
f46d            Display_Load_Or_Verify
              ; **********************

f46d a0 5f              LDY #<MSG_LOAD      ; $5f
f46f 24 9d              BIT VERCK
f471 10 02              BPL DLOV_10
f473 a0 6d              LDY #<MSG_VERIFY    ; $6d
f475 20 49 f3 DLOV_10   JSR Kernal_Message_If_Direct
f478 a0 39              LDY #<[MSG_SEARCHING + 7];$39 add "ING"
f47a 4c 49 f3           JMP Kernal_Message_If_Direct

              ; ******************
f47d            Get_File_Parameter
              ; ******************

f47d a2 00              LDX #0
f47f 86 96              STX STATUS
f481 86 d1              STX FNLEN
f483 e8                 INX
f484 86 d3              STX SA              ; SA = 1
f486 a2 08              LDX #8
f488 86 d4              STX FA              ; FA = 8
f48a 20 4d f5           JSR ChrGot_Or_RTS
f48d 20 3c f5           JSR Set_Filename_From_String
f490 20 4d f5           JSR ChrGot_Or_RTS
f493 20 a9 f4           JSR Get_Comma_And_Byte
f496 86 d4              STX FA
f498 20 4d f5           JSR ChrGot_Or_RTS
f49b 20 a9 f4           JSR Get_Comma_And_Byte
f49e 86 d3              STX SA
f4a0 a6 28              LDX TXTTAB          ; default: start of BASIC
f4a2 a5 29              LDA TXTTAB+1
f4a4 86 c9              STX EAL
f4a6 85 ca              STA EAL+1
f4a8 60       GFP_Ret   RTS ;Size   44 [Get_File_Parameter]

              ; ******************
f4a9            Get_Comma_And_Byte
              ; ******************

f4a9 20 55 f5           JSR Get_Comma_And_Chr
f4ac 4c d4 c8           JMP Get_Byte_Value

              ; *************
f4af            Send_Filename
              ; *************

f4af a4 d1              LDY FNLEN
f4b1 f0 f5              BEQ GFP_Ret
f4b3 20 d5 f0           JSR LISTEN
f4b6 a5 d3              LDA SA
f4b8 09 f0              ORA #$f0

              ; ****************
f4ba            Send_DOS_Command
              ; ****************

f4ba 20 43 f1           JSR SECOND
f4bd a5 96              LDA STATUS
f4bf 10 05              BPL SeDC_10
f4c1 a0 74              LDY #<MSG_DEVICE_NOT; $74
f4c3 4c af f5           JMP Handle_IO_Error
f4c6 a0 00    SeDC_10   LDY #0
f4c8 b1 da    SeDC_20   LDA (FNADR),Y
f4ca 20 9e f1           JSR CIOUT
f4cd c8                 INY
f4ce c4 d1              CPY FNLEN
f4d0 d0 f6              BNE SeDC_20
f4d2 4c b9 f1           JMP UNLSN

f4d5 00 00 00           .FILL $f4f6 - * (0) ; 33 bytes

              ; *************
f4f6            Kernal_VERIFY
              ; *************

f4f6 a9 80              LDA #$80
f4f8 85 9d              STA VERCK
f4fa 20 05 f4           JSR Load_Verify
f4fd a5 96              LDA STATUS
f4ff 29 10              AND #16
f501 f0 05              BEQ VERI_OK
f503 a0 6e              LDY #<[MSG_VERIFY+1]; $6e
f505 4c af f5           JMP Handle_IO_Error
f508 a0 aa    VERI_OK   LDY #<MSG_OK        ; $aa
f50a 4c 85 f1           JMP Display_Kernal_Message

              ; ************************
f50d            Get_Open_Close_Parameter
              ; ************************

f50d a2 00              LDX #0              ; clear
f50f 86 d3              STX SA              ; secondary address
f511 86 96              STX STATUS          ; status
f513 86 d1              STX FNLEN           ; length of filename
f515 20 4c fd           JSR Set_FA_to_8     ; default device 8
f518 20 58 f5           JSR Assert_Not_At_End
f51b 20 d4 c8           JSR Get_Byte_Value
f51e 86 d2              STX LA              ; store logical address
f520 20 4d f5           JSR ChrGot_Or_RTS
f523 20 a9 f4           JSR Get_Comma_And_Byte
f526 86 d4              STX FA              ; store primary address
f528 20 4d f5           JSR ChrGot_Or_RTS
f52b 20 a9 f4           JSR Get_Comma_And_Byte
f52e 86 d3              STX SA              ; store secondary address
f530 20 4d f5           JSR ChrGot_Or_RTS
f533 20 55 f5           JSR Get_Comma_And_Chr
f536 4c 3c f5           JMP Set_Filename_From_String

f539 00 00 00           .FILL $f53c - * (0) ; 3 bytes

              ; ************************
f53c            Set_Filename_From_String
              ; ************************

f53c 20 98 bd           JSR Eval_Expression
f53f 20 b5 c7           JSR Eval_And_Free_String
f542 85 d1              STA FNLEN
f544 a5 1f              LDA INDEXA
f546 85 da              STA FNADR
f548 a5 20              LDA INDEXA+1
f54a 85 db              STA FNADR+1
f54c 60                 RTS ;Size   17 [Set_Filename_From_String]

              ; *************
f54d            ChrGot_Or_RTS
              ; *************

f54d 20 76 00           JSR CHRGOT
f550 d0 02              BNE Get_Ret
f552 68                 PLA
f553 68                 PLA
f554 60       Get_Ret   RTS ;Size    8 [ChrGot_Or_RTS]

              ; *****************
f555            Get_Comma_And_Chr
              ; *****************

f555 20 f5 be           JSR Need_Comma

              ; *****************
f558            Assert_Not_At_End
              ; *****************

f558 20 76 00           JSR CHRGOT
f55b d0 f7              BNE Get_Ret
f55d 4c 00 bf Err_f55d  JMP Syntax_Error

              ; ***********
f560            Kernal_OPEN
              ; ***********

f560 20 0d f5           JSR Get_Open_Close_Parameter
f563 a5 d2    Mf563     LDA LA

              ; *********
f565            Open_File
              ; *********

f565 f0 f6              BEQ Err_f55d
f567 a0 0e              LDY #<MSG_FILE_OPEN
f569 20 c1 f2           JSR LOOKUP_LA
f56c f0 41              BEQ Handle_IO_Error
f56e a6 ae              LDX LDTND
f570 a0 00              LDY #0              ; also MSG # for TOO MANY FILES
f572 84 96              STY STATUS
f574 e0 0a              CPX #10
f576 f0 37              BEQ Handle_IO_Error
f578 e6 ae              INC LDTND
f57a a5 d2              LDA LA
f57c 9d 51 02           STA LAT,X
f57f a5 d3              LDA SA
f581 09 60              ORA #$60
f583 85 d3              STA SA
f585 9d 65 02           STA SAT,X
f588 a5 d4              LDA FA
f58a 9d 5b 02           STA FAT,X
f58d f0 c5              BEQ Get_Ret         ; open keyboard
f58f c9 03              CMP #3
f591 f0 c1              BEQ Get_Ret         ; open screen
f593 90 c8              BCC Err_f55d        ; no tape support
f595 4c af f4           JMP Send_Filename

f598 00 00 00           .FILL $f5ad - * (0) ; 21 bytes


              ; **********************
f5ad            Display_File_Not_Found
              ; **********************

f5ad a0 24              LDY #<MSG_FILE_NOT_F; $24

              ; ***************
f5af            Handle_IO_Error
              ; ***************

f5af 20 a2 f2           JSR Kernal_CLALL
f5b2 a9 0d              LDA #CR
f5b4 20 66 f2           JSR Kernal_CHROUT
f5b7 a9 3f              LDA #$3f            ; '?'
f5b9 20 66 f2           JSR Kernal_CHROUT
f5bc 20 85 f1           JSR Display_Kernal_Message
f5bf 4c ea b3           JMP Berr_30

              ; ***********
f5c2            Disassemble
              ; ***********

f5c2 20 1f d6           JSR Mon_Get_Addr
f5c5 20 35 f3 Disa_10   JSR Check_STOP_Key  ; STOP key pressed?
f5c8 f0 19              BEQ Disa_Main
f5ca 20 e7 d5           JSR Mon_Cmp_Addr
f5cd 90 14              BCC Disa_Main       ; STAL > MEMUSS ?
f5cf a9 2e    Disa_15   LDA #'.'
f5d1 20 7b d5           JSR Mon_Prompt
f5d4 20 22 d5           JSR Mon_Print_Blank
f5d7 20 14 f6           JSR Dis_Inst        ; Disassemble
f5da 20 e6 f5           JSR Print_Dis_Line
f5dd a5 b3              LDA PC_Adjust
f5df d0 e4              BNE Disa_10
f5e1 e6 b3              INC PC_Adjust
f5e3 4c b1 d4 Disa_Main JMP Mon_Main

              ; **************
f5e6            Print_Dis_Line
              ; **************

f5e6 48                 PHA                 ; save mne index
f5e7 a0 00              LDY #0
f5e9 b9 c1 00 Disa_20   LDA Mon_Op,Y        ; next byte
f5ec 20 5b d7           JSR Print_Hex_Byte
f5ef 4c f8 f5           JMP Disa_50
f5f2 20 22 d5 Disa_40   JSR Mon_Print_Blank
f5f5 20 22 d5           JSR Mon_Print_Blank
f5f8 20 22 d5 Disa_50   JSR Mon_Print_Blank
f5fb c4 be              CPY Dis_Length
f5fd c8                 INY
f5fe 90 e9              BCC Disa_20         ; next byte
f600 c0 03              CPY #3
f602 90 ee              BCC Disa_40         ; blanks
f604 68                 PLA                 ; restore mne index
f605 20 39 f7           JSR Store_Mnemonic
f608 20 8d f9           JSR Store_Address
f60b 20 f9 f9           JSR Print_Dis_Buf
f60e 38                 SEC
f60f a5 be              LDA Dis_Length      ; carry is set
f611 4c 16 fb           JMP AdST_00



              ; ********
f614            Dis_Inst
              ; ********

f614 20 54 d7           JSR Mon_Print_STAL
f617 20 22 d5           JSR Mon_Print_Blank
f61a a0 02              LDY #2              ; fetch 3 bytes
f61c 20 7a 02 DiIn_10   JSR Bank_Fetch
f61f 99 c1 00           STA Mon_Op,Y
f622 88                 DEY
f623 10 f7              BPL DiIn_10         ; opcode in A

              ; **************
f625            Analyze_Opcode
              ; **************

              ; instruction pattern: aaa bbb cc
              ; aaa = instruction
              ; bbb = addressing mode
              ; cc  = group

              ; 1. analyze group cc
              ; ------------------------------------------
              ; cc = 00  one byte instructions, branches
              ; cc = 01  ORA,AND,EOR,ADC,STA,LDA,CMP,SBC
              ; cc = 10  ASL,ROL,LSR,ROR,STX,LDX,DEC,INC
              ; cc = 11  illegal opcodes

f625 a8                 TAY                 ; save opcode
f626 4a                 LSR A               ; bit 0 -> carry
f627 90 0b              BCC AnOp_10
f629 4a                 LSR A               ; bit 1 -> carry
f62a b0 17              BCS AnOp_30         ; 11 -> no valid opcode
f62c c9 22              CMP #$22            ; invalid opcode $89 ?
f62e f0 13              BEQ AnOp_30
f630 29 07              AND #7              ; mask addressing mode bbb
f632 09 80              ORA #$80            ; set bit 7
f634 4a       AnOp_10   LSR A               ; A,X = aaa bbb (cc = x0)
f635 aa                 TAX                 ; A,X = aaa bb  (cc = 10)
f636 bd 6b f6           LDA admode_index,X  ; get addressing mode index
f639 b0 04              BCS AnOp_20         ; branch on cc = 10
f63b 4a                 LSR A               ; move nibble for cc = 00
f63c 4a                 LSR A
f63d 4a                 LSR A
f63e 4a                 LSR A
f63f 29 0f    AnOp_20   AND #15             ; mask addressing mode index
f641 d0 04              BNE AnOp_40         ; branch for valid mode
f643 a0 80    AnOp_30   LDY #$80            ; set invalid opcode
f645 a9 00              LDA #0
f647 aa       AnOp_40   TAX                 ; X = addressing mode index
f648 bd 73 f9           LDA admode_format,X ; A = addressing mode format
f64b 85 bd              STA Mon_Format      ; format
f64d 29 03              AND #3
f64f 85 be              STA Dis_Length      ; length
f651 98                 TYA                 ; restore opcode
f652 29 8f              AND #$8f            ; mask
f654 aa                 TAX                 ; X =
f655 98                 TYA                 ; restore opcode
f656 a0 03              LDY #3              ; Y = 3
f658 e0 8a              CPX #$8a            ; TXS,TAX,TSX,DEX,NOP
f65a f0 0b              BEQ AnOp_70
f65c 4a       AnOp_50   LSR A
f65d 90 08              BCC AnOp_70
f65f 4a                 LSR A
f660 4a       AnOp_60   LSR A
f661 09 20              ORA #$20
f663 88                 DEY
f664 d0 fa              BNE AnOp_60
f666 c8                 INY
f667 88       AnOp_70   DEY
f668 d0 f2              BNE AnOp_50
f66a 60                 RTS ;Size   70 [Analyze_Opcode]

              ; ************
f66b            admode_index
              ; ************

f66b 40                 .BYTE $40           ; $4 BRK        $0 ---
f66c 02                 .BYTE $02           ; $0 ---        $2 ASL zz
f66d 45                 .BYTE $45           ; $4 PHP        $5 ASL A
f66e 03                 .BYTE $03           ; $0 ---        $3 ASL nnnn

f66f d0                 .BYTE $d0           ; $d BPL oo     $0 ---
f670 08                 .BYTE $08           ; $0 ---        $8 ASL zz,X
f671 40                 .BYTE $40           ; $4 CLC        $0 ---
f672 09                 .BYTE $09           ; $0 ---        $9 ASL nnnn,X

f673 30                 .BYTE $30           ; $3 JSR nnnn   $0 --
f674 22                 .BYTE $22           ; $2 BIT zz     $2 ROL zz
f675 45                 .BYTE $45           ; $4 PLP        $5 ROL A
f676 33                 .BYTE $33           ; $3 BIT nnnn   $3 ROL nnnn

f677 d0                 .BYTE $d0           ; $d BMI oo     $0 ---
f678 08                 .BYTE $08           ; $0 ---        $8 ROL zz,X
f679 40                 .BYTE $40           ; $4 SEC        $0 ---
f67a 09                 .BYTE $09           ; $0 ---        $9 ROL nnnn,X

f67b 40                 .BYTE $40           ; $4 RTI        $0 ---
f67c 02                 .BYTE $02           ; $0 ---        $2 LSR zz
f67d 45                 .BYTE $45           ; $4 PHA        $5 LSR A
f67e 33                 .BYTE $33           ; $3 JMP nnnn   $3 LSR nnnn

f67f d0                 .BYTE $d0           ; $d BVC oo     $0 ---
f680 08                 .BYTE $08           ; $0 ---        $8 LSR zz,X
f681 40                 .BYTE $40           ; $4 CLI        $0 ---
f682 09                 .BYTE $09           ; $0 ---        $9 LSR nnnn,X

f683 40                 .BYTE $40           ; $4 RTS        $0 ---
f684 02                 .BYTE $02           ; $0 ---        $2 ROR zz
f685 45                 .BYTE $45           ; $4 PLA        $5 ROR A
f686 b3                 .BYTE $b3           ; $b JMP (nnnn) $3 ROR nnnn

f687 d0                 .BYTE $d0           ; $d BVS oo     $0 ---
f688 08                 .BYTE $08           ; $0 ---        $8 ROR zz,X
f689 40                 .BYTE $40           ; $4 SEI        $0 ---
f68a 09                 .BYTE $09           ; $0 ---        $9 ROR nnnn,X

f68b 00                 .BYTE $00           ; $0 ---        $0 ---
f68c 22                 .BYTE $22           ; $2 STY zz     $2 STX zz
f68d 44                 .BYTE $44           ; $4 DEY        $4 TXA
f68e 33                 .BYTE $33           ; $3 STY nnnn   $3 STX nnnn

f68f d0                 .BYTE $d0           ; $d BCC oo     $0 ---
f690 8c                 .BYTE $8c           ; $8 STY zz,X   $c STX zz,Y
f691 44                 .BYTE $44           ; $4 TYA        $4 TXS
f692 00                 .BYTE $00           ; $0 ---        $0 ---

f693 11                 .BYTE $11           ; $1 LDY #      $1 LDX #
f694 22                 .BYTE $22           ; $2 LDY zz     $2 LDX zz
f695 44                 .BYTE $44           ; $4 TAY        $4 TAX
f696 33                 .BYTE $33           ; $3 LDY nnnn   $3 LDX nnnn

f697 d0                 .BYTE $d0           ; $d BCS oo     $0 ---
f698 8c                 .BYTE $8c           ; $8 LDY zz,X   $c LDX zz,Y
f699 44                 .BYTE $44           ; $4 CLV        $4 TSX
f69a 9a                 .BYTE $9a           ; $9 LDY nnnn,X $a LDX nnnn,Y

f69b 10                 .BYTE $10           ; $1 CPY #      $0 ---
f69c 22                 .BYTE $22           ; $2 CPY zz     $2 DEC zz
f69d 44                 .BYTE $44           ; $4 INY        $4 DEX
f69e 33                 .BYTE $33           ; $3 CPY nnnn   $3 DEC nnnn

f69f d0                 .BYTE $d0           ; $d BNE oo     $0 ---
f6a0 08                 .BYTE $08           ; $0 ---        $8 DEC zz,X
f6a1 40                 .BYTE $40           ; $4 CLD        $0 ---
f6a2 09                 .BYTE $09           ; $0 ---        $9 DEC nnnn,X

f6a3 10                 .BYTE $10           ; $1 CPX #      $0 ---
f6a4 22                 .BYTE $22           ; $2 CPX zz     $2 INC zz
f6a5 44                 .BYTE $44           ; $4 INX        $4 NOP
f6a6 33                 .BYTE $33           ; $3 CPX nnnn   $3 INC nnnn

f6a7 d0                 .BYTE $d0           ; $d BEQ oo     $0 ---
f6a8 08                 .BYTE $08           ; $0 ---        $8 INC zz,X
f6a9 40                 .BYTE $40           ; $4 SED        $0 ---
f6aa 09                 .BYTE $09           ; $0 ---        $9 INC nnnn,X

f6ab 62                 .BYTE $62           ; $6 (zz,X)     $2 zz
f6ac 13                 .BYTE $13           ; $1 #          $3 nnnn
f6ad 78                 .BYTE $78           ; $7 (zz),Y     $8 zz,X
f6ae a9                 .BYTE $a9           ; $a nnnn,Y     $9 nnnn,X

f6af 00 00 00            .FILL $f6c3 - * (0) ; 20 bytes


              ; **********
f6c3            Kernal_SYS
              ; **********

f6c3 20 84 bd           JSR Eval_Numeric
f6c6 20 2d c9           JSR FAC1_To_LINNUM
f6c9 6c 11 00           JMP (LINNUM)

              ; **************
f6cc            Set_Save_Range
              ; **************

f6cc a5 2a              LDA VARTAB
f6ce 85 c9              STA EAL
f6d0 a5 2b              LDA VARTAB+1
f6d2 85 ca              STA EAL+1
f6d4 a5 29              LDA TXTTAB+1
f6d6 85 fc              STA STAL+1
f6d8 a5 28              LDA TXTTAB
f6da 85 fb              STA STAL
f6dc 60                 RTS ;Size   17 [Set_Save_Range]

              ; ***********
f6dd            Kernal_SAVE
              ; ***********

f6dd 20 7d f4           JSR Get_File_Parameter
f6e0 20 cc f6 Mf6e0     JSR Set_Save_Range

              ; *********
f6e3            Save_File
              ; *********

f6e3 a5 d4              LDA FA              ; primary address
f6e5 c9 04              CMP #4              ; unit number >= 4
f6e7 b0 03              BCS SaFi_20         ; branch if OK
f6e9 4c 00 bf SaFi_10   JMP Syntax_Error    ; wrong unit or no filename
f6ec a9 61    SaFi_20   LDA #$61            ; secondary address for saving
f6ee 85 d3              STA SA
f6f0 a4 d1              LDY FNLEN           ; length of filename
f6f2 f0 f5              BEQ SaFi_10         ; error if zero
f6f4 20 af f4           JSR Send_Filename
f6f7 20 d5 f0           JSR LISTEN          ; Send Listen
f6fa a5 d3              LDA SA
f6fc 20 43 f1           JSR SECOND          ; Send Listen Secondary
f6ff a4 fb              LDY STAL            ; save start low
f701 a6 fc              LDX STAL+1          ; save start high
f703 98                 TYA
f704 20 9e f1           JSR CIOUT           ; send start low
f707 8a                 TXA
f708 20 9e f1           JSR CIOUT           ; send start high
f70b a9 00              LDA #0
f70d 85 fb              STA STAL            ; clear pointer low
f70f c4 c9    SaFi_30   CPY EAL             ; compare to end address low
f711 d0 04              BNE SaFi_40         ; not yet
f713 e4 ca              CPX EAL+1           ; compare to end address high
f715 f0 10              BEQ SaFi_50         ; branch if at end
f717 b1 fb    SaFi_40   LDA (STAL),Y        ; load next byte
f719 20 9e f1           JSR CIOUT           ; send it
f71c 20 43 f3           JSR Kernal_STOP     ; check STOP key
f71f c8                 INY                 ; increment Y (low address)
f720 d0 ed              BNE SaFi_30         ; continue loop if not zero
f722 e8                 INX                 ; increment X (high address)
f723 86 fc              STX STAL+1          ; update piointer
f725 d0 e8              BNE SaFi_30         ; branch always
f727 20 b9 f1 SaFi_50   JSR UNLSN           ; Unlisten and fall through

              ; ***************
f72a            Close_Disk_File
              ; ***************

f72a 20 d5 f0           JSR LISTEN          ; send listen
f72d a5 d3              LDA SA
f72f 29 ef              AND #%11101111      ; $ef
f731 09 e0              ORA #%11100000      ; $e0 + unit
f733 20 43 f1           JSR SECOND          ; send secondary listen
f736 4c b9 f1           JMP UNLSN           ; send unlisten

              ; **************
f739            Store_Mnemonic
              ; **************

f739 a2 00              LDX #0
f73b a8                 TAY
f73c b9 f3 f8           LDA Mnemonic_Left,Y
f73f 85 bf              STA Mon_A
f741 b9 33 f9           LDA Mnemonic_Right,Y
f744 85 c0              STA Mon_B
f746 a9 00    PrMn_10   LDA #0
f748 a0 05              LDY #5
f74a 06 c0    PrMn_20   ASL Mon_B
f74c 26 bf              ROL Mon_A
f74e 2a                 ROL A
f74f 88                 DEY
f750 d0 f8              BNE PrMn_20
f752 69 3f              ADC #$3f
f754 9d b1 02           STA Dis_Buf,X
f757 e8                 INX
f758 e0 03              CPX #3
f75a 90 ea              BCC PrMn_10
f75c 60                 RTS ;Size   36 [Store_Mnemonic]


f75d 00 00 00           .FILL $f768 - * (0) ; 11 bytes

              ; ************
f768            Kernal_UDTIM
              ; ************

f768 e6 8f              INC JIFFY_CLOCK+2   ; 1 jiffy = 1/60 sec
f76a d0 18              BNE ud_20
f76c e6 8e              INC JIFFY_CLOCK+1
f76e d0 02              BNE ud_10
f770 e6 8d              INC JIFFY_CLOCK
f772 a5 8d    ud_10     LDA JIFFY_CLOCK
f774 c9 4f              CMP #$4f            ; MSB of $4f1a00 = 24 * 60 * 60 * 60
f776 90 0c              BCC ud_20
f778 a5 8e              LDA JIFFY_CLOCK+1
f77a c9 1a              CMP #$1a
f77c 90 06              BCC ud_20
f77e a9 00              LDA #0
f780 85 8d              STA JIFFY_CLOCK
f782 85 8e              STA JIFFY_CLOCK+1
f784 c6 f8    ud_20     DEC JIFFY6          ; insert additional jiffy count every 5th. call
f786 d0 06              BNE ud_30           ; to generate 60Hz jiffy clock from 50Hz signal
f788 a9 06              LDA #6
f78a 85 f8              STA JIFFY6
f78c d0 da              BNE Kernal_UDTIM    ; branch always
f78e 60       ud_30     RTS ;Size   39 [Kernal_UDTIM]

f78f 00 00 00           .FILL $f7af - * (0) ; 32 bytes

              ; ************
f7af            Kernal_CHKIN
              ; ************

              ; Input:  X = local address
              ; Output: DFLTN (Default Input) set to device FA
              ;         IEEE-488 device will be talker

f7af 48                 PHA                 ; save A
f7b0 a9 00              LDA #0
f7b2 85 96              STA STATUS          ; clear status
f7b4 8a                 TXA
f7b5 48                 PHA                 ; save X
f7b6 20 c1 f2           JSR LOOKUP_LA
f7b9 d0 1b              BNE CHERR_17
f7bb 20 cd f2           JSR Set_LFS_From_X
f7be c9 04              CMP #4              ; A = FA
f7c0 90 0e              BCC CHKIN_10        ; keyboard or screen
f7c2 20 d2 f0           JSR TALK
f7c5 a5 d3              LDA SA
f7c7 20 93 f1           JSR TKSA
f7ca a5 96              LDA STATUS
f7cc 30 0b              BMI CHERR_74
f7ce a5 d4              LDA FA
f7d0 85 af    CHKIN_10  STA DFLTN
f7d2 68                 PLA
f7d3 aa                 TAX
f7d4 68                 PLA
f7d5 60                 RTS ;Size   39 [Kernal_CHKIN]

f7d6 a0 17    CHERR_17  LDY #<MSG_FILE_NOT_O
f7d8 2c                 .BYTE $2c
f7d9 a0 74    CHERR_74  LDY #<MSG_DEVICE_NOT
f7db 2c                 .BYTE $2c
f7dc a0 94    CHERR_94  LDY #<MSG_NOT_OUTPUT
f7de 4c af f5 CHERR_IO  JMP Handle_IO_Error

f7e1 00 00 00           .FILL $f7fe - * (0) ; 29 bytes

              ; *************
f7fe            Kernal_CHKOUT
              ; *************

              ; Input:  X = local address
              ; Output: DFLTO (Default Output) set to device FA
              ;         IEEE-488 device will be listener

f7fe 48                 PHA                 ; save A
f7ff a9 00              LDA #0
f801 85 96              STA STATUS          ; clear status
f803 8a                 TXA
f804 48                 PHA                 ; save X
f805 20 c1 f2           JSR LOOKUP_LA
f808 d0 cc              BNE CHERR_17        ; file not open
f80a 20 cd f2           JSR Set_LFS_From_X
f80d f0 cd              BEQ CHERR_94        ; cannot write to keyboard
f80f c9 04              CMP #4
f811 90 0e              BCC KeCo_10         ; -> screen
f813 20 d5 f0           JSR LISTEN
f816 a5 d3              LDA SA
f818 20 43 f1           JSR SECOND
f81b a5 96              LDA STATUS
f81d 30 ba              BMI CHERR_74
f81f a5 d4              LDA FA
f821 85 b0    KeCo_10   STA DFLTO
f823 68                 PLA
f824 aa                 TAX
f825 68                 PLA
f826 60                 RTS ;Size   41 [Kernal_CHKOUT]

              ; **************
f827            Set_Wedge_Unit
              ; **************

f827 20 70 00           JSR CHRGET
f82a 90 0c              BCC SWUN_10
f82c a6 ab              LDX Wedge_Unit      ; X = Unit
f82e 98                 TYA                 ; A = 0
f82f 20 83 cf           JSR Print_Integer_XA
f832 20 df ba           JSR Print_CR
f835 4c ff b3           JMP Basic_Ready
f838 20 f6 b8 SWUN_10   JSR Scan_Linenumber
f83b a5 11              LDA LINNUM
f83d 85 ab              STA Wedge_Unit
f83f 4c ff b3           JMP Basic_Ready

              ; ************
f842            Wedge_Parser
              ; ************

f842 a0 00              LDY #0
f844 84 9d              STY VERCK           ; no verify
f846 b1 77              LDA (TXTPTR),Y
f848 c9 40              CMP #'@'            ; wedge control
f84a f0 1d              BEQ Command_Or_Status
f84c c9 3e              CMP #'>'            ; wedge control
f84e f0 19              BEQ Command_Or_Status
f850 c9 24              CMP #'$'            ; directory
f852 f0 38              BEQ Wedge_Directory
f854 c9 23              CMP #'#'
f856 f0 cf              BEQ Set_Wedge_Unit
f858 c9 2f              CMP #'/'
f85a f0 57              BEQ Wedge_Load
f85c c9 5e              CMP #'^'
f85e f0 46              BEQ Wedge_Run
f860 20 6b ed           JSR Extended_Command
f863 20 fb b4           JSR Tokenize_Line
f866 4c 79 b7           JMP Start_Program

              ; *****************
f869            Command_Or_Status
              ; *****************

f869 e6 77              INC TXTPTR
f86b b1 77              LDA (TXTPTR),Y
f86d f0 14              BEQ Get_Status
f86f c9 24              CMP #'$'            ; dir command
f871 f0 19              BEQ Wedge_Directory

              ; ************
f873            Send_Command
              ; ************

f873 20 2b fb           JSR DOS_Open_Comm_Write
f876 b1 77    SeCo_10   LDA (TXTPTR),Y
f878 f0 06              BEQ SeCo_20
f87a 20 9e f1           JSR CIOUT
f87d c8                 INY
f87e 10 f6              BPL SeCo_10
f880 20 b9 f1 SeCo_20   JSR UNLSN

              ; **********
f883            Get_Status
              ; **********

f883 20 c7 f8           JSR Wedge_Prepare
f886 20 98 f8           JSR Print_Status
f889 4c ff b3           JMP Basic_Ready

              ; ***************
f88c            Wedge_Directory
              ; ***************

f88c 20 d0 f8           JSR Wedge_Filename
f88f 20 c7 f8           JSR Wedge_Prepare
f892 20 89 d8           JSR Wedge_Call_Dir
f895 4c ff b3           JMP Basic_Ready

              ; ************
f898            Print_Status
              ; ************

f898 20 e1 db           JSR Clear_Status
f89b 20 91 d9           JSR Kernal_Read_DS
f89e 4c 85 db           JMP Display_Status

f8a1 52 55 4e RUN_Now   .BYTE "RUN:\r"

              ; *********
f8a6            Wedge_Run
              ; *********

f8a6 a2 05              LDX #5              ; put "RUN" into keyboard buffer
f8a8 86 9e              STX CharsInBuffer
f8aa bd a0 f8 WeRu_10   LDA RUN_Now-1,X
f8ad 9d 6e 02           STA KEYD-1,X
f8b0 ca                 DEX
f8b1 d0 f7              BNE WeRu_10

              ; **********
f8b3            Wedge_Load
              ; **********

f8b3 20 70 00           JSR CHRGET
f8b6 c9 30              CMP #'0'            ; Skip size info in dir listings
f8b8 90 04              BCC WeLo_10
f8ba c9 3a              CMP #'9'+1
f8bc 90 f5              BCC Wedge_Load
f8be 20 d0 f8 WeLo_10   JSR Wedge_Filename
f8c1 20 c7 f8           JSR Wedge_Prepare
f8c4 4c 1d f4           JMP Load_Verify_Params_Set

              ; *************
f8c7            Wedge_Prepare
              ; *************

f8c7 a5 ab              LDA Wedge_Unit
f8c9 85 d4              STA FA
f8cb a9 00              LDA #0
f8cd 85 96              STA STATUS
f8cf 60                 RTS ;Size    9 [Wedge_Prepare]

              ; **************
f8d0            Wedge_Filename
              ; **************

f8d0 a0 ff              LDY #-1
f8d2 20 76 00           JSR CHRGOT
f8d5 c9 22              CMP #$22            ; quote
f8d7 d0 02              BNE WeFi_10
f8d9 e6 77              INC TXTPTR          ; skip quote
f8db c8       WeFi_10   INY
f8dc b1 77              LDA (TXTPTR),y
f8de f0 04              BEQ WeFi_20
f8e0 c9 22              CMP #$22            ; quote
f8e2 d0 f7              BNE WeFi_10
f8e4 84 d1    WeFi_20   STY FNLEN           ; store length
f8e6 a5 77              LDA TXTPTR
f8e8 85 da              STA FNADR
f8ea a5 78              LDA TXTPTR + 1
f8ec 85 db              STA FNADR + 1
f8ee a5 ab              LDA Wedge_Unit
f8f0 85 d4              STA FA
f8f2 60                 RTS ;Size   35 [Wedge_Filename]

              ; *************
f8f3            Mnemonic_Left
              ; *************

f8f3 1c                 .BYTE >"BRK"
f8f4 8a                 .BYTE >"PHP"
f8f5 1c                 .BYTE >"BPL"
f8f6 23                 .BYTE >"CLC"
f8f7 5d                 .BYTE >"JSR"
f8f8 8b                 .BYTE >"PLP"
f8f9 1b                 .BYTE >"BMI"
f8fa a1                 .BYTE >"SEC"
f8fb 9d                 .BYTE >"RTI"
f8fc 8a                 .BYTE >"PHA"
f8fd 1d                 .BYTE >"BVC"
f8fe 23                 .BYTE >"CLI"
f8ff 9d                 .BYTE >"RTS"
f900 8b                 .BYTE >"PLA"
f901 1d                 .BYTE >"BVS"
f902 a1                 .BYTE >"SEI"
f903 00                 .BYTE >"???"
f904 29                 .BYTE >"DEY"
f905 19                 .BYTE >"BCC"
f906 ae                 .BYTE >"TYA"
f907 69                 .BYTE >"LDY"
f908 a8                 .BYTE >"TAY"
f909 19                 .BYTE >"BCS"
f90a 23                 .BYTE >"CLV"
f90b 24                 .BYTE >"CPY"
f90c 53                 .BYTE >"INY"
f90d 1b                 .BYTE >"BNE"
f90e 23                 .BYTE >"CLD"
f90f 24                 .BYTE >"CPX"
f910 53                 .BYTE >"INX"
f911 19                 .BYTE >"BEQ"
f912 a1                 .BYTE >"SED"
f913 00                 .BYTE >"???"
f914 1a                 .BYTE >"BIT"
f915 5b                 .BYTE >"JMP"
f916 5b                 .BYTE >"JMP"
f917 a5                 .BYTE >"STY"
f918 69                 .BYTE >"LDY"
f919 24                 .BYTE >"CPY"
f91a 24                 .BYTE >"CPX"
f91b ae                 .BYTE >"TXA"
f91c ae                 .BYTE >"TXS"
f91d a8                 .BYTE >"TAX"
f91e ad                 .BYTE >"TSX"
f91f 29                 .BYTE >"DEX"
f920 00                 .BYTE >"???"
f921 7c                 .BYTE >"NOP"
f922 00                 .BYTE >"???"
f923 15                 .BYTE >"ASL"
f924 9c                 .BYTE >"ROL"
f925 6d                 .BYTE >"LSR"
f926 9c                 .BYTE >"ROR"
f927 a5                 .BYTE >"STX"
f928 69                 .BYTE >"LDX"
f929 29                 .BYTE >"DEC"
f92a 53                 .BYTE >"INC"
f92b 84                 .BYTE >"ORA"
f92c 13                 .BYTE >"AND"
f92d 34                 .BYTE >"EOR"
f92e 11                 .BYTE >"ADC"
f92f a5                 .BYTE >"STA"
f930 69                 .BYTE >"LDA"
f931 23                 .BYTE >"CMP"
f932 a0                 .BYTE >"SBC"

              ; **************
f933            Mnemonic_Right
              ; **************

f933 d8                 .BYTE <"BRK"
f934 62                 .BYTE <"PHP"
f935 5a                 .BYTE <"BPL"
f936 48                 .BYTE <"CLC"
f937 26                 .BYTE <"JSR"
f938 62                 .BYTE <"PLP"
f939 94                 .BYTE <"BMI"
f93a 88                 .BYTE <"SEC"
f93b 54                 .BYTE <"RTI"
f93c 44                 .BYTE <"PHA"
f93d c8                 .BYTE <"BVC"
f93e 54                 .BYTE <"CLI"
f93f 68                 .BYTE <"RTS"
f940 44                 .BYTE <"PLA"
f941 e8                 .BYTE <"BVS"
f942 94                 .BYTE <"SEI"
f943 00                 .BYTE <"???"
f944 b4                 .BYTE <"DEY"
f945 08                 .BYTE <"BCC"
f946 84                 .BYTE <"TYA"
f947 74                 .BYTE <"LDY"
f948 b4                 .BYTE <"TAY"
f949 28                 .BYTE <"BCS"
f94a 6e                 .BYTE <"CLV"
f94b 74                 .BYTE <"CPY"
f94c f4                 .BYTE <"INY"
f94d cc                 .BYTE <"BNE"
f94e 4a                 .BYTE <"CLD"
f94f 72                 .BYTE <"CPX"
f950 f2                 .BYTE <"INX"
f951 a4                 .BYTE <"BEQ"
f952 8a                 .BYTE <"SED"
f953 00                 .BYTE <"???"
f954 aa                 .BYTE <"BIT"
f955 a2                 .BYTE <"JMP"
f956 a2                 .BYTE <"JMP"
f957 74                 .BYTE <"STY"
f958 74                 .BYTE <"LDY"
f959 74                 .BYTE <"CPY"
f95a 72                 .BYTE <"CPX"
f95b 44                 .BYTE <"TXA"
f95c 68                 .BYTE <"TXS"
f95d b2                 .BYTE <"TAX"
f95e 32                 .BYTE <"TSX"
f95f b2                 .BYTE <"DEX"
f960 00                 .BYTE <"???"
f961 22                 .BYTE <"NOP"
f962 00                 .BYTE <"???"
f963 1a                 .BYTE <"ASL"
f964 1a                 .BYTE <"ROL"
f965 26                 .BYTE <"LSR"
f966 26                 .BYTE <"ROR"
f967 72                 .BYTE <"STX"
f968 72                 .BYTE <"LDX"
f969 88                 .BYTE <"DEC"
f96a c8                 .BYTE <"INC"
f96b c4                 .BYTE <"ORA"
f96c ca                 .BYTE <"AND"
f96d 26                 .BYTE <"EOR"
f96e 48                 .BYTE <"ADC"
f96f 44                 .BYTE <"STA"
f970 44                 .BYTE <"LDA"
f971 a2                 .BYTE <"CMP"
f972 c8                 .BYTE <"SBC"

              ; *************
f973            admode_format
              ; *************

              ;                 76543210
              ;                 --------
              ;                 x         $
              ;                  x        ($
              ;                   x       #$
              ;                    x      ,X
              ;                     x     )
              ;                      x    ,Y
              ;                       xx  length - 1

f973 00                  .BYTE %00000000  ; 0         implicit
f974 21                  .BYTE %00100001  ; 1  $#     immediate
f975 81                  .BYTE %10000001  ; 2  $zz    zeropage
f976 82                  .BYTE %10000010  ; 3  $nnnn  absolute
f977 00                  .BYTE %00000000  ; 4         implicit
f978 00                  .BYTE %00000000  ; 5         implicit
f979 59                  .BYTE %01011001  ; 6 ($zz,X) indexed indirect
f97a 4d                  .BYTE %01001101  ; 7 ($zz),Y indirect indexed
f97b 91                  .BYTE %10010001  ; 8 $zz,X   zeropage,X
f97c 92                  .BYTE %10010010  ; 9 $nnnn,X absolute,X
f97d 86                  .BYTE %10000110  ; a $nnnn,Y absolute,Y
f97e 4a                  .BYTE %01001010  ; b ($nnnn) indirect
f97f 85                  .BYTE %10000101  ; c $zz,Y   zeropage,Y
f980 9d                  .BYTE %10011101  ; d $nnnn   relative

f981 2c 29 2c adr_char1  .BYTE ",),#($"
f987 59 00 58 adr_char2  .BYTE "Y",0,"X$$",0

              ; *************
f98d            Store_Address
              ; *************

f98d a5 bd              LDA Mon_Format
f98f 85 bf              STA Mon_A
f991 a0 03              LDY #3              ; buffer pointer after mnemonic
f993 a5 be              LDA Dis_Length
f995 f0 41              BEQ StAd_Ret        ; finish for implied address
f997 a9 20              LDA #' '            ; store blank
f999 8d b4 02           STA Dis_Buf+3
f99c c8                 INY                 ; inc buffer pointer
f99d a2 05              LDX #5              ; 6 flags to process
f99f e0 02    StAd_10   CPX #2              ; flag2: address
f9a1 d0 16              BNE StAd_30
f9a3 a5 be              LDA Dis_Length
f9a5 c9 01              CMP #1
f9a7 f0 05              BEQ StAd_20         ; 8 bit operand
f9a9 a5 c3              LDA Mon_Hi
f9ab 20 e2 f9           JSR Store_Hex
f9ae a5 bf    StAd_20   LDA Mon_A
f9b0 c9 e8              CMP #$e8            ; branch ?
f9b2 b0 1e              BCS StAd_50         ; compute target
f9b4 a5 c2              LDA Mon_Lo          ; low  byte of operand
f9b6 20 e2 f9           JSR Store_Hex
f9b9 06 bf    StAd_30   ASL Mon_A
f9bb 90 10              BCC StAd_40
f9bd bd 81 f9           LDA adr_char1,X
f9c0 99 b1 02           STA Dis_Buf,Y
f9c3 c8                 INY
f9c4 bd 87 f9           LDA adr_char2,X
f9c7 f0 04              BEQ StAd_40
f9c9 99 b1 02           STA Dis_Buf,Y
f9cc c8                 INY
f9cd ca       StAd_40   DEX
f9ce 10 cf              BPL StAd_10
f9d0 30 06              BMI StAd_Ret
f9d2 20 46 fe StAd_50   JSR Offset_To_Target
f9d5 20 dc f9           JSR Store_Hex_XA
f9d8 8c b0 02 StAd_Ret  STY Dis_Buf_Length
f9db 60                 RTS ;Size   79 [Store_Address]


              ; ************
f9dc            Store_Hex_XA
              ; ************
f9dc 48                 PHA
f9dd 8a                 TXA
f9de 20 e2 f9           JSR Store_Hex
f9e1 68                 PLA

              ; *********
f9e2            Store_Hex
              ; *********

f9e2 48                 PHA
f9e3 4a                 LSR A
f9e4 4a                 LSR A
f9e5 4a                 LSR A
f9e6 4a                 LSR A
f9e7 20 67 d7           JSR Nibble_To_Hex
f9ea 99 b1 02           STA Dis_Buf,Y
f9ed c8                 INY
f9ee 68                 PLA
f9ef 29 0f              AND #15
f9f1 20 67 d7           JSR Nibble_To_Hex
f9f4 99 b1 02           STA Dis_Buf,Y
f9f7 c8                 INY
f9f8 60                 RTS ;Size   23 [Store_Hex]


              ; *************
f9f9            Print_Dis_Buf
              ; *************

f9f9 a0 00              LDY #0
f9fb b9 b1 02 PDB_10    LDA Dis_Buf,Y
f9fe 20 02 e2           JSR EDIT_CHROUT
fa01 c8                 INY
fa02 cc b0 02           CPY Dis_Buf_Length
fa05 90 f4              BCC PDB_10
fa07 60                 RTS ;Size   15 [Print_Dis_Buf]

              ; ***********
fa08            Ass_Operand
              ; ***********

fa08 20 f4 d8           JSR Mon_CHRIN
fa0b f0 11              BEQ AsOp_30         ; finished
fa0d c9 20              CMP #' '
fa0f f0 f7              BEQ Ass_Operand     ; ignore blanks
fa11 20 99 fd           JSR Get_Constant
fa14 f0 08              BEQ AsOp_30         ; no chars left
fa16 99 c1 02           STA Ass_Buf,Y
fa19 c8                 INY
fa1a c0 10              CPY #16
fa1c 90 ea              BCC Ass_Operand
fa1e ad c1 02 AsOp_30   LDA Ass_Buf         ; 1.st char of mnemonic
fa21 c9 42              CMP #'B'
fa23 d0 19              BNE AsOp_Ret        ; no branch
fa25 ad c2 02           LDA Ass_Buf+1       ; 2nd. char of mnemonic
fa28 c9 49              CMP #'I'
fa2a f0 12              BEQ AsOp_Ret        ; BIT
fa2c c9 52              CMP #'R'
fa2e f0 0e              BEQ AsOp_Ret        ; BRK
fa30 a5 c3              LDA Mon_Hi
fa32 f0 0b              BEQ AsOp_40
fa34 38                 SEC                 ; convert target to offset
fa35 a5 c2              LDA Mon_Lo
fa37 e5 fb              SBC STAL
fa39 38                 SEC
fa3a e9 02              SBC #2
fa3c 85 c2              STA Mon_Lo
fa3e 60       AsOp_Ret  RTS ;Size   55 [Ass_Operand]
fa3f 4c 36 fe AsOp_40   JMP Expand_Target


              ; ********
fa42            Assemble
              ; ********

              ; Strategy: convert operand to disassembler format
              ; Loop opcode from 0 to 255 and call disassembler
              ; until mnemonic and operand match.

fa42 20 71 d7           JSR Hex_To_STAL      ; target address
fa45 90 5d              BCC Ass_Err
fa47 a0 00    Ass_010   LDY #0               ; reset buffer pointer
fa49 84 c1              STY Mon_Op
fa4b 84 c2              STY Mon_Lo
fa4d 84 c3              STY Mon_Hi
fa4f 20 f4 d8 Ass_020   JSR Mon_CHRIN        ; get next char
fa52 f0 50              BEQ Ass_Err
fa54 c9 20              CMP #' '
fa56 f0 ef              BEQ Ass_010          ; restart on blank
fa58 99 c1 02           STA Ass_Buf,Y        ; save char
fa5b c8                 INY
fa5c c0 03              CPY #3
fa5e d0 ef              BNE Ass_020          ; look for more
fa60 20 f4 d8           JSR Mon_CHRIN
fa63 f0 0b              BEQ Ass_040          ; Mnemonic only
fa65 c9 20              CMP #' '
fa67 d0 3b              BNE Ass_Err          ; blank after mnemonic is mandatory
fa69 8d c4 02           STA Ass_Buf+3
fa6c c8                 INY
fa6d 20 08 fa           JSR Ass_Operand
fa70 8c c0 02 Ass_040   STY Ass_Buf_Length
fa73 a5 c1    Ass_050   LDA Mon_Op
fa75 20 25 f6           JSR Analyze_Opcode
fa78 8d d0 02           STA Ass_Index
fa7b 20 39 f7           JSR Store_Mnemonic
fa7e 20 8d f9           JSR Store_Address
fa81 ae c0 02           LDX Ass_Buf_Length
fa84 ec b0 02           CPX Dis_Buf_Length
fa87 d0 0b              BNE Ass_070
fa89 ca       Ass_060   DEX
fa8a 30 1b              BMI Ass_080         ; match
fa8c bd c1 02           LDA Ass_Buf,X
fa8f dd b1 02           CMP Dis_Buf,X
fa92 f0 f5              BEQ Ass_060
fa94 e6 c1    Ass_070   INC Mon_Op          ; try next op code
fa96 d0 db              BNE Ass_050
fa98 a5 cc              LDA Mon_ZP          ; was a zP mode ?
fa9a d0 08              BNE Ass_Err
fa9c c6 cc              DEC Mon_ZP          ; invalidate
fa9e 20 17 fe           JSR Expand_Address
faa1 4c 73 fa           JMP Ass_050         ; now try two byte operands
faa4 4c ac d4 Ass_Err   JMP Mon_Error
faa7 86 ba    Ass_080   STX Dis_Line        ; disable disassembler line count
faa9 a5 fb              LDA STAL
faab 85 f9              STA BPTR
faad a5 fc              LDA STAL+1
faaf 85 fa              STA BPTR+1
fab1 a4 be              LDY Dis_Length
fab3 b9 c1 00 Ass_090   LDA Mon_Op,Y        ; store instruction
fab6 20 8b 02           JSR Bank_Store
fab9 20 7a 02           JSR Bank_Fetch
fabc d9 c1 00           CMP Mon_Op,Y        ; successfull ?
fabf d0 e3              BNE Ass_Err
fac1 88                 DEY
fac2 10 ef              BPL Ass_090
fac4 20 b4 e1           JSR Edit_To_Left_Margin
fac7 a9 9d              LDA #$9d            ; Cursor UP
fac9 20 02 e2           JSR EDIT_CHROUT
facc a9 41              LDA #'A'
face 20 7b d5           JSR Mon_Prompt
fad1 20 22 d5           JSR Mon_Print_Blank
fad4 20 54 d7           JSR Mon_Print_STAL
fad7 20 22 d5           JSR Mon_Print_Blank
fada ad d0 02           LDA Ass_Index
fadd 20 e6 f5           JSR Print_Dis_Line
fae0 a9 0d              LDA #CR
fae2 20 02 e2           JSR EDIT_CHROUT
fae5 78                 SEI                 ; prompt to keyboard buffer
fae6 a9 41              LDA #'A'
fae8 8d 6f 02           STA KEYD
faeb a9 20              LDA #' '
faed 8d 70 02           STA KEYD+1
faf0 a5 fc              LDA STAL+1
faf2 20 45 d7           JSR Make_Hex_Byte
faf5 8e 71 02           STX KEYD+2
faf8 8d 72 02           STA KEYD+3
fafb a5 fb              LDA STAL
fafd 20 45 d7           JSR Make_Hex_Byte
fb00 8e 73 02           STX KEYD+4
fb03 8d 74 02           STA KEYD+5
fb06 a9 20              LDA #' '
fb08 8d 75 02           STA KEYD+6
fb0b a2 07              LDX #7
fb0d 86 9e              STX CharsInBuffer
fb0f 58                 CLI
fb10 4c b8 d4           JMP Mon_10

              ; ********
fb13            Inc_STAL
              ; ********

fb13 a9 01              LDA #1

              ; ********
fb15            Add_STAL
              ; ********

fb15 18                 CLC
fb16 65 fb    AdST_00   ADC STAL
fb18 85 fb              STA STAL
fb1a 90 02              BCC AdST_Ret
fb1c e6 fc    AdST_10   INC STAL+1
fb1e 60       AdST_Ret  RTS ;Size   10 [Add_STAL]


              ; ********
fb1f            Inc_BPTR
              ; ********

fb1f a9 01              LDA #1

              ; ********
fb21            Add_BPTR
              ; ********

fb21 18                 CLC
fb22 65 f9    AdBP_00   ADC BPTR
fb24 85 f9              STA BPTR
fb26 90 02              BCC AdBP_Ret
fb28 e6 fa    AdBP_10   INC BPTR+1
fb2a 60       AdBP_Ret  RTS ;Size   10 [Add_BPTR]


              ; *******************
fb2b            DOS_Open_Comm_Write
              ; *******************

fb2b 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
fb2e 20 d5 f0           JSR LISTEN
fb31 a9 6f              LDA #$6f
fb33 85 d3              STA SA
fb35 4c 43 f1           JMP SECOND

              ; *********
fb38            Mon_Wedge
              ; *********

fb38 20 f4 d8           JSR Mon_CHRIN
fb3b f0 10              BEQ Mon_Wedge_Status
fb3d 48                 PHA
fb3e 20 2b fb           JSR DOS_Open_Comm_Write
fb41 68                 PLA
fb42 20 9e f1 MoWe_10   JSR CIOUT
fb45 20 f4 d8           JSR Mon_CHRIN
fb48 d0 f8              BNE MoWe_10
fb4a 20 b9 f1           JSR UNLSN

              ; ****************
fb4d            Mon_Wedge_Status
              ; ****************

fb4d 20 25 d5           JSR Mon_Print_CR
fb50 20 c7 f8           JSR Wedge_Prepare
fb53 20 98 f8           JSR Print_Status
fb56 4c b1 d4           JMP Mon_Main

              ; *******
fb59            Mon_Dir
              ; *******

fb59 a0 00              LDY #0
fb5b a9 24              LDA #'$'
fb5d 99 42 03 MoDi_10   STA DOS_Filename,Y
fb60 c8                 INY
fb61 20 f4 d8           JSR Mon_CHRIN
fb64 d0 f7              BNE MoDi_10
fb66 84 d1              STY FNLEN
fb68 20 cc d6           JSR Set_DOS_FNADR
fb6b 20 25 d5           JSR Mon_Print_CR
fb6e 20 c7 f8           JSR Wedge_Prepare
fb71 20 89 d8           JSR Wedge_Call_Dir
fb74 4c b1 d4           JMP Mon_Main

              ; ****************
fb77            Init_RAM_Vectors
              ; ****************

fb77 a2 0b              LDX #RBVT_END - ROM_BASIC_Vector_Table - 1
fb79 bd 83 fb IRV_10    LDA ROM_BASIC_Vector_Table,X
fb7c 9d 00 03           STA IERROR,X
fb7f ca                 DEX
fb80 10 f7              BPL IRV_10
fb82 60                 RTS ;Size   12 [Init_RAM_Vectors]

              ; **********************
fb83            ROM_BASIC_Vector_Table
              ; **********************

fb83 d2 b3              .WORD DEF_ERROR     ; $0300 IERROR
fb85 09 b4              .WORD DEF_MAIN      ; $0302 IMAIN
fb87 fe b4              .WORD DEF_CRUNCH    ; $0304 ICRNCH
fb89 ab b6              .WORD DEF_QPLOP     ; $0306 IQPLOP
fb8b 7c b7              .WORD DEF_GONE      ; $0308 IGONE
fb8d 81 be              .WORD DEF_EVAL      ; $030a IEVAL
fb8f          RBVT_END
fb8f 00 00 00           .FILL $fbc4 - * (0) ; 53 bytes

              ; **********
fbc4            Set_STATUS
              ; **********

fbc4 05 96              ORA STATUS
fbc6 85 96              STA STATUS
fbc8 60                 RTS ;Size    5 [Set_STATUS]


              ; *********
fbc9            Mon_Get_3
              ; *********

fbc9 20 71 d7           JSR Hex_To_STAL
fbcc 90 11              BCC MG3_Err
fbce a2 fd              LDX #MEMUSS
fbd0 20 73 d7           JSR Read_Hex_Word
fbd3 90 0a              BCC MG3_Err
fbd5 a2 f9              LDX #BPTR
fbd7 20 73 d7           JSR Read_Hex_Word
fbda 90 03              BCC MG3_Err
fbdc a0 00              LDY #0
fbde 60                 RTS ;Size   22 [Mon_Get_3]
fbdf 68       MG3_Err   PLA
fbe0 68                 PLA
fbe1 4c ac d4           JMP Mon_Error

              ; ***********
fbe4            Mon_Compare
              ; ***********

fbe4 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fbe7 20 25 d5           JSR Mon_Print_CR
fbea a9 f9    MoCo_10   LDA #BPTR
fbec 8d 81 02           STA Bank_Fetch+7
fbef a5 b7              LDA W_Bank
fbf1 20 7c 02           JSR Bank_Fetch+2    ; LDA (BPTR),Y
fbf4 85 bf              STA Mon_A
fbf6 a9 fb              LDA #STAL
fbf8 8d 81 02           STA Bank_Fetch+7
fbfb 20 7a 02           JSR Bank_Fetch      ; LDA (STAL),Y
fbfe c5 bf              CMP Mon_A
fc00 f0 06              BEQ MoCo_20
fc02 20 54 d7           JSR Mon_Print_STAL
fc05 20 22 d5           JSR Mon_Print_Blank
fc08 20 13 fb MoCo_20   JSR Inc_STAL
fc0b 20 1f fb           JSR Inc_BPTR
fc0e 20 f2 d5           JSR Cmp_STAL_MEMUSS
fc11 b0 d7              BCS MoCo_10
fc13 4c b1 d4           JMP Mon_Main

              ; ************
fc16            Mon_Transfer
              ; ************

fc16 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fc19 a5 f9              LDA BPTR            ; BPTR > STAL ?
fc1b c5 fb              CMP STAL
fc1d a5 fa              LDA BPTR+1
fc1f e5 fc              SBC STAL+1
fc21 b0 17              BCS MoTr_20         ; BPTR > STAL: copy backward
fc23 20 7a 02 MoTr_10   JSR Bank_Fetch
fc26 20 8b 02           JSR Bank_Store
fc29 20 13 fb           JSR Inc_STAL
fc2c 20 1f fb           JSR Inc_BPTR
fc2f 20 f2 d5           JSR Cmp_STAL_MEMUSS
fc32 b0 ef              BCS MoTr_10
fc34 4c b1 d4 MoTr_Ret  JMP Mon_Main
fc37 4c ac d4 MoTr_Err  JMP Mon_Error
fc3a 38       MoTr_20   SEC
fc3b a5 fd              LDA MEMUSS          ; exchange STAL <-> MEMUSS
fc3d a6 fb              LDX STAL
fc3f 86 fd              STX MEMUSS
fc41 85 fb              STA STAL
fc43 e5 fd              SBC MEMUSS
fc45 85 bf              STA Mon_A           ; Mon_A = MEMUSS - STAL
fc47 a5 fe              LDA MEMUSS+1
fc49 a6 fc              LDX STAL+1
fc4b 86 fe              STX MEMUSS+1
fc4d 85 fc              STA STAL+1
fc4f e5 fe              SBC MEMUSS+1
fc51 85 c0              STA Mon_A+1
fc53 90 e2              BCC MoTr_Err        ; Error: MEMUSS < STAL
fc55 18                 CLC
fc56 a5 f9              LDA BPTR            ; BPTR += (MEMUSS - STAL)
fc58 65 bf              ADC Mon_A
fc5a 85 f9              STA BPTR
fc5c a5 fa              LDA BPTR+1
fc5e 65 c0              ADC Mon_A+1
fc60 85 fa              STA BPTR+1
fc62 20 7a 02 MoTr_30   JSR Bank_Fetch
fc65 20 8b 02           JSR Bank_Store
fc68 20 f2 d5           JSR Cmp_STAL_MEMUSS ; STAL == MEMUSS -> finished
fc6b b0 c7              BCS MoTr_Ret
fc6d a5 fb              LDA STAL
fc6f d0 02              BNE MoTr_40
fc71 c6 fc              DEC STAL+1
fc73 c6 fb    MoTr_40   DEC STAL
fc75 a5 f9              LDA BPTR
fc77 d0 02              BNE MoTr_50
fc79 c6 fa              DEC BPTR+1
fc7b c6 f9    MoTr_50   DEC BPTR
fc7d 4c 62 fc           JMP MoTr_30

              ; ********
fc80            Mon_Hunt
              ; ********

fc80 20 1f d6           JSR Mon_Get_Addr    ; get range
fc83 a0 00              LDY #0
fc85 20 f4 d8 MoHu_10   JSR Mon_CHRIN       ; skip blanks
fc88 f0 5b              BEQ MoHu_Err
fc8a c9 20              CMP #' '
fc8c f0 f7              BEQ MoHu_10
fc8e c9 22              CMP #$22            ; quote ?
fc90 f0 16              BEQ MoHu_40         ; string
fc92 20 87 d7           JSR Read_Hex_A      ; get first byte
fc95 90 4e              BCC MoHu_Err
fc97 b0 05              BCS MoHu_30         ; continue reading hex
fc99 20 80 d7 MoHu_20   JSR Read_Hex        ; loop for reading hex bytes
fc9c 90 1b              BCC MoHu_50         ; end of line
fc9e 99 42 03 MoHu_30   STA DOS_Filename,Y
fca1 c8                 INY
fca2 c0 10              CPY #16
fca4 90 f3              BCC MoHu_20
fca6 b0 11              BCS MoHu_50
fca8 20 f4 d8 MoHu_40   JSR Mon_CHRIN       ; loop for reading string
fcab f0 0c              BEQ MoHu_50
fcad c9 22              CMP #$22            ; quote
fcaf f0 08              BEQ MoHu_50
fcb1 99 42 03           STA DOS_Filename,Y
fcb4 c8                 INY
fcb5 c0 10              CPY #16
fcb7 90 ef              BCC MoHu_40
fcb9 84 b5    MoHu_50   STY MONCNT
fcbb 20 25 d5           JSR Mon_Print_CR
fcbe 20 35 f3 MoHu_60   JSR Check_STOP_Key  ; STOP key pressed?
fcc1 f0 1f              BEQ MoHu_Ret
fcc3 20 e7 d5           JSR Mon_Cmp_Addr
fcc6 90 1a              BCC MoHu_Ret
fcc8 a0 00              LDY #0
fcca 20 7a 02 MoHu_70   JSR Bank_Fetch
fccd d9 42 03           CMP DOS_Filename,Y
fcd0 d0 0b              BNE MoHu_80         ; no match
fcd2 c8                 INY
fcd3 c4 b5              CPY MONCNT
fcd5 90 f3              BCC MoHu_70
fcd7 20 54 d7           JSR Mon_Print_STAL
fcda 20 22 d5           JSR Mon_Print_Blank
fcdd 20 13 fb MoHu_80   JSR Inc_STAL
fce0 d0 dc              BNE MoHu_60
fce2 4c b1 d4 MoHu_Ret  JMP Mon_Main
fce5 4c ac d4 MoHu_Err  JMP Mon_Error


fce8 00 00 00           .FILL $fd16 - * (0) ; 46 bytes

              ; ***********
fd16            Entry_RESET
              ; ***********

fd16 a2 ff              LDX #$ff
fd18 78                 SEI
fd19 9a                 TXS
fd1a d8                 CLD
fd1b 20 37 e0           JSR EDIT_RESET
fd1e a9 ff              LDA #<Basic_Ready
fd20 85 94              STA NMINV
fd22 a9 b3              LDA #>Basic_Ready
fd24 85 95              STA NMINV+1
fd26 a9 51              LDA #<MONITOR_BREAK
fd28 85 92              STA CBINV
fd2a a9 d4              LDA #>MONITOR_BREAK
fd2c 85 93              STA CBINV+1
fd2e a9 ac              LDA #<Mon_Error
fd30 8d fa 03           STA Reset_Vector
fd33 a9 d4              LDA #>Mon_Error
fd35 8d fb 03           STA Reset_Vector+1
fd38 a9 00              LDA #0
fd3a 8d fc 03           STA Ignore_Timeout
fd3d 58                 CLI
fd3e 4c b6 d3           JMP Init_BASIC_RAM_Vectors

fd41 00 00 00           .FILL $fd49 - * (0) ; 8 bytes

              ; *********
fd49            Entry_NMI
              ; *********

fd49 6c 94 00           JMP (NMINV)

              ; ***********
fd4c            Set_FA_to_8
              ; ***********

fd4c a2 08              LDX #8
fd4e 86 d4              STX FA
fd50 60                 RTS ;Size    5 [Set_FA_to_8]

              ; ********
fd51            Mon_Unit
              ; ********

fd51 20 80 d7           JSR Read_Hex
fd54 90 0a              BCC MoUn_10
fd56 c9 10              CMP #16
fd58 b0 06              BCS MoUn_10
fd5a c9 04              CMP #4
fd5c 90 02              BCC MoUn_10
fd5e 85 ab              STA Wedge_Unit
fd60 20 22 d5 MoUn_10   JSR Mon_Print_Blank
fd63 a5 ab              LDA Wedge_Unit
fd65 20 5b d7           JSR Print_Hex_Byte
fd68 20 25 d5           JSR Mon_Print_CR
fd6b 4c b1 d4           JMP Mon_Main

              ; ********
fd6e            Mon_Next
              ; ********

fd6e 78                 SEI
fd6f a9 89              LDA #<Mon_Step_IRQ
fd71 85 90              STA CINV
fd73 a9 fd              LDA #>Mon_Step_IRQ
fd75 85 91              STA CINV+1
fd77 a9 a0              LDA #$a0            ; enable T2 time out interrupt
fd79 8d 4e e8           STA VIA_IER         ; interrupt enable register
fd7c a9 2f              LDA #47             ; overhead + 1 cycle
fd7e 8d 48 e8           STA VIA_Timer_2_Lo
fd81 a9 00              LDA #0
fd83 8d 49 e8           STA VIA_Timer_2_Hi  ; trigger start of timer T2
fd86 4c ab d6           JMP Mon_Step

              ; ************
fd89            Mon_Step_IRQ
              ; ************

fd89 ad 4d e8           LDA VIA_IFR
fd8c 29 20              AND #$20            ; T2 timeout interrupt ?
fd8e f0 06              BEQ MSI_10
fd90 2c 48 e8           BIT VIA_Timer_2_Lo  ; clear interrupt
fd93 6c 92 00           JMP (CBINV)
fd96 4c 55 e4 MSI_10    JMP IRQ_NORMAL


              ; ************
fd99            Get_Constant
              ; ************

fd99 20 05 d9           JSR Is_Int
fd9c 90 51              BCC GeCo_Ret
fd9e c9 24              CMP #'$'
fda0 d0 50              BNE GeCo_45
fda2 20 f4 d8 GeCo_10   JSR Mon_CHRIN       ; parse hex constant
fda5 20 11 d9           JSR Is_Hex
fda8 90 25              BCC GeCo_30
fdaa 20 fa d8           JSR Hex_To_Bin
fdad a2 04              LDX #4
fdaf 06 c2    GeCo_20   ASL Mon_Lo
fdb1 26 c3              ROL Mon_Hi
fdb3 ca                 DEX
fdb4 d0 f9              BNE GeCo_20
fdb6 05 c2              ORA Mon_Lo
fdb8 85 c2              STA Mon_Lo
fdba 4c a2 fd           JMP GeCo_10
fdbd a6 cb    GeCo_25   LDX Mon_Tmp
fdbf e0 2d              CPX #'-'
fdc1 d0 0c              BNE GeCo_30
fdc3 a6 c3              LDX Mon_Hi
fdc5 d0 28              BNE GeCo_Ret        ; no negative 16 bit values
fdc7 48                 PHA
fdc8 a9 00              LDA #0
fdca e5 c2              SBC Mon_Lo          ; carry was set from CPX
fdcc 85 c2              STA Mon_Lo
fdce 68                 PLA
fdcf 48       GeCo_30   PHA                 ; push char after constant
fdd0 a9 24              LDA #'$'
fdd2 99 c1 02           STA Ass_Buf,Y
fdd5 c8                 INY
fdd6 98                 TYA
fdd7 18                 CLC
fdd8 69 10              ADC #16
fdda a8                 TAY
fddb a5 c3              LDA Mon_Hi
fddd 85 cc              STA Mon_ZP
fddf f0 03              BEQ GeCo_40
fde1 20 e2 f9           JSR Store_Hex
fde4 a5 c2    GeCo_40   LDA Mon_Lo
fde6 20 e2 f9           JSR Store_Hex
fde9 98                 TYA
fdea 38                 SEC
fdeb e9 10              SBC #16
fded a8                 TAY
fdee 68                 PLA                 ; pop char after constant
fdef c9 0d    GeCo_Ret  CMP #CR             ; EOI
fdf1 60                 RTS ;Size   89 [Get_Constant]
fdf2 85 cb    GeCo_45   STA Mon_Tmp         ; save sign
fdf4 c9 2b              CMP #'+'
fdf6 f0 15              BEQ GeCo_70
fdf8 c9 2d              CMP #'-'
fdfa f0 11              BEQ GeCo_70
fdfc a6 c2    GeCo_50   LDX Mon_Lo
fdfe 86 11              STX LINNUM
fe00 a6 c3              LDX Mon_Hi
fe02 86 12              STX LINNUM+1
fe04 20 0d b9           JSR Dec_Char
fe07 85 c2              STA Mon_Lo
fe09 a5 12              LDA LINNUM+1
fe0b 85 c3              STA Mon_Hi
fe0d 20 f4 d8 GeCo_70   JSR Mon_CHRIN
fe10 20 19 d9           JSR Is_Dec
fe13 b0 e7              BCS GeCo_50
fe15 90 a6              BCC GeCo_25         ; finished


              ; **************
fe17            Expand_Address
              ; **************

fe17 ac c0 02           LDY Ass_Buf_Length
fe1a b9 c0 02 ExAd_10   LDA Ass_Buf-1,Y
fe1d c9 24              CMP #'$'
fe1f f0 06              BEQ ExAd_20
fe21 99 c2 02           STA Ass_Buf+1,Y
fe24 88                 DEY
fe25 d0 f3              BNE ExAd_10
fe27 a9 30    ExAd_20   LDA #'0'
fe29 99 c1 02           STA Ass_Buf,Y
fe2c 99 c2 02           STA Ass_Buf+1,Y
fe2f ee c0 02           INC Ass_Buf_Length
fe32 ee c0 02           INC Ass_Buf_Length
fe35 60                 RTS ;Size   31 [Expand_Address]

              ; *************
fe36            Expand_Target
              ; *************

              ; Take branch offset, stored in Mon_Lo
              ; Convert it it to ASCII target of format $xxxx
              ; Store it in Ass_Buf after the branch mnemonic
              ; E.g.: BEQ $1234
              ;       ^   ^    ^
              ;       0   4    9

fe36 a9 24              LDA #'$'
fe38 8d c5 02           STA Ass_Buf+4
fe3b a0 15              LDY #21             ; 5 + 16
fe3d 20 46 fe           JSR Offset_To_Target
fe40 20 dc f9           JSR Store_Hex_XA
fe43 a0 09              LDY #9              ; length of branch instruction
fe45 60                 RTS ;Size   16 [Expand_Target]


              ; ****************
fe46            Offset_To_Target
              ; ****************

              ; Input:  Mon_Lo  = Offset
              ;         STAL    = PC
              ; Output: X       = Target Hi
              ;         A       = Target Lo

fe46 a6 fc              LDX STAL+1
fe48 a5 c2              LDA Mon_Lo
fe4a 10 01              BPL OTT_10
fe4c ca                 DEX
fe4d 18       OTT_10    CLC
fe4e 65 fb              ADC STAL
fe50 90 01              BCC OTT_20
fe52 e8                 INX
fe53 18       OTT_20    CLC
fe54 69 02              ADC #2
fe56 90 01              BCC OTT_30
fe58 e8                 INX
fe59 60       OTT_30    RTS ;Size   20 [Offset_To_Target]

fe5a                    .SIZE ;   20 [Offset_To_Target]

              ; *******
fe5a            Replace
              ; *******

fe5a 20 76 00           JSR CHRGOT
fe5d c9 22              CMP #QUOTE
fe5f f0 06              BEQ Repl_00
fe61 20 fb b4           JSR Tokenize_Line
fe64 20 70 00           JSR CHRGET
fe67 85 23    Repl_00   STA RENNEW          ; 1st. delimiter
fe69 a6 77              LDX TXTPTR
fe6b e8       Repl_01   INX
fe6c bd 00 02           LDA BUF,X
fe6f f0 4a              BEQ Repl_Err
fe71 c5 23              CMP RENNEW          ; 2nd. delimiter ?
fe73 d0 f6              BNE Repl_01
fe75 86 25              STX RENNEW+2        ; remember position
fe77 a9 00              LDA #0
fe79 9d 00 02           STA BUF,X
fe7c 8a                 TXA
fe7d 18                 CLC                 ; subtract one more
fe7e e5 77              SBC TXTPTR
fe80 85 26              STA RENNEW+3        ; length of search string
fe82 e8       Repl_02   INX
fe83 bd 00 02           LDA BUF,X
fe86 f0 33              BEQ Repl_Err
fe88 c5 23              CMP RENNEW          ; 3rd. delimiter ?
fe8a d0 f6              BNE Repl_02
fe8c a9 00              LDA #0
fe8e 9d 00 02           STA BUF,X
fe91 8a                 TXA
fe92 18                 CLC                 ; subtract one more
fe93 e5 25              SBC RENNEW+2
fe95 85 27              STA RENNEW+4        ; length of replace string
fe97 20 4d ed           JSR Reset_Renumber_Pointer
fe9a a0 03    Repl_08   LDY #3
fe9c 84 24              STY RENNEW+1        ; start position for scan
fe9e 20 35 f3 Repl_10   JSR Check_STOP_Key  ; STOP key pressed?
fea1 f0 15              BEQ Repl_Ret
fea3 20 c5 ed           JSR Contains_Pattern
fea6 d0 08              BNE Repl_20
fea8 20 be fe           JSR Replace_String
feab e6 24              INC RENNEW+1
fead 4c 9e fe           JMP Repl_10
feb0 20 5e ed Repl_20   JSR Update_Link
feb3 d0 e5              BNE Repl_08
feb5 20 f0 b5           JSR Reset_Variable_Pointer
feb8 4c ff b3 Repl_Ret  JMP Basic_Ready
febb 4c 00 bf Repl_Err  JMP Syntax_Error


              ; **************
febe            Replace_String
              ; **************

febe 38                 SEC
febf a5 27              LDA RENNEW+4        ; length of replacement string
fec1 e5 26              SBC RENNEW+3        ; length of search string
fec3 85 23              STA RENNEW          ; difference
fec5 d0 20              BNE ReSt_30
fec7 98       ReSt_05   TYA
fec8 38                 SEC
fec9 e5 26              SBC RENNEW+3        ; length of search string
fecb a8                 TAY
fecc a6 25              LDX RENNEW+2        ; position of replacement
fece e8       ReSt_10   INX
fecf bd 00 02           LDA BUF,X
fed2 f0 05              BEQ ReSt_20
fed4 91 5c              STA (TMPPTC),Y
fed6 c8                 INY
fed7 d0 f5              BNE ReSt_10         ; always
fed9 a5 23    ReSt_20   LDA RENNEW
fedb f0 03              BEQ ReSt_25
fedd 20 b6 b4           JSR Rechain
fee0 20 f9 ea ReSt_25   JSR List_BASIC_Line
fee3 20 25 d5           JSR Mon_Print_CR
fee6 60                 RTS ;Size   41 [Replace_String]
fee7 90 38    ReSt_30   BCC ReSt_50
fee9 98                 TYA
feea 48                 PHA
feeb a5 5c              LDA TMPPTC
feed 48                 PHA
feee a5 5d              LDA TMPPTC+1
fef0 48                 PHA
fef1 18                 CLC
fef2 98                 TYA
fef3 65 5c              ADC TMPPTC
fef5 85 5c              STA TMPPTC
fef7 90 02              BCC ReSt_35
fef9 e6 5d              INC TMPPTC+1
fefb a5 2a    ReSt_35   LDA VARTAB          ; search str < replace str
fefd 85 57              STA TMPPTB
feff 65 23              ADC RENNEW
ff01 85 55              STA TMPPTA
ff03 a4 2b              LDY VARTAB+1
ff05 84 58              STY TMPPTB+1
ff07 90 01              BCC ReSt_40
ff09 c8                 INY
ff0a 84 56    ReSt_40   STY TMPPTA+1
ff0c 20 50 b3           JSR Open_Up_Space
ff0f a5 2e              LDA STREND
ff11 85 2a              STA VARTAB
ff13 a5 2f              LDA STREND+1
ff15 85 2b              STA VARTAB+1
ff17 68                 PLA
ff18 85 5d              STA TMPPTC+1
ff1a 68                 PLA
ff1b 85 5c              STA TMPPTC
ff1d 68       ReSt_45   PLA
ff1e a8                 TAY
ff1f d0 a6              BNE ReSt_05         ; always
ff21 98       ReSt_50   TYA
ff22 48                 PHA
ff23 65 5c              ADC TMPPTC
ff25 85 55              STA TMPPTA
ff27 a5 5d              LDA TMPPTC+1
ff29 69 00              ADC #0
ff2b 85 56              STA TMPPTA+1
ff2d 38                 SEC
ff2e a5 26              LDA RENNEW+3        ; length of search string
ff30 e5 27              SBC RENNEW+4        ; length of replacement string
ff32 85 23              STA RENNEW
ff34 38                 SEC
ff35 a5 55              LDA TMPPTA
ff37 e5 23              SBC RENNEW
ff39 85 57              STA TMPPTB
ff3b a5 56              LDA TMPPTA+1
ff3d e9 00              SBC #0
ff3f 85 58              STA TMPPTB+1
ff41 a0 00              LDY #0
ff43 b1 55    ReSt_60   LDA (TMPPTA),Y
ff45 91 57              STA (TMPPTB),Y
ff47 e6 57              INC TMPPTB
ff49 d0 02              BNE ReSt_62
ff4b e6 58              INC TMPPTB+1
ff4d e6 55    ReSt_62   INC TMPPTA
ff4f d0 02              BNE ReSt_64
ff51 e6 56              INC TMPPTA+1
ff53 a5 2a    ReSt_64   LDA VARTAB
ff55 c5 55              CMP TMPPTA
ff57 d0 ea              BNE ReSt_60
ff59 a6 2b              LDX VARTAB+1
ff5b e4 56              CPX TMPPTA+1
ff5d d0 e4              BNE ReSt_60
ff5f e5 23              SBC RENNEW
ff61 85 2a              STA VARTAB
ff63 85 2e              STA STREND
ff65 8a                 TXA
ff66 e9 00              SBC #0
ff68 85 2b              STA VARTAB+1
ff6a 85 2f              STA STREND+1
ff6c 4c 1d ff           JMP ReSt_45
ff6f 60       ReSt_Ret  RTS ;Size  178 [Replace_String]

ff70 00 00 00           .FILL $ff93-* (0) ; 35 bytes

              ; ************
ff93            Basic_CONCAT
              ; ************

ff93 4c c7 da           JMP Kernal_CONCAT

              ; ***********
ff96            Basic_DOPEN
              ; ***********

ff96 4c 42 d9           JMP Kernal_DOPEN

              ; ************
ff99            Basic_DCLOSE
              ; ************

ff99 4c 07 da           JMP Kernal_DCLOSE

              ; ************
ff9c            Basic_RECORD
              ; ************

ff9c 4c af d7           JMP Kernal_RECORD

              ; ************
ff9f            Basic_HEADER
              ; ************

ff9f 4c d2 d9           JMP Kernal_HEADER

              ; *************
ffa2            Basic_COLLECT
              ; *************

ffa2 4c 65 da           JMP Kernal_COLLECT

              ; ************
ffa5            Basic_BACKUP
              ; ************

ffa5 4c 7e da           JMP Kernal_BACKUP

              ; **********
ffa8            Basic_COPY
              ; **********

ffa8 4c a7 da           JMP Kernal_COPY

              ; ************
ffab            Basic_APPEND
              ; ************

ffab 4c 77 d9           JMP Kernal_APPEND

              ; ***********
ffae            Basic_DSAVE
              ; ***********

ffae 4c 0d db           JMP Kernal_DSAVE

              ; ***********
ffb1            Basic_DLOAD
              ; ***********

ffb1 4c 3a db           JMP Kernal_DLOAD

              ; ***************
ffb4            Basic_DIRECTORY
              ; ***************

ffb4 4c 73 d8           JMP Kernal_DIRECTORY

              ; ************
ffb7            Basic_RENAME
              ; ************

ffb7 4c 55 db           JMP Kernal_RENAME

              ; *************
ffba            Basic_SCRATCH
              ; *************

ffba 4c 66 db           JMP Kernal_SCRATCH

              ; *******
ffbd            Read_DS
              ; *******

ffbd 4c 91 d9           JMP Kernal_Read_DS

              ; ****
ffc0            OPEN
              ; ****

ffc0 4c 60 f5           JMP Kernal_OPEN

              ; *****
ffc3            CLOSE
              ; *****

ffc3 4c dd f2           JMP Kernal_CLOSE

              ; *****
ffc6            CHKIN
              ; *****

ffc6 4c af f7           JMP Kernal_CHKIN

              ; ******
ffc9            CHKOUT
              ; ******

ffc9 4c fe f7           JMP Kernal_CHKOUT

              ; ******
ffcc            CLRCHN
              ; ******

ffcc 4c a6 f2           JMP Kernal_CLRCHN

              ; *****
ffcf            CHRIN
              ; *****

ffcf 4c 15 f2           JMP Kernal_CHRIN

              ; ******
ffd2            CHROUT
              ; ******

ffd2 4c 66 f2           JMP Kernal_CHROUT

              ; **********
ffd5            Basic_LOAD
              ; **********

ffd5 4c 01 f4           JMP Kernal_LOAD

              ; **********
ffd8            Basic_SAVE
              ; **********

ffd8 4c dd f6           JMP Kernal_SAVE

              ; ************
ffdb            Basic_VERIFY
              ; ************

ffdb 4c f6 f4           JMP Kernal_VERIFY

              ; *********
ffde            Basic_SYS
              ; *********

ffde 4c c3 f6           JMP Kernal_SYS

              ; ****
ffe1            STOP
              ; ****

ffe1 4c 43 f3           JMP Kernal_STOP

              ; *****
ffe4            GETIN
              ; *****

ffe4 4c 05 f2           JMP Kernal_GETIN

              ; *****
ffe7            CLALL
              ; *****

ffe7 4c a2 f2           JMP Kernal_CLALL

              ; *****
ffea            UDTIM
              ; *****

ffea 4c 68 f7           JMP Kernal_UDTIM
ffed 8c 8c 8c           .FILL $fffa-* ($8c) ; 13 bytes

              ; ***************
fffa            HardwareVectors
              ; ***************

fffa 49 fd              .WORD Entry_NMI
fffc 16 fd              .WORD Entry_RESET
fffe 42 e4              .WORD IRQ_MAIN


 1868 Symbols
-------------
Basic_USR                      $0000   267D  1144   7081
BSOS_KBD                       $0001    15D 10727  10740  10751  10810
                                     10823  10841  10854  10865  10924
                                     10937
USRVEC                         $0001   268D  7084   7085
CTRLA                          $0001   243D  9465
CTRLB                          $0002   244D  9449   9606
CHARAC                         $0003   270D  2364   2368   2369   3064
                                      3069   3073   3779   3788   4676
                                      4691   6238   6733   6790
ENDCHR                         $0004   271D  1707   1755   1758   2366
                                      2367   2370   2373   3076   4677
                                      4693
CTRLD                          $0004   245D  9461   9616
COUNT                          $0005   272D  1560   1609   1625   1722
                                      1739   1765   4145   4232   4286
                                      4310   4334   4372   4404  11292
                                     11307  11315
DIMFLG                         $0006   279D  3897   4200   4239   4283
                                      4317   4368
VALTYP                         $0007   285D  2490   2777   3057   3247
                                      3295   3317   3424   3610   3830
                                      3914   3928   4203   4235   4475
                                      4491   4736   5189
BELL                           $0007   246D  9445
INTFLG                         $0008   291D  2488   3090   3642   3915
                                      3935   4201   4237
GARBFL                         $0009   306D  1698   1710   1751   3704
                                      3707   3708   3711   4754   4791
                                      4795
TAB                            $0009   247D  9453   9602
SUBFLG                         $000a   312D  1891   2053   3932   3944
                                      3949   4535   4560
INPFLG                         $000b   316D  2892   3019   3038   3059
                                      3141
TANSGN                         $000c   326D  3393   3868   6949   6951
                                      6969   6979
DS_Len                         $000d   330
CR                             $000d   248D  1676   2800   7296   7969
                                      7999   8406   8436   8444   8446
                                      9171   9241   9429   9586  11623
                                     11856  11979  12469  13395  13821
CTRLN                          $000e   249D  9447   9612
DS_Ptr                         $000e   331
CTRLO                          $000f   250D  9451   9610
IOPMPT                         $0010   338D  1499   2753   2793   2867
                                      2902   2926   2933   2946   2953
                                      2956   2980   2999   3047   3147
                                      3558   7091
DOWN                           $0011   251D  9441   9596
LINNUM                         $0011   346D  1617   1618   1801   1806
                                      1926   1927   1929   1952   1954
                                      2287   2434   2435   2437   2458
                                      2460   2462   2463   2464   2466
                                      2467   2468   2469   2471   2472
                                      2474   5299   5300   5307   5309
                                      5313y  5316   5318   5328y  5343y
                                      7096   7097   7102y  7105y  7106y
                                      7109y  7110y  7113y  7116   7118
                                      8216   8218   8857   8859   8862
                                      8869   8871   8873   8975   8978
                                      9841   9842   9844  10594  10596
                                     10692  10695  11049  11050  11067
                                     11071  11075  11078  11228  11230
                                     11500  11501  11636  11638  12693
                                     12901  13829  13831  13834
RVS                            $0012   252D  9443   9598
HOME                           $0013   253D  9463   9600
TEMPPT                         $0013   351D  1880   4720   4741   5063
LASTPT                         $0014   356D  4737   5059   5061   5065
                                      7092
DEL                            $0014   254D  9435   9590
CTRLU                          $0015   255D  9459   9614
TEMPST                         $0016   363D  1879   4721
CTRLV                          $0016   256D  9457   9604
CTRLY                          $0019   257D  9455   9608
ESC                            $001b   258D  9431
RIGHT                          $001d   259D  2871   9439   9594
INDEXA                         $001f   367D  1400   1410   1416   1565
                                      1567   1590   1592   1594y  1598
                                      1650y  1654   1657y  1659   1661y
                                      1662   1663   1664y  1725   1727
                                      1730   1732   1735y  1766y  1768
                                      1770   1773y  2022   2024   2028
                                      2030   2031y  2035y  2561y  2635
                                      2636   2649   2651   2682y  2686y
                                      2689y  2696   2697   2701   2703
                                      2854y  3300   3302   3357   3359
                                      3374   3376   4047   4048   4050y
                                      4053y  4056y  4060y  4068y  4072
                                      4073   4075   4076   4082y  4086y
                                      4090y  4099   4102   4106   4107
                                      4109   4333   4401   4434   4761
                                      4764   4769   4781y  4784y  4836
                                      4838   4841y  4851   4855y  4866y
                                      4876y  4879y  4969   4970   4980y
                                      5013   5014   5024   5025   5040y
                                      5043y  5046y  5048   5049   5107
                                      5108   5110   5200y  5240   5243
                                      5245   5756   5757   5759y  5762y
                                      5765y  5768y  5776y  5956   5957
                                      5959y  6011   6012   6015y  6018y
                                      6021y  6026y  6029y  8678y  8794y
                                      8800   8802   8812   8813  10222
                                     10225  12390  12392
RENINC                         $0021   375D  8849   8852   8870   8874
                                      8924   8927   9833   9835   9851y
                                      9854   9858   9859
INDEXB                         $0021   371D  1569   1576   1588   1595y
                                      1599   3188   5244   5249   5251y
                                      5254y  5259y  6141   6147   6149y
                                      6153y  6158y  6163y  6167y  6173
QUOTE                          $0022   260D  1989   1998   2376   2965
                                      3070   3443   4675   4695   7599
                                      7603   8598   8705   9258   9262
                                     11177  11183  11409  11432  13910
FAC3M1                         $0023   379D  5589   5592   5691   5732
                                      5734   5735   5942
RENNEW                         $0023   388D  8850   8853   8858   8863
                                      8883   8886   8914   8917   8923
                                      8925   8926   8928   8997   9009
                                     11330  11333  11347  11352  11356
                                     13914  13919  13921  13927  13931
                                     13937  13938  13941  13947  13961
                                     13962  13963  13967  13969  13976
                                     13997  14024  14025  14026  14029
                                     14049
FAC3M2                         $0024   380D  5587   5590   5692   5729
                                      5731   5736   5944
FAC3M3                         $0025   381D  4415   4436   4461   5585
                                      5588   5693   5726   5728   5737
                                      5946
FAC3M4                         $0026   382D  4444   4464   5583   5586
                                      5694   5723   5725   5738   5891
                                      5948
FAC3M5                         $0027   384
TXTTAB                         $0028   392D  1644   1645   1787   1788
                                      1830y  1832y  1833   1837   1899
                                      1902   2192   2194   2296   2297
                                      6421   6422   7095   7101   7129
                                      7132  10217y 10219y 10620  10623
                                     10681  10682  11258  11260  12302
                                     12303  12703  12705
VARTAB                         $002a   396D  1566   1574   1575   1577
                                      1579   1584   1607   1611   1623
                                      1624   1836   1839   1867   1868
                                      2607   2611   3950   3951   6432
                                      6434   9019   9020   9848  12225
                                     12228  12246  12248  12699  12701
                                     13995  13999  14006  14008  14043
                                     14046  14050  14054
ARYTAB                         $002c   400D  1869   1870   3954   3956
                                      4015   4016   4033   4034   4240
                                      4241
STREND                         $002e   404D  1395   1396   1621   1622
                                      1871   1872   4019   4020   4043
                                      4045   4244   4246   4346   4347
                                      4360   4364   4481   4484   4772
                                      4775  11367  11489  11568y 11599y
                                     14005  14007  14051  14055
FRETOP                         $0030   408D  1459   1462   1471   1474
                                      1860   1861   2600   2604   2691
                                      2694   4093   4096   4480   4483
                                      4759   4762   4787   4788   4812
                                      4814   4882   4884   5026   5028
                                      5033   5036   7121   7122  11376
FRESPC                         $0032   412D  4777   4778   4785   4786
                                      4806   4809   4846   4848   4849
                                      4852y  4854   4856   4858   4862
                                      4869y  4873y  4875   4878   4881
                                      4883   4981y  4986   4987   4989
MEMSIZ                         $0034   416D  1858   1859   4805   4808
                                      7119   7120   7127   7131
CURLIN                         $0036   422D  1513   1545   2072   2074
                                      2127   2130   2215   2220   2221
                                      2246   2247   2268   2270   2286
                                      2326   2328   2899   2900   3206
                                      3208   4514   6448   6449
OLDLIN                         $0038   427D  2222   2223   2244   2245
OLDTXT                         $003a   434D  1890   2116   2117   2218
                                      2219   2238   2241   2909   2910
DATLIN                         $003c   442D  2897   2898   3126   3130
DATPTR                         $003e   448D  2197   2198   3009   3010
INPPTR                         $0040   454D  3020   3021   3032   3033
                                      3103   3104   3139   3140   3145
VARNAM                         $0042   464D  3608   3609   3903   3936
                                      3937   3942   3958   3961   3996
                                      3997   4113   4116   4208   4210
                                      4214   4216   4251   4253   4299
                                      4304   4408   4411
VARPTR                         $0044   470D  4135   4136   4420   4423
                                      4425   4542   4544   4582   4587
                                      4589y  4593   4604   4606   6607
                                      6619
FORPNT                         $0046   475D  1366   1369   1371   1374
                                      2097   2099   2314   2484   2485
                                      2508y  2511y  2521   2640   2643
                                      2648   2650   2664y  3026   3027
                                      3176   3177   3195   3196   5336
                                      5341   5344   5345   6003   6004
YSAVE                          $0048   481D  3030   3031   3105   3106
                                      3311   3390
ACCSYM                         $004a   485D  3274   3283   3284   3286
                                      3290   3325   3340   3831
FUNCPT                         $004b   491D  4562   4563   4577   4579
                                      4581y  4585y  4599y  4602y  4610
                                      4612   4622y  4625y  4628y  4631y
                                      4634y  4807   4810   4813   4815
                                      4818   4820   4822   4825y  4829
                                      4830y  4831   4833   4837y  4840
                                      4842   4844   4860   4863   4868y
                                      4872y  6722   6723   6728   6729
                                      6738   6739   6971   6972   6981
                                      6982
DESCPT                         $004d   495D  2633   2634   2663y  4658
                                      4659   4940   4941   5090y  5093y
                                      5100   5101   5121y  5143y  5165
                                      5167
INDEXC                         $004f   499D  2641y  2644y  2655y  2658y
                                      2702   2705   5020y  5023y  5031
                                      5034
JUMPER                         $0051   504D  3764   7080
FUNJMP                         $0052   509D  3761   3763   5159   5168
                                      5390   5420   5434   5485   6783
                                      6800
FACTPA                         $0054   514D  5995   5996   6822   6825
                                      6826   6974   6975
TMPPTA                         $0055   515D  1415   1417   1419   1422y
                                      1426y  1428   1610   1615   4027
                                      4028   4030   4031   4035   4036
                                      4041   4042   4057   4058   4061
                                      4062   4077   4079   4152   4153
                                      4336   4338   4341   4353y  4355
                                      4358   4419   4422  13998  14003
                                     14019  14022  14028  14031  14035y
                                     14040  14042  14044  14047
TMPPTB                         $0057   516D  1398   1402   1408   1411
                                      1413   1421y  1425y  1427   1608
                                      1612   4021   4022   4087   4092
                                      4100y  4103y  8882y  8885y 10625
                                     10627  10683  10684  10698  10700
                                     13996  14000  14030  14033  14036y
                                     14037  14039
FACTPB                         $0059   521D  5988   6860   6861
TMPVAR                         $005a   522D  3619   3623   4446   4467
                                      6257   6289   6296   6298   6299
                                      6304   6309   6321   6346   6356
                                      6363   6483   6515   6524   6530
                                      6546   6557   6558   6613   6640
                                      6645
TMPPTC                         $005c   523D  1399   1403   1564y  1568
                                      1570   1572y  1580   1583   1628y
                                      1795   1796   1797y  1802y  1807y
                                      1811y  1937y  1945y  1948y  1966y
                                      1969y  1970   1971   1995y  2004y
                                      2300   2303   3952   3953   3959y
                                      3963y  3968   4017   4018   4114y
                                      4117y  4120y  4122y  4124y  4126y
                                      4128y  4129   4132   4148   4149
                                      4242   4243   4249y  4254y  4257y
                                      4259   4262y  4263   4288y  4300y
                                      4305y  4314y  4326y  4329y  4361
                                      4363y  4366   4367y  4371y  4382y
                                      4387y  4435y  4438y  6282   6285
                                      6292   6293   6319   6350   8902y
                                      8908y  8911y  8959y  8962y  8969y
                                      8972y  9008y  9015   9018   9832
                                      9834   9850y  9855   9856  10619
                                     10622  10626  10628  10648y 10651y
                                     10652  10653  10666y 10669y 10672y
                                     10685  10686  10688y 10691y 10694y
                                     10697  10699  10703y 10706y 11165
                                     11168  11259  11261  11278y 11281y
                                     11282  11283  11354y 11357y 13973y
                                     13985  13987  13991  13992  13994
                                     14010  14012  14018  14020
FAC1EX                         $005e   527D  2390   2528   2628   2629
                                      3372   3408   3833   3843   3847
                                      4183   4668   4698   4725   4891
                                      5293   5372   5411   5414   5421
                                      5428   5481   5509   5513   5520
                                      5653   5657   5778   5788   5795
                                      5828   5869   5870   5872   5960
                                      5969   6028   6046   6063   6074
                                      6091   6125   6156   6189   6226
                                      6231   6341   6500   6750   6785
                                      6795   6796   6909   6912   7015
FAC1M1/FAC1M2                  $005f   528D  2081   2082   3370   3679
                                      3834   3860y  4492   4666   4685
                                      4727   5080y  5447   5461   5464
                                      5496   5498   5506   5522   5541
                                      5543   5569   5703   5877   5915
                                      5943   5965   5968   5976   6025
                                      6110   6114   6160   6199   6455
                                      6589   6591   6882   6900   6902
                                     11231    529D  2550   3368   3835
                                      4493   4667   4686   4729   5444
                                      5463   5466   5493   5495   5505
                                      5523   5544   5546   5567   5701
                                      5880   5912   5945   5977   6020
                                      6112   6164   6200   6456   6586
                                      6588   6884   6903   6905  11229
FAC1M3/FAC1M4                  $0061   530D  2507   2591y  2594y  2610
                                      2613   2620y  2625   2730   2731
                                      3366   3476   3606   3645y  3648y
                                      3720   3747   3781   3793   3798
                                      4224   4379   4398   4656   4732
                                      4923   4934y  5002   5224   5297
                                      5441   5465   5468   5490   5492
                                      5504   5524   5547   5549   5565
                                      5699   5883   5909   5947   5978
                                      6017   6124   6168   6201   6583
                                      6585   6886   6904   6906    531D
                                      2414   2510   2606   2614   2626
                                      2727   2728   3364   3473   3607
                                      3612   3657   3721   3745   3783
                                      3790   3795   4226   4381   4402
                                      4657   4733   4921   5003   5130
                                      5146   5148   5226   5298   5438
                                      5467   5470   5487   5489   5503
                                      5525   5550   5552   5563   5697
                                      5886   5906   5949   5979   6014
                                      6123   6174   6202   6232   6237
                                      6580   6582   6888   6899   6901
FAC1SI                         $0063   532D  2079   2094   2529   2723
                                      3194   3361   3406   3849   3855
                                      4176   5291   5367   5369   5416
                                      5482   5533   5535   5770   5798
                                      5800   5966   6023   6043   6093
                                      6127   6134   6154   6176   6207
                                      6233   6339   6489   6493   6752
                                      6754   6908   6943   6947   6978
                                      7011   7014   7031
SGNFLG                         $0064   533D  6265   6312   6842   6862
BITS                           $0065   535D  4893   4899   4900   6196
FAC2EX                         $0066   539D  3395   3824   3825   5391
                                      5392   5429   5431   5777   5785
                                      6045   6064   6719   6794   6797
FAC2M1                         $0067   540D  3397   3822   3823   5497
                                      5733   5774   5876   5900   5914
                                      5916
FAC2M2                         $0068   541D  3399   5494   5730   5766
                                      5879   5899   5911   5913
FAC2M3/FAC2M4                  $0069   542D  3401   3836   3839   3859y
                                      5491   5727   5763   5882   5898
                                      5908   5910    543D  3403   3837
                                      3840   5488   5724   5760   5885
                                      5897   5905   5907
FAC2SI                         $006b   544D  3405   3820   5370   5415
                                      5769   5772   6037   6338   6725
                                      6933
STRPTR/FROUND                  $006c   548D  2592   2595   2599   2603
                                      2622   2623   3407   4683   4684
                                      4689y  4700   4702   4706   4712
                                      4713   4928   4930   4932y  4944
                                      4945   4955y  4958y  4961y  5371
                                      5426   5771   5797   5826   5851
                                      6340   6808   6938    553D  4734
                                      4898   5389   5424   5435   5469
                                      5471   5486   5502   5526   5553
                                      5555   5556   5584   5605   5695
                                      5739   5927   5964   6030   6049
                                      6067   6076   6126   6172   6203
                                      6204   6212   6779   6801   6910
TMPPTD                         $006e   557D  1720   1740   2530   2533
                                      2534   2542   3621   4297   4309
                                      4331   4332   4349   4350   4356
                                      4374   4375   4392   4393   4403
                                      4406   4456   4457   4701   4705
                                      5238   5239   5265   5266   6494
                                      6562   6571   6608   6618   6631
                                      6819   6820   6833   6834   6841y
                                      6843   6847   6848   6849   6851
                                      6852   6857   6858
CHRGET                         $0070   577D  1541   1921   2091   2172
                                      2418   2441   2837   2922   3056
                                      3221   3287   3425   3435   3521
                                      3549   3736   3916   3921   3941
                                      4168   5211   6266   6272   6283
                                      7088   8619   8669   8690   8698
                                      8765   8822   8867   8878   9839
                                     11222  11314  11329  12893  12992
                                     13913
CHRGOT                         $0076   578D  1917   2088   2182   2274
                                      2385   2399   2759   3036   3095
                                      3109   3218   3275   3552   3882
                                      3891   3904   4229   4613   5131
                                      5227   5255   5338   7743   7760
                                      7770   8578   8685   8732   8854
                                      8864   8875   9829   9836  10519
                                     11246  12400  12416  13016  13909
TXTPTR                         $0077   579D  1539   1540   1696   1723
                                      1764   1778   1780   1901   1904
                                      2067   2069   2112   2115   2119y
                                      2122y  2126y  2129y  2132   2133
                                      2135   2213   2214   2242   2243
                                      2264   2266   2291   2292   2302
                                      2305   2330   2332   2346   2347
                                      2349   2371y  2911   2912   3028
                                      3029   3034   3035   3051   3052
                                      3062   3077   3078   3101   3102
                                      3107   3108   3122y  3125y  3128y
                                      3131y  3210   3212   3262   3264
                                      3265   3320   3322   3323   3450
                                      3451   3519y  4546   4548   4595
                                      4597   4600   4603   4617   4619
                                      5236   5237   5241   5246   5267
                                      5268   6360y  7058   7060   8659
                                      8661   8662y 10513  10518  11144
                                     11146  11147x 11167  11170  11294
                                     11306  11346  12125  12911y 12932
                                     12933y 12943y 13019  13021y 13026
                                     13028  13915  13926
ISNUM                          $007d   580D  2562
RNDX                           $0088   584D  6890   6891   6914   6915
JIFFY_CLOCK                    $008d   593D  2551   3674   3675  10033
                                     12796  12798  12800  12801  12804
                                     12808  12809
CINV                           $0090   601D  7187   7189   7540   7542
                                      9796  10040  10042  13749  13751
CBINV                          $0092   609D  9795  13698  13700  13768
NMINV                          $0094   614D 13694  13696  13716
STATUS                         $0096   625D  2982   3561   3690   6426
                                      7947   7957   8461   9869  11372
                                     11382  11565  11570  11589  11601
                                     11642  11679  11697  11952  11977
                                     12145  12158  12178  12288  12330
                                     12351  12365  12437  12829  12840
                                     12868  12880  13008  13531  13532
Key_Index                      $0097   630D 10326  10359  10385
Key_Flags                      $0098   639D  6410  10036  10322  10324
                                     10364  10365  10439
Power_Flag                     $0099   646D  7222   9722  10496  10498
                                     10555  10571  10589  10610
Default_Bank                   $009a   652D 10038  11108  11129
Stop_Flag                      $009b   657D 10430  12097
Source_Unit                    $009c   662D  8274   8575   8636   8639
                                     11478  11558  11625  11674
VERCK                          $009d   667D  7591   7611   7636   8377
                                     12161  12215  12222  12239  12276
                                     12349  12910
CharsInBuffer                  $009e   671D  9136   9138   9148   9165
                                     10415  10422  11955  12102  12982
                                     13413
ReverseFlag                    $009f   675D  9269   9484   9632   9733
C3PO                           $00a0   679D 11754  11760  11885  11887
LastInputCol                   $00a1   681D  9181   9189   9237  11975
InputRow                       $00a3   682D  9184   9706  11969
InputCol                       $00a4   683D  9187  11967
BSOUR                          $00a5   694D 11765  11781  11805  11876
                                     11892
SFDX                           $00a6   720D 10327  10431
BLNSW                          $00a7   727D  9149   9803  10064
BLNCT                          $00a8   734D  9157   9277   9805   9808
                                     10063
GDBLN                          $00a9   743D  9158   9814
BLNON                          $00aa   750D  9152   9155   9810   9813
Wedge_Unit                     $00ab   755D  7099  12895  12902  13005
                                     13030  13736  13738
CRSW                           $00ac   760D  9174   9211   9240   9423
                                     11973
Target_Unit                    $00ad   762D 11477  11526  11584  11618
                                     11692
LDTND                          $00ae   769D  8056   8185  12004  12033
                                     12079  12080  12082  12435  12440
DFLTN                          $00af   773D 11953  11964  12014  12026
                                     12843
DFLTO                          $00b0   777D  9243  10046  11990  12010
                                     12024  12883
DOS_FC                         $00b1   787D 11445  11506  11576  11604
DOS_EOF                        $00b2   788D 11571  11607
PC_Adjust                      $00b3   789D  7170   7182   7198   7410
                                     12490  12492
SCROLLING                      $00b4   790
MONCNT                         $00b5   791D  7242   7251   7254   7270
                                      7402   7405   7508   7522  13661
                                     13672
R_Bank                         $00b6   796D  7193   7383   7496   7983
                                      8896   8993  11062  11103
W_Bank                         $00b7   797D  7195   7385   7498   7991
                                      8897   8953  11123  13562
ZP_b8                          $00b8   798
DOS_RL                         $00b9   799D  9877   9881   9883  11499
                                     11514  11537  11549  11573  11578
                                     11590  11609  11683
Dis_Line                       $00ba   800D  7423   7425   7427   7465
                                      7478   9968  13372
DosPtr                         $00bb   801D 11399  11401  11403  11408y
                                     11415  11417  11488  11492
Mon_Format                     $00bd   802D 12573  13208
Dis_Length                     $00be   803D 12507  12517  12575  13211
                                     13219  13377
Mon_A                          $00bf   804D 12772  12778  13209  13224
                                     13229  13564  13568  13602  13608
                                     13612  13615
Mon_B                          $00c0   805D 12774  12777
Mon_Op                         $00c1   806D 12501  12530  13332  13351
                                     13364  13378  13381
Mon_Lo                         $00c2   807D 13227  13312  13316  13333
                                     13785  13789  13790  13799  13800
                                     13814  13828  13833  13890
Mon_Hi                         $00c3   808D 13222  13309  13334  13786
                                     13795  13810  13830  13835
ScrPtr                         $00c4   813D  9160y  9176y  9219y  9275y
                                      9322y  9389y  9391y  9398y  9517y
                                      9555y  9560y  9563y  9567y  9680y
                                      9743y  9811y  9816y 10154  10158
                                     10565y 10576y 10636
CursorCol                      $00c6   814D  2810   2829   4501   9081
                                      9159   9188   9218   9235   9288
                                      9314   9333   9369   9372   9386
                                      9388   9424   9476   9559   9650
                                      9651   9678   9724   9809   9902
                                      9905  10559  10600  10614  10634
                                     11966
SAL                            $00c7   816D  9098   9099   9100y  9742y
                                     10128  10132
EAL                            $00c9   817D  6423   6424   6431   6433
                                      7633  11369  11371  11374  11379
                                     11381y 12143  12144  12151  12153
                                     12163y 12168y 12169y 12170y 12172
                                     12174  12227  12230  12245  12247
                                     12258  12260  12304  12305  12700
                                     12702  12740  12742
Mon_Tmp                        $00cb   819D  7516   7519   7725   7730
                                     13792  13823
Mon_ZP                         $00cc   820D 13366  13368  13811
QTSW                           $00cd   840D  9183   9231   9260   9261
                                      9437   9588   9734  10587  10674
BITTS                          $00ce   842
EOT                            $00cf   843
ZD0                            $00d0   844
FNLEN                          $00d1   846D  6417   7616   8299   8516
                                      8572   8674   9886  11437  11504
                                     11536  11539  11540  11551  11552
                                     11666  12137  12289  12319  12338
                                     12366  12389  12726  13025  13496
LA                             $00d2   847D  7749   7939   8176   8200
                                      8568   8612  12050  12062  12370
                                     12425  12441
SA                             $00d3   848D  6420   7593   7629   7937
                                      8062   8120   8214   9873   9990
                                     10010  11562  11587  11596  11621
                                     11628  11677  11695  12052  12139
                                     12192  12195  12232  12291  12301
                                     12322  12364  12376  12443  12445
                                     12725  12730  12759  12838  12878
                                     13460
FA                             $00d4   849D  7622   8114   8117   8184
                                      8276   8577   8778  11476  11479
                                     11527  11559  11585  11619  11626
                                     11675  11693  11764  12054  12133
                                     12293  12298  12373  12447  12720
                                     12842  12882  13006  13031  13723
RigMargin                      $00d5   851D  9173   9278   9311   9323
                                      9352   9370   9393   9475   9518
                                      9554   9570   9643   9744  10568
                                     10637  11974
TAPE1                          $00d6   852
CursorRow                      $00d8   853D  9074   9087   9185   9309
                                      9312   9504   9525   9641   9662
                                      9664   9692   9707   9712  10557
                                     10570  10579  10602  10612  10631
                                     10654  11968
DATAX                          $00d9   854D  9224   9226   9227   9246
                                      9251   9410   9425
FNADR                          $00da   855D  6413   6415   7574   7576
                                      7605y  8301   8303   8518   8520
                                      9888y 11416  11418  11421y 11425y
                                     11428y 11431y 11440y 11455y 11510y
                                     11517y 11522y 11532  11652y 11657y
                                     11664y 11682y 11700y 12335y 12391
                                     12393  13027  13029
INSRT                          $00dc   856D  9272   9274   9433   9569
                                      9572   9592   9732
ROPRTY                         $00dd   857
FSBLK                          $00de   858
ScreenRows                     $00df   859D  9115   9344  10069
TopMargin                      $00e0   860D  9062   9073   9308   9342
                                      9359   9505   9523   9526   9661
                                      9690   9693   9696   9756   9769
                                     10532  10543  10632  10640  10643
                                     10646
BotMargin                      $00e1   861D  9065   9351   9642   9708
                                      9754   9771  10531  10544  10561
LefMargin                      $00e2   862D  9080   9287   9307   9332
                                      9343   9360   9385   9506   9649
                                      9677   9723  10143  10512
XMAX                           $00e3   863D 10044  10416
LSTX                           $00e4   864D 10387  10392  10409
KOUNT                          $00e5   865D 10066  10398  10404
DELAY                          $00e6   866D 10065  10394  10396  10411
CHIME                          $00e7   867D 10085  10098  10107
PrevChar                       $00e8   873D  9299   9530  10032
SCRIV                          $00e9   874D  9205  10078  10079
SCROV                          $00eb   875D  9415  10082  10083
JIFFY6                         $00f8   876D 12810  12813
BPTR                           $00f9   877D  7510   7512   8985   8995
                                      8998   9924   9935   9937  11127y
                                     11268  11270  13374  13376  13446
                                     13447  13449  13545  13560  13583
                                     13585  13611  13613  13614  13616
                                     13625  13627  13628
STAL                           $00fb   878D  7279   7281   7413   7415
                                      7435   7437   7509   7511   7660
                                      7662   7695   9002   9004   9011
                                      9016   9994y 10013y 11059  11061
                                     11106y 12704  12706  12732  12733
                                     12739  12744y 12750  13313  13373
                                     13375  13402  13406  13428  13429
                                     13431  13565  13584  13586  13598
                                     13600  13604  13606  13621  13623
                                     13624  13889  13894
MEMUSS                         $00fd   879D  7434   7436   7467   7468
                                      7475   8302   8304   8315y  8728
                                      8729   9927   9934   9936  13542
                                     13597  13599  13601  13603  13605
                                     13607
STACK                          $0100   888D  1363   1368   1370   1372
                                      1375   3190   3193   3199   3203
                                      3205   3207   3209   3211   4220
                                      4222   4225   4227   4648   4649
                                      6492   6565   6570   6612   6617
                                      6632   6648   6650   6658   6660
                                      6662   6665   6667   9792  11239
BUF                            $0200   893D  1604   1619   1620   1627
                                      1678   1699   1733   1743   1744
                                      1756   1761   1775   1777   2790
                                      2791   2792   2927   2928   2930
                                      2978   2987   3041   3042   3043
                                     11298  11350  13917  13923  13929
                                     13934  13971
LAT                            $0251   895D  8190  12036  12049  12083
                                     12084  12442
FAT                            $025b   896D  8188  12053  12085  12086
                                     12448
SAT                            $0265   897D  8059  12051  12087  12088
                                     12446
KEYD                           $026f   898D  9131   9133   9134   9167
                                     10421  12984  13399  13401  13404
                                     13405  13408  13409  13411
Bank_Fetch                     $027a   909D   908   7245   7258   7518
                                      9007  11064  11070  11074  11077
                                     11093  12529  13380  13561  13563
                                     13566  13567  13588  13617  13668
Bank_Store                     $028b   908D  7517   8909   8912   8915
                                      8918   8946   8960   8963   8976
                                      8979   9940  11175  11181  11190
                                     11206  11241  11247  13379  13589
                                     13618
Mon_Register                   $02a0   910D  7173   7175   7177   7179
                                      7183   7186   7188   7190   7192
                                      7194   7196   7278   7280   7384
                                      7386   7390   7392   7395   7397
                                      7401   7412   7414   7491   7495
                                      7497   7535   7537   7539   7541
                                      7548   7550   7552   7554   7556
                                      7557   7558   7565
Dis_Buf_Length                 $02b0   911D 13243  13283  13357
Dis_Buf                        $02b1   912D 12783  13214  13232  13236
                                     13265  13270  13280  13362
Ass_Buf_Length                 $02c0   913D 13350  13356  13846  13856
                                     13857
Ass_Buf                        $02c1   914D 13297  13301  13304  13339
                                     13347  13361  13804  13847  13850
                                     13854  13855  13872
Ass_Index                      $02d0   915D 13353  13393
IERROR                         $0300   920D  1492  13509
IMAIN                          $0302   921D  1532
ICRNCH                         $0304   922D  1690
IQPLOP                         $0306   923D  2006
IGONE                          $0308   924D  2141
IEVAL                          $030a   925D  3417
DOS_Tmp                        $033a   931D  7742   7769   8220   8300
                                      8312   8319   8573   8727  11503
DOS_Drive_1                    $033b   932D  8502   8570   8647  11680
DOS_Drive_2                    $033c   933D  8506   8571   8648   8716
                                     11423  11698
DOS_Attr                       $033d   934D  8491   8527   8532   8569
                                      8627   8653   8668
DOS_Flags                      $033e   947D  7792   7796   7813   7822
                                      7832   7925   8076   8235   8251
                                      8351   8567   8606   8617   8641
                                      8671   8710   8724   8741   8748
                                      8749   8797
DOS_Id                         $033f   948D  8152   8332   8335   8574
                                      8663
DOS_Command_Length             $0341   949D  8476   8478   8675   8681
DOS_Filename                   $0342   950D  7573   7575   8679  13492
                                     13648  13657  13669
DOS_Command_Buffer             $0353   951D  8083   8213   8215   8217
                                      8219   8221   8316   8333   8336
                                      8355   8508   8517   8519   9955
                                      9960   9984  10277  10288  11481
DOS_Status                     $03ad   952D  3633   3634   3709   8124
                                      8131   8133   8414   9874
TABS_SET                       $03ee   953D  9656   9658   9911  10073
Reset_Vector                   $03fa   954D 13702  13704
Ignore_Timeout                 $03fc   955D 11821  11830  13706
SCREEN_RAM                     $8000   957
Basic_Statement_Table          $b000  1080D  2168   2170
Basic_Function_Table           $b066  1138D  3760   3762
Basic_Operator_Table           $b094  1168D  3305   3327   3335   3337
                                      3349
Basic_Keyword_Table            $b0b2  1185D  1724   1726   2021   2023
Msg_Start                      $b20d  1284D  1484   1502   1682   2319
                                      2321   2904   3252   3527   4270
                                      4277   4282   4517   4524   4723
                                      4790   4936   5576   5935   8758
                                      8810
Msg_SYNTA                      $b21d  1288D  3527
Msg_GOSUB                      $b223  1289D  2319
Msg_QUANT                      $b242  1291D  4277   8758
Msg_FLOW                       $b252  1292D  5576
Msg_OOM                        $b25a  1293D  1484   4790
Msg_UNDEF                      $b267  1294D  2321
Msg_SUBSC                      $b278  1295D  4270
Msg_REDIM                      $b285  1296D  4282
Msg_DIV                        $b292  1297D  5935
Msg_DIREC                      $b2a2  1298D  4517
Msg_TYPE                       $b2b0  1299D  3252
Msg_LONG                       $b2bd  1300D  1682   4936   8810
Msg_DATA                       $b2cc  1301D  2904
Msg_COMPL                      $b2d5  1302D  4723
Msg_FUNC                       $b2f6  1304D  4524
Msg_ERR                        $b306  1305D  1510   1511
Msg_IN                         $b30d  1306D  6445   6446
Msg_READY                      $b312  1311D  1524   1525
Msg_BREAK                      $b31b  1317D  2226   2227
Find_Active_FOR                $b322  1351D  2055   2315   3178
FAF_10                         $b327  1363D  1381
FAF_20                         $b33c  1372D  1367
FAF_30                         $b348  1377D  1373
FAF_Ret                        $b34f  1382D  1365   1376
Open_Up_Space                  $b350  1385D  1616   4029  14004
OUS_10                         $b374  1415D  1412
OUS_20                         $b380  1421D  1424
OUS_30                         $b384  1423D  1418   1420   1430
OUS_40                         $b38b  1427D  1407
Check_Stack_Avail              $b393  1434D  2063   2263   3271
BSOS_Bank_Init                 $b399  1443D 10037
Check_Mem_Avail                $b3a0  1451D  1394   4295   4345
CMA_10                         $b3aa  1464D  1461
CMA_Ret                        $b3bd  1476D  1460   1463   1472
Error_Out_Of_Memory            $b3cd  1481D  1439   1473   1475   4390
                                      8988  11378
Basic_Error                    $b3cf  1487D  1683   2240   2322   2905
                                      3253   3528   4278   4525   4724
                                      4937   5577   5936   8759   8811
DEF_ERROR                      $b3d2  1495D 13518
Berr_20                        $b3dd  1502D  1508
Berr_30                        $b3ea  1509D 12474
Berr_40                        $b3f1  1512D  2229
Basic_Ready                    $b3ff  1521D  1515   1976   2230   7140
                                      7151   7153   7567   9023  11340
                                     12899  12903  12956  12965  13693
                                     13695  13952
Get_Basic_Statement            $b406  1529D  1543   1605   1638
DEF_MAIN                       $b409  1535D 13519
New_Basic_Line                 $b41f  1550D  1546
NBL_10                         $b45a  1589D  1586
NBL_20                         $b462  1594D  1591   1597   1601
NBL_30                         $b470  1602D  1562
NBL_40                         $b48b  1615D  1613
NBL_50                         $b4a5  1627D  1630
Reset_And_Rechain              $b4ad  1633D 12249
Rechain                        $b4b6  1641D  1603   1637   6436   9022
                                     10220  13978
Rech_10                        $b4be  1648D  1665
Rech_20                        $b4c0  1649D  1651
Rech_30                        $b4d4  1662D  1647
Read_String                    $b4e2  1671D  3003  10497
ReaS_10                        $b4e4  1675D  1681
ReaS_20                        $b4f8  1684D  1677
Tokenize_Line                  $b4fb  1687D  1559  11328  12925  13912
DEF_CRUNCH                     $b4fe  1693D 13520
ToLi_01                        $b504  1699D  1704   1754
ToLi_02                        $b510  1705D  1700
ToLi_03                        $b526  1716D  1713
ToLi_04                        $b52e  1720D  1717
ToLi_05                        $b540  1729D  1736
ToLi_06                        $b547  1733D  1728   1731   1774
ToLi_07                        $b555  1740D  1776
ToLi_08                        $b557  1741D  1702   1706   1711   1715
                                      1719   1757   1759
ToLi_09                        $b56a  1751D  1748
ToLi_10                        $b56c  1752D  1750
ToLi_11                        $b573  1756D  1763
ToLi_12                        $b57c  1760D  1709
ToLi_13                        $b583  1764D  1738
ToLi_14                        $b587  1766D  1772
ToLi_15                        $b590  1771D  1769
ToLi_16                        $b59c  1777D  1745
Find_BASIC_Line                $b5a6  1784D  1561   1916   9831   9845
Find_BASIC_Line_AX             $b5aa  1791D  1812   2298
FBL_10                         $b5c8  1810D  1804
FBL_30                         $b5ce  1813D  1798
FBL_Ret                        $b5cf  1814D  1803   1808   1809   1822
Basic_NEW                      $b5d2  1819D  1117
Perform_NEW                    $b5d4  1825D  7137
Reset_BASIC_Execution          $b5e9  1842D  1602   1636   2255   6435
                                      9021
Basic_CLR                      $b5ee  1849D  1111
Reset_Variable_Pointer         $b5f0  1855D  2256  13951
RVP_10                         $b60b  1873D 12251
Flush_BASIC_Stack              $b60e  1876D  1509   7078
FBS_Ret                        $b621  1892D  1852
Reset_BASIC_Exec_Pointer       $b622  1895D  1845  12250
RBEP_Ret                       $b62f  1905D  1914   1920   1923
Basic_LIST                     $b630  1908D  1110
LIST_10                        $b638  1915D  1911   1912
LIST_15                        $b64f  1924D  1918
LIST_20                        $b659  1933D  1928   1972
LIST_25                        $b674  1956D  1953
LIST_30                        $b676  1961D  1955
LIST_60                        $b679  1965
LIST_50                        $b686  1976D  1938   1956
List_Line                      $b689  1981D  1961  10673
LiLi_08                        $b690  1988D  2012   2014
LiLi_10                        $b697  1994D  1999
LiLi_20                        $b6a3  2003D  1990   2043
DEF_QPLOP                      $b6ab  2009D 13521
LiLi_30                        $b6be  2026D  2033
LiLi_40                        $b6c1  2028D  2032
LiLi_50                        $b6c7  2031D  2029
LiLi_60                        $b6cd  2034D  2027   2040
LiLi_Ret                       $b6dd  2044D  1996   2005
Basic_FOR                      $b6de  2049D  1084
FOR_10                         $b6ef  2061D  2056
FOR_30                         $b72f  2093D  2090
Execute                        $b74a  2108D  2103   2149   2276   3213
                                      6437
Exec_10                        $b759  2118D  2114
Start_Program                  $b779  2138D  2134   2175  12926
DEF_GONE                       $b77c  2144D 13522
Interpret                      $b785  2152D  2148   2402
Inpr_10                        $b787  2159D  2417
Inpr_20                        $b795  2166D  2162
Inpr_30                        $b7a2  2173D  2160
Inpr_40                        $b7a5  2174D  2120
Inpr_50                        $b7a9  2176D  2164
Basic_GO                       $b7ac  2179D  1118
Basic_RESTORE                  $b7b7  2188D  1095   1873
REST_10                        $b7c1  2197D  2195   3143
REST_Ret                       $b7c5  2199D  2158
Basic_STOP                     $b7c6  2202D  1099  12111
Basic_END                      $b7c8  2208D  1083
END_10                         $b7c9  2212D  2205
END_20                         $b7d8  2220D  2991
END_30                         $b7e0  2224D  2217
END_40                         $b7e2  2226D  2124
END_50                         $b7eb  2230D  2228
Basic_CONT                     $b7ee  2233D  1109
CONT_10                        $b7f9  2241D  2239
CONT_Ret                       $b807  2248D  2212   2236
Basic_RUN                      $b808  2251D  1093
RUN_10                         $b80a  2255
RUN_20                         $b80d  2256D  2254
Basic_GOSUB                    $b813  2260D  1096
GOSUB_10                       $b825  2274D  2257
Basic_GOTO                     $b830  2281D  1092   2185   2275   2401
GOTO_10                        $b847  2296D  2288
GOTO_20                        $b84b  2298D  2293   2295
GOTO_Ret                       $b85c  2306D  2312
Basic_RETURN                   $b85d  2309D  1097
RET_10                         $b86e  2321D  2299
RET_20                         $b873  2323D  2413
RET_30                         $b876  2324D  2318
Basic_DATA                     $b883  2335D  1086   2986   4550
Add_Y_To_Execution_Pointer     $b886  2341D  2398   3133
AYEP_Ret                       $b890  2350D  2348   2372   2374
Skip_To_EOS                    $b891  2353D  2064   2338   3116
Skip_To_EOL                    $b894  2360D  2285   2397
NeSt_10                        $b89c  2367D  2378
NeSt_20                        $b8a4  2371D  2377
Basic_IF                       $b8b3  2381D  1094
IF_10                          $b8c2  2390D  2387
Basic_REM                      $b8c6  2394D  1098
REM_10                         $b8cb  2399D  2391
REM_20                         $b8d3  2402D  2400
Basic_ON                       $b8d6  2405D  1100
ON_10                          $b8de  2412D  2439
ON_20                          $b8e2  2414D  2411   2421
ON_30                          $b8ea  2418D  2415
Scan_Linenumber                $b8f6  2426D  1558   1915   1922   2284
                                      2419   8856   8868   8879   9830
                                      9840  10521  11224  12900
ScLi_10                        $b8fe  2437D  2442
ScLi_Ret                       $b90c  2443D  2436
Dec_Char                       $b90d  2446D  2440  13832
LIM_10                         $b92e  2475D  2473
Basic_LET                      $b930  2480D  1091   2054   2173
Assign_Numeric_variable        $b94d  2500D  3091
LET_10                         $b961  2513D  2503
LET_20                         $b964  2515D  2496
Assign_String_Variable         $b965  2518D  3084
CLOCK_10                       $b978  2530D  2545
CLOCK_20                       $b992  2542D  2538
CLOCK_30                       $b9a2  2550D  2553
Add_TI_String_Digit_To_FAC1    $b9ab  2558D  2531   2535
ATSD_10                        $b9b2  2564D  2526
ATSD_20                        $b9b5  2565D  2563
Assign_Normal_String           $b9ba  2569D  2523
ANS_10                         $b9c9  2599
ANS_20                         $b9cb  2600
ANS_30                         $b9d7  2606D  2602
ANS_40                         $b9e5  2613D  2601   2605   2608
ANS_50                         $b9ec  2619D  2597   2609   2612
ANS_60                         $ba05  2633D  2615
ANS_70                         $ba1e  2648D  2639
ANS_80                         $ba33  2662D  2653
ANS_90                         $ba35  2663D  2666
Back_Reference_Position        $ba3d  2670D  2638   2652   5017
BRP_10                         $ba57  2696D  2693
BRP_no                         $ba6c  2709D  2684   2690   2692   2695
FAC1_INT                       $ba6f  2719D  4190
FACI_Ret                       $ba81  2732D  2724
Basic_PRINTN                   $ba88  2737D  1107
Basic_CMD                      $ba8e  2744D  1112   2740
CMD_10                         $ba98  2751D  2748
PRINT_10                       $baa2  2758D  2778
PRINT_20                       $baa5  2759D  2783
Basic_PRINT                    $baa8  2762D  1108   2755
PRINT_30                       $baaa  2766D  2838
Terminate_BUF                  $bad2  2786D  1684
Print_CR                       $badf  2797D  1500   1940   2765  12898
PRINT_Ret                      $bae4  2802D  2766   2794
Comma_Tab                      $baf0  2807D  2773
CoTa_10                        $baf3  2812D  2813
Tab_Spc                        $bafd  2819D  2768   2771
TaSp_10                        $bb0d  2831D  2816
TaSp_20                        $bb0e  2832D  2827
TaSp_30                        $bb11  2834D  2836
TaSp_40                        $bb14  2835D  2833
TaSp_50                        $bb17  2837D  2775   2830
Print_String                   $bb1d  2841D  1512   1526   2908   3151
                                      6466   7126   7136
Print_String_From_Descriptor   $bb20  2847D  2758   2781   2970
PSFD_10                        $bb28  2854D  2858
PSFD_Ret                       $bb31  2859D  2852
Cursor_Right_Or_Space          $bb3a  2864D  2782   2834   3002
CROS_10                        $bb41  2871D  2868
Print_Question_Mark            $bb44  2875D  1501   3001   3049
Print_Char                     $bb46  2881D  1988   1997   2038
Bad_Input                      $bb4c  2889D  3099
BaIn_10                        $bb56  2897D  2894
BaIn_20                        $bb5a  2899D  2896
SynErr                         $bb5e  2901D  2825
BaIn_30                        $bb61  2902D  2893
BaIn_40                        $bb6a  2906D  2903
Basic_GET                      $bb7a  2916D  1116
GET_10                         $bb8f  2927D  2921
Basic_INPUTN                   $bba4  2940D  1087
Set_Default_Channels           $bbb2  2950D  2741   2985
SDC_10                         $bbb4  2954D  2934
Basic_INPUT                    $bbbe  2962D  1088
Input_String                   $bbcd  2973D  2947   2966
InSt_10                        $bbd5  2979D  3564
InSt_20                        $bbe8  2987D  2981   2984
InSt_30                        $bbf0  2990D  3560
Prompt_And_Input               $bbf5  2996D  2979   3050
PAI_10                         $bbff  3003D  3000
Basic_READ                     $bc02  3006D  1090
READ_10                        $bc09  3013D  2988   3565
Read_Get                       $bc0b  3016D  2932
READ_15                        $bc11  3025D  3112
READ_20                        $bc3d  3046D  3039
READ_25                        $bc46  3050D  3048
READ_30                        $bc49  3051D  3044
READ_35                        $bc4d  3056D  3037   3136
READ_40                        $bc61  3069D  3060
READ_45                        $bc6d  3075D  3065
READ_50                        $bc6e  3076D  3071
READ_55                        $bc79  3082D  3080
READ_60                        $bc85  3089D  3058
READ_65                        $bc8d  3095D  3085
READ_70                        $bc99  3101D  3096   3098
READ_75                        $bcb4  3116D  3046   3135
READ_80                        $bccd  3131D  3119
READ_85                        $bcda  3139D  3110
READ_90                        $bce5  3144D  3142
READ_Ret                       $bcf6  3152D  3146   3148
Msg_Extra_Ignored              $bcf7  3157D  3149   3150
Msg_Redo_From_Start            $bd07  3163D  2906   2907
Basic_NEXT                     $bd19  3169D  1085
NEXT_10                        $bd1f  3175D  3172   3222
NEXT_20                        $bd24  3177D  3174
NEXT_30                        $bd2d  3181D  3123
NEXT_40                        $bd2f  3182D  3179
NEXT_50                        $bd6f  3213D  3220
NEXT_60                        $bd72  3214D  3204
Eval_Numeric                   $bd84  3225D  2078   2092   4608   5217
                                      5277  12691
Is_Numeric                     $bd87  3231D  3307   3389   3765   4175
                                      4537   4564   4575   4643
Is_String                      $bd89  3238D  3742   4926   4996
Check_Var_Type                 $bd8a  3244D  2495   3818
CVT_10                         $bd90  3250D  3251
CVT_20                         $bd91  3251D  3248
CVT_30                         $bd93  3252D  3249
CVT_40                         $bd95  3253D  3181
Eval_Expression                $bd98  3259D  2384   2492   2776   3228
                                      3492   3740   4169   7754   7758
                                      8789  12387
EvEx_05                        $bd9e  3265D  3263
EvEx_10                        $bda3  3268D  3341
EvEx_15                        $bdb0  3275D  4948
EvEx_20                        $bdb3  3276D  3288
EvEx_25                        $bdce  3290D  3278   3280
EvEx_30                        $bddf  3299D  3296
EvEx_35                        $bde7  3304D  3326
EvEx_40                        $bdf0  3308D  3329
EvEx_45                        $bdf1  3309D  3537
EvEx_50                        $bdfe  3317D  3291
EvEx_55                        $be08  3323D  3321
EvEx_60                        $be10  3327D  3312
Use_Operator                   $be17  3332D  3309
SynErr1                        $be27  3343D  3285
Push_Operand                   $be2a  3346D  3339
Push_FAC1                      $be2e  3353D  2084   2096
PuFA_10                        $be39  3363D  3360
Pop_FAC2                       $be52  3381D  3292   3294
PoFA_10                        $be55  3386D  3314
PoFA_20                        $be57  3387D  3306
PoFA_30                        $be5e  3390D  3388
PoFA_40                        $be60  3391D  3315   3328
PoFA_50                        $be7a  3408D  3386
Evaluate                       $be7e  3414D  3272   4925
DEF_EVAL                       $be81  3420D 13523
Eva_10                         $be85  3425D  3442
Eva_20                         $be8a  3427D  3438
Eva_30                         $be8d  3428D  3426
Float_PI                       $bea0  3436D  3432   3433
Eva_40                         $bea5  3437D  3431
Make_String_Descriptor_From_Co $beb5  3447D  2967
MSDF_10                        $bebe  3455D  3453
Eva_50                         $bec4  3458D  3444
Op_NOT                         $becc  3464D  1179
Eva_60                         $bedb  3480D  3459
Eva_70                         $bee2  3483D  3481
Eval_In_Parenthesis            $bee9  3488D  3484   3757   4574
Need_Right_Parenthesis         $beef  3495D  4233   4538   5155   7756
                                      8833
Need_Left_Parenthesis          $bef2  3502D  3491   3739   4533   7753
                                      8831
Need_Comma                     $bef5  3509D  2924   2944   3111   3741
                                      3874   5134   5284   7750   7762
                                     12410
Need_A                         $bef7  3515D  2077   2184   2389   2487
                                      2750   2969   4540   4558   7745
Syntax_Error                   $bf00  3524D  2176   2323   2901   3343
                                      3520   3551   3907   4004   4615
                                      7786   8088   8174   8250   8349
                                      8372   8604   8656   8697   8709
                                      8740   8799   8829  12136  12418
                                     12723  13953
Negate                         $bf05  3531D  3440
Nega_10                        $bf07  3535D  3461
JMP_Get_Var                    $bf0c  3540D  3429
Any_Except_Pi                  $bf0f  3546D  2147
Input_String_Patch             $bf19  3555D  2989
InSt_40                        $bf20  3561D  3559
InSt_50                        $bf29  3565D  3563
Extended_Statement_Table       $bf2c  3568D 11310  11312  11319
Extended_Keyword_Table         $bf3a  3580D 11300  11317
Get_Var                        $bf8c  3595D  3543   3991
GeVa_10                        $bfbb  3628D  3615   3617
GeVa_Ret                       $bfcd  3636D  3613   3629   3631
Get_Numeric_Value              $bfce  3639D  3611
Load_Float                     $bfdf  3654D  3643
Load_Jiffyclock                $c003  3671D  3618   3663
Check_ST_Var                   $c00f  3683D  3660
Check_DS_Var                   $c01c  3694D  3687   3689
Load_Float_Var                 $c040  3717D  3658   3662   3698   3700
Function_Call                  $c047  3725D  3485
FuCa_10                        $c071  3757D  3738
FuCa_20                        $c076  3760D  3756
Op_OR                          $c086  3768D  1177
Op_AND                         $c088  3775D  1176
ANDOR_10                       $c0a8  3795D  3789
Op_COMPARE                     $c0b6  3810D  1180
OpCO_10                        $c0ce  3829D  3819
OpCO_20                        $c0f6  3849D  3844   3846
OpCO_30                        $c0fb  3852D  3861
OpCO_40                        $c101  3856D  3828
OpCO_50                        $c106  3859D  3854
OpCO_60                        $c112  3865D  3856   3858   3863
OpCO_70                        $c11b  3871D  3869
DIM_10                         $c11e  3874D  3883
Basic_DIM                      $c121  3877D  1089
Parse_Name                     $c12b  3887D  2483   3025   3175   3605
                                      4536
Get_Array_Address              $c130  3894D  3881
Get_FN_Address                 $c132  3900D  4561
GFA_Err                        $c13c  3907D  3933
Get_Address                    $c13f  3910D  3906
GeAd_05                        $c14f  3920D  3917
GeAd_10                        $c150  3921D  3922   3924
GeAd_15                        $c15a  3925D  3919
GeAd_20                        $c164  3930D  3926
GeAd_25                        $c174  3938D  3929
GeAd_30                        $c17b  3942D  3931
GeAd_35                        $c187  3948D  3946
GeAd_40                        $c18f  3952D  3972
GeAd_45                        $c191  3953D  3970
GeAd_50                        $c19b  3958D  3955
GeAd_55                        $c1ab  3966D  3964
GeAd_60                        $c1ac  3967D  3960
Is_Alpha                       $c1b6  3975D  3428   3905   3918   3923
IsAl_Ret                       $c1bf  3983D  3979
Create_Var                     $c1c0  3986D  3957
CrVa_05                        $c1c6  3993D  4001
CrVa_10                        $c1cb  3996D  3992
CrVa_15                        $c1db  4004D  4008   4012   4014
CrVa_20                        $c1de  4005D  3999   4003
CrVa_25                        $c1e6  4009D  4006
CrVa_30                        $c1f2  4015D  4010
CrVa_35                        $c208  4027D  4025
CrVa_40                        $c21c  4041D  4064   4066
CrVa_45                        $c220  4043D  4080
CrVa_50                        $c228  4047D  4044
CrVa_55                        $c259  4076D  4074   4108   4110
CrVa_60                        $c263  4081D  4078
CrVa_65                        $c281  4098D  4095
CrVa_70                        $c28b  4104D  4083   4094   4097
CrVa_75                        $c298  4112D  4046
CrVa_80                        $c2b4  4129D  3965
CrVa_85                        $c2be  4135D  4133
Array_Pointer_To_First         $c2c8  4142D  4285   4294
APTF_10                        $c2d4  4152D  4150
Float_M32768                   $c2d9  4157D  4186   4187
Eval_Positive_Integer          $c2dd  4165D  4212
Eval_Positive_Integer_Check    $c2e3  4172D  5223
Real_To_Integer                $c2ea  4180D  2505   3472   3780   3786
RIT_10                         $c2f7  4189D  4177
RIT_20                         $c2f9  4190D  4185
Find_Array                     $c2fc  4193D  3947
FiAr_05                        $c306  4206D  4231
FiAr_10                        $c347  4242D  4264
FiAr_15                        $c353  4248D  4245
FiAr_20                        $c362  4256D  4252
Bad_Subscript                  $c370  4267D  4289   4389
Jump_To_Illegal_Quantity       $c373  4274D  2564   4189   5203   5652
                                      7082   7083   8861   9861
FiAr_Err                       $c375  4278D  4284
FiAr_25                        $c378  4282D  4255
FiAr_30                        $c38c  4294D  4247
FiAr_35                        $c39f  4303D  4301
FiAr_40                        $c3a8  4309D  4306
FiAr_45                        $c3b1  4315D  4335
FiAr_50                        $c3c1  4325D  4318
FiAr_55                        $c3e4  4345D  4342
FiAr_60                        $c3f3  4352D  4354   4357
FiAr_65                        $c3f8  4355D  4351
FiAr_70                        $c415  4371D  4290
FiAr_72                        $c41d  4375D  4405
FiAr_74                        $c433  4389D  4384
FiAr_76                        $c436  4390D  4337   4344   4455   4466
FiAr_78                        $c439  4391D  4383
FiAr_80                        $c43a  4392D  4388
FiAr_82                        $c44b  4402D  4395
FiAr_84                        $c45c  4411D  4409
FiAr_86                        $c462  4415D  4412
FiAr_Ret                       $c476  4426D  4369   4516
Mult_16x16                     $c477  4431D  4330   4396
Mult_16x16_A                   $c480  4441D  4417
Mu16_10                        $c48a  4449D  4468
Mu16_20                        $c4a3  4467D  4458
Basic_FRE                      $c4a8  4472D  1145
FRE_10                         $c4af  4478D  4476
AY_To_Real                     $c4bc  4487D  3478   3651   3794   3799
                                      4508
Basic_POS                      $c4c9  4498D  1146
Y_To_Float                     $c4cb  4504D  5181   5202   5319
Assert_Non_Direct              $c4cf  4511D  2919   2976   4532
Undefined_Function             $c4d7  4521D  4586
Basic_DEF                      $c4dc  4528D  1105
Get_FN                         $c50a  4554D  4531   4570
Eval_FNX                       $c51d  4567D  3482
FNX_10                         $c53e  4589D  4592
FNX_20                         $c56f  4616D  4614
FNX_30                         $c575  4620D  4551
Basic_STR                      $c58e  4640D  1157
STR_10                         $c598  4648D  3626
Allocate_String_FAC1           $c59e  4653D  4711   4938
Allocate_String_A              $c5a6  4662D  2621   5077   5099
Create_String_Descriptor       $c5b0  4672D  2780   2844   3455   3635
                                      4650
Create_String_Descriptor_AY    $c5b6  4680D  3082
CSD_10                         $c5c0  4688D  4694
CSD_20                         $c5cd  4695D  4692
CSD_30                         $c5d1  4697D  4690
CSD_40                         $c5d2  4698D  4696
CSD_50                         $c5de  4705D  4703
CSD_60                         $c5e8  4710D  4707
Push_String_Descriptor         $c5f3  4717D  4709   4947   5083   5113
PuSD_Err                       $c5fb  4724D  4792
PuSD_10                        $c5fe  4725D  4722
Allocate_String_Space          $c61d  4745D  4665
ASS_10                         $c61f  4755D  4797
ASS_30                         $c63a  4772D  4770
ASS_40                         $c644  4777D  4774
ASS_50                         $c65a  4789D  4756
ASS_60                         $c65b  4790D  4773   4776
Garbage_Collection             $c66a  4802D  1467   4478   4793  11475
GaCo_05                        $c676  4812D  4832   4834   4864   4880
GaCo_10                        $c68a  4824D  4821
GaCo_15                        $c69f  4836D  4828
GaCo_20                        $c6b0  4846D  4843
GaCo_25                        $c6b6  4849D  4847
GaCo_30                        $c6c7  4860D  4857
GaCo_35                        $c6d1  4866D  4861
GaCo_40                        $c6d4  4868D  4871
GaCo_45                        $c6eb  4881D  4816
FAC1_LSB                       $c6f4  4888D  6194
FACX_LSB                       $c6f6  4892D  5604
FACB_10                        $c6fa  4894D  4911
FACB_Ret                       $c71c  4912D  4895
Concatenate                    $c74f  4918D  3297
Conc_10                        $c76f  4938D  4935
Store_String_STRPTR            $c78c  4951D  4939
Store_String_XY                $c79a  4966D  2624   4714
Store_String_INDEXA            $c79e  4973D  4943   5112
SSI_10                         $c7a2  4979D  4983
SSI_Ret                        $c7b4  4990D  4977   4988
Eval_And_Free_String           $c7b5  4993D  5187   8790  12388
Free_String_FAC1               $c7b8  4999D  2524   2850   3832   4477
Free_String_AY                 $c7bc  5006D  3838   4942   4946   5102
GSD_40                         $c7ed  5039D  5016   5018
GSD_Ret                        $c7ff  5051D  5027   5029
Pop_Descriptor_Stack           $c811  5056D  2627   2637   5015
PDS_Ret                        $c821  5067D  5060   5062
Basic_CHR                      $c822  5070D  1160
Basic_LEFT                     $c836  5086D  1161
LEFT_10                        $c83c  5092D  5123
LEFT_20                        $c842  5096D  5092
LEFT_30                        $c843  5097D  5144
LEFT_40                        $c844  5098D  5147   5149
LEFT_50                        $c85b  5111D  5109
Basic_RIGHT                    $c862  5116D  1162
Basic_MID                      $c86d  5126D  1163
MID_10                         $c87e  5136D  5133
Pop_DESCPT                     $c897  5152D  5089   5119   5136
Basic_LEN                      $c8b2  5177D  1156
Eval_String_Desc               $c8b8  5184D  5180   5197   5233
Basic_ASC                      $c8c1  5194D  1159
ASC_10                         $c8cb  5202D  5198
ASC_Err                        $c8ce  5203D  5137   5225   5292   5295
Get_Next_Byte_Value            $c8d1  5208D  2823
Get_Byte_Value                 $c8d4  5214D  2408   2747   2923   2943
                                      3751   5135   5285   8832   8834
                                     12313  12369
Eval_Byte                      $c8d7  5220D  5073
Basic_VAL                      $c8e3  5230D  1158
VAL_10                         $c8eb  5236D  5234
VAL_20                         $c903  5249D  5247
Restore_Execution_Pointer      $c918  5262D  3083   3456
Get_Word_And_Byte              $c921  5274D  5325   5335
Need_Comma_Get_Byte            $c927  5281D  5340
FAC1_To_LINNUM                 $c92d  5288D  5278   5311   7755   7759
                                     12692
Basic_PEEK                     $c943  5304D  1155
Basic_POKE                     $c95a  5322D  1106
Basic_WAIT                     $c963  5332D  1101
WAIT_10                        $c972  5341D  5339
WAIT_20                        $c976  5343D  5346
WAIT_Ret                       $c97e  5347D  5409
Add_0_5_To_FAC1                $c97f  5350D  6539   6946
AY_Minus_FAC1                  $c986  5358D  5666   6942   7029
Op_MINUS                       $c989  5364D  1172   6802   6939
Add_Var_AY_To_FAC1             $c99d  5378D  3197   5355   5660   5672
                                      6859   6898   6924   6955
Op_PLUS                        $c9a0  5384D  1171   5373   6342
PLUS_10                        $c9a5  5389D  5387
AddSub_FAC2_To_FAC1            $c9ad  5395D  5827
AFTF_10                        $c9c9  5423D  5413
AFTF_20                        $c9cd  5425D  5422
AFTF_30                        $c9d0  5426D  5412
AFTF_40                        $c9dc  5432D  5430
AFTF_50                        $c9ff  5448D  6128
Normalise_FAC1                 $ca0d  5455D  5448   5450   5950   6239
                                      6913
NF1_10                         $ca11  5461D  5474
Clear_FAC1                     $ca2d  5477D  5235   5510   5805
CF1_10                         $ca2f  5481D  6721
AFTF_60                        $ca34  5485D  5427
AFTF_65                        $ca53  5501D  5507
AFTF_70                        $ca5f  5507D  5462
Mantissa_Overflow              $ca6c  5516D  5499
AFTF_80                        $ca6e  5520D  6085
AFTF_Ret                       $ca7c  5527D  5519
Negate_FAC1                    $ca7d  5530D  5449
Negate_FAC1_Mantissa           $ca83  5538
Inc_FAC1_Mantissa              $caa5  5560D  6083   6211
IFM_Ret                        $cab3  5570D  5557   5564   5566   5568
Overflow_Error                 $cab4  5573D  5521   5806   6352
Shift_FAC3                     $cab9  5580D  5712
Shift_FACX_A                   $cacf  5601D  5425
SFA_10                         $cad8  5608D  5614
SFA_40                         $cae4  5615D  5607
REAL_1                         $caf2  5621D  2085   2086   5664   5665
                                      7019   7020
VLOG_A                         $caf7  5625D  5667   5668
HALF_SQRT_2                    $cb0c  5632D  5658   5659
SQRT_2                         $cb11  5636D  5661   5662
MINUS_0_5                      $cb16  5639D  5670   5671
LN_2                           $cb1b  5643D  5675   5676
Basic_LOG                      $cb20  5646D  1149   6737
LOG_10                         $cb27  5652D  5650
LOG_20                         $cb2a  5653D  5651
Multiply_FAC1_With_AY          $cb5e  5679D  6513   6740   6778   6823
                                      6827   6850   6895
Op_MULTIPLY                    $cb61  5685D  1173
Mult_SubA                      $cb8c  5708D  5696   5698   5700   5702
Mult_SubB                      $cb91  5715D  5704   5711
MULT_20                        $cb94  5720D  5742
MULT_30                        $cbb0  5735D  5721
MULT_Ret                       $cbbe  5743D  5688
Load_FAC2_From_AY              $cbc2  5748D  5361   5381   5682   5859
Check_FAC                      $cbed  5782D  5689   5871
ChFA_10                        $cbef  5786D  6810
ChFA_20                        $cbfa  5793D  5789
ChFA_30                        $cc04  5798D  5796
ChFA_40                        $cc07  5800D  6788
ChFA_50                        $cc0d  5803D  5786   5793
ChFA_Err                       $cc12  5806D  5790   5802   5819   5829
                                      5873
Multiply_FAC1_BY_10            $cc18  5811D  2532   2546   6308   6322
                                      6523
Add_And_Double                 $cc23  5822D  2541
Mul10_Ret                      $cc2e  5830D  5816
Float_10                       $cc2f  5833D  5843   5844
Divide_FAC1_By_10              $cc34  5839D  6303   6529
Divide_FAC2_By_AY              $cc3d  5848D  6934
AY_Divided_By_FAC1             $cc45  5856D  5663   6983   7021
Op_DIVIDE                      $cc48  5862D  1174   5853
DIV_10                         $cc5f  5876D  5902
DIV_20                         $cc75  5887D  5878   5881   5884   5901
                                      5903
DIV_30                         $cc82  5895D  5889   5920
DIV_40                         $cc85  5897D  5918
DIV_50                         $cc93  5904D  5896
DIV_60                         $ccb0  5919D  5892
DIV_70                         $ccb4  5921D  5893
Divide_By_Zero                 $ccc0  5932D  5865
FAC3_To_FAC1                   $ccc5  5939D  5705   5929
Load_FAC1_AY                   $ccd8  5953D  2087   3191   3434   3677
                                      3722   5852   6712   6892   6976
LFAY_10                        $ccde  5959D  5962
Set_FAC1                       $ccf4  5973D  6191
FAC1_To_FACTPB                 $ccfd  5985D  6840
FAC1_To_FACTPA                 $cd00  5992D  6821   6967
FAC1_To_FORPNT                 $cd06  6000D  2513   3198
FAC1_To_XY                     $cd0a  6007D  4594   5997   6724   6916
                                      6973
FAC2_To_FAC1                   $cd32  6034D  3785   5388
Copy_ABS_FAC2_To_FAC1          $cd34  6040D  6734
F1F2_10                        $cd38  6045D  6048
FAC1_Round_And_Copy_To_FAC2    $cd42  6053D  2536   5814   5842   6335
                                      6709   6930   6935
FAC1_To_FAC2                   $cd45  6059D  6784
FA12_10                        $cd47  6063D  6066
FA12_Ret                       $cd50  6068D  6075   6077   6084
Round_FAC1                     $cd51  6071D  2504   3363   5866   6010
                                      6056
Inc_FAC1                       $cd59  6080D  6782
Get_FAC1_Sign                  $cd61  6088D  2093   5649   6104   6152
                                      6878
GFS_10                         $cd65  6093D  6155
GFS_20                         $cd67  6094D  6179
GFS_Ret                        $cd6e  6098D  6092   6096
Basic_SGN                      $cd6f  6101D  1141
A_To_FAC1                      $cd72  6107D  3691   3712   3871   6337
ATOF_10                        $cd7a  6114D  4495
Convert_Integer_To_Real        $cd7f  6119D  6459  11234
CITR_10                        $cd85  6125D  3666
Basic_ABS                      $cd8e  6131D  1143
Compare_FAC1_AY                $cd91  6138D  3826   4188   6521   6533
                                      6730
Compare_FAC1_INDEXB_Y          $cd93  6144D  3200
CFAY_10                        $cdc8  6176D  6157   6161   6165   6169
CFAY_20                        $cdce  6179D  6177
FAC1_LSR                       $cdd1  6182D  2547   2722   5296   6229
                                      6540
FLSR_10                        $cdd5  6191
FLSR_20                        $cdd8  6192D  6190
FLSR_30                        $cde6  6199D  6197   6206
FLSR_40                        $cdff  6212D  6195   6208   6210
FLSR_Ret                       $ce01  6213D  6175   6228
Basic_INT                      $ce02  6218D  1142   6727   6789   6936
INT_10                         $ce1a  6238D  6234
Read_Real_To_FAC1              $ce29  6244D  3089   3427   5256
RRTF_02                        $ce2d  6257D  6259
RRTF_04                        $ce3e  6266D  6262   6294   6326
RRTF_06                        $ce43  6268D  6264
RRTF_08                        $ce60  6282D  6279
RRTF_10                        $ce62  6283D  6275   6277   6364
RRTF_12                        $ce67  6285D  6281
RRTF_20                        $ce73  6292D  6269
RRTF_22                        $ce79  6296D  6271   6286
RRTF_24                        $ce7b  6297D  6290
RRTF_26                        $ce84  6303D  6305
RRTF_28                        $ce8d  6308D  6301   6310
RRTF_30                        $ce94  6312D  6300   6306
RRTF_32                        $ce99  6316D  6313
RRTF_34                        $ce9c  6318D  6260   6267
RRTF_36                        $cea3  6322D  6320
Add_A_To_FAC1                  $ceb4  6331D  2566   5674   6325
RRTF_40                        $cec7  6346D  6273   6284
RRTF_42                        $ced6  6353D  6348
RRTF_44                        $cee4  6363D  6351
REAL_1e8                       $cee9  6367D  6519   6520
REAL_9x9                       $ceee  6373D  6531   6532
REAL_1e9                       $cef3  6379D  6511   6512
BSOS_TEXT                      $cef8  6384D  6392   6399   6412   6414
                                      6416
Option_ROM                     $cf01  6387D  7138
OpRO_10                        $cf03  6391D  6395
OpRO_20                        $cf11  6397D  6393
OpRO_30                        $cf13  6398D  6402
OpRO_40                        $cf21  6404D  6400   6411
BOOT_File                      $cf22  6407D  7139
BOFi_10                        $cf4e  6430D  6427
Print_IN                       $cf78  6442D  1516
Print_Integer_XA               $cf83  6452D  1984   7133   7952  12897
To_Print_String                $cf90  6463D  6447
Format_FAC1                    $cf93  6469D  2779   6460  11235
Format_FAC1_Y                  $cf95  6475D  4645
FoFA_02                        $cfa1  6492D  6490
FoFA_04                        $cfb2  6508D  6501
FoFA_06                        $cfc1  6515D  6510
FoFA_08                        $cfc3  6519D  6525
FoFA_10                        $cfd3  6529D  6534
FoFA_12                        $cfd8  6531D  6522
FoFA_14                        $cff9  6555D  6549
FoFA_16                        $cffa  6556D  6551
FoFA_18                        $d005  6562D  6560
FoFA_20                        $d016  6571D  6567
FoFA_22                        $d018  6572D  6561
Format_Jiffyclock              $d01a  6575D  3625
FoFA_78                        $d01c  6579D  6594   6597   6627
FoFA_80                        $d040  6597D  6593
FoFA_82                        $d042  6598D  6595
FoFA_84                        $d049  6602D  6599
FoFA_86                        $d064  6618D  6614
FoFA_88                        $d076  6631D  6625
FoFA_90                        $d078  6632D  6635
FoFA_91                        $d085  6639D  6637
FoFA_92                        $d095  6648D  6642
FoFA_93                        $d0a1  6654D  6656
FoFA_94                        $d0b6  6665D  6502
FoFA_95                        $d0b9  6666D  6641
FoFA_96                        $d0be  6668D  6663
Float_0_5                      $d0c7  6675D  2522   3993   3994   5353
                                      5354   6710   6711
Decimal_Conversion_Table       $d0cc  6681D  6581   6584   6587   6590
Jiffy_Conversion_Table         $d0f0  6695
Basic_SQR                      $d108  6706D  1147
Op_POWER                       $d112  6715D  1175
PWR_10                         $d11b  6722D  6720
PWR_20                         $d135  6734D  6726   6731
Op_NEGATE                      $d14b  6747D  1178   6316   6803   6952
                                      6958
NEGA_Ret                       $d155  6755D  6744   6751
REV_LOG_2                      $d156  6758D  6776   6777
VAR_EXP                        $d15b  6762D  6804   6805
Basic_EXP                      $d184  6773D  1150   6718   6741
EXP_10                         $d194  6783D  6781
EXP_20                         $d19f  6788
EXP_30                         $d1a2  6789D  6787
EXP_40                         $d1ac  6794D  6799
Square_And_Series_Eval         $d1d7  6816D  5669   6961   7024
Eval_Series_AY                 $d1ed  6830D  6806
Eval_Series                    $d1f1  6837D  6824
EvSe_10                        $d200  6848D  6846
EvSe_20                        $d204  6850D  6863
EvSe_30                        $d211  6857D  6855
RND_VA                         $d221  6866D  6893   6894
RND_VB                         $d225  6867D  6896   6897
Basic_RND                      $d229  6870D  1148
RND_10                         $d247  6890D  6880
RND_20                         $d25c  6899D  6879
RND_30                         $d26c  6907D  6889
Basic_COS                      $d282  6919D  1151
Basic_SIN                      $d289  6927D  1152   6970
SIN_10                         $d2bb  6952D  6945   6990
SIN_20                         $d2be  6953D  6948
SIN_30                         $d2cb  6959D  6957
Basic_TAN                      $d2d2  6964D  1153
TAN_10                         $d2fa  6986D  6980
PI_Half                        $d2fe  6991D  6922   6923   7027   7028
Two_PI                         $d303  6992D  6931   6932
Float_0_25                     $d308  6995D  6940   6941   6953   6954
VAR_SIN                        $d30d  6999D  6959   6960
Basic_ATN                      $d32c  7008D  1154
ATN_20                         $d341  7022D  7018
ATN_30                         $d352  7030D  7026
VAR_ATN                        $d35c  7037D  7022   7023
CHRGET_ROM                     $d399  7055D  7065   7087
CHRG_10                        $d39f  7061D  7059
CHRG_20                        $d3b0  7070D  7063
Init_BASIC_RAM_Vectors         $d3b6  7075D 13708
IBRV_10                        $d3c9  7087D  7090
IBRV_20                        $d3e8  7102D  7115   7117
IBRV_30                        $d404  7118D  7107   7111
Bytes_Free_Message             $d438  7143D  7134   7135
Monitor                        $d445  7149D  3572
MONITOR_BREAK                  $d451  7162D 13697  13699
MOBR_05                        $d459  7170D  7168
MOBR_10                        $d49c  7201D  7205
MOBR_20                        $d4a8  7206D  7199   7203
Mon_Error                      $d4ac  7210D  7229   7483   7609   9944
                                     13371  13552  13595  13679  13701
                                     13703
Mon_Main                       $d4b1  7217D  7224   7458   7499   7614
                                      7639   7984   7992   9943  12493
                                     13484  13501  13576  13594  13678
                                     13741
Mon_10                         $d4b8  7223D  7226  13415
Mon_20                         $d4c1  7227D  7207
Mon_30                         $d4c3  7228D  7231
Mon_Print_A_Hex_Values         $d4d4  7239D  7400   7453  10583
MPAH_10                        $d4d8  7244D  7252
MPAH_12                        $d4e9  7251D  7249
MPAH_20                        $d4f8  7258D  7271
MPAH_30                        $d505  7264D  7261
MPAH_40                        $d507  7265D  7263
MPAH_42                        $d512  7270D  7268
MPAH_Ret                       $d516  7272D  7256
Mon_STAL_Register              $d517  7275D  7399
Mon_Print_Blank                $d522  7286D  7244   7250   7253   7269
                                      7389   7394  12487  12504  12505
                                     12506  12527  13390  13392  13571
                                     13675  13737
Mon_Print_CR                   $d525  7293D  7220   7369  11337  13481
                                     13498  13559  13662  13740  13980
Mon_Start                      $d52a  7300D  7202
Mon_Commands                   $d535  7303D  7230
Mon_Sub_Hi                     $d54d  7309D  7232
Mon_Sub_Lo                     $d564  7337D  7234
Mon_Prompt                     $d57b  7365D  7388   7450  10580  12486
                                     13389
Display_Register               $d583  7374D  7329   7357
DiRe_10                        $d585  7378D  7382
DiRe_20                        $d5ca  7404D  7409
Mon_Cmp_Addr                   $d5e7  7420D  7447  12483  13665
Cmp_STAL_MEMUSS                $d5f2  7431D  7424  13574  13592  13619
Display_Memory                 $d5fb  7441D  7327   7355
DiMe_10                        $d5fe  7445D  7456   9999  10020
To_Mon_Main                    $d61c  7457D  7411   7446   7448   7524
Mon_Get_Addr                   $d61f  7461D  7444  12480  13635
MGA_Ret                        $d640  7479D  7470   7474
MGA_Err                        $d641  7480D  7472   7477
To_Mon_Err                     $d643  7482D  7506   7515   7520   7533
Modify_Register                $d646  7486D  7317   7345
MoRe_10                        $d648  7490D  7494
Modify_Memory                  $d660  7502D  7316   7344
MoMe_10                        $d667  7508
MoMe_20                        $d673  7514D  7523
MoMe_30                        $d684  7521
Mon_Go                         $d68b  7527D  7324   7352
MoGo_10                        $d6a0  7538D  7531
Mon_Step                       $d6ab  7545D 13758
Mon_Exit                       $d6c5  7562D  7334   7362
Set_DOS_FNADR                  $d6cc  7570D  7595   8676  13497
Mon_Load                       $d6d5  7580D  7315   7326   7343   7354
Mon_Save                       $d6d8  7587D  7330   7358
MLS_10                         $d6e7  7597D  7600
MLS_20                         $d6f0  7601D  7608
MLS_Err                        $d700  7609D  7598   7602   7612   7626
                                      7632   7635   7637
MLS_30                         $d703  7611D  7618   7624
MLS_35                         $d705  7612
MLS_50                         $d70d  7616D  7604   7620
Make_Hex_Byte                  $d745  7642D  7668  13403  13407
Mon_Print_STAL                 $d754  7657D  7451  10581  12526  13391
                                     13570  13674
Print_Hex_Byte                 $d75b  7665D  7246   7391   7393   7396
                                      7398   7661   9882  11665  12152
                                     12154  12259  12261  12502  13739
Mon_Print_XA                   $d75e  7671
Nibble_To_Hex                  $d767  7681D  7650   7654  13264  13269
NTH_10                         $d76e  7688D  7686
Hex_To_STAL                    $d771  7692D  7471   7505   7627   9956
                                     13329  13540
Read_Hex_Word                  $d773  7698D  7476   7634   9925   9928
                                     13543  13546
RHW_Ret                        $d77f  7706D  7702
Read_Hex                       $d780  7709D  7490   7514   7534   7536
                                      7621   7701   7704   7716   7982
                                      7990   9930  13646  13730
Read_Hex_A                     $d787  7717D 13643
ReHe_Ret                       $d7a3  7732D  7719   7728
Kernal_RECORD                  $d7af  7738D 14083
RECO_10                        $d7db  7758D  7752
RECO_20                        $d7e1  7760D  7757
RECO_30                        $d7fe  7772D  7761
RECO_40                        $d801  7773D  7748   7766   7768
Allow_Drive_Unit_Filename      $d804  7776D  8143   8397
DOS_JMP_Syntax_Error           $d808  7783D  7751   7763   7771   7795
                                      7804   7812   7821   7831
Check_Filename_Given           $d80b  7789D  7780   8346   8369
Allow_Drive_And_Unit           $d818  7800D  7922   8231
No_WL_Record                   $d81d  7808D  8290
Check_Filename_Syntax          $d824  7816D  8385
Check_Record_Syntax            $d82e  7826D  8070   8099
DOS_Build_Table                $d838  7836D  8481
Kernal_DIRECTORY               $d873  7918D 14131
DIRE_10                        $d885  7929D  7927
Wedge_Call_Dir                 $d889  7933D 12964  13500
WCD_10                         $d89e  7945D  7951   7972
WCD_20                         $d8b4  7955D  7964   7967
WCD_30                         $d8cc  7965D  7966
WCD_40                         $d8d3  7969D  7956
WCD_80                         $d8dc  7974D  7948   7958   7961
Mon_Set_Bank                   $d8e4  7979D  7320   7348
Mon_Write_Bank                 $d8ec  7987D  7333   7361
Mon_CHRIN                      $d8f4  7995D  7223   7469   7473   7530
                                      7597   7601   7617   7623   7630
                                      7714   7726   9959  13291  13335
                                     13343  13467  13473  13494  13637
                                     13653  13780  13836
Hex_To_Bin                     $d8fa  8003D  7720   7729  13783
HTB_Ret                        $d904  8012D  8010
Is_Int                         $d905  8015D 13776
Is_Hex                         $d911  8026D  7718   7727  13781
Is_Dec                         $d919  8035D 13837
IH_True                        $d921  8042D  8019   8021   8023   8032
IH_False                       $d923  8044D  8030   8039   8041
Select_Free_SA                 $d92f  8050D  8073   8102
SFSA_10                        $d931  8054D  8060
SFSA_20                        $d935  8057D  8061
SFSA_30                        $d93f  8062D  8058
Kernal_DOPEN                   $d942  8066D 14071
DOPEN_20                       $d95c  8081D  8077
DOPEN_30                       $d964  8085D  8081
DOPEN_Err                      $d96c  8088D  8072   8101   8146
Kernal_APPEND                  $d977  8095D 14113
Kernal_Read_DS                 $d991  8111D  3632   3701   6429   8156
                                      8405   9871  11580  11611  11640
                                     12972  14149
KRD_10                         $d999  8118D  8115
KDR_20                         $d9a5  8123D  8129
KDR_30                         $d9b4  8130D  8127
Kernal_HEADER                  $d9d2  8139D 14089
HEAD_10                        $d9f1  8155D  8153
HEAD_20                        $da05  8163D  8149   8158   8160
Kernal_DCLOSE                  $da07  8168D 14077
CLOSE_10                       $da11  8175D  8173
Close_All_Device_Files         $da1b  8181D  8147   8177   8193   8232
                                      8254
CLOSE_20                       $da1f  8186D  8189
CLOSE_Ret                      $da30  8194D  8187
Build_Record_Command           $da31  8197D  7772
BRC_10                         $da3d  8205D  8202
DOS_Record_No                  $da43  8209D 11639
Kernal_COLLECT                 $da65  8227D 14095
COLL_10                        $da7a  8239D  8237
Kernal_BACKUP                  $da7e  8243D 14101
BACK_Err                       $da87  8250D  8253
BACK_10                        $da8a  8251D  8249
Put_DOS_Command                $da98  8259D  8155   8240   8281   8293
                                      8390   8402
PDC_10                         $da9b  8263D  8224  11528
Kernal_COPY                    $daa7  8270D 14107
KECO_10                        $dab5  8279D  8275   8277
Kernal_CONCAT                  $dac7  8286D 14065
Copy_Filename_To_DOS_Buffer    $dad4  8296D  8485
Copy_MEMUSS_To_DOS_Buffer      $dae1  8307D  8488
CMDB_10                        $daea  8315D  8320
CMDB_20                        $daf8  8322D  8313
CMDB_30                        $daf9  8323D  8321
Insert_DOS_Id                  $dafd  8329D  8495
Kernal_DSAVE                   $db0d  8342D 14119
DSAVE_10                       $db1a  8350D  8348
DSAVE_20                       $db32  8360D  8353
Kernal_DLOAD                   $db3a  8365D 14125
DLOAD_10                       $db44  8372D  8387
DLOAD_20                       $db47  8373D  8371
Kernal_RENAME                  $db55  8381D 14137
Kernal_SCRATCH                 $db66  8393D 14143
Display_Status                 $db85  8410D 12973
DiSt_10                        $db87  8414D  8418
DiSt_Ret                       $db92  8419D  8399   8404
Are_You_Sure                   $db9e  8424D  8148   8398
AYS_10                         $dbcb  8446D  8434   8439   8442   8450
AYS_20                         $dbd5  8451D  8428   8437   8445
AYS_Ret                        $dbd6  8452D  8448
Clear_Status                   $dbe1  8457D  8175   8206   8477  12971
Build_DOS_Command              $dbfa  8467D  7930   8105   8262   8361
                                      8375
Build_DOS_Command_X            $dbfc  8473D  8086   8358  11485
BDC_10                         $dc02  8478D  8505   8510
BDC_20                         $dc14  8486D  8484
BDC_30                         $dc1b  8489D  8487
BDC_40                         $dc24  8493D  8490
BDC_50                         $dc2b  8496D  8494
BDC_60                         $dc34  8500D  8497
BDC_70                         $dc3d  8504D  8501
BDC_80                         $dc44  8507D  8503
BDC_90                         $dc46  8508D  8482   8492   8499
DOS_SETNAM                     $dc4c  8513D  8223   8479   9966
Write_Attribute                $dc57  8524D  8498
WrAt_10                        $dc60  8531D  8528
WrAt_Ret                       $dc67  8534D  8530
Parse_DOS_Parameter            $dc68  8563D  7921   8069   8098   8142
                                      8171   8230   8246   8273   8289
                                      8345   8368   8384   8396
PDP_02                         $dc8e  8582D  8579   8691
PDP_04                         $dca1  8592D  8589
PDP_08                         $dcb9  8604D  8608   8618   8643
PDP_10                         $dcbc  8606D  8583
PDP_12                         $dcd4  8617D  8585
PDP_14                         $dcdf  8622D  8587
PDP_16                         $dced  8629D  8620
PDP_20                         $dcf5  8633D  8599   8603
PDP_22                         $dcf8  8635D  8595   8694
PDP_24                         $dd00  8638D  8597
PDP_26                         $dd08  8641D  8593
PDP_28                         $dd24  8652D  8611   8624   8626   8646
PDP_30                         $dd27  8653D  8601
PDP_32                         $dd31  8657D  8655
PDP_34                         $dd35  8659D  8666
PDP_36                         $dd3b  8662D  8660
PDP_37                         $dd4a  8669D  8590
PDP_38                         $dd50  8671D  8633
PDP_40                         $dd62  8678D  8682
PDP_44                         $dd72  8685D  8615   8631   8637   8640
                                      8651   8670
PDP_46                         $dd7a  8688D  8686
PDP_48                         $dd84  8692D  8689
PDP_50                         $dd8b  8695D  8693
PDP_52                         $dd92  8698D  8696   8735
PDP_54                         $dda9  8709D  8712
PDP_56                         $ddac  8710D  8700
PDP_58                         $ddc5  8720D  8702   8737
PDP_60                         $ddcb  8722D  8704   8739
PDP_62                         $ddd1  8724D  8706   8708
PDP_64                         $dde5  8732D  8719   8721   8723
PDP_66                         $ddf6  8740D  8767   8788
PDP_68                         $ddf9  8741D  8580   8687   8733
Set_DOS_Flags                  $ddfd  8745D  8614   8630   8650   8684
                                      8718   8731   8780   8805
DOS_JMP_Illegal_Quantity       $de27  8755D  7773   8652   8715   8775
                                      8777   8792   8807
DOS_Parse_Unit                 $de2c  8762D  8635   8720
Get_Unit_Value                 $de33  8770D  8638   8722
DOS_Parse_Filename             $de49  8785D  8673   8726
DPF_10                         $de64  8800D  8798
DPF_20                         $de6a  8803D  8801
DPF_30                         $de70  8806D  8796
DPF_40                         $de7c  8812D  8809
DOS_Parse_Value                $de87  8819D  8609   8622   8644   8713
                                      8773
DOS_Get_Byte                   $de8a  8825D  7746   7764
DGB_10                         $de8f  8830D  8828
DGB_20                         $de9a  8834D  8830
Start_Message                  $de9d  8837D  7124   7125
Renumber                       $deb1  8843D  3571
Renu_Err                       $decd  8861D  8872   8887   8930
Renu_10                        $ded0  8862D  8860
Renu_15                        $df0f  8893D  8855   8866   8877
Renu_20                        $df12  8894D  8889
Renu_25                        $df1b  8901D  8940
Renu_30                        $df55  8944D  8903
Renu_35                        $df59  8946D  8948
Renu_40                        $df66  8958D  8987
Renu_45                        $dfa0  8992D  8964
Renu_50                        $dfbd  9007D  9014   9017
Renu_55                        $dfca  9013D  9010
Renu_60                        $dfd3  9018D  9012
Renu_90                        $dfd5  9019D  9860  10227
EDITOR_JUMP_TABLE              $e000  9028
EDIT_RESET                     $e037  9052D  9031  13692
EDIT_CLEAR                     $e03d  9059D  9038   9635
EDCL_10                        $e03f  9063D  9067
EDIT_HOME                      $e04a  9070D  9533  10629
Edit_Goto_Left_Margin          $e04e  9077D  9697  10664
Edit_Use_CursorRow             $e052  9084D  9313   9513   9669   9713
                                     10603
EDIT_SET_CRT                   $e057  9091D 10478  10489
ESC_10                         $e05b  9100D  9104
Edit_Program_Rows              $e067  9109D  9544
EDIT_GETIN                     $e0a7  9128D  9032   9161  11958
EDGE_10                        $e0ac  9133D  9137
Edit_Get_Line                  $e0bc  9144D  9172
EGL_10                         $e0bf  9148D  9150   9170   9212
EGL_20                         $e0d7  9161D  9153
EGL_30                         $e0e2  9166D  9169
EGL_40                         $e0ed  9171D  9163
EGL_50                         $e0f7  9176D  9179
EGL_60                         $e0fe  9180D  9177
EDIT_CHRIN                     $e116  9198D  9033  11970  11976
Edit_CHRIN_Standard            $e11d  9208D 10076  10077
Edit_CHRIN_Screen              $e121  9215D  9186   9190
ECS_05                         $e12d  9224D  9221
ECS_10                         $e139  9230D  9228
ECS_20                         $e13f  9233D  9230
ECS_30                         $e143  9235D  9223   9232   9233
ECS_40                         $e14c  9239D  9191
ECS_50                         $e15b  9246D  9238   9244
ECS_Ret                        $e163  9252
Edit_Quote_Toggle              $e164  9255D  9236   9472
EQT_Ret                        $e16e  9263D  9259
Edit_Display_Char              $e16f  9266D  9473   9502   9626   9629
EDC_10                         $e175  9272D  9270
EDC_20                         $e17b  9275D  9273
Edit_Chrout_Epilog_Return      $e186  9283D  9478
EDC_30                         $e18b  9288D  9280
Edit_Chrout_Epilog             $e18d  9291D  9315   9467   9534   9618
                                      9647   9659   9670   9698   9735
Edit_Wrap_Back                 $e196  9304D  9653
EWB_10                         $e1a5  9314D  9310
Edit_Erase_To_EOL              $e1aa  9318D  9064   9761   9776
EETE_10                        $e1ac  9322D  9325
Edit_To_Left_Margin            $e1b4  9329D  9182  13385
Edit_Full_Screen               $e1bb  9338D  9532   9545  10070
EDIT_BOTTOM_RIGHT              $e1c5  9348D  9048
EDIT_TOP_LEFT                  $e1ca  9356D  9047
CO_Shift                       $e1cf  9363D  9426
CO_Tab                         $e1d2  9366D  9374   9454
CO_Size                        $e1e2  9379D  9462
Edit_Delete_Char               $e1e5  9382D  9436
EdDC_05                        $e1e9  9387D  9371
EdDC_10                        $e1ed  9389D  9395
EDIT_CHROUT                    $e202  9406D  7204   7214   7265   7297
                                      7371   7379   7407   7676   7678
                                      7954   7959   7970   8407   8416
                                      9034   9147   9245  11866  11994
                                     12156  12264  13281  13387  13396
Edit_CHROUT_Standard           $e20c  9419D 10080  10081
CO_Exit                        $e266  9467D  9375   9387   9399   9477
                                      9481   9485   9488   9491   9499
                                      9507   9514   9521
CO_Normal                      $e269  9471D  9428
CO_Right                       $e271  9475D  9440
CO_Down                        $e27a  9480D  9442
CO_RVS                         $e27f  9483D  9444
CO_Bell                        $e285  9487D  9446
CO_ChText                      $e28a  9490D  9448
CO_Return                      $e28f  9493D  9430
CO_Escape                      $e292  9495D  9432
CO_ChNew                       $e295  9497D  9450
CO_Switch                      $e297  9498D  9639
CO_Rev                         $e29c  9501D  9434   9438
CO_Top                         $e2a1  9504D  9452
CO_ScDown                      $e2a9  9509D  9466
CO_ScUp                        $e2ac  9511D  9456
CO_DEOL                        $e2b7  9516D  9458
CODE_10                        $e2b9  9517D  9520
CO_DLine                       $e2c2  9523D  9460
CO_Home                        $e2cf  9530D  9464
CoHo_05                        $e2d3  9532
COHo_10                        $e2d6  9533D  9531
Edit_Screen_30                 $e2dc  9536D  9622
Edit_Screen_25                 $e2e2  9540D  9379
Edit_Screen_Program            $e2e6  9543D  9539
CS_Return                      $e2ef  9548D  9587
Edit_Insert_Char               $e2f2  9551D  9591
InCh_10                        $e2fa  9558D  9565
InCh_20                        $e307  9566D  9562
Edit_CHROUT_Shifted            $e316  9578D  9363
CS_Exit                        $e360  9618D  9557   9571   9573   9633
                                      9636   9644   9652   9679
CS_Size                        $e363  9622D  9617
CS_Pi                          $e366  9623D  9583
CS_Print                       $e369  9625D  9585
CS_Rev                         $e36e  9628D  9589   9593
CS_RVS                         $e373  9631D  9599
CS_Clear                       $e379  9635D  9546   9601
CS_ChOld                       $e37e  9638D  9607
CS_Bottom                      $e383  9641D  9611
CS_Graph                       $e38b  9646D  9613
CS_Left                        $e391  9649D  9595
CS_Tab                         $e39c  9655D  9603
CS_Up                          $e3ab  9661D  9597
CS_ScDown                      $e3b5  9667D  9509   9609   9663
COSW_10                        $e3bb  9669D  9665
CS_Delete_BOL                  $e3c1  9673D  9605
CSDB_10                        $e3c5  9678D  9682
CS_Insert_Line                 $e3ce  9687D  9615
TM_Epi                         $e3d8  9695D  9528
Edit_Cursor_Down               $e3e1  9703D  9286   9480   9725
CSCD_10                        $e3ef  9712D  9709
CO_Screen_Return               $e3f4  9718D  9493   9548
CO_JMP_Escape                  $e3ff  9728D  9495
Edit_Scroll                    $e40a  9738D  9759   9774
ES_10                          $e40d  9742D  9746
EDIT_SCROLL_DOWN               $e417  9751D  9042   9667   9694  10644
ESD_10                         $e419  9755D  9760
ESD_30                         $e426  9761D  9757
EDIT_SCROLL_UP                 $e429  9766D  9043   9511   9527   9710
ESU_10                         $e42b  9770D  9775
ESU_30                         $e438  9776D  9772
IRQ_MAIN                       $e442  9783D  9035  14248
IRQ_05                         $e452  9796D  9794
IRQ_NORMAL                     $e455  9799D  9036  10039  10041  13769
IRQ_10                         $e470  9815D  9812
IRQ_20                         $e474  9817D  9804   9806
IRQ_END                        $e477  9818D  9037
Delete                         $e47d  9826D  3573
Del_10                         $e4a3  9845D  9843
Del_20                         $e4ab  9848D  9846
Del_30                         $e4af  9850D  9853   9857
DelErr                         $e4c5  9861D  9838
Get_Record_Size                $e4c8  9865D  9889  11685
GRS_90                         $e4fa  9890D  9876   9885
Mon_Message                    $e4fb  9893D  7378
IS_TAB                         $e525  9899D  9373   9655
BITPOS                         $e537  9915D  9657   9910
Mon_Fill                       $e53f  9921D  7323   7351
MoFi_10                        $e555  9934D  9942
MoFi_End                       $e569  9943D  9938
MoFi_Err                       $e56c  9944D  9926   9929   9931
Open_Disk_Buffer               $e56f  9950D  9983
ODB_20                         $e580  9959D  9965
ODB_30                         $e58f  9966D  9963
Mon_Disk                       $e5a7  9978D  7332   7360
MIB_30                         $e5c0  9993D  9996
Mon_Output_Block               $e5d1 10002D  9986
MOB_10                         $e5e0 10013D 10016
Edit_Init                      $e606 10025D  9055
EdIn_10                        $e611 10033D 10035
EdIn_20                        $e66d 10073D 10075
Double_Beep                    $e68a 10089D 10086
EDIT_BEEP                      $e68d 10095D  9045   9046   9487  10092
BEEP_10                        $e69d 10105D 10114
BEEP_20                        $e6a5 10108D 10109  10112
BEEP_Ret                       $e6b6 10117D 10099
Set_Screen_SAL                 $e6b7 10120D  9741
Cursor_BOL                     $e6c9 10136D  9063   9755   9770  10563
                                     10575
Update_ScrPtr                  $e6cb 10146D  9088
RUN_String                     $e6dd 10162D  9166
CRT_TEXT                       $e6e5 10169D 10476  10477
CRT_GRAPHICS                   $e6f7 10195D 10487  10488
OLD                            $e701 10213D  3577
SOUND_TAB                      $e74e 10232D 10105
Line_Addr_Lo                   $e755 10238D 10127  10153  10511
Line_Addr_Hi                   $e76e 10247D 10131  10157  10516
B_P_0                          $e78e 10255D 10264  10267
U1                             $e796 10256D 10276
Reset_BP                       $e79b 10259D 10007
RBP_30                         $e7a0 10264D 10268
Preset_U1                      $e7ae 10272D  9953
PU1_10                         $e7b0 10276D 10279
Mon_Disk_Comm                  $e7ba 10283D  9987  10018
MDC_10                         $e7bf 10288D 10292
PIA1_Port_A                    $e810   974D 10048  10319  10321  10380
                                     11931
PIA1_Cont_A                    $e811   975D 10060  11757  11762
PIA1_Port_B                    $e812   976D 10056  10332  10333
PIA1_Cont_B                    $e813   977D 10055
PIA2_Port_A                    $e820   994D 11935
PIA2_Cont_A                    $e821   995D 10058  11753  11855  11918
                                     11939  11943
PIA2_Port_B                    $e822   996D 10052  10061  11783  11798
PIA2_Cont_B                    $e823   997D 10059  11776  11787  11796
VIA_Port_B                     $e840  1038D 10050  11749  11751  11766
                                     11769  11777  11784  11790  11812
                                     11814  11851  11853  11899  11901
                                     11919  11921  11926  11928  11930
                                     11940
VIA_Port_A                     $e841  1039
VIA_DDR_B                      $e842  1040D 10051
VIA_DDR_A                      $e843  1041
VIA_Timer_1_Lo                 $e844  1042D  6881
VIA_Timer_1_Hi                 $e845  1043D  6885  10053  11789  11923
VIA_Timer_1_Latch_Lo           $e846  1044
VIA_Timer_1_Latch_Hi           $e847  1045
VIA_Timer_2_Lo                 $e848  1046D  6883  10106  13755  13767
VIA_Timer_2_Hi                 $e849  1047D  6887  13757
VIA_Shift                      $e84a  1048D 10103  10115
VIA_ACR                        $e84b  1050D 10101  10116
VIA_PCR                        $e84c  1055D 10475  10486
VIA_IFR                        $e84d  1057D 11791  11924  13764
VIA_IER                        $e84e  1067D 10029  10067  13753
VIA_Port_A_no_HS               $e84f  1068
CRT_Address                    $e880  1073D  9101   9118   9121  10457
CRT_Value                      $e881  1074D  9102   9119   9122  10458
EDIT_KEY_SCAN                  $e924 10314D  9044   9817
ScKbd_02                       $e93a 10332D 10334  10381
ScKbd_04                       $e944 10339D 10376
ScKbd_06                       $e95c 10364D 10347  10349  10355
ScKbd_08                       $e960 10369D 10360
ScKbd_10                       $e961 10370D 10340
ScKbd_12                       $e96c 10385D 10371
ScKbd_22                       $e972 10388D 10397  10399
ScKbd_13                       $e973 10392D 10386
ScKbd_14                       $e97f 10398D 10395
ScKbd_15                       $e98b 10404D 10402
ScKbd_16                       $e98f 10409D 10393
ScKbd_18                       $e995 10412D 10405
ScKbd_24                       $e9a2 10421
ScKbd_26                       $e9a7 10426D 10417
ScKbd_28                       $e9af 10430D 10428
ScKbd_30                       $e9b1 10431D 10414
Lookup_Keycode                 $e9b4 10435D 10412
LoKe_10                        $e9bf 10443D 10441
LoKe_20                        $e9c0 10444D 10440
LoKe_30                        $e9c6 10447D 10444
Edit_Switch_Char_ROM           $e9ca 10451D  9498
EDIT_RESET_CRT                 $e9d3 10463D  9041   9056
EDIT_CHARSET_TEXT              $e9d6 10470D  9039   9490
EDIT_CHARSET_GRAPHICS          $e9e4 10481D  9040   9646
Read_Power_String              $e9f2 10492D  1538
Check_Linenumber               $e9fc 10502D 10535  10547
ChLi_Ret                       $ea1c 10523D 10520
Check_Line_Upwards             $ea1f 10528D 10592
CLU_10                         $ea21 10532D 10536
CLU_Ret                        $ea2b 10537D 10533
Check_Line_Downwards           $ea2c 10540D 10616
CLD_10                         $ea2e 10544D 10548
CLD_Ret                        $ea38 10549D 10545
Power_Scroll_Up                $ea39 10552D  9512   9711
PSU_10                         $ea4b 10565D 10569
PSU_15                         $ea81 10592D 10572
PSU_20                         $ea8c 10597D 10595
PSU_30                         $ea92 10599D 10566  10578  10590  10593
                                     10617  10624  10633  10656
PSU_Ret                        $ea9b 10604D 10556  10611
Power_Scroll_Down              $ea9c 10607D  9668
PSD_20                         $eaba 10625D 10621
PSD_30                         $ead2 10636D 10639
List_BASIC_Line                $eaf9 10661D 10598  10630  10655  11336
                                     13979
LBL_Ret                        $eb0e 10675D 10667
Find_Power_Line                $eb0f 10678D  8880  10597  10618
FPL_10                         $eb17 10685D 10707
FPL_40                         $eb3f 10708D 10689  10696
KEYBOARD_NORMAL                $eb40 10711D 10447
KEYBOARD_SHIFTED               $eb90 10835D 10445
KEYBOARD_CONTROL               $ebe1 10951D 10438
Find_Entry                     $ec32 11046D  8973
Find_LINNUM                    $ec36 11053D 11225
FiEn_10                        $ec42 11063D 11084
FiEn_20                        $ec63 11079D 11066
FiEn_30                        $ec66 11082D 11068  11072
Install_Bank_Access            $ec6e 11088D  7180   8894
FSC_10                         $ec70 11092D 11096
Bank_Fetch_Start               $ec7c 11100D   908  11092  11095
Bank_Fetch_End                 $ec8d 11115
Bank_Store_Start               $ec8d 11119D   908
Bank_Store_End                 $eca0 11136D 11095
Get_Next                       $eca0 11141D 11174  11180  11189  11205
GeNe_10                        $eca6 11147D 11145
Xfer_Line                      $eca9 11151D  8980
XfLi_10                        $ecba 11173D 11185  11194  11210
XfLi_20                        $ecc7 11179D 11184
XfLi_30                        $ecd6 11186D 11178
XfLi_40                        $ecda 11188D 11191
XfLi_50                        $ece4 11193D 11187  11213
XfLi_55                        $ecfa 11204D 11208
XfLi_60                        $ed05 11209D 11203
XfLi_70                        $ed09 11211D 11195  11197  11199  11201
XfLi_Ret                       $ed10 11214D 11176  11182
Exchange_Number                $ed11 11218D 11211  11249
ExNu_10                        $ed34 11239D 11244
ExNu_20                        $ed40 11245D 11223  11240
ExNu_Ret                       $ed4c 11250
Reset_Renumber_Pointer         $ed4d 11253D  8893   8954   9005  11331
                                     13939
Reset_BPTR                     $ed55 11264D  8888
Update_Link                    $ed5e 11274D  8939   8984   9847  11338
                                     13949
Extended_Command               $ed6b 11288D 12924
ExCo_10                        $ed6f 11293D 11320
ExCo_20                        $ed73 11296D 11301
ExCo_30                        $ed95 11315D 11303
ExCo_40                        $ed97 11316D 11318
Find_Text                      $eda3 11325D  3574
FiTe_10                        $edae 11332D 11339
FiTe_20                        $edbd 11338D 11335
Contains_Pattern               $edc5 11343D 11334  13944
CoPa_10                        $edc5 11346D 11358
CoPa_20                        $edc9 11348D 11355
CoPa_Ret                       $ede0 11360D 11351  11353
Load_Directory                 $ede1 11363D 11486
LoDi_10                        $edf1 11374D 11386
LoDi_20                        $edfb 11379D 11377
LoDi_30                        $edfd 11380D 11385
LoDi_40                        $ee0b 11387D 11383
DOS_Get_Dir_Entry              $ee0e 11390D 11444  11494
DGDE_05                        $ee19 11405D 11402
DGDE_10                        $ee1b 11407D 11410
DGDE_20                        $ee42 11430D 11435
DGDE_40                        $ee4d 11437D 11433
DGDE_60                        $ee4f 11439D 11442
DGDE_80                        $ee5e 11448D 11411
DOS_Add_Comma                  $ee5f 11451D 11505  11512  11519
DOS_Copy                       $ee65 11472D  8278
DOSC_10                        $ee8b 11494D 11630
DOSC_15                        $ee92 11499D 11496
DOSC_20                        $eeb5 11517D 11508
DOSC_25                        $eebd 11522D 11515
DOSC_35                        $eed2 11544D 11538
DOSC_47                        $eed8 11549
DOSC_50                        $eee0 11554D 11550
DOSC_55                        $eee3 11558D 11608  11613  11615
DOSC_60                        $eef5 11567D 11574
DOSC_65                        $ef05 11576D 11572
DOSC_66                        $ef15 11584D 11579
DOSC_67                        $ef28 11594D 11591
DOSC_70                        $ef32 11599D 11605
DOSC_75                        $ef56 11617D 11582  11602  11610
Send_Record_No                 $ef77 11633D 11592
SRN_10                         $ef7d 11639D 11637
Print_Filename                 $ef88 11646D 11544
PrFi_10                        $ef8f 11652D 11667
PrFi_20                        $efad 11666D 11656  11659
PrFi_90                        $efb1 11668D 11650
Open_Read_File                 $efb2 11671D 11545
ORF_10                         $efcc 11686D 11684
Open_Write_File                $efcf 11689D 11554
MSG_TOO_MANY                   $f000 11710
KERNAL_MESSAGES                $f000 11707D 11863
MSG_FILE_OPEN                  $f00e 11711D 12432
MSG_FILE_NOT_O                 $f017 11712D  8203  12849
MSG_FILE_NOT_F                 $f024 11713D 12462
MSG_SEARCHING                  $f032 11714D 12280
MSG_FOR                        $f03d 11715
MSG_PRESS                      $f041 11716
MSG_RECORD                     $f04d 11717
MSG_ON_TAPE                    $f056 11718
MSG_LOAD                       $f05f 11719D 12275
MSG_WRITING                    $f064 11720
MSG_VERIFY                     $f06d 11721D 12278  12354
MSG_DEVICE_NOT                 $f074 11722D 12332  12851
MSG_NOT_INPUT                  $f086 11723
MSG_NOT_OUTPUT                 $f094 11724D 12853
MSG_FOUND                      $f0a3 11725
MSG_OK                         $f0aa 11726D 12356
MSG_READY                      $f0ae 11727D 12241
MSG_SURE                       $f0b6 11728D  8429
MSG_BAD_DISK                   $f0c5 11729D  8161
TALK                           $f0d2 11732D  8118   9988  11560  12194
                                     12837
LISTEN                         $f0d5 11739D  8263   9969  10008  11594
                                     12321  12729  12758  12877  13458
TALI_10                        $f0d7 11745D 11910
TALI_20                        $f0fa 11763D 11755
TALI_30                        $f0ff 11766D 11767
Send_IEEE_Byte                 $f109 11772D 11758  11806  11877  11890
SIB_10                         $f11e 11784D 11785
SIB_20                         $f128 11788D 11824
SIB_30                         $f12d 11790D 11794
tby6                           $f138 11795D 11836
SECOND                         $f143 11802D  9971  10011  11597  12329
                                     12731  12762  12879  13461
Set_ATN                        $f148 11809D 11879  11911
Time_Out_Writing               $f151 11818D 11792
Time_Out_Reading               $f15b 11827D 11925
Timo_W                         $f165 11834D 11822
Timo_S                         $f167 11835D 11843
Device_Not_Present             $f16c 11839D 11780
Timo_R                         $f170 11844D 11831
Set_NRFD_NDAC_low              $f175 11848D 11878
Display_Kernal_Message         $f185 11860D  8162   8430  11869  12119
                                     12357  12473
TKSA                           $f193 11873D  8121   9991  11563  12196
                                     12839
CIOUT                          $f19e 11882D  9973  10014  10265  10290
                                     11600  11995  12336  12735  12737
                                     12745  12945  13472
Ciout_10                       $f1a6 11889D 11886
Ciout_20                       $f1ab 11892D 11888
UNTLK                          $f1ae 11896D  6428   8132   9997  11577
                                     12017  12180
UNLSN                          $f1b9 11906D  7940   9974  10017  10269
                                     10293  11606  11617  12013  12340
                                     12752  12763  12948  13475
ACPTR                          $f1c0 11914D  7945   7949   7955   8123
                                      9993  11380  11567  11981  12160
                                     12197  12199
Acptr_10                       $f1cd 11922D 11833
Acptr_20                       $f1d2 11924D 11927
Acptr_30                       $f1ee 11935D 11932
Acptr_40                       $f1f9 11940D 11941
Kernal_GETIN                   $f205 11948D 14227
GETIN_10                       $f20d 11955D  7962   7965
Kernal_CHRIN                   $f215 11961D  7998   8432   8435   8440
                                      8443   8449   9954   9957  14185
KeIn_10                        $f224 11971D 11954  11965
KeIn_20                        $f231 11977D 11972
KeIn_30                        $f237 11980D 11956
KeIn_40                        $f238 11981D 11978
Kernal_CHROUT                  $f266 11986D 12470  12472  14191
KeCH_10                        $f271 11995D 11993
Kernal_CLALL                   $f2a2 12000D 12468  14233
Kernal_CLRCHN                  $f2a6 12007D  7171   7974   8431  12101
                                     14179
KeCL_10                        $f2af 12014D 12012
Set_Default_IO                 $f2b8 12020D 12016
LOOKUP_LA                      $f2c1 12030D  8201  12068  12433  12832
                                     12871
LOOK_10                        $f2c3 12034D 12037
LOOK_Ret                       $f2cb 12038D 12035
Set_LFS_From_X                 $f2cd 12043D  8205  12075  12834  12873
Kernal_CLOSE                   $f2dd 12058D 14161
Close_LA_in_A                  $f2e2 12065D  7976   8178
Close_File_A                   $f2e7 12072D  8191
ClFi_10                        $f2f1 12079D 12077
ClFi_20                        $f30b 12089D 12069  12081
Check_STOP_Key                 $f335 12094D  7445   7960  12110  12481
                                     13663  13942
ChST_Ret                       $f342 12104D 12099  12118
Kernal_STOP                    $f343 12107D  2111  11823  11832  12159
                                     12746  14221
Kernal_Message_If_Direct       $f349 12114D 12242  12279  12281
In_Direct_Mode                 $f351 12122D  8159   8403   8427  11649
                                     12117  12148  12175  12182  12243
Load_File                      $f356 12130D  7613  12238
LoFi_10                        $f35c 12136D 12138
LoFi_15                        $f35f 12137D 12135
LoFi_20                        $f370 12145D 12142
LoFi_25                        $f377 12148D 12146
LoFi_30                        $f38e 12157D  6430  12149
LoFi_35                        $f390 12158
LoFi_40                        $f392 12159D 12179
LoFi_45                        $f3a7 12168D 12162
LoFi_50                        $f3a9 12169D 12171
LoFi_55                        $f3af 12172D 12164
LoFi_60                        $f3bd 12178D 12173  12176
LoFi_70                        $f3c1 12180D 11387  12167
LoFi_80                        $f3cd 12185D 12183
Open_Load_File                 $f3d0 12188D  6425  11366  12140
Merge                          $f3e6 12202D  3576
Kernal_LOAD                    $f401 12211D 14197
KeLO_10                        $f403 12215D 12206
Load_Verify                    $f405 12218D 12350
Load_Verify_Params_Set         $f41d 12235D  8378  12223  12999
LVPS_20                        $f439 12250D 12244
LVPS_Ret                       $f43f 12252D 12240
Print_EAL                      $f440 12255D 12177  12185
PrEA_10                        $f44e 12264D 12266
PrEA_Ret                       $f454 12267
Display_Load_Or_Verify         $f46d 12272D 12150
DLOV_10                        $f475 12279D 12277
Get_File_Parameter             $f47d 12284D 12221  12713
GFP_Ret                        $f4a8 12306D 12320
Get_Comma_And_Byte             $f4a9 12309D 12297  12300  12372  12375
Send_Filename                  $f4af 12316D  9870  11686  11701  12193
                                     12453  12728
Send_DOS_Command               $f4ba 12326D  8265
SeDC_10                        $f4c6 12334D 12331
SeDC_20                        $f4c8 12335D 12339
Kernal_VERIFY                  $f4f6 12345D 14209
VERI_OK                        $f508 12356D 12353
Get_Open_Close_Parameter       $f50d 12360D 12061  12424
Set_Filename_From_String       $f53c 12384D 12295  12379
ChrGot_Or_RTS                  $f54d 12397D 12294  12296  12299  12371
                                     12374  12377
Get_Ret                        $f554 12404D 12401  12417  12449  12451
Get_Comma_And_Chr              $f555 12407D 12312  12378
Assert_Not_At_End              $f558 12413D 12368
Err_f55d                       $f55d 12418D 12431  12452
Kernal_OPEN                    $f560 12421D 14155
Mf563                          $f563 12425D  8087   8106
Open_File                      $f565 12428D  7941
Display_File_Not_Found         $f5ad 12459D 12147
Handle_IO_Error                $f5af 12465D  8204  12333  12355  12434
                                     12439  12854
Disassemble                    $f5c2 12477D  7322   7350
Disa_10                        $f5c5 12481D 12491
Disa_15                        $f5cf 12485D  7416
Disa_Main                      $f5e3 12493D 12482  12484
Print_Dis_Line                 $f5e6 12496D 12489  13394
Disa_20                        $f5e9 12501D 12509
Disa_40                        $f5f2 12504D 12511
Disa_50                        $f5f8 12506D 12503
Dis_Inst                       $f614 12523D 12488
DiIn_10                        $f61c 12529D 12532
Analyze_Opcode                 $f625 12535D 13352
AnOp_10                        $f634 12559D 12552
AnOp_20                        $f63f 12567D 12562
AnOp_30                        $f643 12569D 12554  12556
AnOp_40                        $f647 12571D 12568
AnOp_50                        $f65c 12583D 12592
AnOp_60                        $f660 12586D 12589
AnOp_70                        $f667 12591D 12582  12584
admode_index                   $f66b 12596D 12561
Kernal_SYS                     $f6c3 12688D 14215
Set_Save_Range                 $f6cc 12696D 12714
Kernal_SAVE                    $f6dd 12710D 14203
Mf6e0                          $f6e0 12714D  8359   8362
Save_File                      $f6e3 12717D  7638
SaFi_10                        $f6e9 12723D 12727
SaFi_20                        $f6ec 12724D 12722
SaFi_30                        $f70f 12740D 12748  12751
SaFi_40                        $f717 12744D 12741
SaFi_50                        $f727 12752D 12743
Close_Disk_File                $f72a 12755D  9998  10019  11622  11629
                                     12078  12181
Store_Mnemonic                 $f739 12766D 12513  13354
PrMn_10                        $f746 12775D 12786
PrMn_20                        $f74a 12777D 12781
Kernal_UDTIM                   $f768 12793D  9802  12814  14239
ud_10                          $f772 12801D 12799
ud_20                          $f784 12810D 12797  12803  12806
ud_30                          $f78e 12815D 12811
Kernal_CHKIN                   $f7af 12820D  7943  14167
CHKIN_10                       $f7d0 12843D 12836
CHERR_17                       $f7d6 12849D 12833  12872
CHERR_74                       $f7d9 12851D 12841  12881
CHERR_94                       $f7dc 12853D 12874
CHERR_IO                       $f7de 12854
Kernal_CHKOUT                  $f7fe 12859D 14173
KeCo_10                        $f821 12883D 12876
Set_Wedge_Unit                 $f827 12890D 12919
SWUN_10                        $f838 12900D 12894
Wedge_Parser                   $f842 12906D  1547
Command_Or_Status              $f869 12929D 12913  12915
Send_Command                   $f873 12939
SeCo_10                        $f876 12943D 12947
SeCo_20                        $f880 12948D 12944
Get_Status                     $f883 12951D 12934
Wedge_Directory                $f88c 12959D 12917  12936
Print_Status                   $f898 12968D 12955  13483
RUN_Now                        $f8a1 12975D 12983
Wedge_Run                      $f8a6 12978D 12923
WeRu_10                        $f8aa 12983D 12986
Wedge_Load                     $f8b3 12989D 12921  12996
WeLo_10                        $f8be 12997D 12994
Wedge_Prepare                  $f8c7 13002D  6418   7596   9967  12954
                                     12963  12998  13457  13482  13499
Wedge_Filename                 $f8d0 13012D 12962  12997
WeFi_10                        $f8db 13020D 13018  13024
WeFi_20                        $f8e4 13025D 13022
Mnemonic_Left                  $f8f3 13035D 12771
Mnemonic_Right                 $f933 13104D 12773
admode_format                  $f973 13173D 12572
adr_char1                      $f981 13201D 13231
adr_char2                      $f987 13202D 13234
Store_Address                  $f98d 13205D 12514  13355
StAd_10                        $f99f 13217D 13239
StAd_20                        $f9ae 13224D 13221
StAd_30                        $f9b9 13229D 13218
StAd_40                        $f9cd 13238D 13230  13235
StAd_50                        $f9d2 13241D 13226
StAd_Ret                       $f9d8 13243D 13212  13240
Store_Hex_XA                   $f9dc 13248D 13242  13875
Store_Hex                      $f9e2 13256D 13223  13228  13252  13813
                                     13815
Print_Dis_Buf                  $f9f9 13276D 12515
PDB_10                         $f9fb 13280D 13284
Ass_Operand                    $fa08 13288D 13294  13300  13349
AsOp_30                        $fa1e 13301D 13292  13296
AsOp_Ret                       $fa3e 13317D 13303  13306  13308
AsOp_40                        $fa3f 13318D 13310
Assemble                       $fa42 13322D  7314   7319   7342   7347
Ass_010                        $fa47 13331D 13338
Ass_020                        $fa4f 13335D 13342
Ass_040                        $fa70 13350D 13344
Ass_050                        $fa73 13351D 13365  13370
Ass_060                        $fa89 13359D 13363
Ass_070                        $fa94 13364D 13358
Ass_Err                        $faa4 13371D 13330  13336  13346  13367
                                     13382
Ass_080                        $faa7 13372D 13360
Ass_090                        $fab3 13378D 13384
Inc_STAL                       $fb13 13418D 13572  13590  13676
Add_STAL                       $fb15 13424D  7455  10585  11083
AdST_00                        $fb16 13428D 12518
AdST_10                        $fb1c 13431
AdST_Ret                       $fb1e 13432D 13430
Inc_BPTR                       $fb1f 13436D  9941  13573  13591
Add_BPTR                       $fb21 13442D  8935   8983
AdBP_00                        $fb22 13446
AdBP_10                        $fb28 13449
AdBP_Ret                       $fb2a 13450D 13448
DOS_Open_Comm_Write            $fb2b 13454D 10262  10286  12942  13470
Mon_Wedge                      $fb38 13464D  7318   7346
MoWe_10                        $fb42 13472D 13474
Mon_Wedge_Status               $fb4d 13478D 13468
Mon_Dir                        $fb59 13487D  7313   7341
MoDi_10                        $fb5d 13492D 13495
Init_RAM_Vectors               $fb77 13504D  7123
IRV_10                         $fb79 13508D 13511
ROM_BASIC_Vector_Table         $fb83 13515D 13507  13508
RBVT_END                       $fb8f 13524D 13507
Set_STATUS                     $fbc4 13528D 11835  11845  11934  12166
Mon_Get_3                      $fbc9 13537D 13558  13582
MG3_Err                        $fbdf 13550D 13541  13544  13547
Mon_Compare                    $fbe4 13555D  7321   7349
MoCo_10                        $fbea 13560D 13575
MoCo_20                        $fc08 13572D 13569
Mon_Transfer                   $fc16 13579D  7331   7359
MoTr_10                        $fc23 13588D 13593
MoTr_Ret                       $fc34 13594D 13620
MoTr_Err                       $fc37 13595D 13609
MoTr_20                        $fc3a 13596D 13587
MoTr_30                        $fc62 13617D 13629
MoTr_40                        $fc73 13624D 13622
MoTr_50                        $fc7b 13628D 13626
Mon_Hunt                       $fc80 13632D  7325   7353
MoHu_10                        $fc85 13637D 13640
MoHu_20                        $fc99 13646D 13651
MoHu_30                        $fc9e 13648D 13645
MoHu_40                        $fca8 13653D 13642  13660
MoHu_50                        $fcb9 13661D 13647  13652  13654  13656
MoHu_60                        $fcbe 13663D 13677
MoHu_70                        $fcca 13668D 13673
MoHu_80                        $fcdd 13676D 13670
MoHu_Ret                       $fce2 13678D 13664  13666
MoHu_Err                       $fce5 13679D 13638  13644
Entry_RESET                    $fd16 13685D 14247
Entry_NMI                      $fd49 13713D 14246
Set_FA_to_8                    $fd4c 13719D 12367
Mon_Unit                       $fd51 13727D  7312   7340
MoUn_10                        $fd60 13737D 13731  13733  13735
Mon_Next                       $fd6e 13744D  7328   7356
Mon_Step_IRQ                   $fd89 13761D 13748  13750
MSI_10                         $fd96 13769D 13766
Get_Constant                   $fd99 13773D 13295
GeCo_10                        $fda2 13780D 13791
GeCo_20                        $fdaf 13785D 13788
GeCo_25                        $fdbd 13792D 13839
GeCo_30                        $fdcf 13802D 13782  13794
GeCo_40                        $fde4 13814D 13812
GeCo_Ret                       $fdef 13821D 13777  13796
GeCo_45                        $fdf2 13823D 13779
GeCo_50                        $fdfc 13828D 13838
GeCo_70                        $fe0d 13836D 13825  13827
Expand_Address                 $fe17 13843D 13369
ExAd_10                        $fe1a 13847D 13852
ExAd_20                        $fe27 13853D 13849
Expand_Target                  $fe36 13861D 13318
Offset_To_Target               $fe46 13881D 13241  13874
OTT_10                         $fe4d 13893D 13891
OTT_20                         $fe53 13897D 13895
OTT_30                         $fe59 13901D 13899
Replace                        $fe5a 13906D  3575
Repl_00                        $fe67 13914D 13911
Repl_01                        $fe6b 13916D 13920
Repl_02                        $fe82 13928D 13932
Repl_08                        $fe9a 13940D 13950
Repl_10                        $fe9e 13942D 13948
Repl_20                        $feb0 13949D 13945
Repl_Ret                       $feb8 13952D 13943
Repl_Err                       $febb 13953D 13918  13930
Replace_String                 $febe 13957D 13946
ReSt_05                        $fec7 13965D 14015
ReSt_10                        $fece 13970D 13975
ReSt_20                        $fed9 13976D 13972
ReSt_25                        $fee0 13979D 13977
ReSt_30                        $fee7 13982D 13964
ReSt_35                        $fefb 13995D 13993
ReSt_40                        $ff0a 14003D 14001
ReSt_45                        $ff1d 14013D 14056
ReSt_50                        $ff21 14016D 13982
ReSt_60                        $ff43 14035D 14045  14048
ReSt_62                        $ff4d 14040D 14038
ReSt_64                        $ff53 14043D 14041
ReSt_Ret                       $ff6f 14057
Basic_CONCAT                   $ff93 14062D  1119
Basic_DOPEN                    $ff96 14068D  1120
Basic_DCLOSE                   $ff99 14074D  1121
Basic_RECORD                   $ff9c 14080D  1122
Basic_HEADER                   $ff9f 14086D  1123
Basic_COLLECT                  $ffa2 14092D  1124
Basic_BACKUP                   $ffa5 14098D  1125
Basic_COPY                     $ffa8 14104D  1126
Basic_APPEND                   $ffab 14110D  1127
Basic_DSAVE                    $ffae 14116D  1128
Basic_DLOAD                    $ffb1 14122D  1129
Basic_DIRECTORY                $ffb4 14128D  1130   1133
Basic_RENAME                   $ffb7 14134D  1131
Basic_SCRATCH                  $ffba 14140D  1132
Read_DS                        $ffbd 14146
OPEN                           $ffc0 14152D  1114
CLOSE                          $ffc3 14158D  1115
CHKIN                          $ffc6 14164D  2925   2945
CHKOUT                         $ffc9 14170D  2752
CLRCHN                         $ffcc 14176D  1498   2954
CHRIN                          $ffcf 14182D  1675
CHROUT                         $ffd2 14188D  1505   2801   2855   2884
                                      9879   9880  11624  11654  11660
                                     11662
Basic_LOAD                     $ffd5 14194D  1102
Basic_SAVE                     $ffd8 14200D  1103
Basic_VERIFY                   $ffdb 14206D  1104
Basic_SYS                      $ffde 14212D  1113
STOP                           $ffe1 14218D  1939
GETIN                          $ffe4 14224D  3040
CLALL                          $ffe7 14230D  1866
UDTIM                          $ffea 14236
HardwareVectors                $fffa 14243
INDEXA                         $001f   367D  1400   1410   1416   1565
                                      1567   1590   1592   1594y  1598
                                      1650y  1654   1657y  1659   1661y
                                      1662   1663   1664y  1725   1727
                                      1730   1732   1735y  1766y  1768
                                      1770   1773y  2022   2024   2028
                                      2030   2031y  2035y  2561y  2635
                                      2636   2649   2651   2682y  2686y
                                      2689y  2696   2697   2701   2703
                                      2854y  3300   3302   3357   3359
                                      3374   3376   4047   4048   4050y
                                      4053y  4056y  4060y  4068y  4072
                                      4073   4075   4076   4082y  4086y
                                      4090y  4099   4102   4106   4107
                                      4109   4333   4401   4434   4761
                                      4764   4769   4781y  4784y  4836
                                      4838   4841y  4851   4855y  4866y
                                      4876y  4879y  4969   4970   4980y
                                      5013   5014   5024   5025   5040y
                                      5043y  5046y  5048   5049   5107
                                      5108   5110   5200y  5240   5243
                                      5245   5756   5757   5759y  5762y
                                      5765y  5768y  5776y  5956   5957
                                      5959y  6011   6012   6015y  6018y
                                      6021y  6026y  6029y  8678y  8794y
                                      8800   8802   8812   8813  10222
                                     10225  12390  12392
TMPPTC                         $005c   523D  1399   1403   1564y  1568
                                      1570   1572y  1580   1583   1628y
                                      1795   1796   1797y  1802y  1807y
                                      1811y  1937y  1945y  1948y  1966y
                                      1969y  1970   1971   1995y  2004y
                                      2300   2303   3952   3953   3959y
                                      3963y  3968   4017   4018   4114y
                                      4117y  4120y  4122y  4124y  4126y
                                      4128y  4129   4132   4148   4149
                                      4242   4243   4249y  4254y  4257y
                                      4259   4262y  4263   4288y  4300y
                                      4305y  4314y  4326y  4329y  4361
                                      4363y  4366   4367y  4371y  4382y
                                      4387y  4435y  4438y  6282   6285
                                      6292   6293   6319   6350   8902y
                                      8908y  8911y  8959y  8962y  8969y
                                      8972y  9008y  9015   9018   9832
                                      9834   9850y  9855   9856  10619
                                     10622  10626  10628  10648y 10651y
                                     10652  10653  10666y 10669y 10672y
                                     10685  10686  10688y 10691y 10694y
                                     10697  10699  10703y 10706y 11165
                                     11168  11259  11261  11278y 11281y
                                     11282  11283  11354y 11357y 13973y
                                     13985  13987  13991  13992  13994
                                     14010  14012  14018  14020
FAC1M3/FAC1M4                  $0061   530D  2507   2591y  2594y  2610
                                      2613   2620y  2625   2730   2731
                                      3366   3476   3606   3645y  3648y
                                      3720   3747   3781   3793   3798
                                      4224   4379   4398   4656   4732
                                      4923   4934y  5002   5224   5297
                                      5441   5465   5468   5490   5492
                                      5504   5524   5547   5549   5565
                                      5699   5883   5909   5947   5978
                                      6017   6124   6168   6201   6583
                                      6585   6886   6904   6906    531D
                                      2414   2510   2606   2614   2626
                                      2727   2728   3364   3473   3607
                                      3612   3657   3721   3745   3783
                                      3790   3795   4226   4381   4402
                                      4657   4733   4921   5003   5130
                                      5146   5148   5226   5298   5438
                                      5467   5470   5487   5489   5503
                                      5525   5550   5552   5563   5697
                                      5886   5906   5949   5979   6014
                                      6123   6174   6202   6232   6237
                                      6580   6582   6888   6899   6901
TXTPTR                         $0077   579D  1539   1540   1696   1723
                                      1764   1778   1780   1901   1904
                                      2067   2069   2112   2115   2119y
                                      2122y  2126y  2129y  2132   2133
                                      2135   2213   2214   2242   2243
                                      2264   2266   2291   2292   2302
                                      2305   2330   2332   2346   2347
                                      2349   2371y  2911   2912   3028
                                      3029   3034   3035   3051   3052
                                      3062   3077   3078   3101   3102
                                      3107   3108   3122y  3125y  3128y
                                      3131y  3210   3212   3262   3264
                                      3265   3320   3322   3323   3450
                                      3451   3519y  4546   4548   4595
                                      4597   4600   4603   4617   4619
                                      5236   5237   5241   5246   5267
                                      5268   6360y  7058   7060   8659
                                      8661   8662y 10513  10518  11144
                                     11146  11147x 11167  11170  11294
                                     11306  11346  12125  12911y 12932
                                     12933y 12943y 13019  13021y 13026
                                     13028  13915  13926
LINNUM                         $0011   346D  1617   1618   1801   1806
                                      1926   1927   1929   1952   1954
                                      2287   2434   2435   2437   2458
                                      2460   2462   2463   2464   2466
                                      2467   2468   2469   2471   2472
                                      2474   5299   5300   5307   5309
                                      5313y  5316   5318   5328y  5343y
                                      7096   7097   7102y  7105y  7106y
                                      7109y  7110y  7113y  7116   7118
                                      8216   8218   8857   8859   8862
                                      8869   8871   8873   8975   8978
                                      9841   9842   9844  10594  10596
                                     10692  10695  11049  11050  11067
                                     11071  11075  11078  11228  11230
                                     11500  11501  11636  11638  12693
                                     12901  13829  13831  13834
FAC1M1/FAC1M2                  $005f   528D  2081   2082   3370   3679
                                      3834   3860y  4492   4666   4685
                                      4727   5080y  5447   5461   5464
                                      5496   5498   5506   5522   5541
                                      5543   5569   5703   5877   5915
                                      5943   5965   5968   5976   6025
                                      6110   6114   6160   6199   6455
                                      6589   6591   6882   6900   6902
                                     11231    529D  2550   3368   3835
                                      4493   4667   4686   4729   5444
                                      5463   5466   5493   5495   5505
                                      5523   5544   5546   5567   5701
                                      5880   5912   5945   5977   6020
                                      6112   6164   6200   6456   6586
                                      6588   6884   6903   6905  11229
STRPTR/FROUND                  $006c   548D  2592   2595   2599   2603
                                      2622   2623   3407   4683   4684
                                      4689y  4700   4702   4706   4712
                                      4713   4928   4930   4932y  4944
                                      4945   4955y  4958y  4961y  5371
                                      5426   5771   5797   5826   5851
                                      6340   6808   6938    553D  4734
                                      4898   5389   5424   5435   5469
                                      5471   5486   5502   5526   5553
                                      5555   5556   5584   5605   5695
                                      5739   5927   5964   6030   6049
                                      6067   6076   6126   6172   6203
                                      6204   6212   6779   6801   6910
FAC1EX                         $005e   527D  2390   2528   2628   2629
                                      3372   3408   3833   3843   3847
                                      4183   4668   4698   4725   4891
                                      5293   5372   5411   5414   5421
                                      5428   5481   5509   5513   5520
                                      5653   5657   5778   5788   5795
                                      5828   5869   5870   5872   5960
                                      5969   6028   6046   6063   6074
                                      6091   6125   6156   6189   6226
                                      6231   6341   6500   6750   6785
                                      6795   6796   6909   6912   7015
STAL                           $00fb   878D  7279   7281   7413   7415
                                      7435   7437   7509   7511   7660
                                      7662   7695   9002   9004   9011
                                      9016   9994y 10013y 11059  11061
                                     11106y 12704  12706  12732  12733
                                     12739  12744y 12750  13313  13373
                                     13375  13402  13406  13428  13429
                                     13431  13565  13584  13586  13598
                                     13600  13604  13606  13621  13623
                                     13624  13889  13894
TMPPTD                         $006e   557D  1720   1740   2530   2533
                                      2534   2542   3621   4297   4309
                                      4331   4332   4349   4350   4356
                                      4374   4375   4392   4393   4403
                                      4406   4456   4457   4701   4705
                                      5238   5239   5265   5266   6494
                                      6562   6571   6608   6618   6631
                                      6819   6820   6833   6834   6841y
                                      6843   6847   6848   6849   6851
                                      6852   6857   6858
FUNCPT                         $004b   491D  4562   4563   4577   4579
                                      4581y  4585y  4599y  4602y  4610
                                      4612   4622y  4625y  4628y  4631y
                                      4634y  4807   4810   4813   4815
                                      4818   4820   4822   4825y  4829
                                      4830y  4831   4833   4837y  4840
                                      4842   4844   4860   4863   4868y
                                      4872y  6722   6723   6728   6729
                                      6738   6739   6971   6972   6981
                                      6982
TMPPTA                         $0055   515D  1415   1417   1419   1422y
                                      1426y  1428   1610   1615   4027
                                      4028   4030   4031   4035   4036
                                      4041   4042   4057   4058   4061
                                      4062   4077   4079   4152   4153
                                      4336   4338   4341   4353y  4355
                                      4358   4419   4422  13998  14003
                                     14019  14022  14028  14031  14035y
                                     14040  14042  14044  14047
FAC1SI                         $0063   532D  2079   2094   2529   2723
                                      3194   3361   3406   3849   3855
                                      4176   5291   5367   5369   5416
                                      5482   5533   5535   5770   5798
                                      5800   5966   6023   6043   6093
                                      6127   6134   6154   6176   6207
                                      6233   6339   6489   6493   6752
                                      6754   6908   6943   6947   6978
                                      7011   7014   7031
CHRGET                         $0070   577D  1541   1921   2091   2172
                                      2418   2441   2837   2922   3056
                                      3221   3287   3425   3435   3521
                                      3549   3736   3916   3921   3941
                                      4168   5211   6266   6272   6283
                                      7088   8619   8669   8690   8698
                                      8765   8822   8867   8878   9839
                                     11222  11314  11329  12893  12992
                                     13913
RENNEW                         $0023   388D  8850   8853   8858   8863
                                      8883   8886   8914   8917   8923
                                      8925   8926   8928   8997   9009
                                     11330  11333  11347  11352  11356
                                     13914  13919  13921  13927  13931
                                     13937  13938  13941  13947  13961
                                     13962  13963  13967  13969  13976
                                     13997  14024  14025  14026  14029
                                     14049
CHRGOT                         $0076   578D  1917   2088   2182   2274
                                      2385   2399   2759   3036   3095
                                      3109   3218   3275   3552   3882
                                      3891   3904   4229   4613   5131
                                      5227   5255   5338   7743   7760
                                      7770   8578   8685   8732   8854
                                      8864   8875   9829   9836  10519
                                     11246  12400  12416  13016  13909
VARTAB                         $002a   396D  1566   1574   1575   1577
                                      1579   1584   1607   1611   1623
                                      1624   1836   1839   1867   1868
                                      2607   2611   3950   3951   6432
                                      6434   9019   9020   9848  12225
                                     12228  12246  12248  12699  12701
                                     13995  13999  14006  14008  14043
                                     14046  14050  14054
SA                             $00d3   848D  6420   7593   7629   7937
                                      8062   8120   8214   9873   9990
                                     10010  11562  11587  11596  11621
                                     11628  11677  11695  12052  12139
                                     12192  12195  12232  12291  12301
                                     12322  12364  12376  12443  12445
                                     12725  12730  12759  12838  12878
                                     13460
STATUS                         $0096   625D  2982   3561   3690   6426
                                      7947   7957   8461   9869  11372
                                     11382  11565  11570  11589  11601
                                     11642  11679  11697  11952  11977
                                     12145  12158  12178  12288  12330
                                     12351  12365  12437  12829  12840
                                     12868  12880  13008  13531  13532
FNADR                          $00da   855D  6413   6415   7574   7576
                                      7605y  8301   8303   8518   8520
                                      9888y 11416  11418  11421y 11425y
                                     11428y 11431y 11440y 11455y 11510y
                                     11517y 11522y 11532  11652y 11657y
                                     11664y 11682y 11700y 12335y 12391
                                     12393  13027  13029
EAL                            $00c9   817D  6423   6424   6431   6433
                                      7633  11369  11371  11374  11379
                                     11381y 12143  12144  12151  12153
                                     12163y 12168y 12169y 12170y 12172
                                     12174  12227  12230  12245  12247
                                     12258  12260  12304  12305  12700
                                     12702  12740  12742
TXTTAB                         $0028   392D  1644   1645   1787   1788
                                      1830y  1832y  1833   1837   1899
                                      1902   2192   2194   2296   2297
                                      6421   6422   7095   7101   7129
                                      7132  10217y 10219y 10620  10623
                                     10681  10682  11258  11260  12302
                                     12303  12703  12705
TMPPTB                         $0057   516D  1398   1402   1408   1411
                                      1413   1421y  1425y  1427   1608
                                      1612   4021   4022   4087   4092
                                      4100y  4103y  8882y  8885y 10625
                                     10627  10683  10684  10698  10700
                                     13996  14000  14030  14033  14036y
                                     14037  14039
CursorCol                      $00c6   814D  2810   2829   4501   9081
                                      9159   9188   9218   9235   9288
                                      9314   9333   9369   9372   9386
                                      9388   9424   9476   9559   9650
                                      9651   9678   9724   9809   9902
                                      9905  10559  10600  10614  10634
                                     11966
FA                             $00d4   849D  7622   8114   8117   8184
                                      8276   8577   8778  11476  11479
                                     11527  11559  11585  11619  11626
                                     11675  11693  11764  12054  12133
                                     12293  12298  12373  12447  12720
                                     12842  12882  13006  13031  13723
FORPNT                         $0046   475D  1366   1369   1371   1374
                                      2097   2099   2314   2484   2485
                                      2508y  2511y  2521   2640   2643
                                      2648   2650   2664y  3026   3027
                                      3176   3177   3195   3196   5336
                                      5341   5344   5345   6003   6004
FRETOP                         $0030   408D  1459   1462   1471   1474
                                      1860   1861   2600   2604   2691
                                      2694   4093   4096   4480   4483
                                      4759   4762   4787   4788   4812
                                      4814   4882   4884   5026   5028
                                      5033   5036   7121   7122  11376
STREND                         $002e   404D  1395   1396   1621   1622
                                      1871   1872   4019   4020   4043
                                      4045   4244   4246   4346   4347
                                      4360   4364   4481   4484   4772
                                      4775  11367  11489  11568y 11599y
                                     14005  14007  14051  14055
BPTR                           $00f9   877D  7510   7512   8985   8995
                                      8998   9924   9935   9937  11127y
                                     11268  11270  13374  13376  13446
                                     13447  13449  13545  13560  13583
                                     13585  13611  13613  13614  13616
                                     13625  13627  13628
TMPVAR                         $005a   522D  3619   3623   4446   4467
                                      6257   6289   6296   6298   6299
                                      6304   6309   6321   6346   6356
                                      6363   6483   6515   6524   6530
                                      6546   6557   6558   6613   6640
                                      6645
FNLEN                          $00d1   846D  6417   7616   8299   8516
                                      8572   8674   9886  11437  11504
                                     11536  11539  11540  11551  11552
                                     11666  12137  12289  12319  12338
                                     12366  12389  12726  13025  13496
FRESPC                         $0032   412D  4777   4778   4785   4786
                                      4806   4809   4846   4848   4849
                                      4852y  4854   4856   4858   4862
                                      4869y  4873y  4875   4878   4881
                                      4883   4981y  4986   4987   4989
CURLIN                         $0036   422D  1513   1545   2072   2074
                                      2127   2130   2215   2220   2221
                                      2246   2247   2268   2270   2286
                                      2326   2328   2899   2900   3206
                                      3208   4514   6448   6449
ScrPtr                         $00c4   813D  9160y  9176y  9219y  9275y
                                      9322y  9389y  9391y  9398y  9517y
                                      9555y  9560y  9563y  9567y  9680y
                                      9743y  9811y  9816y 10154  10158
                                     10565y 10576y 10636
FAC2M3/FAC2M4                  $0069   542D  3401   3836   3839   3859y
                                      5491   5727   5763   5882   5898
                                      5908   5910    543D  3403   3837
                                      3840   5488   5724   5760   5885
                                      5897   5905   5907
VARNAM                         $0042   464D  3608   3609   3903   3936
                                      3937   3942   3958   3961   3996
                                      3997   4113   4116   4208   4210
                                      4214   4216   4251   4253   4299
                                      4304   4408   4411
CursorRow                      $00d8   853D  9074   9087   9185   9309
                                      9312   9504   9525   9641   9662
                                      9664   9692   9707   9712  10557
                                     10570  10579  10602  10612  10631
                                     10654  11968
MEMUSS                         $00fd   879D  7434   7436   7467   7468
                                      7475   8302   8304   8315y  8728
                                      8729   9927   9934   9936  13542
                                     13597  13599  13601  13603  13605
                                     13607
TopMargin                      $00e0   860D  9062   9073   9308   9342
                                      9359   9505   9523   9526   9661
                                      9690   9693   9696   9756   9769
                                     10532  10543  10632  10640  10643
                                     10646
QUOTE                          $0022   260D  1989   1998   2376   2965
                                      3070   3443   4675   4695   7599
                                      7603   8598   8705   9258   9262
                                     11177  11183  11409  11432  13910
INDEXB                         $0021   371D  1569   1576   1588   1595y
                                      1599   3188   5244   5249   5251y
                                      5254y  5259y  6141   6147   6149y
                                      6153y  6158y  6163y  6167y  6173
CR                             $000d   248D  1676   2800   7296   7969
                                      7999   8406   8436   8444   8446
                                      9171   9241   9429   9586  11623
                                     11856  11979  12469  13395  13821
VALTYP                         $0007   285D  2490   2777   3057   3247
                                      3295   3317   3424   3610   3830
                                      3914   3928   4203   4235   4475
                                      4491   4736   5189
RigMargin                      $00d5   851D  9173   9278   9311   9323
                                      9352   9370   9393   9475   9518
                                      9554   9570   9643   9744  10568
                                     10637  11974
IOPMPT                         $0010   338D  1499   2753   2793   2867
                                      2902   2926   2933   2946   2953
                                      2956   2980   2999   3047   3147
                                      3558   7091
COUNT                          $0005   272D  1560   1609   1625   1722
                                      1739   1765   4145   4232   4286
                                      4310   4334   4372   4404  11292
                                     11307  11315
DESCPT                         $004d   495D  2633   2634   2663y  4658
                                      4659   4940   4941   5090y  5093y
                                      5100   5101   5121y  5143y  5165
                                      5167
VARPTR                         $0044   470D  4135   4136   4420   4423
                                      4425   4542   4544   4582   4587
                                      4589y  4593   4604   4606   6607
                                      6619
FAC2EX                         $0066   539D  3395   3824   3825   5391
                                      5392   5429   5431   5777   5785
                                      6045   6064   6719   6794   6797
LefMargin                      $00e2   862D  9080   9287   9307   9332
                                      9343   9360   9385   9506   9649
                                      9677   9723  10143  10512
Mon_Lo                         $00c2   807D 13227  13312  13316  13333
                                     13785  13789  13790  13799  13800
                                     13814  13828  13833  13890
CHARAC                         $0003   270D  2364   2368   2369   3064
                                      3069   3073   3779   3788   4676
                                      4691   6238   6733   6790
DOS_RL                         $00b9   799D  9877   9881   9883  11499
                                     11514  11537  11549  11573  11578
                                     11590  11609  11683
RENINC                         $0021   375D  8849   8852   8870   8874
                                      8924   8927   9833   9835   9851y
                                      9854   9858   9859
LA                             $00d2   847D  7749   7939   8176   8200
                                      8568   8612  12050  12062  12370
                                     12425  12441
Mon_A                          $00bf   804D 12772  12778  13209  13224
                                     13229  13564  13568  13602  13608
                                     13612  13615
VERCK                          $009d   667D  7591   7611   7636   8377
                                     12161  12215  12222  12239  12276
                                     12349  12910
JIFFY_CLOCK                    $008d   593D  2551   3674   3675  10033
                                     12796  12798  12800  12801  12804
                                     12808  12809
MONCNT                         $00b5   791D  7242   7251   7254   7270
                                      7402   7405   7508   7522  13661
                                     13672
CharsInBuffer                  $009e   671D  9136   9138   9148   9165
                                     10415  10422  11955  12102  12982
                                     13413
FAC2SI                         $006b   544D  3405   3820   5370   5415
                                      5769   5772   6037   6338   6725
                                      6933
FAC2M1                         $0067   540D  3397   3822   3823   5497
                                      5733   5774   5876   5900   5914
                                      5916
FUNJMP                         $0052   509D  3761   3763   5159   5168
                                      5390   5420   5434   5485   6783
                                      6800
INDEXC                         $004f   499D  2641y  2644y  2655y  2658y
                                      2702   2705   5020y  5023y  5031
                                      5034
ARYTAB                         $002c   400D  1869   1870   3954   3956
                                      4015   4016   4033   4034   4240
                                      4241
FAC3M4                         $0026   382D  4444   4464   5583   5586
                                      5694   5723   5725   5738   5891
                                      5948
FAC3M3                         $0025   381D  4415   4436   4461   5585
                                      5588   5693   5726   5728   5737
                                      5946
GARBFL                         $0009   306D  1698   1710   1751   3704
                                      3707   3708   3711   4754   4791
                                      4795
ENDCHR                         $0004   271D  1707   1755   1758   2366
                                      2367   2370   2373   3076   4677
                                      4693
BSOS_KBD                       $0001    15D 10727  10740  10751  10810
                                     10823  10841  10854  10865  10924
                                     10937
BotMargin                      $00e1   861D  9065   9351   9642   9708
                                      9754   9771  10531  10544  10561
QTSW                           $00cd   840D  9183   9231   9260   9261
                                      9437   9588   9734  10587  10674
LDTND                          $00ae   769D  8056   8185  12004  12033
                                     12079  12080  12082  12435  12440
CINV                           $0090   601D  7187   7189   7540   7542
                                      9796  10040  10042  13749  13751
INPPTR                         $0040   454D  3020   3021   3032   3033
                                      3103   3104   3139   3140   3145
OLDTXT                         $003a   434D  1890   2116   2117   2218
                                      2219   2238   2241   2909   2910
Mon_Hi                         $00c3   808D 13222  13309  13334  13786
                                     13795  13810  13830  13835
DosPtr                         $00bb   801D 11399  11401  11403  11408y
                                     11415  11417  11488  11492
W_Bank                         $00b7   797D  7195   7385   7498   7991
                                      8897   8953  11123  13562
R_Bank                         $00b6   796D  7193   7383   7496   7983
                                      8896   8993  11062  11103
Source_Unit                    $009c   662D  8274   8575   8636   8639
                                     11478  11558  11625  11674
Power_Flag                     $0099   646D  7222   9722  10496  10498
                                     10555  10571  10589  10610
FAC2M2                         $0068   541D  3399   5494   5730   5766
                                      5879   5899   5911   5913
ACCSYM                         $004a   485D  3274   3283   3284   3286
                                      3290   3325   3340   3831
MEMSIZ                         $0034   416D  1858   1859   4805   4808
                                      7119   7120   7127   7131
INSRT                          $00dc   856D  9272   9274   9433   9569
                                      9572   9592   9732
DATAX                          $00d9   854D  9224   9226   9227   9246
                                      9251   9410   9425
Mon_Op                         $00c1   806D 12501  12530  13332  13351
                                     13364  13378  13381
Dis_Line                       $00ba   800D  7423   7425   7427   7465
                                      7478   9968  13372
Wedge_Unit                     $00ab   755D  7099  12895  12902  13005
                                     13030  13736  13738
Key_Flags                      $0098   639D  6410  10036  10322  10324
                                     10364  10365  10439
FACTPA                         $0054   514D  5995   5996   6822   6825
                                      6826   6974   6975
FAC3M2                         $0024   380D  5587   5590   5692   5729
                                      5731   5736   5944
FAC3M1                         $0023   379D  5589   5592   5691   5732
                                      5734   5735   5942
SUBFLG                         $000a   312D  1891   2053   3932   3944
                                      3949   4535   4560
INTFLG                         $0008   291D  2488   3090   3642   3915
                                      3935   4201   4237
Mon_Tmp                        $00cb   819D  7516   7519   7725   7730
                                     13792  13823
SAL                            $00c7   816D  9098   9099   9100y  9742y
                                     10128  10132
Dis_Length                     $00be   803D 12507  12517  12575  13211
                                     13219  13377
PC_Adjust                      $00b3   789D  7170   7182   7198   7410
                                     12490  12492
DFLTO                          $00b0   777D  9243  10046  11990  12010
                                     12024  12883
YSAVE                          $0048   481D  3030   3031   3105   3106
                                      3311   3390
TANSGN                         $000c   326D  3393   3868   6949   6951
                                      6969   6979
DIMFLG                         $0006   279D  3897   4200   4239   4283
                                      4317   4368
DFLTN                          $00af   773D 11953  11964  12014  12026
                                     12843
Target_Unit                    $00ad   762D 11477  11526  11584  11618
                                     11692
CRSW                           $00ac   760D  9174   9211   9240   9423
                                     11973
BLNCT                          $00a8   734D  9157   9277   9805   9808
                                     10063
BSOUR                          $00a5   694D 11765  11781  11805  11876
                                     11892
LASTPT                         $0014   356D  4737   5059   5061   5065
                                      7092
INPFLG                         $000b   316D  2892   3019   3038   3059
                                      3141
DELAY                          $00e6   866D 10065  10394  10396  10411
DOS_FC                         $00b1   787D 11445  11506  11576  11604
BLNON                          $00aa   750D  9152   9155   9810   9813
LastInputCol                   $00a1   681D  9181   9189   9237  11975
C3PO                           $00a0   679D 11754  11760  11885  11887
ReverseFlag                    $009f   675D  9269   9484   9632   9733
CBINV                          $0092   609D  9795  13698  13700  13768
RNDX                           $0088   584D  6890   6891   6914   6915
BITS                           $0065   535D  4893   4899   4900   6196
SGNFLG                         $0064   533D  6265   6312   6842   6862
DATPTR                         $003e   448D  2197   2198   3009   3010
DATLIN                         $003c   442D  2897   2898   3126   3130
OLDLIN                         $0038   427D  2222   2223   2244   2245
TEMPPT                         $0013   351D  1880   4720   4741   5063
SCROV                          $00eb   875D  9415  10082  10083
SCRIV                          $00e9   874D  9205  10078  10079
PrevChar                       $00e8   873D  9299   9530  10032
CHIME                          $00e7   867D 10085  10098  10107
KOUNT                          $00e5   865D 10066  10398  10404
LSTX                           $00e4   864D 10387  10392  10409
ScreenRows                     $00df   859D  9115   9344  10069
Mon_ZP                         $00cc   820D 13366  13368  13811
BLNSW                          $00a7   727D  9149   9803  10064
InputRow                       $00a3   682D  9184   9706  11969
Default_Bank                   $009a   652D 10038  11108  11129
Key_Index                      $0097   630D 10326  10359  10385
NMINV                          $0094   614D 13694  13696  13716
FACTPB                         $0059   521D  5988   6860   6861
RIGHT                          $001d   259D  2871   9439   9594
JIFFY6                         $00f8   876D 12810  12813
XMAX                           $00e3   863D 10044  10416
Mon_B                          $00c0   805D 12774  12777
Mon_Format                     $00bd   802D 12573  13208
DOS_EOF                        $00b2   788D 11571  11607
GDBLN                          $00a9   743D  9158   9814
SFDX                           $00a6   720D 10327  10431
InputCol                       $00a4   683D  9187  11967
Stop_Flag                      $009b   657D 10430  12097
JUMPER                         $0051   504D  3764   7080
CTRLY                          $0019   257D  9455   9608
CTRLV                          $0016   256D  9457   9604
TEMPST                         $0016   363D  1879   4721
CTRLU                          $0015   255D  9459   9614
DEL                            $0014   254D  9435   9590
HOME                           $0013   253D  9463   9600
RVS                            $0012   252D  9443   9598
DOWN                           $0011   251D  9441   9596
CTRLO                          $000f   250D  9451   9610
CTRLN                          $000e   249D  9447   9612
TAB                            $0009   247D  9453   9602
CTRLD                          $0004   245D  9461   9616
CTRLB                          $0002   244D  9449   9606
USRVEC                         $0001   268D  7084   7085
Basic_USR                      $0000   267D  1144   7081
ISNUM                          $007d   580D  2562
ESC                            $001b   258D  9431
BELL                           $0007   246D  9445
CTRLA                          $0001   243D  9465
FSBLK                          $00de   858
ROPRTY                         $00dd   857
TAPE1                          $00d6   852
ZD0                            $00d0   844
EOT                            $00cf   843
BITTS                          $00ce   842
ZP_b8                          $00b8   798
SCROLLING                      $00b4   790
FAC3M5                         $0027   384
DS_Ptr                         $000e   331
DS_Len                         $000d   330
INDEXA                         $001f   367D  1400   1410   1416   1565
                                      1567   1590   1592   1594y  1598
                                      1650y  1654   1657y  1659   1661y
                                      1662   1663   1664y  1725   1727
                                      1730   1732   1735y  1766y  1768
                                      1770   1773y  2022   2024   2028
                                      2030   2031y  2035y  2561y  2635
                                      2636   2649   2651   2682y  2686y
                                      2689y  2696   2697   2701   2703
                                      2854y  3300   3302   3357   3359
                                      3374   3376   4047   4048   4050y
                                      4053y  4056y  4060y  4068y  4072
                                      4073   4075   4076   4082y  4086y
                                      4090y  4099   4102   4106   4107
                                      4109   4333   4401   4434   4761
                                      4764   4769   4781y  4784y  4836
                                      4838   4841y  4851   4855y  4866y
                                      4876y  4879y  4969   4970   4980y
                                      5013   5014   5024   5025   5040y
                                      5043y  5046y  5048   5049   5107
                                      5108   5110   5200y  5240   5243
                                      5245   5756   5757   5759y  5762y
                                      5765y  5768y  5776y  5956   5957
                                      5959y  6011   6012   6015y  6018y
                                      6021y  6026y  6029y  8678y  8794y
                                      8800   8802   8812   8813  10222
                                     10225  12390  12392
TMPPTC                         $005c   523D  1399   1403   1564y  1568
                                      1570   1572y  1580   1583   1628y
                                      1795   1796   1797y  1802y  1807y
                                      1811y  1937y  1945y  1948y  1966y
                                      1969y  1970   1971   1995y  2004y
                                      2300   2303   3952   3953   3959y
                                      3963y  3968   4017   4018   4114y
                                      4117y  4120y  4122y  4124y  4126y
                                      4128y  4129   4132   4148   4149
                                      4242   4243   4249y  4254y  4257y
                                      4259   4262y  4263   4288y  4300y
                                      4305y  4314y  4326y  4329y  4361
                                      4363y  4366   4367y  4371y  4382y
                                      4387y  4435y  4438y  6282   6285
                                      6292   6293   6319   6350   8902y
                                      8908y  8911y  8959y  8962y  8969y
                                      8972y  9008y  9015   9018   9832
                                      9834   9850y  9855   9856  10619
                                     10622  10626  10628  10648y 10651y
                                     10652  10653  10666y 10669y 10672y
                                     10685  10686  10688y 10691y 10694y
                                     10697  10699  10703y 10706y 11165
                                     11168  11259  11261  11278y 11281y
                                     11282  11283  11354y 11357y 13973y
                                     13985  13987  13991  13992  13994
                                     14010  14012  14018  14020
FAC1M3/FAC1M4                  $0061   530D  2507   2591y  2594y  2610
                                      2613   2620y  2625   2730   2731
                                      3366   3476   3606   3645y  3648y
                                      3720   3747   3781   3793   3798
                                      4224   4379   4398   4656   4732
                                      4923   4934y  5002   5224   5297
                                      5441   5465   5468   5490   5492
                                      5504   5524   5547   5549   5565
                                      5699   5883   5909   5947   5978
                                      6017   6124   6168   6201   6583
                                      6585   6886   6904   6906    531D
                                      2414   2510   2606   2614   2626
                                      2727   2728   3364   3473   3607
                                      3612   3657   3721   3745   3783
                                      3790   3795   4226   4381   4402
                                      4657   4733   4921   5003   5130
                                      5146   5148   5226   5298   5438
                                      5467   5470   5487   5489   5503
                                      5525   5550   5552   5563   5697
                                      5886   5906   5949   5979   6014
                                      6123   6174   6202   6232   6237
                                      6580   6582   6888   6899   6901
TXTPTR                         $0077   579D  1539   1540   1696   1723
                                      1764   1778   1780   1901   1904
                                      2067   2069   2112   2115   2119y
                                      2122y  2126y  2129y  2132   2133
                                      2135   2213   2214   2242   2243
                                      2264   2266   2291   2292   2302
                                      2305   2330   2332   2346   2347
                                      2349   2371y  2911   2912   3028
                                      3029   3034   3035   3051   3052
                                      3062   3077   3078   3101   3102
                                      3107   3108   3122y  3125y  3128y
                                      3131y  3210   3212   3262   3264
                                      3265   3320   3322   3323   3450
                                      3451   3519y  4546   4548   4595
                                      4597   4600   4603   4617   4619
                                      5236   5237   5241   5246   5267
                                      5268   6360y  7058   7060   8659
                                      8661   8662y 10513  10518  11144
                                     11146  11147x 11167  11170  11294
                                     11306  11346  12125  12911y 12932
                                     12933y 12943y 13019  13021y 13026
                                     13028  13915  13926
LINNUM                         $0011   346D  1617   1618   1801   1806
                                      1926   1927   1929   1952   1954
                                      2287   2434   2435   2437   2458
                                      2460   2462   2463   2464   2466
                                      2467   2468   2469   2471   2472
                                      2474   5299   5300   5307   5309
                                      5313y  5316   5318   5328y  5343y
                                      7096   7097   7102y  7105y  7106y
                                      7109y  7110y  7113y  7116   7118
                                      8216   8218   8857   8859   8862
                                      8869   8871   8873   8975   8978
                                      9841   9842   9844  10594  10596
                                     10692  10695  11049  11050  11067
                                     11071  11075  11078  11228  11230
                                     11500  11501  11636  11638  12693
                                     12901  13829  13831  13834
FAC1M1/FAC1M2                  $005f   528D  2081   2082   3370   3679
                                      3834   3860y  4492   4666   4685
                                      4727   5080y  5447   5461   5464
                                      5496   5498   5506   5522   5541
                                      5543   5569   5703   5877   5915
                                      5943   5965   5968   5976   6025
                                      6110   6114   6160   6199   6455
                                      6589   6591   6882   6900   6902
                                     11231    529D  2550   3368   3835
                                      4493   4667   4686   4729   5444
                                      5463   5466   5493   5495   5505
                                      5523   5544   5546   5567   5701
                                      5880   5912   5945   5977   6020
                                      6112   6164   6200   6456   6586
                                      6588   6884   6903   6905  11229
STRPTR/FROUND                  $006c   548D  2592   2595   2599   2603
                                      2622   2623   3407   4683   4684
                                      4689y  4700   4702   4706   4712
                                      4713   4928   4930   4932y  4944
                                      4945   4955y  4958y  4961y  5371
                                      5426   5771   5797   5826   5851
                                      6340   6808   6938    553D  4734
                                      4898   5389   5424   5435   5469
                                      5471   5486   5502   5526   5553
                                      5555   5556   5584   5605   5695
                                      5739   5927   5964   6030   6049
                                      6067   6076   6126   6172   6203
                                      6204   6212   6779   6801   6910
FAC1EX                         $005e   527D  2390   2528   2628   2629
                                      3372   3408   3833   3843   3847
                                      4183   4668   4698   4725   4891
                                      5293   5372   5411   5414   5421
                                      5428   5481   5509   5513   5520
                                      5653   5657   5778   5788   5795
                                      5828   5869   5870   5872   5960
                                      5969   6028   6046   6063   6074
                                      6091   6125   6156   6189   6226
                                      6231   6341   6500   6750   6785
                                      6795   6796   6909   6912   7015
STAL                           $00fb   878D  7279   7281   7413   7415
                                      7435   7437   7509   7511   7660
                                      7662   7695   9002   9004   9011
                                      9016   9994y 10013y 11059  11061
                                     11106y 12704  12706  12732  12733
                                     12739  12744y 12750  13313  13373
                                     13375  13402  13406  13428  13429
                                     13431  13565  13584  13586  13598
                                     13600  13604  13606  13621  13623
                                     13624  13889  13894
TMPPTD                         $006e   557D  1720   1740   2530   2533
                                      2534   2542   3621   4297   4309
                                      4331   4332   4349   4350   4356
                                      4374   4375   4392   4393   4403
                                      4406   4456   4457   4701   4705
                                      5238   5239   5265   5266   6494
                                      6562   6571   6608   6618   6631
                                      6819   6820   6833   6834   6841y
                                      6843   6847   6848   6849   6851
                                      6852   6857   6858
FUNCPT                         $004b   491D  4562   4563   4577   4579
                                      4581y  4585y  4599y  4602y  4610
                                      4612   4622y  4625y  4628y  4631y
                                      4634y  4807   4810   4813   4815
                                      4818   4820   4822   4825y  4829
                                      4830y  4831   4833   4837y  4840
                                      4842   4844   4860   4863   4868y
                                      4872y  6722   6723   6728   6729
                                      6738   6739   6971   6972   6981
                                      6982
TMPPTA                         $0055   515D  1415   1417   1419   1422y
                                      1426y  1428   1610   1615   4027
                                      4028   4030   4031   4035   4036
                                      4041   4042   4057   4058   4061
                                      4062   4077   4079   4152   4153
                                      4336   4338   4341   4353y  4355
                                      4358   4419   4422  13998  14003
                                     14019  14022  14028  14031  14035y
                                     14040  14042  14044  14047
FAC1SI                         $0063   532D  2079   2094   2529   2723
                                      3194   3361   3406   3849   3855
                                      4176   5291   5367   5369   5416
                                      5482   5533   5535   5770   5798
                                      5800   5966   6023   6043   6093
                                      6127   6134   6154   6176   6207
                                      6233   6339   6489   6493   6752
                                      6754   6908   6943   6947   6978
                                      7011   7014   7031
CHRGET                         $0070   577D  1541   1921   2091   2172
                                      2418   2441   2837   2922   3056
                                      3221   3287   3425   3435   3521
                                      3549   3736   3916   3921   3941
                                      4168   5211   6266   6272   6283
                                      7088   8619   8669   8690   8698
                                      8765   8822   8867   8878   9839
                                     11222  11314  11329  12893  12992
                                     13913
RENNEW                         $0023   388D  8850   8853   8858   8863
                                      8883   8886   8914   8917   8923
                                      8925   8926   8928   8997   9009
                                     11330  11333  11347  11352  11356
                                     13914  13919  13921  13927  13931
                                     13937  13938  13941  13947  13961
                                     13962  13963  13967  13969  13976
                                     13997  14024  14025  14026  14029
                                     14049
CHRGOT                         $0076   578D  1917   2088   2182   2274
                                      2385   2399   2759   3036   3095
                                      3109   3218   3275   3552   3882
                                      3891   3904   4229   4613   5131
                                      5227   5255   5338   7743   7760
                                      7770   8578   8685   8732   8854
                                      8864   8875   9829   9836  10519
                                     11246  12400  12416  13016  13909
Mon_Register                   $02a0   910D  7173   7175   7177   7179
                                      7183   7186   7188   7190   7192
                                      7194   7196   7278   7280   7384
                                      7386   7390   7392   7395   7397
                                      7401   7412   7414   7491   7495
                                      7497   7535   7537   7539   7541
                                      7548   7550   7552   7554   7556
                                      7557   7558   7565
VARTAB                         $002a   396D  1566   1574   1575   1577
                                      1579   1584   1607   1611   1623
                                      1624   1836   1839   1867   1868
                                      2607   2611   3950   3951   6432
                                      6434   9019   9020   9848  12225
                                     12228  12246  12248  12699  12701
                                     13995  13999  14006  14008  14043
                                     14046  14050  14054
SA                             $00d3   848D  6420   7593   7629   7937
                                      8062   8120   8214   9873   9990
                                     10010  11562  11587  11596  11621
                                     11628  11677  11695  12052  12139
                                     12192  12195  12232  12291  12301
                                     12322  12364  12376  12443  12445
                                     12725  12730  12759  12838  12878
                                     13460
STACK                          $0100   888D  1363   1368   1370   1372
                                      1375   3190   3193   3199   3203
                                      3205   3207   3209   3211   4220
                                      4222   4225   4227   4648   4649
                                      6492   6565   6570   6612   6617
                                      6632   6648   6650   6658   6660
                                      6662   6665   6667   9792  11239
STATUS                         $0096   625D  2982   3561   3690   6426
                                      7947   7957   8461   9869  11372
                                     11382  11565  11570  11589  11601
                                     11642  11679  11697  11952  11977
                                     12145  12158  12178  12288  12330
                                     12351  12365  12437  12829  12840
                                     12868  12880  13008  13531  13532
FNADR                          $00da   855D  6413   6415   7574   7576
                                      7605y  8301   8303   8518   8520
                                      9888y 11416  11418  11421y 11425y
                                     11428y 11431y 11440y 11455y 11510y
                                     11517y 11522y 11532  11652y 11657y
                                     11664y 11682y 11700y 12335y 12391
                                     12393  13027  13029
EAL                            $00c9   817D  6423   6424   6431   6433
                                      7633  11369  11371  11374  11379
                                     11381y 12143  12144  12151  12153
                                     12163y 12168y 12169y 12170y 12172
                                     12174  12227  12230  12245  12247
                                     12258  12260  12304  12305  12700
                                     12702  12740  12742
TXTTAB                         $0028   392D  1644   1645   1787   1788
                                      1830y  1832y  1833   1837   1899
                                      1902   2192   2194   2296   2297
                                      6421   6422   7095   7101   7129
                                      7132  10217y 10219y 10620  10623
                                     10681  10682  11258  11260  12302
                                     12303  12703  12705
BUF                            $0200   893D  1604   1619   1620   1627
                                      1678   1699   1733   1743   1744
                                      1756   1761   1775   1777   2790
                                      2791   2792   2927   2928   2930
                                      2978   2987   3041   3042   3043
                                     11298  11350  13917  13923  13929
                                     13934  13971
TMPPTB                         $0057   516D  1398   1402   1408   1411
                                      1413   1421y  1425y  1427   1608
                                      1612   4021   4022   4087   4092
                                      4100y  4103y  8882y  8885y 10625
                                     10627  10683  10684  10698  10700
                                     13996  14000  14030  14033  14036y
                                     14037  14039
CursorCol                      $00c6   814D  2810   2829   4501   9081
                                      9159   9188   9218   9235   9288
                                      9314   9333   9369   9372   9386
                                      9388   9424   9476   9559   9650
                                      9651   9678   9724   9809   9902
                                      9905  10559  10600  10614  10634
                                     11966
FA                             $00d4   849D  7622   8114   8117   8184
                                      8276   8577   8778  11476  11479
                                     11527  11559  11585  11619  11626
                                     11675  11693  11764  12054  12133
                                     12293  12298  12373  12447  12720
                                     12842  12882  13006  13031  13723
FORPNT                         $0046   475D  1366   1369   1371   1374
                                      2097   2099   2314   2484   2485
                                      2508y  2511y  2521   2640   2643
                                      2648   2650   2664y  3026   3027
                                      3176   3177   3195   3196   5336
                                      5341   5344   5345   6003   6004
FRETOP                         $0030   408D  1459   1462   1471   1474
                                      1860   1861   2600   2604   2691
                                      2694   4093   4096   4480   4483
                                      4759   4762   4787   4788   4812
                                      4814   4882   4884   5026   5028
                                      5033   5036   7121   7122  11376
STREND                         $002e   404D  1395   1396   1621   1622
                                      1871   1872   4019   4020   4043
                                      4045   4244   4246   4346   4347
                                      4360   4364   4481   4484   4772
                                      4775  11367  11489  11568y 11599y
                                     14005  14007  14051  14055
BPTR                           $00f9   877D  7510   7512   8985   8995
                                      8998   9924   9935   9937  11127y
                                     11268  11270  13374  13376  13446
                                     13447  13449  13545  13560  13583
                                     13585  13611  13613  13614  13616
                                     13625  13627  13628
TMPVAR                         $005a   522D  3619   3623   4446   4467
                                      6257   6289   6296   6298   6299
                                      6304   6309   6321   6346   6356
                                      6363   6483   6515   6524   6530
                                      6546   6557   6558   6613   6640
                                      6645
FNLEN                          $00d1   846D  6417   7616   8299   8516
                                      8572   8674   9886  11437  11504
                                     11536  11539  11540  11551  11552
                                     11666  12137  12289  12319  12338
                                     12366  12389  12726  13025  13496
FRESPC                         $0032   412D  4777   4778   4785   4786
                                      4806   4809   4846   4848   4849
                                      4852y  4854   4856   4858   4862
                                      4869y  4873y  4875   4878   4881
                                      4883   4981y  4986   4987   4989
CURLIN                         $0036   422D  1513   1545   2072   2074
                                      2127   2130   2215   2220   2221
                                      2246   2247   2268   2270   2286
                                      2326   2328   2899   2900   3206
                                      3208   4514   6448   6449
ScrPtr                         $00c4   813D  9160y  9176y  9219y  9275y
                                      9322y  9389y  9391y  9398y  9517y
                                      9555y  9560y  9563y  9567y  9680y
                                      9743y  9811y  9816y 10154  10158
                                     10565y 10576y 10636
FAC2M3/FAC2M4                  $0069   542D  3401   3836   3839   3859y
                                      5491   5727   5763   5882   5898
                                      5908   5910    543D  3403   3837
                                      3840   5488   5724   5760   5885
                                      5897   5905   5907
VARNAM                         $0042   464D  3608   3609   3903   3936
                                      3937   3942   3958   3961   3996
                                      3997   4113   4116   4208   4210
                                      4214   4216   4251   4253   4299
                                      4304   4408   4411
DOS_Flags                      $033e   947D  7792   7796   7813   7822
                                      7832   7925   8076   8235   8251
                                      8351   8567   8606   8617   8641
                                      8671   8710   8724   8741   8748
                                      8749   8797
CursorRow                      $00d8   853D  9074   9087   9185   9309
                                      9312   9504   9525   9641   9662
                                      9664   9692   9707   9712  10557
                                     10570  10579  10602  10612  10631
                                     10654  11968
Bank_Store                     $028b   908D  7517   8909   8912   8915
                                      8918   8946   8960   8963   8976
                                      8979   9940  11175  11181  11190
                                     11206  11241  11247  13379  13589
                                     13618
MEMUSS                         $00fd   879D  7434   7436   7467   7468
                                      7475   8302   8304   8315y  8728
                                      8729   9927   9934   9936  13542
                                     13597  13599  13601  13603  13605
                                     13607
TopMargin                      $00e0   860D  9062   9073   9308   9342
                                      9359   9505   9523   9526   9661
                                      9690   9693   9696   9756   9769
                                     10532  10543  10632  10640  10643
                                     10646
DOS_Command_Buffer             $0353   951D  8083   8213   8215   8217
                                      8219   8221   8316   8333   8336
                                      8355   8508   8517   8519   9955
                                      9960   9984  10277  10288  11481
Bank_Fetch                     $027a   909D   908   7245   7258   7518
                                      9007  11064  11070  11074  11077
                                     11093  12529  13380  13561  13563
                                     13566  13567  13588  13617  13668
QUOTE                          $0022   260D  1989   1998   2376   2965
                                      3070   3443   4675   4695   7599
                                      7603   8598   8705   9258   9262
                                     11177  11183  11409  11432  13910
INDEXB                         $0021   371D  1569   1576   1588   1595y
                                      1599   3188   5244   5249   5251y
                                      5254y  5259y  6141   6147   6149y
                                      6153y  6158y  6163y  6167y  6173
CR                             $000d   248D  1676   2800   7296   7969
                                      7999   8406   8436   8444   8446
                                      9171   9241   9429   9586  11623
                                     11856  11979  12469  13395  13821
VALTYP                         $0007   285D  2490   2777   3057   3247
                                      3295   3317   3424   3610   3830
                                      3914   3928   4203   4235   4475
                                      4491   4736   5189
RigMargin                      $00d5   851D  9173   9278   9311   9323
                                      9352   9370   9393   9475   9518
                                      9554   9570   9643   9744  10568
                                     10637  11974
IOPMPT                         $0010   338D  1499   2753   2793   2867
                                      2902   2926   2933   2946   2953
                                      2956   2980   2999   3047   3147
                                      3558   7091
COUNT                          $0005   272D  1560   1609   1625   1722
                                      1739   1765   4145   4232   4286
                                      4310   4334   4372   4404  11292
                                     11307  11315
DESCPT                         $004d   495D  2633   2634   2663y  4658
                                      4659   4940   4941   5090y  5093y
                                      5100   5101   5121y  5143y  5165
                                      5167
VARPTR                         $0044   470D  4135   4136   4420   4423
                                      4425   4542   4544   4582   4587
                                      4589y  4593   4604   4606   6607
                                      6619
FAC2EX                         $0066   539D  3395   3824   3825   5391
                                      5392   5429   5431   5777   5785
                                      6045   6064   6719   6794   6797
KEYD                           $026f   898D  9131   9133   9134   9167
                                     10421  12984  13399  13401  13404
                                     13405  13408  13409  13411
LefMargin                      $00e2   862D  9080   9287   9307   9332
                                      9343   9360   9385   9506   9649
                                      9677   9723  10143  10512
Mon_Lo                         $00c2   807D 13227  13312  13316  13333
                                     13785  13789  13790  13799  13800
                                     13814  13828  13833  13890
CHARAC                         $0003   270D  2364   2368   2369   3064
                                      3069   3073   3779   3788   4676
                                      4691   6238   6733   6790
Ass_Buf                        $02c1   914D 13297  13301  13304  13339
                                     13347  13361  13804  13847  13850
                                     13854  13855  13872
DOS_RL                         $00b9   799D  9877   9881   9883  11499
                                     11514  11537  11549  11573  11578
                                     11590  11609  11683
RENINC                         $0021   375D  8849   8852   8870   8874
                                      8924   8927   9833   9835   9851y
                                      9854   9858   9859
LA                             $00d2   847D  7749   7939   8176   8200
                                      8568   8612  12050  12062  12370
                                     12425  12441
Mon_A                          $00bf   804D 12772  12778  13209  13224
                                     13229  13564  13568  13602  13608
                                     13612  13615
VERCK                          $009d   667D  7591   7611   7636   8377
                                     12161  12215  12222  12239  12276
                                     12349  12910
JIFFY_CLOCK                    $008d   593D  2551   3674   3675  10033
                                     12796  12798  12800  12801  12804
                                     12808  12809
MONCNT                         $00b5   791D  7242   7251   7254   7270
                                      7402   7405   7508   7522  13661
                                     13672
CharsInBuffer                  $009e   671D  9136   9138   9148   9165
                                     10415  10422  11955  12102  12982
                                     13413
FAC2SI                         $006b   544D  3405   3820   5370   5415
                                      5769   5772   6037   6338   6725
                                      6933
FAC2M1                         $0067   540D  3397   3822   3823   5497
                                      5733   5774   5876   5900   5914
                                      5916
FUNJMP                         $0052   509D  3761   3763   5159   5168
                                      5390   5420   5434   5485   6783
                                      6800
INDEXC                         $004f   499D  2641y  2644y  2655y  2658y
                                      2702   2705   5020y  5023y  5031
                                      5034
ARYTAB                         $002c   400D  1869   1870   3954   3956
                                      4015   4016   4033   4034   4240
                                      4241
FAC3M4                         $0026   382D  4444   4464   5583   5586
                                      5694   5723   5725   5738   5891
                                      5948
FAC3M3                         $0025   381D  4415   4436   4461   5585
                                      5588   5693   5726   5728   5737
                                      5946
GARBFL                         $0009   306D  1698   1710   1751   3704
                                      3707   3708   3711   4754   4791
                                      4795
ENDCHR                         $0004   271D  1707   1755   1758   2366
                                      2367   2370   2373   3076   4677
                                      4693
BSOS_KBD                       $0001    15D 10727  10740  10751  10810
                                     10823  10841  10854  10865  10924
                                     10937
DOS_Tmp                        $033a   931D  7742   7769   8220   8300
                                      8312   8319   8573   8727  11503
BotMargin                      $00e1   861D  9065   9351   9642   9708
                                      9754   9771  10531  10544  10561
QTSW                           $00cd   840D  9183   9231   9260   9261
                                      9437   9588   9734  10587  10674
LDTND                          $00ae   769D  8056   8185  12004  12033
                                     12079  12080  12082  12435  12440
CINV                           $0090   601D  7187   7189   7540   7542
                                      9796  10040  10042  13749  13751
INPPTR                         $0040   454D  3020   3021   3032   3033
                                      3103   3104   3139   3140   3145
OLDTXT                         $003a   434D  1890   2116   2117   2218
                                      2219   2238   2241   2909   2910
DOS_Status                     $03ad   952D  3633   3634   3709   8124
                                      8131   8133   8414   9874
Dis_Buf                        $02b1   912D 12783  13214  13232  13236
                                     13265  13270  13280  13362
Mon_Hi                         $00c3   808D 13222  13309  13334  13786
                                     13795  13810  13830  13835
DosPtr                         $00bb   801D 11399  11401  11403  11408y
                                     11415  11417  11488  11492
W_Bank                         $00b7   797D  7195   7385   7498   7991
                                      8897   8953  11123  13562
R_Bank                         $00b6   796D  7193   7383   7496   7983
                                      8896   8993  11062  11103
Source_Unit                    $009c   662D  8274   8575   8636   8639
                                     11478  11558  11625  11674
Power_Flag                     $0099   646D  7222   9722  10496  10498
                                     10555  10571  10589  10610
FAC2M2                         $0068   541D  3399   5494   5730   5766
                                      5879   5899   5911   5913
ACCSYM                         $004a   485D  3274   3283   3284   3286
                                      3290   3325   3340   3831
MEMSIZ                         $0034   416D  1858   1859   4805   4808
                                      7119   7120   7127   7131
DOS_Filename                   $0342   950D  7573   7575   8679  13492
                                     13648  13657  13669
DOS_Attr                       $033d   934D  8491   8527   8532   8569
                                      8627   8653   8668
INSRT                          $00dc   856D  9272   9274   9433   9569
                                      9572   9592   9732
DATAX                          $00d9   854D  9224   9226   9227   9246
                                      9251   9410   9425
Mon_Op                         $00c1   806D 12501  12530  13332  13351
                                     13364  13378  13381
Dis_Line                       $00ba   800D  7423   7425   7427   7465
                                      7478   9968  13372
Wedge_Unit                     $00ab   755D  7099  12895  12902  13005
                                     13030  13736  13738
Key_Flags                      $0098   639D  6410  10036  10322  10324
                                     10364  10365  10439
FACTPA                         $0054   514D  5995   5996   6822   6825
                                      6826   6974   6975
FAC3M2                         $0024   380D  5587   5590   5692   5729
                                      5731   5736   5944
FAC3M1                         $0023   379D  5589   5592   5691   5732
                                      5734   5735   5942
SUBFLG                         $000a   312D  1891   2053   3932   3944
                                      3949   4535   4560
INTFLG                         $0008   291D  2488   3090   3642   3915
                                      3935   4201   4237
DOS_Drive_2                    $033c   933D  8506   8571   8648   8716
                                     11423  11698
LAT                            $0251   895D  8190  12036  12049  12083
                                     12084  12442
Mon_Tmp                        $00cb   819D  7516   7519   7725   7730
                                     13792  13823
SAL                            $00c7   816D  9098   9099   9100y  9742y
                                     10128  10132
Dis_Length                     $00be   803D 12507  12517  12575  13211
                                     13219  13377
PC_Adjust                      $00b3   789D  7170   7182   7198   7410
                                     12490  12492
DFLTO                          $00b0   777D  9243  10046  11990  12010
                                     12024  12883
YSAVE                          $0048   481D  3030   3031   3105   3106
                                      3311   3390
TANSGN                         $000c   326D  3393   3868   6949   6951
                                      6969   6979
DIMFLG                         $0006   279D  3897   4200   4239   4283
                                      4317   4368
DOS_Id                         $033f   948D  8152   8332   8335   8574
                                      8663
Ass_Buf_Length                 $02c0   913D 13350  13356  13846  13856
                                     13857
SAT                            $0265   897D  8059  12051  12087  12088
                                     12446
FAT                            $025b   896D  8188  12053  12085  12086
                                     12448
DFLTN                          $00af   773D 11953  11964  12014  12026
                                     12843
Target_Unit                    $00ad   762D 11477  11526  11584  11618
                                     11692
CRSW                           $00ac   760D  9174   9211   9240   9423
                                     11973
BLNCT                          $00a8   734D  9157   9277   9805   9808
                                     10063
BSOUR                          $00a5   694D 11765  11781  11805  11876
                                     11892
LASTPT                         $0014   356D  4737   5059   5061   5065
                                      7092
INPFLG                         $000b   316D  2892   3019   3038   3059
                                      3141
TABS_SET                       $03ee   953D  9656   9658   9911  10073
DOS_Command_Length             $0341   949D  8476   8478   8675   8681
DOS_Drive_1                    $033b   932D  8502   8570   8647  11680
DELAY                          $00e6   866D 10065  10394  10396  10411
DOS_FC                         $00b1   787D 11445  11506  11576  11604
BLNON                          $00aa   750D  9152   9155   9810   9813
LastInputCol                   $00a1   681D  9181   9189   9237  11975
C3PO                           $00a0   679D 11754  11760  11885  11887
ReverseFlag                    $009f   675D  9269   9484   9632   9733
CBINV                          $0092   609D  9795  13698  13700  13768
RNDX                           $0088   584D  6890   6891   6914   6915
BITS                           $0065   535D  4893   4899   4900   6196
SGNFLG                         $0064   533D  6265   6312   6842   6862
DATPTR                         $003e   448D  2197   2198   3009   3010
DATLIN                         $003c   442D  2897   2898   3126   3130
OLDLIN                         $0038   427D  2222   2223   2244   2245
TEMPPT                         $0013   351D  1880   4720   4741   5063
Ignore_Timeout                 $03fc   955D 11821  11830  13706
Dis_Buf_Length                 $02b0   911D 13243  13283  13357
SCROV                          $00eb   875D  9415  10082  10083
SCRIV                          $00e9   874D  9205  10078  10079
PrevChar                       $00e8   873D  9299   9530  10032
CHIME                          $00e7   867D 10085  10098  10107
KOUNT                          $00e5   865D 10066  10398  10404
LSTX                           $00e4   864D 10387  10392  10409
ScreenRows                     $00df   859D  9115   9344  10069
Mon_ZP                         $00cc   820D 13366  13368  13811
BLNSW                          $00a7   727D  9149   9803  10064
InputRow                       $00a3   682D  9184   9706  11969
Default_Bank                   $009a   652D 10038  11108  11129
Key_Index                      $0097   630D 10326  10359  10385
NMINV                          $0094   614D 13694  13696  13716
FACTPB                         $0059   521D  5988   6860   6861
RIGHT                          $001d   259D  2871   9439   9594
Reset_Vector                   $03fa   954D 13702  13704
IERROR                         $0300   920D  1492  13509
Ass_Index                      $02d0   915D 13353  13393
JIFFY6                         $00f8   876D 12810  12813
XMAX                           $00e3   863D 10044  10416
Mon_B                          $00c0   805D 12774  12777
Mon_Format                     $00bd   802D 12573  13208
DOS_EOF                        $00b2   788D 11571  11607
GDBLN                          $00a9   743D  9158   9814
SFDX                           $00a6   720D 10327  10431
InputCol                       $00a4   683D  9187  11967
Stop_Flag                      $009b   657D 10430  12097
JUMPER                         $0051   504D  3764   7080
CTRLY                          $0019   257D  9455   9608
CTRLV                          $0016   256D  9457   9604
TEMPST                         $0016   363D  1879   4721
CTRLU                          $0015   255D  9459   9614
DEL                            $0014   254D  9435   9590
HOME                           $0013   253D  9463   9600
RVS                            $0012   252D  9443   9598
DOWN                           $0011   251D  9441   9596
CTRLO                          $000f   250D  9451   9610
CTRLN                          $000e   249D  9447   9612
TAB                            $0009   247D  9453   9602
CTRLD                          $0004   245D  9461   9616
CTRLB                          $0002   244D  9449   9606
USRVEC                         $0001   268D  7084   7085
Basic_USR                      $0000   267D  1144   7081
IEVAL                          $030a   925D  3417
IGONE                          $0308   924D  2141
IQPLOP                         $0306   923D  2006
ICRNCH                         $0304   922D  1690
IMAIN                          $0302   921D  1532
ISNUM                          $007d   580D  2562
ESC                            $001b   258D  9431
BELL                           $0007   246D  9445
CTRLA                          $0001   243D  9465
FSBLK                          $00de   858
ROPRTY                         $00dd   857
TAPE1                          $00d6   852
ZD0                            $00d0   844
EOT                            $00cf   843
BITTS                          $00ce   842
ZP_b8                          $00b8   798
SCROLLING                      $00b4   790
FAC3M5                         $0027   384
DS_Ptr                         $000e   331
DS_Len                         $000d   330
