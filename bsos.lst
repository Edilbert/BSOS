              ; ****************************************************
              ; * Complete Commodore 8296 Operating System & BASIC *
              ; ****************************************************

              ; Use the Bit Shift Assembler "bsa" for assembly of this source

b000          * = $b000   ; *** b000 ***  Commodore 8296

              .STORE $B000, $1000, "b000.basic"
              .STORE $C000, $1000, "c000.basic"
              .STORE $D000, $1000, "d000.basic"
              .STORE $E000, $1000, "e000.edit"
              .STORE $F000, $1000, "f000.kernal"

0001          BSOS_KBD = 1

              ; revision 1.11 08-Jan-2020
              ; -------------------------
              ; enhance DELETE commnd
              ; implement OLD command

              ; revision 1.10 09-Oct-2015
              ; -------------------------
              ; optimize garbage collection
              ; implement REPLACE command
              ; implement 26 rows mode

              ; revision 1.09 10-Sep-2015
              ; -------------------------
              ; optimize BASIC routines Scan_Linenumber and Basic_LIST
              ; in order to make parts of them callable subroutines
              ; These routines are used in the assembler and power scrolling

              ; revision 1.08 04-Aug-2015
              ; -------------------------
              ; Implement conditional code for original keyboard layout
              ; or BSOS keyboard layout (BSOS_KBD)

              ; revision 1.07 04-Aug-2015
              ; -------------------------
              ; Implement ML Disassembler

              ; revision 1.06 29-Jul-2015
              ; -------------------------
              ; Check disk error after trying to boot from disk

              ; revision 1.05 19-Jan-2015
              ; -------------------------
              ; Detect and activate option ROM's
              ; Detect and run "BSOS BOOT" during boot
              ; Non desctructive RAM test
              ; Optimization of BSM LOAD/SAVE

              ; revision 1.03 29-Dec-2014
              ; -------------------------
              ; Add unit to unit capability to the COPY command

              ; revision 1.02 23-Dec-2014
              ; -------------------------
              ; Fix bug in DSAVE/DOPEN (Save and Replace bug)
              ; Optimize DOS Parameter Parser

              ; revision 1.01 14-Dec-2014
              ; -------------------------
              ; Add support for Nils Eilers' SoftROM
              ; The LOAD and DLOAD routines may be used to load data files
              ; directly into the address range $9000 - $AFFF. This works well
              ; for RAM or SoftROM (which in fact is flashed) installed there.

              ; revision 1.00 30-Nov-2014
              ; -------------------------
              ; First public release

              ; The operating system and BASIC interpreter is stored on two chips:

              ; The editor is stored on a 2332 (4KB) ROM (or 2532 EPROM) for the
              ; address range $E000 - $EFFF. The range $E800 - $E8FF is reserved
              ; for I/O and is not accessible

              ; The remaining code is stored on a 23128 (16KB) ROM (or 27128 EPROM):
              ; The address ranges are: $C000 $D000 $B000 $F000

              ; So after assembling you can prepare the EPROM images by using
              ; 1) e000.edit for a 2532 EPROM
              ; 2) cat c000.basic d000.basic b000.basic f000.kernal >os8296.rom
              ;    and use os8296.rom then for a 27128 EPROM

              ; PATCHES APPLIED
              ; ===============

              ; DOS parameter parser accepts 0-9 for drive value (original 0-1)
              ; This allows BASIC4 to work with all 10 possible drives of petSD

              ; The BSM memory display and modifier uses 16 bytes per line

              ; DELETED FEATURES
              ; ================

              ; All tape related code is removed
              ; The entry of diacritic characters is removed (accented letters etc.)

              ; NEW FEATURES
              ; ============

              ; The COPY command accepts different units for source and target
              ; The full syntax is (s = source, t = target):
              ; COPY Ds,"filepattern",Us TO Dt,Ut
              ; The D(rive) parameter defaults to D0 if not specified
              ; The U(nit)  parameter defaults to U8 if not specified
              ; Examples:
              ;
              ; COPY U8 TO U9           copies all files from D0,U8 to D0,U9
              ; COPY D1,U8 TO D2,U10    copies all files from D1,U8 to D2,U10
              ; COPY "*" TO U11         copies all files from D0,U8 to D0,U11
              ; COPY D1,"A*" TO U10     copies all files beginning with A

              ; restrictions:
              ; Currently REL files are not supported.
              ; It is is not possible to give a different name for the target file,
              ; use the RENAME command if necessary

              ; The machine language monitor BSM can now display memory from other banks.
              ; The new command ".b" (set Bank) stores a byte for the bank register.
              ; This affects the memory display for the asddress range $8000 - $ffff.
              ; Common values for the bank register are:

              ; .b 00    : system bank (screen RAM, ROM, I/O)
              ; .b 80    ; RAM bank 0/2 in $8000 - $ffff
              ; .b 8c    ; RAM bank 1/3 in $8000 - $ffff

              ; BSM includes a disassembler:

              ; .d f5c2 f5ef     disassemble the given range
              ; .d f5c2          disassemble 10 statements starting with $f5c2
              ; .d               Disassemble next 10 statements

              ; EDITING
              ; =======

              ; The editor scrolls the BASIC listing upwards or downwards if the
              ; cursor is moved up on the top line or down on the bottom line
              ; The idea (not the code) is taken from Brad Templeton's POWER ROM
              ; The character set is expanded with the missing ASCII characters {|}~ 
              ; These can be used by pressing the CONTROL key together with:
              ; CONTROL 7/      |
              ; CONTROL 8(      {
              ; CONTROL 9)      }
              ; CONTROL .Pi     ~ 

              ; LOAD, SAVE and VERIFY use now unit 8 as default device

              ; LOAD "filename",8,0 forces the file to load to $0401
              ; this enables the loading of C64 and other BASIC programs, which use
              ; different start addresses for BASIC programs.

              ; The Disk-Wedge is integrated, loosely based on Nils Eilers' code.

              ; @                          read drive status
              ; @command                   send dos command
              ; @$                         directory
              ; $                          directory
              ; $0                         directory of drive 0
              ; $0:pat*                    directory of files starting with "pat"
              ; /prog                      load program prog
              ; ^prog                      load and run program prog
              ; #9                         switch to unit 9
              ; #                          display current unit

              ; New commands added:

              ; DELETE from-to       ; Deletes a line range
              ;   DELETE 500-700 deletes all lines in this range
              ; FIND "text"          ; lists all lines with strings containing <text>
              ; FIND /text/          ; lists all lines with BASIC   containing <text>
              ;                      ; any character may be used as delimiter
              ; MONITOR              ; Calls BSM
              ; RENUMBER new,inc,old ; Renumbers a BASIC program
              ;    The default values for new,inc,old are: 10,10,first line
              ;    RENUMBER 1000,10  renumbers the whole program to linenumbers
              ;       1000,1010,1020 etc.

              ; **********************
              ; BASIC scalar variables
              ; **********************

              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Type     | Exa.|  0  |  1  |  2  |  3  |  4  |  5  |  6
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Float    | AB  |  A  |  B  | EXP | MSB | MAN | MAN | LSB
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Integer  | AB% |  A^ |  B^ | MSB | LSB |  0  |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Function | AB( |  A^ |  B  | LFP | MFP | LBP | MBP | ARG
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; String   | AB$ |  A  |  B^ | LEN | LSP | MSP |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----

              ; ************
              ; BASIC arrays
              ; ************

              ; ---------+-----+-----+-----+---------------+
              ; Type     | Exa.|  0  |  1  |  Element Size |
              ; ---------+-----+-----+-----+---------------+
              ; Float    | AB  |  A  |  B  |       5       |
              ; ---------+-----+-----+-----+---------------+
              ; Integer  | AB% |  A^ |  B^ |       2       |
              ; ---------+-----+-----+-----+---------------+
              ; String   | AB$ |  A  |  B^ |       3       |
              ; ---------+-----+-----+-----+---------------+

              ; The circumflex ^ indicates characters OR'ed with $80

              ; Array header:

              ; Byte  0   : 1st. character of name
              ; Byte  1   : 2nd, character of name
              ; Byte  2-3 : length of array including header in bytes
              ; Byte  4   : dimension count
              ; Byte  5-6 : Hi/Lo elements of 1st. dimension, (e.g. 11 for dim a(10)
              ; Byte  7-8 : Hi/Lo elements of 2nd. dimension if dimension count > 1
              ; Byte  x-x : Two bytes for each dimension

              ; *******
              ; Equates
              ; *******

0001          CTRLA     = $01 ; scroll window down
0002          CTRLB     = $02 ; switch character ROM
0004          CTRLD     = $04 ; toggle display size between 25 or 26 rows
0007          BELL      = $07 ; chime
0009          TAB       = $09
000d          CR        = $0d
000e          CTRLN     = $0e ; switch to text mode
000f          CTRLO     = $0f ; set top left window corner
0011          DOWN      = $11
0012          RVS       = $12
0013          HOME      = $13
0014          DEL       = $14
0015          CTRLU     = $15
0016          CTRLV     = $16
0019          CTRLY     = $19
001b          ESC       = $1b
001d          RIGHT     = $1d
0022          QUOTE     = $22

              ; These locations contain the JMP instruction and target address of the
              ; USR command. They are initialised so that if you try to execute a USR
              ; call without changing them you will receive an ILLEGAL QUANTITY error
              ; message.

0000          Basic_USR = $00               ; initialized to $4c the code for JMP
0001          USRVEC    = $01               ; initialized to $c373 (Illegal_Quantity)

0003          CHARAC    = $03               ; search character
0004          ENDCHR    = $04               ; scan quotes flag
0005          COUNT     = $05               ; line crunch/array access/logic operators

              ; This is used as a flag by the routines that build an array or
              ; reference an existing array. It is used to determine whether a
              ; variable is in an array, whether the array has already been
              ; DIMensioned, and whether a new array should assume default size.

0006          DIMFLG    = $06               ; DIM flag

              ; This flag is used to indicate whether data being operated upon is
              ; string or numeric. A value of $FF in this location indicates string
              ; data while a $00 indicates numeric data.

0007          VALTYP    = $07               ; data type, $FF = string, $00 = numeric

              ; If the above flag indicates numeric then a $80 in this location
              ; identifies the number as an integer, and a $00 indicates a floating
              ; point number.

0008          INTFLG    = $08     ; data type flag, $80 = integer, $00 = floating pt.

              ; The garbage collection routine uses this location as a flag to
              ; indicate that garbage collection has already been tried before adding
              ; a new string. If there is still not enough memory, an OUT OF MEMORY
              ; error message will result.

              ; LIST uses this byte as a flag to let it know when it has come to a
              ; character string in quotes. It will then print the string,rather than
              ; search it for BASIC keyword tokens.

              ; This location is also used during the process of converting a line of
              ; text in the BASIC input buffer into a linked program line of BASIC
              ; keyword tokens to flag a DATA line is being processed.

0009          GARBFL    = $09     ; garbage collected/open quote/DATA flag

              ; This flag is set from the routines handling FOR, DEF and FN
              ; statements. Names for loop indices and function names must not be
              ; integer. Only identifiers of type real are allowed.

000a          SUBFLG    = $0a     ; subscript/FNx flag

              ; input mode, $00 = INPUT, $40 = GET, $80 = READ

000b          INPFLG    = $0b     ; input mode, $00 = INPUT, $40 = GET, $98 = READ

              ; This location is used to determine whether the sign of the value
              ; returned by the functions SIN, COS, ATN or TAN is positive or negative
              ; Also the comparison routines use this location to indicate the outcome
              ; of the compare. For A <=> B the value here will be $01 if A > B,
              ; $02 if A = B, and $04 if A < B. If more than one comparison operator
              ; was used to compare the two variables then the value here will be a
              ; combination of the above values.

000c          TANSGN    = $0c     ; ATN sign/comparison evaluation flag

              ; Disk status or temporary string descriptor

000d          DS_Len    = $0d     ; unused
000e          DS_Ptr    = $0e     ; unused

              ; When the default input or output device is used the value here will
              ; be a zero, and the format of prompting and output will be the standard
              ; screen output format. The location $B8 is used to decide what device
              ; actually to put input from or output to.

0010          IOPMPT    = $10     ; current I/O channel

              ; Used whenever a 16 bit integer is used e.g. the target line number for
              ; GOTO, LIST, ON, and GOSUB also the number of a BASIC line that is to
              ; be added or replaced. additionally PEEK, POKE, WAIT, and SYS use this
              ; location as a pointer to the address which is the subject of the
              ; command.

0011          LINNUM = $11        ; line number

              ; This location points to the next available slot in the temporary
              ; string descriptor stack located at TEMPST ($16-$1e).

0013          TEMPPT = $13        ; descriptor stack pointer, next free

              ; This contains information about temporary strings which have not yet
              ; been assigned to a string variable.

0014          LASTPT = $14        ; current descriptor stack item pointer

              ; Stack for temporary string descriptors
              ; String 1: $16-$18
              ; String 2: $19-$1b
              ; String 3: $1c-$1e

0016          TEMPST = $16        ; temporary descriptor stack

              ; miscellaneous pointer / word used in many BASIC routines

001f          INDEXA = $1f        ; miscellaneous pointer

              ; miscellaneous pointer / word used in many BASIC routines

0021          INDEXB = $21

              ; above address shared with RENUMBER as increment value

0021          RENINC = $21        ; RENUMBER increment value

              ; Floating point accumulator #3 (mantissa only)

0023          FAC3M1 = $23        ; mantissa byte 1 MSB
0024          FAC3M2 = $24        ; mantissa byte 2
0025          FAC3M3 = $25        ; mantissa byte 3
0026          FAC3M4 = $26        ; mantissa byte 4 LSB

0027          FAC3M5 = $27        ; unused

              ; FAC3 addresses shared with RENUMBER as start value for line numbers

0023          RENNEW = $23        ; RENUMBER new line number start

              ; Start of BASIC program - initialized to $0401

0028          TXTTAB = $28        ; Text Table

              ; Two byte pointer to the start of the BASIC variable storage area.

002a          VARTAB = $2a        ; Variable table

              ; Two byte pointer to the start of the BASIC array storage area.

002c          ARYTAB = $2c        ; Array table

              ; Two byte pointer to end of the start of free RAM.

002e          STREND = $2e        ; String end

              ; Two byte pointer to the highest address used by BASIC +1.

0030          FRETOP = $30        ; top of BASIC memory

              ; Two byte pointer to the bottom of the string text storage area.

0032          FRESPC = $32        ; bottom of string space

              ; Two byte pointer to the highest RAM address

0034          MEMSIZ = $34        ; top of RAM

              ; These locations contain the line number of the BASIC statement which
              ; is currently being executed. A value of $FF in location $3A means that
              ; BASIC is in immediate mode.

0036          CURLIN = $36        ; current line number

              ; When program execution ends or stops the last line number executed is
              ; stored here.

0038          OLDLIN = $38        ; break line number

              ; These locations contain the address of the start of the text of the
              ; BASIC statement that is being executed.  The value of the pointer to
              ; the address of the BASIC text character currently being scanned is
              ; stored here each time a new BASIC statement begins execution.

003a          OLDTXT = $3a        ; continue pointer

              ; These locations hold the line number of the current DATA statement
              ; being READ. If an error concerning the DATA occurs this number will
              ; be moved to $39/$3A so that the error message will show the line that
              ; contains the DATA statement rather than in the line that contains the
              ; READ statement.

003c          DATLIN = $3c        ; current DATA line number

              ; These locations point to the address where the next DATA will be READ
              ; from. RESTORE sets this pointer back to the address indicated by the
              ; start of BASIC pointer.

003e          DATPTR = $3e        ; DATA pointer

              ; READ, INPUT and GET all use this as a pointer to the address of the
              ; source of incoming data, such as DATA statements, or the text input
              ; buffer.

0040          INPPTR = $40        ; READ pointer

              ; Two bytes storing the name of a BASIC variable as ASCII values
              ; The combination of the two bits 7 determines the type
              ; ---------------------------------------------
              ; Real    : AB      = $41 $42 = 'A'     'B'
              ; Function: FNAB()  = $c1 $42 = 'A'+$80 'B'
              ; String  : AB$     = $41 $c2 = 'A'     'B'+$80
              ; Integer : AB%     = $c1 $c2 = 'A'+$80 'B'+$80

0042          VARNAM = $42        ; current variable name

              ; These locations point to the value of the current BASIC variable.
              ; Specifically they point to the byte just after the two-character
              ; variable name.

0044          VARPTR = $44        ; current variable address

              ; The address of the BASIC variable which is the subject of a FOR/NEXT
              ; loop is first stored here before being pushed onto the stack.

0046          FORPNT = $46        ; FOR/NEXT variable pointer

              ; The expression evaluation routine creates this to let it know whether
              ; the current comparison operation is a < $01, = $02 or > $04 comparison
              ; or combination.

0048          YSAVE  = $48        ; BASIC execute pointer temporary/precedence flag

              ; used to compare the variable type on both sides of an operator

004a          ACCSYM = $4a        ; comparison evaluation flag

              ; These locations are used as a pointer to the function that is created
              ; during function definition. During function execution it points to
              ; where the evaluation results should be saved.

004b          FUNCPT = $4b        ; FAC temp store/function/variable/garbage pointer

              ; Temporary Pointer to the current string descriptor.

004d          DESCPT = $4d        ; FAC temp store/descriptor pointer

              ; Temporary pointer used in subroutines

004f          INDEXC = $4f

              ; The first byte is the 6502 JMP instruction $4C, followed by the
              ; address of the required function taken from the table at $B000.

0051          JUMPER = $51         ; JMP opcode for functions

              ; Used as jump address for previous opcode
              ; Several uses as temporary storage in BASIC routines

0052          FUNJMP = $52         ; functions jump vector

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary pointer (block pointer, array pointer)

0054          FACTPA = $54         ; FAC temp store ($54 - $58)
0055          TMPPTA = $55         ; temp pointer A
0057          TMPPTB = $57         ; temp pointer B

              ; Temporary storage for floating point values (5 bytes)
              ; and temporary variables

0059          FACTPB = $59         ; FAC temp store ($59 - $5d)
005a          TMPVAR = $5a         ; temporary variable
005c          TMPPTC = $5c         ; temporary pointer

              ; Floating point accumulator 1

005e          FAC1EX = $5e         ; FAC1 exponent
005f          FAC1M1 = $5f         ; FAC1 mantissa 1
0060          FAC1M2 = $60         ; FAC1 mantissa 2
0061          FAC1M3 = $61         ; FAC1 mantissa 3
0062          FAC1M4 = $62         ; FAC1 mantissa 4
0063          FAC1SI = $63         ; FAC1 sign
0064          SGNFLG = $64         ; constant count/negative flag

0065          BITS   = $65         ; unused

              ; Floating point accumulator 2

0066          FAC2EX = $66         ; FAC2 exponent
0067          FAC2M1 = $67         ; FAC2 mantissa 1
0068          FAC2M2 = $68         ; FAC2 mantissa 2
0069          FAC2M3 = $69         ; FAC2 mantissa 3
006a          FAC2M4 = $6a         ; FAC2 mantissa 4
006b          FAC2SI = $6b         ; FAC2 sign

              ; String pointer and FAC sign comparison and FAC rounding

006c          STRPTR = $6c         ; string pointer & FAC variables

              ; this address is sometimes used as high btye for the STRPTR
              ; and as rounding byte (5th. byte of mantissa) for FAC1

006d          FROUND = $6d         ; FAC1 mantissa 5 = rounding byte

              ; Temporary pointer and index used in many BASIC routines

006e          TMPPTD = $6e         ; temp BASIC execute/array pointer low byte/index

              ; Basic CHRGET (with increment) and CHRGOT (no increment) routine
              ; Also ISNUM for check if character is numeric
              ; Copied to this location from CHRGET_ROM at $d399
              ;
              ; 0070 e6 77     CHRGET    INC TXTPTR
              ; 0072 d0 02               BNE CHRGOT
              ; 0074 e6 78               INC TXTPTR+1
              ; 0076 ad 60 ea  CHRGOT    LDA $ffff       ; modified by previous code
              ; 0079 c9 3a               CMP #':'        ; check of end of statement
              ; 007b b0 0a               BCS CHRRET
              ; 007d c9 20     ISNUM     CMP #' '        ; skip blanks
              ; 007f f0 ef               BEQ CHRGET
              ; 0081 38                  SEC
              ; 0082 e9 30               SBC #'0'
              ; 0084 38                  SEC
              ; 0085 e9 d0               SBC #$d0
              ; 0087 60        CHRRET    RTS

0070          CHRGET = $70        ; Get program byte with pointer pre increment
0076          CHRGOT = $76        ; Get program byte
0077          TXTPTR = $77        ; Pointer to current program byte
007d          ISNUM  = $7d        ; Check for numeric digit

              ; Random seed, five bytes ($88 - $8c)

0088          RNDX   = $88        ; Random seed

              ; These three locations form a counter which is updated 60 times a
              ; second, and serves as a software clock which counts the number of
              ; jiffies that have elapsed since the computer was turned on.
              ; European computers running at 50 Hz add an additional count every
              ; 5th. jiffy in order to compensate the lower interrupt frequency.
              ; After 24 hours and one jiffy these locations are set back to $000000.

008d          JIFFY_CLOCK = $8d   ; Count jiffies (1/60 seconds)

              ; Vector, which may be used to redirect the interrupt routine.
              ; It is initialized to IRQ_NORMAL ($e455), which handles updating
              ; the jiffy clock, blinking the cursor and scanning the keyboard
              ; ROM's with tape routines switch this vector during tape activities
              ; to routines handling write to tape or read from tape.

0090          CINV   = $90        ; IRQ vector (IRQ_NORMAL)

              ; Vector, which may be used to redirect the break routine.
              ; The break routine is called after executing the BRK ($00) command
              ; either by intention or accidentally due to an error.
              ; It is initialized to MONITOR_BREAK ($d467), which saves the contents
              ; of all registers and starts BSM, the Bit Shifter Monitor.

0092          CBINV  = $92        ; BRK vector (MONITOR_BREAK)

              ; Vector, which may be used to redirect the Non Maskable Interrupt.
              ; It is intialized to Basic_Reday ($b3ff).

0094          NMINV  = $94        ; NMI vector (Basic_Reday)

              ; The STATUS byte is used to flag I/O errors or End-Of-Information
              ; A bit set to 1 indicates foloowing conditions:

              ; bit 0 : time out write
              ; bit 1 : time out read
              ; bit 4 : verify error
              ; bit 6 : EOI (End Of Information)
              ; bit 7 : device not present

0096          STATUS = $96        ; Status byte for I/O operations

              ; Key_Index is used in the subroutine EDIT_KEY_SCAN
              ; It holds the index for the character tables or -1 ($ff) for no key

0097          Key_Index = $97     ; Key index for character lookup

              ; The keyflags are used to select the character lookup table for
              ; NORMAL, SHIFTED or CONTROL.
              ; Flags are set by setting the corresponding bit to 0

              ; bit 7:  0 = <shift>
              ; bit 6:  0 = <control>

0098          Key_Flags = $98

              ; The power flag activates power scrolling (continuous scrolling)
              ; when set. It is active in direct mode and inactive in run mode.

0099          Power_Flag = $99    ; $ff power scrolling on, $00 off


              ; The default bank holds the configuration for the bank register $FFF0
              ; If the operating system runs from ROM its value is $00
              ; Loadable BSOS runs for configuration $ec

009a          Default_Bank = $9a  ; $00 = OS running in ROM

              ; The Stop_Flag is set by the keyboard scan routine
              ; $ff = no STOP key pressed, $ef = STOP key pressed

009b          Stop_Flag = $9b     ; $ef = 1110 1111 flags STOP key pressed

              ; Originally used as variable SVXT for tape routines
              ; Mow used by Parse_DOS_Parameter

009c          Source_Unit = $9c   ; Source unit for COPY command

              ; VERCK flags LOAD (0) or VERIFY ($80) mode for the load routines
              ; MERGE uses the value $40

009d          VERCK         = $9d ; LOAD or VERIFY flag

              ; Counter for the number of keys in keyboard buffer

009e          CharsInBuffer = $9e ; number of keys buffered

              ; Flag indicating reverse mode for screen output

009f          ReverseFlag  = $9f  ; 0 = normal   non zero = reverse

              ; IEEE-488 output: deferred character flag

00a0          C3PO         = $a0  ; 0 = no character waiting, $ff = character waiting

00a1          LastInputCol = $a1  ; screen input stops reading at LastInputVol
00a3          InputRow     = $a3  ; store screen input row number (0-24)
00a4          InputCol     = $a4  ; store screen input column (0-79)

              ; The IEEE-488 output routine CIOUT delays the output by one character,
              ; which is stored in BSOUR. CIOUT checks on each call, if a character
              ; is stored in BSOUR for transmisson, by testing the flag C3PO.
              ; If C3PO is negative, the character in BSOUR is sent and the actual
              ; character is stored in BSOUR. If BSOUR is empty (C3PO == 0), the only
              ; action is storing the actual character in BSOUR and making C3PO
              ; negative. The delay in sending makes it possible  to send the
              ; EOI (End Of Information) along with the last character to transmit.

00a5          BSOUR  = $a5        ; IEEE-488  output: deferred character (buffer)

              ; The keyscan interrupt routine uses this location to indicate which key
              ; is currently being pressed. The value here is then used as an index
              ; into the appropriate keyboard table to determine which character to
              ; print when a key is struck.
              ; The correspondence between the key pressed and the number stored here
              ; is as follows:

              ; $00          $10   2      $20   4      $30   6       $40   9
              ; $01          $11  [DOWN]  $21   UE     $31   AE      $41
              ; $02   sz     $12          $22   O      $32   L       $42  [HOME]
              ; $03  [DEL]   $13   0      $23   [      $33  [RETURN] $43   7
              ; $04   9      $14   ,      $24   U      $34   J       $44   0
              ; $05   6      $15   N      $25   T      $35   G       $45   7
              ; $06   3      $16   V      $26   E      $36   D       $46   4
              ; $07   <   ]  $17   Y      $27   Q      $37   A       $47   1
              ; $08   1      $18   3      $28   ]      $38   5       $48
              ; $09          $19  [SHIFT] $29   P      $39   OE      $49
              ; $0A          $1A          $2A   I      $3A   K       $4a  [STOP]
              ; $0B  [RIGHT] $1B   .      $2B   +      $3B   #       $4b   8
              ; $0C   M      $1C   .      $2C   Z      $3C   H       $4c   ´
              ; $0D  [SPACE] $1D   B      $2D   R      $3D   F       $4d   9
              ; $0E   X      $1E   C      $2E   W      $3E   S       $4e   6
              ; $0F  [CTRL]  $1F  [SHIFT] $2F  [TAB]   $3F  [ESC]    $4f   3

00a6          SFDX   = $a6         ; which key

              ; When this flag is set to a nonzero value, it indicates to the routine
              ; that normally flashes the cursor not to do so. The cursor blink is
              ; turned off when there are characters in the keyboard buffer, or when
              ; the program is running.

00a7          BLNSW   = $a7        ; cursor enable, $00 = flash cursor

              ; The routine that blinks the cursor uses this location to tell when
              ; it's time for a blink. The number 20 is put here and decremented every
              ; jiffy until it reaches zero. Then the cursor state is changed, the
              ; number 20 is put back here, and the cycle starts all over again.

00a8          BLNCT   = $a8

              ; The cursor is formed by printing the inverse of the character that
              ; occupies the cursor position. If that characters is the letter A, for
              ; example, the flashing cursor merely alternates between printing an A
              ; and a reverse-A. This location keeps track of the normal screen code
              ; of the character that is located at the cursor position, so that it
              ; may be restored when the cursor moves on.

00a9          GDBLN  = $a9         ; character under cursor

              ; This location keeps track of whether, during the current cursor blink,
              ; the character under the cursor was reversed, or was restored to
              ; normal. This location will contain 0 if the character is reversed, and
              ; 1 if the character is not reversed.

00aa          BLNON  = $aa         ; cursor blink phase

              ; The current unit number for wedge commands is held in Wedge_Unit
              ; It is initialized to 8 and can be changed with #<unit>

00ab          Wedge_Unit = $ab     ; current device for DOS wedge commands

              ; input from keyboard or screen, $xx = input is available from the
              ; screen, $00 = input should be obtained from the keyboard

00ac          CRSW   = $ac         ; input from keyboard or screen

00ad          Target_Unit = $ad    ; used by DOS Copy

              ; The number of currently open I/O files is stored here. The maximum
              ; number that can be open at one time is ten. The number stored here is
              ; used as the index to the end of the tables that hold the file numbers,
              ; device numbers, and secondary addresses.

00ae          LDTND  = $ae         ; open file count

              ; The default value of this location is 0.

00af          DFLTN  = $af         ; input device number

              ; The default value of this location is 3.

00b0          DFLTO  = $b0         ; output device number

                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard
                                   ;  1      cassette #1 - disabled in BSOS
                                   ;  2      cassette #2 - disabled in BSOS
                                   ;  3      screen
                                   ;  4-31   IEEE-488 bus

00b1          DOS_FC     = $b1     ; used for DOS_Copy
00b2          DOS_EOF    = $b2     ; used for DOS_Copy
00b3          PC_Adjust  = $b3     ; used in monitor
00b4          SCROLLING  = $b4     ; unused
00b5          MONCNT     = $b5     ; BSM counter variable

              ; Theses variables are used to store the value for the bank switching
              ; register while performing the RENUMBER command.

00b6          R_Bank     = $b6     ; Read  Bank value for bank switching
00b7          W_Bank     = $b7     ; Write Bank value for bank switching
00b8          ZP_b8      = $b8     ; unused
00b9          DOS_RL     = $b9     ; used for DOS_Copy
00ba          Dis_Line   = $ba     ; Disassembler
00bb          DosPtr     = $bb     ; used for DS$
00bd          Mon_Format = $bd     ; Disassembler
00be          Dis_Length = $be     ; Disassembler
00bf          Mon_A      = $bf     ; Disassembler
00c0          Mon_B      = $c0     ; Disassembler
00c1          Mon_Op     = $c1     ; Disassembler
00c2          Mon_Lo     = $c2     ; Disassembler
00c3          Mon_Hi     = $c3     ; Disassembler

              ; The Screen Pointer ScrPtr contains the screen memory address
              ; of the current cursor position

00c4          ScrPtr     = $c4      ; screen pointer ($8000 - $87cf)
00c6          CursorCol  = $c6      ; cursor column (0 - 79)

00c7          SAL        = $c7      ; used for windows scrolling
00c9          EAL        = $c9      ; used for LOAD, SAVE and BSM

00cb          Mon_Tmp    = $cb      ; Monitor temporary
00cc          Mon_ZP     = $cc      ; Monitor ZP flag

              ; A nonzero value in this location indicates that the editor is in quote
              ; mode. Quote mode is toggled every time that you type in a quotation
              ; mark on a given line, the first quote mark turns it on, the second
              ; turns it off, the third turns it on, etc.

              ; If the editor is in this mode when a cursor control character or other
              ; nonprinting character is entered, a printed equivalent will appear on
              ; the screen instead of the cursor movement or other control operation
              ; taking place. Instead, that action is deferred until the string is
              ; sent to the string by a PRINT statement, at which time the cursor
              ; movement or other control operation will take place.

              ; The exception to this rule is the DELETE key, which will function
              ; normally within quote mode. The only way to print a character which is
              ; equivalent to the DELETE key is by entering insert mode. Quote mode
              ; may be exited by printing a closing quote or by hitting the RETURN or
              ; SHIFT-RETURN or ESC keys.

00cd          QTSW   = $cd        ; quote switch non zero:inside quotes

00ce          BITTS  = $ce        ; unused (transmitter byte buffer)
00cf          EOT    = $cf        ; unused (end of tape)
00d0          ZD0    = $d0        ; unused

00d1          FNLEN  = $d1        ; Length of filename - for file open and DOS
00d2          LA     = $d2        ; Local     Address
00d3          SA     = $d3        ; Secondary Address
00d4          FA     = $d4        ; First     Address

00d5          RigMargin  = $d5    ; right margin of window (0 - 79)
00d6          TAPE1      = $d6    ; unused
00d8          CursorRow  = $d8    ; current corsor row
00d9          DATAX      = $d9    ; temprary storage
00da          FNADR      = $da    ; file name address
00dc          INSRT      = $dc    ; # of inserts outstanding
00dd          ROPRTY     = $dd    ; unused
00de          FSBLK      = $de    ; unused
00df          ScreenRows = $df    ; current screen rows - 1 (24 or 29)
00e0          TopMargin  = $e0    ; bottom margin of window (0 - screenrows-1)
00e1          BotMargin  = $e1    ; top margin of window
00e2          LefMargin  = $e2    ; left margin of window
00e3          XMAX       = $e3    ; length of keyboard buffer-1 = 9
00e4          LSTX       = $e4    ; last key pressed
00e5          KOUNT      = $e5    ; repeat speed counter
00e6          DELAY      = $e6    ; repeat delay
00e7          CHIME      = $e7    ; chime counter

              ; save the last character processed by Edit_CHROUT in PrevChar
              ; this is used to identify the seuence <HOME><HOME>, which resets
              ; the window to full screen

00e8          PrevChar   = $e8    ; used for key press repetion
00e9          SCRIV      = $e9    ; EDIT_CHRIN vector
00eb          SCROV      = $eb    ; EDIT_CHROUT vector
00f8          JIFFY6     = $f8    ; 50Hz jiffy clock compensation counter
00f9          BPTR       = $f9    ; multi purpose
00fb          STAL       = $fb    ; start address
00fd          MEMUSS     = $fd    ; end   address

              ; the bottom of the stack is used from the BASIC formatting routine
              ; which converts numbers to strings.
              ; The 4 top addresses $01fc-$01ff are used by the BASIC tokenizer
              ; for storing link and line number of an entered BASIC line,
              ; so the usable stack range is limited to $0110 - $01fb.
              ; BASIC initializes the stack pointer to $fa

0100          STACK      = $0100

              ; The input buffer accepts input lines with a maximum of 80 characters
              ; It is also used as workspace for the BASIC tokenizer.

0200          BUF        = $0200

0251          LAT        = $0251  ; Logical Address Table
025b          FAT        = $025b  ; First   Address Table (unit / device)
0265          SAT        = $0265  ; Second  Address Table
026f          KEYD       = $026f  ; keyboard buffer (10 byte)

              ; Commodore BASIC 4 used the area $027a - $0339
              ; as buffer for tape operations (TAPE1 buffer)
              ; BSOS has no TAPE routine and uses it for storing routines
              ; for accessing memory at different banks. These routines must
              ; be located at low RAM, because the ROM area is switched off
              ; while accessing High RAM.
              ; The area is used by the Monitor and RENUMBER command only.

028b          Bank_Store = Bank_Fetch + Bank_Store_Start - Bank_Fetch_Start
027a          Bank_Fetch     = $027a
02a0          Mon_Register   = $02a0
02b0          Dis_Buf_Length = $02b0
02b1          Dis_Buf        = $02b1
02c0          Ass_Buf_Length = $02c0
02c1          Ass_Buf        = $02c1
02d0          Ass_Index      = $02d0
02d1          Ass_Dollar     = $02d1
02d2          Ass_Length     = $02d2

              ; The area $033a - $03c9 was the tape buffer 2 on BASIC 2
              ; BASIC 4 uses this area for variables and buffers related to the
              ; BASIC 4 disk commands, like DOPEN, DCLOSE, DIRECTORY, etc.

033a          DOS_Tmp     = $033a
033b          DOS_Drive_1 = $033b
033c          DOS_Drive_2 = $033c
033d          DOS_Attr    = $033d

              ; DOS_flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

033e          DOS_Flags          = $033e
033f          DOS_Id             = $033f
0341          DOS_Command_Length = $0341
0342          DOS_Filename       = $0342
0353          DOS_Command_Buffer = $0353
03ad          DOS_Status         = $03ad
03ee          TABS_SET           = $03ee    ; 80 bits TAB table
03fa          Reset_Vector       = $03fa    ; set but unused
03fc          Ignore_Timeout     = $03fc

8000          SCREEN_RAM         = $8000

              ; *****************************
              ; MCS 6520 Peripheral Adapter 1
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E810 |CASR| EOI|    |    |Select Keyboard Row| PIA1_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E811 |  0 |  0 |  1 |  1 |  1 |  x |  0 |  0 | PIA1_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E812 |          Keyboard Row (8 keys)        | PIA1_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E813 |  0 |  0 |  1 |  1 |  1 |  1 |  0 |  1 | PIA1_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e810          PIA1_Port_A = $e810
e811          PIA1_Cont_A = $e811
e812          PIA1_Port_B = $e812
e813          PIA1_Cont_B = $e813

              ; *****************************
              ; MCS 6520 Peripheral Adapter 2
              ; *****************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  0| E820 |             IEEE-488 DATA IN          | PIA2_Port_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  1| E821 |    |    |    |    |NDAC|    |    |    | PIA2_Cont_A
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  2| E822 |             IEEE-488 DATA OUT         | PIA2_Port_B
              ; --+------+----+----+----+----+----+----+----+----+------------
              ;  3| E823 | SRQ|    |    |    | DAV|    |    |    | PIA2_Cont_B
              ; --+------+----+----+----+----+----+----+----+----+------------

e820          PIA2_Port_A = $e820
e821          PIA2_Cont_A = $e821
e822          PIA2_Port_B = $e822
e823          PIA2_Cont_B = $e823

              ; ************************************
              ; MCS 6522 Versatile Interface Adapter
              ; ************************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  0| E840 | DAV|NRFD|    |    |    | ATN|NRFD|NDAC| Port_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  1| E841 |              User-Port                | Port_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  2| E842 |  0 |  0 |  0 |  1 |  1 |  1 |  1 |  0 | DDR_B
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  3| E843 |       User-Port Data Direction        | DDR_A
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  4| E844 |    |    |    |    |    |    |    |    | Timer 1 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  5| E845 |    |    |    |    |    |    |    |    | Timer 1 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  6| E846 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  7| E847 |    |    |    |    |    |    |    |    | Timer 1 latch
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  8| E848 |    |    |    |    |    |    |    |    | Timer 2 low
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ;  9| E849 |    |    |    |    |    |    |    |    | Timer 2 high
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 10| E84A |    Shift Register                     | Shift
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 11| E84B |    Auxiliary Control Register         | ACR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 12| E84C |    |    |    |    |    |    |    |    | PCR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 13| E84D |    Interrupt Flag Register            | IFR
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 14| E84E |    Interrupt Enable Register          | IER
              ; --+------+----+----+----+----+----+----+----+----+--------------
              ; 15| E84F |    No Handshake Register              | no_HS
              ; --+------+----+----+----+----+----+----+----+----+--------------

e840          VIA_Port_B           = $e840
e841          VIA_Port_A           = $e841  ; unused
e842          VIA_DDR_B            = $e842
e843          VIA_DDR_A            = $e843  ; unused
e844          VIA_Timer_1_Lo       = $e844
e845          VIA_Timer_1_Hi       = $e845
e846          VIA_Timer_1_Latch_Lo = $e846  ; unused
e847          VIA_Timer_1_Latch_Hi = $e847  ; unused
e848          VIA_Timer_2_Lo       = $e848
e849          VIA_Timer_2_Hi       = $e849
e84a          VIA_Shift            = $e84a

e84b          VIA_ACR              = $e84b  ; Auxiliary Control Register
              ; bit 7: Timer 1 : Output Enable    1 = continuous 0 = single
              ; bit 6: Timer 1 : Free-Run Enable  1 = PB7 pulse  0 = IRQ
              ; bit 5: Timer 2 : Control          1 = pulse      0 = single

e84c          VIA_PCR              = $e84c

e84d          VIA_IFR              = $e84d  ; Interrupt Flag Register
              ; 7        IRQ
              ;  6       T1
              ;   5      T2
              ;    4     CB1
              ;     3    CB2
              ;      2   SR
              ;       1  CA1
              ;        0 CA2

e84e          VIA_IER              = $e84e  ; Interrupt Enable Register
e84f          VIA_Port_A_no_HS     = $e84f  ; unused




e880          CRT_Address          = $e880
e881          CRT_Value            = $e881

b000          * = $b000   ; *** b000 ***  Commodore 8296


              ; *********************
b000            Basic_Statement_Table
              ; *********************

b000 c7 b7              .WORD Basic_END       - 1
b002 dd b6              .WORD Basic_FOR       - 1
b004 18 bd              .WORD Basic_NEXT      - 1
b006 82 b8              .WORD Basic_DATA      - 1
b008 a3 bb              .WORD Basic_INPUTN    - 1
b00a bd bb              .WORD Basic_INPUT     - 1
b00c 20 c1              .WORD Basic_DIM       - 1
b00e 01 bc              .WORD Basic_READ      - 1
b010 2f b9              .WORD Basic_LET       - 1
b012 2f b8              .WORD Basic_GOTO      - 1
b014 07 b8              .WORD Basic_RUN       - 1
b016 b2 b8              .WORD Basic_IF        - 1
b018 b6 b7              .WORD Basic_RESTORE   - 1
b01a 12 b8              .WORD Basic_GOSUB     - 1
b01c 5c b8              .WORD Basic_RETURN    - 1
b01e c5 b8              .WORD Basic_REM       - 1
b020 c5 b7              .WORD Basic_STOP      - 1
b022 d5 b8              .WORD Basic_ON        - 1
b024 62 c9              .WORD Basic_WAIT      - 1
b026 d4 ff              .WORD Basic_LOAD      - 1
b028 d7 ff              .WORD Basic_SAVE      - 1
b02a da ff              .WORD Basic_VERIFY    - 1
b02c db c4              .WORD Basic_DEF       - 1
b02e 59 c9              .WORD Basic_POKE      - 1
b030 87 ba              .WORD Basic_PRINTN    - 1
b032 a7 ba              .WORD Basic_PRINT     - 1
b034 ed b7              .WORD Basic_CONT      - 1
b036 2f b6              .WORD Basic_LIST      - 1
b038 ed b5              .WORD Basic_CLR       - 1
b03a 8d ba              .WORD Basic_CMD       - 1
b03c dd ff              .WORD Basic_SYS       - 1
b03e bf ff              .WORD OPEN            - 1
b040 c2 ff              .WORD CLOSE           - 1
b042 79 bb              .WORD Basic_GET       - 1
b044 d1 b5              .WORD Basic_NEW       - 1
b046 ab b7              .WORD Basic_GO        - 1
b048 92 ff              .WORD Basic_CONCAT    - 1
b04a 95 ff              .WORD Basic_DOPEN     - 1
b04c 98 ff              .WORD Basic_DCLOSE    - 1
b04e 9b ff              .WORD Basic_RECORD    - 1
b050 9e ff              .WORD Basic_HEADER    - 1
b052 a1 ff              .WORD Basic_COLLECT   - 1
b054 a4 ff              .WORD Basic_BACKUP    - 1
b056 a7 ff              .WORD Basic_COPY      - 1
b058 aa ff              .WORD Basic_APPEND    - 1
b05a ad ff              .WORD Basic_DSAVE     - 1
b05c b0 ff              .WORD Basic_DLOAD     - 1
b05e b3 ff              .WORD Basic_DIRECTORY - 1
b060 b6 ff              .WORD Basic_RENAME    - 1
b062 b9 ff              .WORD Basic_SCRATCH   - 1
b064 b3 ff              .WORD Basic_DIRECTORY - 1

b066                    .SIZE ;  102 [Basic_Statement_Table]

              ; ********************
b066            Basic_Function_Table
              ; ********************

b066 6f cd              .WORD Basic_SGN
b068 02 ce              .WORD Basic_INT
b06a 8e cd              .WORD Basic_ABS
b06c 00 00              .WORD Basic_USR
b06e a8 c4              .WORD Basic_FRE
b070 c9 c4              .WORD Basic_POS
b072 08 d1              .WORD Basic_SQR
b074 29 d2              .WORD Basic_RND
b076 20 cb              .WORD Basic_LOG
b078 84 d1              .WORD Basic_EXP
b07a 82 d2              .WORD Basic_COS
b07c 89 d2              .WORD Basic_SIN
b07e d2 d2              .WORD Basic_TAN
b080 2c d3              .WORD Basic_ATN
b082 43 c9              .WORD Basic_PEEK
b084 b2 c8              .WORD Basic_LEN
b086 8e c5              .WORD Basic_STR
b088 e3 c8              .WORD Basic_VAL
b08a c1 c8              .WORD Basic_ASC
b08c 22 c8              .WORD Basic_CHR
b08e 36 c8              .WORD Basic_LEFT
b090 62 c8              .WORD Basic_RIGHT
b092 6d c8              .WORD Basic_MID

b094                    .SIZE ;   46 [Basic_Function_Table]

              ; ********************
b094            Basic_Operator_Table
              ; ********************

b094 79 9f c9           .BYTE $79, Op_PLUS     - 1
b097 79 88 c9           .BYTE $79, Op_MINUS    - 1
b09a 7b 60 cb           .BYTE $7b, Op_MULTIPLY - 1
b09d 7b 47 cc           .BYTE $7b, Op_DIVIDE   - 1
b0a0 7f 11 d1           .BYTE $7f, Op_POWER    - 1
b0a3 50 87 c0           .BYTE $50, Op_AND      - 1
b0a6 46 85 c0           .BYTE $46, Op_OR       - 1
b0a9 7d 4a d1           .BYTE $7d, Op_NEGATE   - 1
b0ac 5a cb be           .BYTE $5a, Op_NOT      - 1
b0af 64 b5 c0           .BYTE $64, Op_COMPARE  - 1

b0b2                    .SIZE ;   30 [Basic_Operator_Table]

              ; *******************
b0b2            Basic_Keyword_Table
              ; *******************

b0b2 45 4e c4           .BYTE "END"^        ; 80
b0b5 46 4f d2           .BYTE "FOR"^        ; 81
b0b8 4e 45 58           .BYTE "NEXT"^       ; 82
b0bc 44 41 54           .BYTE "DATA"^       ; 83
b0c0 49 4e 50           .BYTE "INPUT#"^     ; 84
b0c6 49 4e 50           .BYTE "INPUT"^      ; 85
b0cb 44 49 cd           .BYTE "DIM"^        ; 86
b0ce 52 45 41           .BYTE "READ"^       ; 87
b0d2 4c 45 d4           .BYTE "LET"^        ; 88
b0d5 47 4f 54           .BYTE "GOTO"^       ; 89
b0d9 52 55 ce           .BYTE "RUN"^        ; 8a
b0dc 49 c6              .BYTE "IF"^         ; 8b
b0de 52 45 53           .BYTE "RESTORE"^    ; 8c
b0e5 47 4f 53           .BYTE "GOSUB"^      ; 8d
b0ea 52 45 54           .BYTE "RETURN"^     ; 8e
b0f0 52 45 cd           .BYTE "REM"^        ; 8f
b0f3 53 54 4f           .BYTE "STOP"^       ; 90
b0f7 4f ce              .BYTE "ON"^         ; 91
b0f9 57 41 49           .BYTE "WAIT"^       ; 92
b0fd 4c 4f 41           .BYTE "LOAD"^       ; 93
b101 53 41 56           .BYTE "SAVE"^       ; 94
b105 56 45 52           .BYTE "VERIFY"^     ; 95
b10b 44 45 c6           .BYTE "DEF"^        ; 96
b10e 50 4f 4b           .BYTE "POKE"^       ; 97
b112 50 52 49           .BYTE "PRINT#"^     ; 98
b118 50 52 49           .BYTE "PRINT"^      ; 99
b11d 43 4f 4e           .BYTE "CONT"^       ; 9a
b121 4c 49 53           .BYTE "LIST"^       ; 9b
b125 43 4c d2           .BYTE "CLR"^        ; 9c
b128 43 4d c4           .BYTE "CMD"^        ; 9d
b12b 53 59 d3           .BYTE "SYS"^        ; 9e
b12e 4f 50 45           .BYTE "OPEN"^       ; 9f
b132 43 4c 4f           .BYTE "CLOSE"^      ; a0
b137 47 45 d4           .BYTE "GET"^        ; a1
b13a 4e 45 d7           .BYTE "NEW"^        ; a2
b13d 54 41 42           .BYTE "TAB("^       ; a3
b141 54 cf              .BYTE "TO"^         ; a4
b143 46 ce              .BYTE "FN"^         ; a5
b145 53 50 43           .BYTE "SPC("^       ; a6
b149 54 48 45           .BYTE "THEN"^       ; a7
b14d 4e 4f d4           .BYTE "NOT"^        ; a8
b150 53 54 45           .BYTE "STEP"^       ; a9
b154 ab                 .BYTE "+"^          ; aa
b155 ad                 .BYTE "-"^          ; ab
b156 aa                 .BYTE "*"^          ; ac
b157 af                 .BYTE "/"^          ; ad
b158 de                 .BYTE "^"^          ; ae
b159 41 4e c4           .BYTE "AND"^        ; af
b15c 4f d2              .BYTE "OR"^         ; b0
b15e be                 .BYTE ">"^          ; b1
b15f bd                 .BYTE "="^          ; b2
b160 bc                 .BYTE "<"^          ; b3
b161 53 47 ce           .BYTE "SGN"^        ; b4
b164 49 4e d4           .BYTE "INT"^        ; b5
b167 41 42 d3           .BYTE "ABS"^        ; b6
b16a 55 53 d2           .BYTE "USR"^        ; b7
b16d 46 52 c5           .BYTE "FRE"^        ; b8
b170 50 4f d3           .BYTE "POS"^        ; b9
b173 53 51 d2           .BYTE "SQR"^        ; ba
b176 52 4e c4           .BYTE "RND"^        ; bb
b179 4c 4f c7           .BYTE "LOG"^        ; bc
b17c 45 58 d0           .BYTE "EXP"^        ; bd
b17f 43 4f d3           .BYTE "COS"^        ; be
b182 53 49 ce           .BYTE "SIN"^        ; bf
b185 54 41 ce           .BYTE "TAN"^        ; c0
b188 41 54 ce           .BYTE "ATN"^        ; c1
b18b 50 45 45           .BYTE "PEEK"^       ; c2
b18f 4c 45 ce           .BYTE "LEN"^        ; c3
b192 53 54 52           .BYTE "STR$"^       ; c4
b196 56 41 cc           .BYTE "VAL"^        ; c5
b199 41 53 c3           .BYTE "ASC"^        ; c6
b19c 43 48 52           .BYTE "CHR$"^       ; c7
b1a0 4c 45 46           .BYTE "LEFT$"^      ; c8
b1a5 52 49 47           .BYTE "RIGHT$"^     ; c9
b1ab 4d 49 44           .BYTE "MID$"^       ; ca
b1af 47 cf              .BYTE "GO"^         ; cb
b1b1 43 4f 4e           .BYTE "CONCAT"^     ; cc
b1b7 44 4f 50           .BYTE "DOPEN"^      ; cd
b1bc 44 43 4c           .BYTE "DCLOSE"^     ; ce
b1c2 52 45 43           .BYTE "RECORD"^     ; cf
b1c8 48 45 41           .BYTE "HEADER"^     ; d0
b1ce 43 4f 4c           .BYTE "COLLECT"^    ; d1
b1d5 42 41 43           .BYTE "BACKUP"^     ; d2
b1db 43 4f 50           .BYTE "COPY"^       ; d3
b1df 41 50 50           .BYTE "APPEND"^     ; d4
b1e5 44 53 41           .BYTE "DSAVE"^      ; d5
b1ea 44 4c 4f           .BYTE "DLOAD"^      ; d6
b1ef 43 41 54           .BYTE "CATALOG"^    ; d7
b1f6 52 45 4e           .BYTE "RENAME"^     ; d8
b1fc 53 43 52           .BYTE "SCRATCH"^    ; d9
b203 44 49 52           .BYTE "DIRECTORY"^  ; da
b20c 00                 .BYTE $00           ; db

b20d                    .SIZE ;  347 [Basic_Keyword_Table]

              ; *********
b20d            Msg_Start
              ; *********

b20d 4e 45 58           .BYTE "NEXT WITHOUT FOR"^
b21d 53 59 4e Msg_SYNTA .BYTE "SYNTAX"^
b223 52 45 54 Msg_GOSUB .BYTE "RETURN WITHOUT GOSUB"^
b237 4f 55 54           .BYTE "OUT OF DATA"^
b242 49 4c 4c Msg_QUANT .BYTE "ILLEGAL QUANTITY"^
b252 4f 56 45 Msg_FLOW  .BYTE "OVERFLOW"^
b25a 4f 55 54 Msg_OOM   .BYTE "OUT OF MEMORY"^
b267 55 4e 44 Msg_UNDEF .BYTE "UNDEF'D STATEMENT"^
b278 42 41 44 Msg_SUBSC .BYTE "BAD SUBSCRIPT"^
b285 52 45 44 Msg_REDIM .BYTE "REDIM'D ARRAY"^
b292 44 49 56 Msg_DIV   .BYTE "DIVISION BY ZERO"^
b2a2 49 4c 4c Msg_DIREC .BYTE "ILLEGAL DIRECT"^
b2b0 54 59 50 Msg_TYPE  .BYTE "TYPE MISMATCH"^
b2bd 53 54 52 Msg_LONG  .BYTE "STRING TOO LONG"^
b2cc 46 49 4c Msg_DATA  .BYTE "FILE DATA"^
b2d5 46 4f 52 Msg_COMPL .BYTE "FORMULA TOO COMPLEX"^
b2e8 43 41 4e           .BYTE "CAN'T CONTINUE"^
b2f6 55 4e 44 Msg_FUNC  .BYTE "UNDEF'D FUNCTION"^
b306 20 45 52 Msg_ERR   .BYTE " ERROR",0
b30d 20 49 4e Msg_IN    .BYTE " IN ",0

b312                    .SIZE ;  261 [Msg_Start]

              ; *********
b312            Msg_READY
              ; *********

b312 0d 52 45           .BYTE "\rREADY.\r",0

              ; *********
b31b            Msg_BREAK
              ; *********

b31b 0d 42 52           .BYTE "\rBREAK",0


              ; FOR TO STEP NEXT data structure on stack
              ; ========================================

              ; 00 : TXTPTR
              ; 01 : TXTPTR+1  address of loop body

              ; 02 : CURLIN+1
              ; 03 : CURLIN    line #  of loop body

              ; 04 : FAC M4
              ; 05 : FAC M3
              ; 06 : FAC M2    value after TO
              ; 07 : FAC M1
              ; 08 : FAC EX

              ; 09 : sign
              ; 0a : FAC M4
              ; 0b : FAC M3
              ; 0c : FAC M2    value after STEP
              ; 0d : FAC M1
              ; 0e : FAC EX

              ; 0f : FORPNT+1
              ; 10 : FORPNT    address of index variable

              ; 11 : 81        loop marker

              ; ***********************
b322            Find_Active_FOR ; $b322
              ; ***********************

              ; Output: X = stackpointer to loop structure
              ;         Z = found flag
              ;         FORPNT = address of index variable

b322 ba                 TSX                 ; X = stack pointer
b323 e8                 INX
b324 e8                 INX                 ; skip return address of current subroutine
b325 e8                 INX
b326 e8                 INX                 ; skip return address of calling subroutine
b327 bd 01 01 FAF_10    LDA STACK+1,X
b32a c9 81              CMP #$81            ; loop marker ?
b32c d0 21              BNE FAF_Ret
b32e a5 47              LDA FORPNT+1        ; index variable given ?
b330 d0 0a              BNE FAF_20
b332 bd 02 01           LDA STACK+2,X       ; index variable low
b335 85 46              STA FORPNT
b337 bd 03 01           LDA STACK+3,X       ; index variable high
b33a 85 47              STA FORPNT+1
b33c dd 03 01 FAF_20    CMP STACK+3,X       ; index address high match ?
b33f d0 07              BNE FAF_30
b341 a5 46              LDA FORPNT
b343 dd 02 01           CMP STACK+2,X       ; index address low  match ?
b346 f0 07              BEQ FAF_Ret         ; OK found correct data structure
b348 8a       FAF_30    TXA
b349 18                 CLC
b34a 69 12              ADC #$12            ; try outer loop
b34c aa                 TAX
b34d d0 d8              BNE FAF_10
b34f 60       FAF_Ret   RTS ;Size   46 [Find_Active_FOR]

              ; *********************
b350            Open_Up_Space ; $b350
              ; *********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ;         TMPPTA = target pointer (upper boundary)
              ;         TMPPTB = source pointer (upper boundary)
              ;         TMPPTC = source pointer (lower boundary)

b350 20 a0 b3           JSR Check_Mem_Avail ; may trigger a garbage collection
b353 85 2e              STA STREND
b355 84 2f              STY STREND+1        ; save new top of variables
b357 38                 SEC
b358 a5 57              LDA TMPPTB
b35a e5 5c              SBC TMPPTC
b35c 85 1f              STA INDEXA
b35e a8                 TAY
b35f a5 58              LDA TMPPTB+1
b361 e5 5d              SBC TMPPTC+1
b363 aa                 TAX                 ; Y/X = bytes to move
b364 e8                 INX                 ; pages + 1
b365 98                 TYA
b366 f0 23              BEQ OUS_40          ; no partial page
b368 a5 57              LDA TMPPTB
b36a 38                 SEC
b36b e5 1f              SBC INDEXA
b36d 85 57              STA TMPPTB
b36f b0 03              BCS OUS_10
b371 c6 58              DEC TMPPTB+1        ; TMPPTB = source ptr
b373 38                 SEC
b374 a5 55    OUS_10    LDA TMPPTA
b376 e5 1f              SBC INDEXA
b378 85 55              STA TMPPTA
b37a b0 08              BCS OUS_30
b37c c6 56              DEC TMPPTA+1        ; TMPPTA = target ptr
b37e 90 04              BCC OUS_30          ; branch always
b380 b1 57    OUS_20    LDA (TMPPTB),Y
b382 91 55              STA (TMPPTA),Y
b384 88       OUS_30    DEY
b385 d0 f9              BNE OUS_20
b387 b1 57              LDA (TMPPTB),Y
b389 91 55              STA (TMPPTA),Y
b38b c6 58    OUS_40    DEC TMPPTB+1
b38d c6 56              DEC TMPPTA+1
b38f ca                 DEX
b390 d0 f2              BNE OUS_30
b392 60                 RTS ;Size   67 [Open_Up_Space]

              ; *************************
b393            Check_Stack_Avail ; $b393
              ; *************************

b393 ba                 TSX
b394 e0 20              CPX #$20
b396 90 35              BCC Error_Out_Of_Memory
b398 60                 RTS ;Size    6 [Check_Stack_Avail]

              ; **************
b399            BSOS_Bank_Init
              ; **************

b399 00                 .BYTE 0             ; changed by BSOS loader

b39a 00 00 00           .FILL $b3a0-* (0) ; 6 bytes

              ; ***********************
b3a0            Check_Mem_Avail ; $b3a0
              ; ***********************

              ; Input:  A = new top of variables low
              ;         Y = new top of variables high
              ; Return if OK
              ; Jump to OOM error if not

b3a0 c4 31              CPY FRETOP+1
b3a2 90 19              BCC CMA_Ret
b3a4 d0 04              BNE CMA_10
b3a6 c5 30              CMP FRETOP
b3a8 90 13              BCC CMA_Ret
b3aa 48       CMA_10    PHA                 ; not enough space
b3ab 98                 TYA                 ; call garbage collectiom
b3ac 48                 PHA
b3ad 20 6a c6           JSR Garbage_Collection
b3b0 68                 PLA
b3b1 a8                 TAY                 ; restore new top high
b3b2 68                 PLA                 ; restore new to low
b3b3 c4 31              CPY FRETOP+1        ; compare again
b3b5 90 06              BCC CMA_Ret
b3b7 d0 14              BNE Error_Out_Of_Memory
b3b9 c5 30              CMP FRETOP
b3bb b0 10              BCS Error_Out_Of_Memory
b3bd 60       CMA_Ret   RTS ;Size   30 [Check_Mem_Avail]

b3be 00 00 00           .FILL $b3cd-* (0) ; 15 bytes

              ; ***************************
b3cd            Error_Out_Of_Memory ; $b3cd
              ; ***************************

b3cd a2 4d              LDX #[Msg_OOM - Msg_Start] ; $4d

              ; *******************
b3cf            Basic_Error ; $b3cf
              ; *******************

              ; Input:  X = Offset from Msg_Start for message

b3cf a5 10              LDA IOPMPT
b3d1 f0 07              BEQ Berr_10
b3d3 20 cc ff           JSR CLRCHN          ; close open channels
b3d6 a9 00              LDA #0
b3d8 85 10              STA IOPMPT
b3da 20 df ba Berr_10   JSR Print_CR
b3dd 20 44 bb           JSR Print_Question_Mark
b3e0 bd 0d b2 Berr_20   LDA Msg_Start,X
b3e3 48                 PHA
b3e4 29 7f              AND #$7f
b3e6 20 d2 ff           JSR CHROUT
b3e9 e8                 INX
b3ea 68                 PLA
b3eb 10 f3              BPL Berr_20
b3ed 20 0e b6 Berr_30   JSR Flush_BASIC_Stack
b3f0 a9 06              LDA #<Msg_ERR
b3f2 a0 b3              LDY #>Msg_ERR
b3f4 20 1d bb Berr_40   JSR Print_String
b3f7 a4 37              LDY CURLIN+1
b3f9 c8                 INY
b3fa f0 03              BEQ Basic_Ready
b3fc 20 78 cf           JSR Print_IN

              ; ********************
b3ff            Basic_Ready ; $ b3ff
              ; ********************

b3ff a9 12              LDA #<Msg_READY
b401 a0 b3              LDY #>Msg_READY
b403 20 1d bb           JSR Print_String

              ; ***************************
b406            Get_Basic_Statement ; $b406
              ; ***************************

b406 20 f2 e9           JSR Read_Power_String
b409 86 77              STX TXTPTR
b40b 84 78              STY TXTPTR+1
b40d 20 70 00           JSR CHRGET
b410 aa                 TAX
b411 f0 f3              BEQ Get_Basic_Statement; empty line
b413 a2 ff              LDX #$ff
b415 86 37              STX CURLIN+1        ; invalidate CURLIN
b417 90 06              BCC New_Basic_Line  ; started with a line number
              ;         JSR Tokenize_Line   ; else direct mode (HOOK FOR WEDGE)
b419 4c 42 f8           JMP Wedge_Parser
b41c 4c 7c b7           JMP Start_Program   ; execute direct mode

              ; **********************
b41f            New_Basic_Line ; $b41f
              ; **********************

              ; This routine uses the addresses $01fc-$01ff for constructing
              ; the link and line number for the line stored in the buffer at $0200
              ; So these bytes are not available for stack operations.
              ; That's why the Flush_Stack routine initializes the stack pointer to $fa.

b41f 20 f6 b8           JSR Scan_Linenumber ; Line number
b422 20 fb b4           JSR Tokenize_Line   ; Crunch line
b425 84 05              STY COUNT           ; new line length (incl. link & number)
b427 20 a3 b5           JSR Find_BASIC_Line ; does this line exist?
b42a 90 44              BCC NBL_30          ; if not -> create a new line
b42c a0 01              LDY #1              ; Y = 1
b42e b1 5c              LDA (TMPPTC),Y      ; link high
b430 85 20              STA INDEXA+1        ; source pointer INDEXA high
b432 a5 2a              LDA VARTAB
b434 85 1f              STA INDEXA          ; source pointer INDEXA low
b436 a5 5d              LDA TMPPTC+1
b438 85 22              STA INDEXB+1        ; target pointer INDEXB high
b43a a5 5c              LDA TMPPTC
b43c 88                 DEY                 ; Y = 0
b43d f1 5c              SBC (TMPPTC),Y      ; negative length of line
b43f 18                 CLC
b440 65 2a              ADC VARTAB          ; subtract line length from VARTAB
b442 85 2a              STA VARTAB          ; by adding the negative length to VARTAB
b444 85 21              STA INDEXB          ; move target pointer INDEXB low
b446 a5 2b              LDA VARTAB+1
b448 69 ff              ADC #$ff
b44a 85 2b              STA VARTAB+1        ; VARTAB -= length of current line
b44c e5 5d              SBC TMPPTC+1
b44e aa                 TAX                 ; pages to move
b44f 38                 SEC
b450 a5 5c              LDA TMPPTC
b452 e5 2a              SBC VARTAB          ; bytes to move
b454 a8                 TAY
b455 b0 03              BCS NBL_10
b457 e8                 INX                 ; increment pages to move
b458 c6 22              DEC INDEXB+1
b45a 18       NBL_10    CLC
b45b 65 1f              ADC INDEXA
b45d 90 03              BCC NBL_20
b45f c6 20              DEC INDEXA+1
b461 18                 CLC
b462 b1 1f    NBL_20    LDA (INDEXA),Y      ; move program code above deleted line
b464 91 21              STA (INDEXB),Y      ; downwards
b466 c8                 INY
b467 d0 f9              BNE NBL_20          ; inner loop moves 1 page
b469 e6 20              INC INDEXA+1
b46b e6 22              INC INDEXB+1
b46d ca                 DEX                 ; pages to move
b46e d0 f2              BNE NBL_20
b470 20 e9 b5 NBL_30    JSR Reset_BASIC_Execution
b473 20 b6 b4           JSR Rechain
b476 ad 00 02           LDA BUF
b479 f0 8b              BEQ Get_Basic_Statement
b47b 18                 CLC
b47c a5 2a              LDA VARTAB
b47e 85 57              STA TMPPTB
b480 65 05              ADC COUNT
b482 85 55              STA TMPPTA
b484 a4 2b              LDY VARTAB+1
b486 84 58              STY TMPPTB+1
b488 90 01              BCC NBL_40
b48a c8                 INY
b48b 84 56    NBL_40    STY TMPPTA+1
b48d 20 50 b3           JSR Open_Up_Space
b490 a5 11              LDA LINNUM
b492 a4 12              LDY LINNUM+1
b494 8d fe 01           STA BUF-2
b497 8c ff 01           STY BUF-1
b49a a5 2e              LDA STREND
b49c a4 2f              LDY STREND+1
b49e 85 2a              STA VARTAB
b4a0 84 2b              STY VARTAB+1
b4a2 a4 05              LDY COUNT
b4a4 88                 DEY
b4a5 b9 fc 01 NBL_50    LDA BUF-4,Y         ; copy buffer to program
b4a8 91 5c              STA (TMPPTC),Y
b4aa 88                 DEY
b4ab 10 f8              BPL NBL_50

              ; *************************
b4ad            Reset_And_Rechain ; $b4ad
              ; *************************

b4ad 20 e9 b5           JSR Reset_BASIC_Execution
b4b0 20 b6 b4           JSR Rechain
b4b3 4c 06 b4           JMP Get_Basic_Statement

              ; ***************
b4b6            Rechain ; $b4b6
              ; ***************

b4b6 a6 28              LDX TXTTAB
b4b8 a5 29              LDA TXTTAB+1
b4ba a0 01              LDY #1
b4bc d0 16              BNE Rech_30
b4be a0 04    Rech_10   LDY #4
b4c0 c8       Rech_20   INY
b4c1 b1 1f              LDA (INDEXA),Y
b4c3 d0 fb              BNE Rech_20         ; scan for 0
b4c5 98                 TYA
b4c6 38                 SEC                 ; + 1
b4c7 65 1f              ADC INDEXA
b4c9 aa                 TAX                 ; X = new address low
b4ca a0 00              LDY #0
b4cc 91 1f              STA (INDEXA),Y      ; store link low
b4ce 98                 TYA                 ; A = 0
b4cf 65 20              ADC INDEXA+1        ; A = new address high
b4d1 c8                 INY                 ; Y = 1
b4d2 91 1f              STA (INDEXA),Y      ; store link high
b4d4 86 1f    Rech_30   STX INDEXA
b4d6 85 20              STA INDEXA+1
b4d8 b1 1f              LDA (INDEXA),Y      ; link high
b4da d0 e2              BNE Rech_10         ; more lines
b4dc 60                 RTS ;Size   39 [Rechain]

b4dd 00 00 00           .FILL $b4e2-* (0) ; 5 bytes

              ; *******************
b4e2            Read_String ; $b4e2
              ; *******************

b4e2 a2 00              LDX #0
b4e4 20 cf ff ReaS_10   JSR CHRIN
b4e7 c9 0d              CMP #CR
b4e9 f0 0d              BEQ ReaS_20
b4eb 9d 00 02           STA BUF,X
b4ee e8                 INX
b4ef e0 51              CPX #81
b4f1 90 f1              BCC ReaS_10
b4f3 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
b4f5 4c cf b3           JMP Basic_Error
b4f8 4c d2 ba ReaS_20   JMP Terminate_BUF

              ; *********************
b4fb            Tokenize_Line ; $b4fb
              ; *********************

b4fb a6 77              LDX TXTPTR
b4fd a0 04              LDY #4
b4ff 84 09              STY GARBFL          ; clear bits 7-4
b501 bd 00 02 ToLi_01   LDA BUF,X           ; get next char
b504 10 07              BPL ToLi_02         ; normal char
b506 c9 ff              CMP #$ff            ; Pi ?
b508 f0 4a              BEQ ToLi_08         ; treat Pi as normal char
b50a e8                 INX                 ; no action on this char
b50b d0 f4              BNE ToLi_01         ; next one
b50d c9 20    ToLi_02   CMP #' '            ; no action on blank
b50f f0 43              BEQ ToLi_08
b511 85 04              STA ENDCHR          ; save char
b513 c9 22              CMP #$22            ; quote ?
b515 f0 62              BEQ ToLi_12         ; handle string
b517 24 09              BIT GARBFL
b519 70 39              BVS ToLi_08
b51b c9 3f              CMP #'?'            ; short for print
b51d d0 04              BNE ToLi_03
b51f a9 99              LDA #$99            ; PRINT token
b521 d0 31              BNE ToLi_08
b523 c9 30    ToLi_03   CMP #'0'
b525 90 04              BCC ToLi_04         ; is symbol
b527 c9 3c              CMP #$3c            ; '<'
b529 90 29              BCC ToLi_08
b52b 84 6e    ToLi_04   STY TMPPTD          ; save Y
b52d a0 00              LDY #0
b52f 84 05              STY COUNT           ; keyword count
b531 86 77              STX TXTPTR          ; update pointer
b533 a9 b0              LDA #>Basic_Keyword_Table
b535 85 20              STA INDEXA+1
b537 a9 b2              LDA #<Basic_Keyword_Table
b539 85 1f              STA INDEXA
b53b d0 07              BNE ToLi_06         ; branch always
b53d e8       ToLi_05   INX                 ; inc buffer  pointer X
b53e e6 1f              INC INDEXA          ; inc keyword pointer INDEXA
b540 d0 02              BNE ToLi_06
b542 e6 20              INC INDEXA+1
b544 bd 00 02 ToLi_06   LDA BUF,X           ; char - keyword char
b547 38                 SEC
b548 f1 1f              SBC (INDEXA),Y
b54a f0 f1              BEQ ToLi_05         ; match, continue with next char
b54c c9 80              CMP #$80            ; match with difference $80 -> found
b54e d0 30              BNE ToLi_13
b550 05 05              ORA COUNT           ; token = $80 | count
b552 a4 6e    ToLi_07   LDY TMPPTD          ; restore Y (started with 4)
b554 e8       ToLi_08   INX                 ; point to char after parsed word
b555 c8                 INY                 ; point to token insert position - 5
b556 99 fb 01           STA BUF-5,Y         ; insert token at start of word
b559 b9 fb 01           LDA BUF-5,Y         ; reload to set flags
b55c f0 3b              BEQ ToLi_16         ; zero -> end of line
b55e 38                 SEC
b55f e9 3a              SBC #':'            ; colon ?
b561 f0 04              BEQ ToLi_09         ; branch on colon
b563 c9 49              CMP #$49            ; DATA token ? ($83 = $3a + $49)
b565 d0 02              BNE ToLi_10
b567 85 09    ToLi_09   STA GARBFL          ; store colon or $49 for DATA
b569 38       ToLi_10   SEC
b56a e9 55              SBC #$55            ; REM token ? ($8f = $3a + $55)
b56c d0 93              BNE ToLi_01         ; no special tokens -> continue parse
b56e 85 04              STA ENDCHR          ; store REM marker in ENDCHR
b570 bd 00 02 ToLi_11   LDA BUF,X
b573 f0 df              BEQ ToLi_08         ; end of parsed text
b575 c5 04              CMP ENDCHR
b577 f0 db              BEQ ToLi_08         ; end of copied text
b579 c8       ToLi_12   INY                 ; copy text in quotes or after REM or DATA
b57a 99 fb 01           STA BUF-5,Y
b57d e8                 INX
b57e d0 f0              BNE ToLi_11         ; continue copy
b580 a6 77    ToLi_13   LDX TXTPTR          ; found keyword match
b582 e6 05              INC COUNT           ; set count to next token
b584 b1 1f    ToLi_14   LDA (INDEXA),Y      ;
b586 08                 PHP                 ; save flags
b587 e6 1f              INC INDEXA          ; let INDEXA point to next token
b589 d0 02              BNE ToLi_15
b58b e6 20              INC INDEXA+1
b58d 28       ToLi_15   PLP                 ; restore flags
b58e 10 f4              BPL ToLi_14         ; true if not single character keyword
b590 b1 1f              LDA (INDEXA),Y      ; load 1st. char of next token keyword
b592 d0 b0              BNE ToLi_06         ; jump if not at end of table
b594 bd 00 02           LDA BUF,X           ; reread parse char
b597 10 b9              BPL ToLi_07         ; start searching from start of table
b599 99 fd 01 ToLi_16   STA BUF-3,Y         ; end of parse, store zeroes at end of line
b59c c6 78              DEC TXTPTR+1        ; set TXTPTR to BUF-1
b59e a9 ff              LDA #$ff
b5a0 85 77              STA TXTPTR
b5a2 60                 RTS ;Size  168 [Tokenize_Line]

              ; ***********************
b5a3            Find_BASIC_Line ; $b5a3
              ; ***********************

b5a3 a5 28              LDA TXTTAB
b5a5 a6 29              LDX TXTTAB+1

              ; **************************
b5a7            Find_BASIC_Line_AX ; $b5a7
              ; **************************

b5a7 a0 01              LDY #1
b5a9 85 5c              STA TMPPTC
b5ab 86 5d              STX TMPPTC+1
b5ad b1 5c              LDA (TMPPTC),Y      ; link high
b5af f0 1a              BEQ FBL_30          ; branch on EOP
b5b1 aa                 TAX                 ; X = link high
b5b2 a0 03              LDY #3
b5b4 a5 12              LDA LINNUM+1
b5b6 d1 5c              CMP (TMPPTC),Y
b5b8 90 12              BCC FBL_Ret         ; branch if beyond
b5ba d0 09              BNE FBL_10
b5bc 88                 DEY                 ; Y = 2
b5bd a5 11              LDA LINNUM
b5bf d1 5c              CMP (TMPPTC),Y
b5c1 f0 09              BEQ FBL_Ret         ; (C=1) found
b5c3 90 07              BCC FBL_Ret         ; (C=0) not found
b5c5 a0 00    FBL_10    LDY #0
b5c7 b1 5c              LDA (TMPPTC),Y      ; Link low
b5c9 b0 dc              BCS Find_BASIC_Line_AX  ; branch always
b5cb 18       FBL_30    CLC                 ; Carry clear = not found
b5cc 60       FBL_Ret   RTS ;Size   38 [Find_BASIC_Line_AX]

b5cd 00 00 00           .FILL $b5d2-* (0) ; 5 bytes

              ; *****************
b5d2            Basic_NEW ; $b5d2
              ; *****************

b5d2 d0 f8              BNE FBL_Ret         ; return if NEW is not a single statement

              ; ***********
b5d4            Perform_NEW
              ; ***********

b5d4 a9 00              LDA #0
b5d6 a8                 TAY
b5d7 91 28              STA (TXTTAB),Y      ; zero link
b5d9 c8                 INY
b5da 91 28              STA (TXTTAB),Y
b5dc a5 28              LDA TXTTAB
b5de 18                 CLC
b5df 69 02              ADC #2
b5e1 85 2a              STA VARTAB          ; VARTAB = TXTTAB + 2
b5e3 a5 29              LDA TXTTAB+1
b5e5 69 00              ADC #0
b5e7 85 2b              STA VARTAB+1

              ; *********************
b5e9            Reset_BASIC_Execution
              ; *********************

b5e9 20 22 b6           JSR Reset_BASIC_Exec_Pointer
b5ec a9 00              LDA #0              ; set for next condition

              ; *********
b5ee            Basic_CLR
              ; *********

b5ee d0 31              BNE FBS_Ret         ; return if not single statement

              ; **********************
b5f0            Reset_Variable_Pointer
              ; **********************

b5f0 a5 34              LDA MEMSIZ
b5f2 a4 35              LDY MEMSIZ+1
b5f4 85 30              STA FRETOP
b5f6 84 31              STY FRETOP+1
b5f8 ea                 NOP
b5f9 ea                 NOP
b5fa ea                 NOP
b5fb ea                 NOP
b5fc 20 e7 ff           JSR CLALL
b5ff a5 2a              LDA VARTAB
b601 a4 2b              LDY VARTAB+1
b603 85 2c              STA ARYTAB
b605 84 2d              STY ARYTAB+1
b607 85 2e              STA STREND
b609 84 2f              STY STREND+1
b60b 20 b7 b7 RVP_10    JSR Basic_RESTORE

              ; *************************
b60e            Flush_BASIC_Stack ; $b60e
              ; *************************

b60e a2 16              LDX #TEMPST         ; clear string descriptor stack
b610 86 13              STX TEMPPT
b612 68                 PLA
b613 a8                 TAY
b614 68                 PLA
b615 a2 fa              LDX #$fa            ; reset stackpointer
b617 9a                 TXS
b618 48                 PHA
b619 98                 TYA
b61a 48                 PHA
b61b a9 00              LDA #0
b61d 85 3b              STA OLDTXT+1
b61f 85 0a              STA SUBFLG
b621 60       FBS_Ret   RTS ;Size   20 [Flush_BASIC_Stack]

              ; ************************
b622            Reset_BASIC_Exec_Pointer
              ; ************************

b622 18                 CLC                 ; TXTPTR = TXTTAB - 1
b623 a5 28              LDA TXTTAB
b625 69 ff              ADC #$ff
b627 85 77              STA TXTPTR
b629 a5 29              LDA TXTTAB+1
b62b 69 ff              ADC #$ff
b62d 85 78              STA TXTPTR+1
b62f 60       RBEP_Ret  RTS ;Size   14 [Reset_BASIC_Exec_Pointer]

              ; **********
b630            Basic_LIST
              ; **********

b630 90 06              BCC LIST_10         ; C=0 : number after LIST
b632 f0 04              BEQ LIST_10         ; Z=1 : end of statement
b634 c9 ab              CMP #$ab            ; '-' token
b636 d0 f7              BNE RBEP_Ret        ; -> RTS
b638 20 f6 b8 LIST_10   JSR Scan_Linenumber ; starting line or 0 for non numeric
b63b 20 a3 b5           JSR Find_BASIC_Line ; setup TMPPTC
b63e 20 76 00           JSR CHRGOT          ; last character read
b641 f0 0c              BEQ LIST_15         ; no end line
b643 c9 ab              CMP #$ab            ; '-' token
b645 d0 e8              BNE RBEP_Ret        ; -> RTS
b647 20 70 00           JSR CHRGET
b64a 20 f6 b8           JSR Scan_Linenumber ; read end line
b64d d0 e0              BNE RBEP_Ret        ; more chars after end line -> RTS
b64f 68       LIST_15   PLA                 ; remove return address
b650 68                 PLA
b651 a5 11              LDA LINNUM
b653 05 12              ORA LINNUM+1
b655 d0 02              BNE LIST_20         ; end line != 0 ?
b657 c6 12              DEC LINNUM+1        ; end line  = $ff00 = 65280

              ; loop for line listing

b659 a0 01    LIST_20   LDY #1

              ; check for EOP and STOP

b65b b1 5c              LDA (TMPPTC),Y      ; link address high
b65d f0 27              BEQ LIST_50         ; -> end of program
b65f 20 e1 ff           JSR STOP            ; check STOP key
b662 20 df ba           JSR Print_CR        ; start listing with newline

              ; get line #

b665 c8                 INY                 ; Y=2
b666 b1 5c              LDA (TMPPTC),Y      ; line # lo
b668 aa                 TAX
b669 c8                 INY                 ; Y=3
b66a b1 5c              LDA (TMPPTC),Y      ; line # hi

              ; check for last line to list

b66c c5 12              CMP LINNUM+1        ; compare with end line hi
b66e d0 04              BNE LIST_25         ; not equal
b670 e4 11              CPX LINNUM          ; compare with end line lo
b672 f0 02              BEQ LIST_30         ; match -> print it
b674 b0 10    LIST_25   BCS LIST_50         ; line # > end line


              ; loop for printing characters

b676 20 89 b6 LIST_30   JSR List_Line

              ; follow link

b679 a8       LIST_60   TAY                 ; Y=0
b67a b1 5c              LDA (TMPPTC),Y      ; link low
b67c aa                 TAX
b67d c8                 INY
b67e b1 5c              LDA (TMPPTC),Y      ; link high
b680 86 5c              STX TMPPTC          ; TMPPTC = link
b682 85 5d              STA TMPPTC+1
b684 d0 d3              BNE LIST_20         ; continue with next line

              ; next line if not EOP

b686 4c ff b3 LIST_50   JMP Basic_Ready     ; LIST finished

b689                    .SIZE ;   89 [Basic_LIST]

              ; *********
b689            List_Line
              ; *********

b689 20 83 cf           JSR Print_Integer_XA; print line #
b68c a9 20              LDA #' '            ; print blank after line #
b68e a0 03              LDY #3              ; before basic text

b690 20 46 bb LiLi_08   JSR Print_Char
b693 c9 22              CMP #QUOTE
b695 d0 0c              BNE LiLi_20

              ; print quoted string

b697 c8       LiLi_10   INY
b698 b1 5c              LDA (TMPPTC),Y
b69a f0 3e              BEQ LiLi_Ret
b69c 20 46 bb           JSR Print_Char      ; print it
b69f c9 22              CMP #QUOTE
b6a1 d0 f4              BNE LiLi_10

              ; get next char

b6a3 c8       LiLi_20   INY                 ; Y++
b6a4 b1 5c              LDA (TMPPTC),Y      ; next character
b6a6 f0 32              BEQ LiLi_Ret
b6a8 10 e6              BPL LiLi_08         ; continue printing if not a token
b6aa c9 ff              CMP #$ff            ; is it the special char PI ?
b6ac f0 e2              BEQ LiLi_08         ; yes, print it

              ; print keyword from token

b6ae aa                 TAX
b6af 98                 TYA
b6b0 48                 PHA                 ; save Y
b6b1 a0 b0              LDY #>[Basic_Keyword_Table-1]
b6b3 84 20              STY INDEXA+1
b6b5 a0 b1              LDY #<[Basic_Keyword_Table-1]
b6b7 84 1f              STY INDEXA
b6b9 a0 00              LDY #0
b6bb ca       LiLi_30   DEX                 ; token--
b6bc 10 0c              BPL LiLi_60         ; count down finished
b6be e6 1f    LiLi_40   INC INDEXA          ; increment address to keyword table
b6c0 d0 02              BNE LiLi_50
b6c2 e6 20              INC INDEXA+1
b6c4 b1 1f    LiLi_50   LDA (INDEXA),Y      ; load next keyword char
b6c6 10 f6              BPL LiLi_40         ; -> inside keyword
b6c8 30 f1              BMI LiLi_30         ; -> end of keyword
b6ca c8       LiLi_60   INY
b6cb b1 1f              LDA (INDEXA),Y      ; next char from keyword table
b6cd 48                 PHA
b6ce 29 7f              AND #$7f
b6d0 20 46 bb           JSR Print_Char      ; print it
b6d3 68                 PLA
b6d4 10 f4              BPL LiLi_60
b6d6 68                 PLA
b6d7 a8                 TAY
b6d8 d0 c9              BNE LiLi_20
b6da 60       LiLi_Ret  RTS ;Size   82 [List_Line]

b6db 00 00 00           .FILL $b6de-* (0) ; 3 bytes

              ; *****************
b6de            Basic_FOR ; $b6de
              ; *****************

b6de a9 80              LDA #$80
b6e0 85 0a              STA SUBFLG          ; Inhibit integer index
b6e2 20 30 b9           JSR Basic_LET       ; define index variable
b6e5 20 22 b3           JSR Find_Active_FOR
b6e8 d0 05              BNE FOR_10          ; branch if none
b6ea 8a                 TXA
b6eb 69 0f              ADC #15             ; add 16 (C=1 from Find_Active_FOR)
b6ed aa                 TAX
b6ee 9a                 TXS
b6ef 68       FOR_10    PLA                 ; remove return address
b6f0 68                 PLA                 ; now there is space for 18 bytes
b6f1 20 93 b3           JSR Check_Stack_Avail
b6f4 20 91 b8           JSR Next_Statement  ; search start of loop body
b6f7 18                 CLC
b6f8 98                 TYA                 ; Y = position of delimiter (0 or ':')
b6f9 65 77              ADC TXTPTR          ; loop body low
b6fb 48                 PHA
b6fc a5 78              LDA TXTPTR+1        ; loop body high
b6fe 69 00              ADC #0
b700 48                 PHA
b701 a5 37              LDA CURLIN+1        ; line # high for body
b703 48                 PHA
b704 a5 36              LDA CURLIN          ; line # low  for body
b706 48                 PHA
b707 a9 a4              LDA #$a4            ; TO token
b709 20 f7 be           JSR Need_A
b70c 20 84 bd           JSR Eval_Numeric    ; read end value
b70f a5 63              LDA FAC1SI
b711 09 7f              ORA #$7f
b713 25 5f              AND FAC1M1
b715 85 5f              STA FAC1M1
b717 18                 CLC                 ; push without sign
b718 20 2e be           JSR Push_FAC1       ; push TO value
b71b a9 f2              LDA #<REAL_1
b71d a0 ca              LDY #>REAL_1
b71f 20 d8 cc           JSR Load_FAC1_AY    ; default 1.0 for STEP value
b722 20 76 00           JSR CHRGOT
b725 c9 a9              CMP #$a9            ; STEP token
b727 d0 06              BNE FOR_30
b729 20 70 00           JSR CHRGET
b72c 20 84 bd           JSR Eval_Numeric
b72f 20 61 cd FOR_30    JSR Get_FAC1_Sign
b732 85 63              STA FAC1SI
b734 38                 SEC                 ; push with sign
b735 20 2e be           JSR Push_FAC1       ; push STEP value
b738 a5 47              LDA FORPNT+1
b73a 48                 PHA
b73b a5 46              LDA FORPNT
b73d 48                 PHA
b73e a9 81              LDA #$81
b740 48                 PHA
b741 d0 07              BNE Execute         ; always

b743 00 00 00           .FILL $b74a-* (0) ; 7 bytes

              ; ***************
b74a            Execute ; $b74a
              ; ***************

b74a 20 43 f3           JSR Kernal_STOP
b74d a4 78              LDY TXTPTR+1
b74f c0 02              CPY #2
b751 f0 06              BEQ Exec_10
b753 a5 77              LDA TXTPTR
b755 85 3a              STA OLDTXT          ; save pointer if not direct
b757 84 3b              STY OLDTXT+1
b759 a0 00    Exec_10   LDY #0
b75b b1 77              LDA (TXTPTR),Y
b75d d0 46              BNE Inpr_40         ; branch if not at line end
b75f a0 02              LDY #2
b761 b1 77              LDA (TXTPTR),Y      ; link high
b763 18                 CLC                 ; C=0 : normal end
b764 f0 7c              BEQ END_40          ; end of program -> READY.
b766 c8                 INY                 ; Y = 3
b767 b1 77              LDA (TXTPTR),Y      ; new line # to CURLIN
b769 85 36              STA CURLIN
b76b c8                 INY
b76c b1 77              LDA (TXTPTR),Y
b76e 85 37              STA CURLIN+1
b770 98                 TYA
b771 65 77              ADC TXTPTR          ; TXTPTR = next statement
b773 85 77              STA TXTPTR
b775 90 05              BCC Start_Program
b777 e6 78              INC TXTPTR+1

b779 ea                 NOP
b77a ea                 NOP
b77b ea                 NOP

              ; *********************
b77c            Start_Program ; $b77c
              ; *********************

b77c 20 0f bf           JSR Any_Except_Pi   ; Pi must not start a statement
b77f 20 85 b7           JSR Interpret
b782 4c 4a b7           JMP Execute

              ; *****************
b785            Interpret ; $b785
              ; *****************

              ; Input:  A = first character of new statement
              ;         Flags set from GETCHR

b785 f0 3e              BEQ REST_Ret        ; branch on empty statement
b787 e9 80    Inpr_10   SBC #$80            ; token -> number
b789 90 17              BCC Inpr_30         ; branch to LET if not token
b78b c9 23              CMP #$23            ; $80-$a2 may start a statement
b78d 90 06              BCC Inpr_20         ; use jump table
b78f c9 4b              CMP #$4b            ; $a3-$cb are functions or operators
b791 90 16              BCC Inpr_50
b793 e9 28              SBC #$28            ; BASIC-4 token
b795 0a       Inpr_20   ASL A
b796 a8                 TAY
b797 b9 01 b0           LDA Basic_Statement_Table+1,Y
b79a 48                 PHA
b79b b9 00 b0           LDA Basic_Statement_Table,Y
b79e 48                 PHA
b79f 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
b7a2 4c 30 b9 Inpr_30   JMP Basic_LET       ; start with variable name
b7a5 c9 3a    Inpr_40   CMP #':'
b7a7 f0 d3              BEQ Start_Program
b7a9 4c 00 bf Inpr_50   JMP Syntax_Error

              ; ****************
b7ac            Basic_GO ; $b7ac
              ; ****************

b7ac 20 76 00           JSR CHRGOT          ; execute GO TO command
b7af a9 a4              LDA #$a4            ; TO token
b7b1 20 f7 be           JSR Need_A
b7b4 4c 30 b8           JMP Basic_GOTO

              ; *********************
b7b7            Basic_RESTORE ; $b7b7
              ; *********************

b7b7 38                 SEC                 ; DATPTR = TXTTAB - 1
b7b8 a5 28              LDA TXTTAB
b7ba e9 01              SBC #1
b7bc a4 29              LDY TXTTAB+1
b7be b0 01              BCS REST_10
b7c0 88                 DEY
b7c1 85 3e    REST_10   STA DATPTR
b7c3 84 3f              STY DATPTR+1
b7c5 60       REST_Ret  RTS ;Size   15 [Basic_RESTORE]

              ; ******************
b7c6            Basic_STOP ; $b7c6
              ; ******************

b7c6 b0 01              BCS END_10          ; C=1 : BREAK

              ; ****************
b7c8            Basic_END ; b7c8
              ; ****************

b7c8 18                 CLC                 ; C=0 : READY
b7c9 d0 3c    END_10    BNE CONT_Ret
b7cb a5 77              LDA TXTPTR
b7cd a4 78              LDY TXTPTR+1
b7cf a6 37              LDX CURLIN+1
b7d1 e8                 INX                 ; CURLIN+1 = $ff : undefined
b7d2 f0 0c              BEQ END_30
b7d4 85 3a              STA OLDTXT
b7d6 84 3b              STY OLDTXT+1
b7d8 a5 36    END_20    LDA CURLIN
b7da a4 37              LDY CURLIN+1
b7dc 85 38              STA OLDLIN
b7de 84 39              STY OLDLIN+1
b7e0 68       END_30    PLA
b7e1 68                 PLA
b7e2 a9 1b    END_40    LDA #<Msg_BREAK     ; $b31b
b7e4 a0 b3              LDY #>Msg_BREAK
b7e6 90 03              BCC END_50
b7e8 4c f4 b3           JMP Berr_40
b7eb 4c ff b3 END_50    JMP Basic_Ready

              ; ******************
b7ee            Basic_CONT ; $b7ee
              ; ******************

b7ee d0 17              BNE CONT_Ret
b7f0 a2 db              LDX #$db
b7f2 a4 3b              LDY OLDTXT+1
b7f4 d0 03              BNE CONT_10
b7f6 4c cf b3           JMP Basic_Error
b7f9 a5 3a    CONT_10   LDA OLDTXT
b7fb 85 77              STA TXTPTR
b7fd 84 78              STY TXTPTR+1
b7ff a5 38              LDA OLDLIN
b801 a4 39              LDY OLDLIN+1
b803 85 36              STA CURLIN
b805 84 37              STY CURLIN+1
b807 60       CONT_Ret  RTS ;Size   26 [Basic_CONT]

              ; *****************
b808            Basic_RUN ; $b808
              ; *****************

b808 d0 03              BNE RUN_20          ; branch onheck_Stack_Avail
b80a 4c e9 b5 RUN_10    JMP Reset_BASIC_Execution
b80d 20 f0 b5 RUN_20    JSR Reset_Variable_Pointer
b810 4c 25 b8           JMP GOSUB_10

              ; *******************
b813            Basic_GOSUB ; $b813
              ; *******************

b813 20 93 b3           JSR Check_Stack_Avail
b816 a5 78              LDA TXTPTR+1
b818 48                 PHA
b819 a5 77              LDA TXTPTR
b81b 48                 PHA
b81c a5 37              LDA CURLIN+1
b81e 48                 PHA
b81f a5 36              LDA CURLIN
b821 48                 PHA
b822 a9 8d              LDA #$8d            ; GOSUB token marker
b824 48                 PHA
b825 20 76 00 GOSUB_10  JSR CHRGOT
b828 20 30 b8           JSR Basic_GOTO
b82b 4c 4a b7           JMP Execute

b82e 00 00              .FILL $b830-* (0) ; 2 bytes

              ; ******************
b830            Basic_GOTO ; $b830
              ; ******************

b830 20 f6 b8           JSR Scan_Linenumber ; read LINNUM
b833 20 94 b8           JSR End_Of_Line     ; skip to end of line
b836 a5 37              LDA CURLIN+1
b838 c5 12              CMP LINNUM+1        ; CURLIN >= LINNUM ?
b83a b0 0b              BCS GOTO_10         ; search from start
b83c 98                 TYA                 ; EOL index
b83d 38                 SEC
b83e 65 77              ADC TXTPTR          ; (A/X) = TXTPTR + length + 1 (carry)
b840 a6 78              LDX TXTPTR+1
b842 90 07              BCC GOTO_20
b844 e8                 INX
b845 b0 04              BCS GOTO_20         ; start search from current link
b847 a5 28    GOTO_10   LDA TXTTAB
b849 a6 29              LDX TXTTAB+1
b84b 20 a7 b5 GOTO_20   JSR Find_BASIC_Line_AX
b84e 90 1e              BCC RET_10          ; undefined statement
b850 a5 5c              LDA TMPPTC
b852 e9 01              SBC #1
b854 85 77              STA TXTPTR          ; TXTPTR = TMPPTC - 1
b856 a5 5d              LDA TMPPTC+1
b858 e9 00              SBC #0
b85a 85 78              STA TXTPTR+1
b85c 60       GOTO_Ret  RTS ;Size   45 [Basic_GOTO]

              ; ********************
b85d            Basic_RETURN ; $b85d
              ; ********************

b85d d0 fd              BNE GOTO_Ret        ; no raguments allowed
b85f a9 ff              LDA #$ff
b861 85 47              STA FORPNT+1        ; invalidate FORPNT
b863 20 22 b3           JSR Find_Active_FOR ; remove open loops
b866 9a                 TXS
b867 c9 8d              CMP #$8d            ; GOSUB token marker ?
b869 f0 0b              BEQ RET_30           ; yes -> perform return
b86b a2 16              LDX #[Msg_GOSUB - Msg_Start] ; $16
b86d 2c                 .BYTE $2c           ; skip next instruction
b86e a2 5a    RET_10    LDX #[Msg_UNDEF - Msg_Start] ; $5a
b870 4c cf b3           JMP Basic_Error
b873 4c 00 bf RET_20    JMP Syntax_Error
b876 68       RET_30    PLA                 ; marker
b877 68                 PLA
b878 85 36              STA CURLIN
b87a 68                 PLA
b87b 85 37              STA CURLIN+1
b87d 68                 PLA
b87e 85 77              STA TXTPTR
b880 68                 PLA
b881 85 78              STA TXTPTR+1

              ; ******************
b883            Basic_DATA ; $b883
              ; ******************

b883 20 91 b8           JSR Next_Statement

              ; **********************************
b886            Add_Y_To_Execution_Pointer ; $b886
              ; **********************************

b886 98                 TYA
b887 18                 CLC
b888 65 77              ADC TXTPTR
b88a 85 77              STA TXTPTR
b88c 90 02              BCC AYEP_Ret
b88e e6 78              INC TXTPTR+1
b890 60       AYEP_Ret  RTS ;Size   11 [Add_Y_To_Execution_Pointer]

              ; **********************
b891            Next_Statement ; $b891
              ; **********************

b891 a2 3a              LDX #':'
b893 2c                 .BYTE $2c

              ; *******************
b894            End_Of_Line ; $b894
              ; *******************

b894 a2 00              LDX #0
b896 86 03              STX CHARAC
b898 a0 00              LDY #0
b89a 84 04              STY ENDCHR
b89c a5 04    NeSt_10   LDA ENDCHR
b89e a6 03              LDX CHARAC
b8a0 85 03              STA CHARAC
b8a2 86 04              STX ENDCHR
b8a4 b1 77    NeSt_20   LDA (TXTPTR),Y
b8a6 f0 e8              BEQ AYEP_Ret
b8a8 c5 04              CMP ENDCHR
b8aa f0 e4              BEQ AYEP_Ret
b8ac c8                 INY
b8ad c9 22              CMP #QUOTE          ; Gaensefuesschen oben
b8af d0 f3              BNE NeSt_20
b8b1 f0 e9              BEQ NeSt_10

              ; ****************
b8b3            Basic_IF ; $b8b3
              ; ****************

b8b3 20 98 bd           JSR Eval_Expression
b8b6 20 76 00           JSR CHRGOT
b8b9 c9 89              CMP #$89            ; GOTO token
b8bb f0 05              BEQ IF_10
b8bd a9 a7              LDA #$a7            ; THEN token
b8bf 20 f7 be           JSR Need_A
b8c2 a5 5e    IF_10     LDA FAC1EX          ; IF clause != 0 (true) or 0 (false)
b8c4 d0 05              BNE REM_10          ; branch if true

              ; *****************
b8c6            Basic_REM ; $b8c6
              ; *****************

b8c6 20 94 b8           JSR End_Of_Line
b8c9 f0 bb              BEQ Add_Y_To_Execution_Pointer
b8cb 20 76 00 REM_10    JSR CHRGOT
b8ce b0 03              BCS REM_20
b8d0 4c 30 b8           JMP Basic_GOTO
b8d3 4c 85 b7 REM_20    JMP Interpret

              ; ********
b8d6            Basic_ON
              ; ********

b8d6 20 d4 c8           JSR Get_Byte_Value
b8d9 48                 PHA
b8da c9 8d              CMP #$8d            ; GOSUB token
b8dc f0 04              BEQ ON_20
b8de c9 89    ON_10     CMP #$89            ; GOTO token
b8e0 d0 91              BNE RET_20          ; -> syntax error
b8e2 c6 62    ON_20     DEC FAC1M4          ; ON - counter
b8e4 d0 04              BNE ON_30
b8e6 68                 PLA
b8e7 4c 87 b7           JMP Inpr_10
b8ea 20 70 00 ON_30     JSR CHRGET
b8ed 20 f6 b8           JSR Scan_Linenumber
b8f0 c9 2c              CMP #','
b8f2 f0 ee              BEQ ON_20
b8f4 68                 PLA
b8f5 60                 RTS ;Size   32 [Basic_ON]

              ; ***************
b8f6            Scan_Linenumber
              ; ***************

              ; Input:  A = 1st. character
              ; Output: LINNUM decoded (0-63999) valid range
              ;         LINNUM = 0 if (A) is not numeric (C=1)

b8f6 a2 00              LDX #0
b8f8 86 11              STX LINNUM
b8fa 86 12              STX LINNUM+1
b8fc b0 0e              BCS ScLi_Ret        ; return if (A) is not numeric
b8fe a6 12    ScLi_10   LDX LINNUM+1
b900 e0 19              CPX #25             ; $fa00 after multiplication
b902 b0 da              BCS ON_10           ; value >= 64000 -> Syntax Error
b904 20 0d b9           JSR Dec_Char
b907 20 70 00           JSR CHRGET
b90a 90 f2              BCC ScLi_10         ; next char if numeric
b90c 60       ScLi_Ret  RTS ;Size   23 [Scan_Linenumber]

              ; ********
b90d            Dec_Char
              ; ********

              ; Input:  LINNUM = 16 bit unsigned integer
              ;         A      = new value to add
              ;         X      = LINNUM+1
              ; Output: LINNUM = LINNUM * 10 + (A)

              ; check on integer overflow is done on calling routine

b90d 29 0f              AND #15             ; char -> bin
b90f 48                 PHA                 ; save value to add
b910 a5 11              LDA LINNUM
b912 0a                 ASL A               ; * 2
b913 26 12              ROL LINNUM+1
b915 0a                 ASL A               ; * 4
b916 26 12              ROL LINNUM+1
b918 65 11              ADC LINNUM          ; * 5
b91a 85 11              STA LINNUM
b91c 8a                 TXA                 ; old high byte of LINNUM
b91d 65 12              ADC LINNUM+1
b91f 85 12              STA LINNUM+1
b921 06 11              ASL LINNUM          ; * 10
b923 26 12              ROL LINNUM+1
b925 68                 PLA                 ; value to add
b926 65 11              ADC LINNUM
b928 85 11              STA LINNUM
b92a 90 02              BCC LIM_10
b92c e6 12              INC LINNUM+1
b92e 60       LIM_10    RTS ;Size   34 [Dec_Char]

b92f 00                 .FILL $b930-* (0) ; 1 bytes

              ; *****************
b930            Basic_LET ; $b930
              ; *****************

b930 20 2b c1           JSR Parse_Name
b933 85 46              STA FORPNT
b935 84 47              STY FORPNT+1
b937 a9 b2              LDA #$b2            ; '=' token
b939 20 f7 be           JSR Need_A
b93c a5 08              LDA INTFLG          ; save attributes
b93e 48                 PHA                 ; of variable
b93f a5 07              LDA VALTYP
b941 48                 PHA
b942 20 98 bd           JSR Eval_Expression ; FAC1 = value or pointer
b945 68                 PLA                 ; VALTYP
b946 2a                 ROL A               ; C=1 : string   C=0 : numeric
b947 20 8a bd           JSR Check_Var_Type
b94a d0 18              BNE LET_20          ; branch for string
b94c 68                 PLA                 ; INTFLG

              ; ***********************
b94d            Assign_Numeric_variable
              ; ***********************

b94d 10 12              BPL LET_10          ; branch for real
b94f 20 51 cd           JSR Round_FAC1
b952 20 ea c2           JSR Real_To_Integer
b955 a0 00              LDY #0
b957 a5 61              LDA FAC1M3
b959 91 46              STA (FORPNT),Y      ; integer high byte
b95b c8                 INY
b95c a5 62              LDA FAC1M4
b95e 91 46              STA (FORPNT),Y      ; integer low  byte
b960 60                 RTS ;Size   20 [Assign_Numeric_variable]
b961 4c 06 cd LET_10    JMP FAC1_To_FORPNT

b964 68       LET_20    PLA                 ; INTFLG

              ; ******************************
b965            Assign_String_Variable ; $b965
              ; ******************************

b965 a4 47              LDY FORPNT+1
b967 c0 d0              CPY #>[Float_0_5 + 2]; void string descriptor for TI$
b969 d0 4f              BNE Assign_Normal_String
b96b 20 b8 c7           JSR Free_String_FAC1
b96e c9 06              CMP #6              ; setting TI$ requires 6 digits
b970 d0 40              BNE ATSD_10
b972 a0 00              LDY #0              ; FAC1 = 0.0
b974 84 5e              STY FAC1EX
b976 84 63              STY FAC1SI
b978 84 6e    CLOCK_10  STY TMPPTD
b97a 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b97d 20 18 cc           JSR Multiply_FAC1_BY_10
b980 e6 6e              INC TMPPTD
b982 a4 6e              LDY TMPPTD
b984 20 ab b9           JSR Add_TI_String_Digit_To_FAC1
b987 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
b98a aa                 TAX                 ; number is zero ?
b98b f0 05              BEQ CLOCK_20
b98d e8                 INX
b98e 8a                 TXA                 ; FAC2 *= 2
b98f 20 23 cc           JSR Add_And_Double  ; FAC1 = (FAC1 + FAC2) * 2
b992 a4 6e    CLOCK_20  LDY TMPPTD
b994 c8                 INY
b995 c0 06              CPY #6
b997 d0 df              BNE CLOCK_10
b999 20 18 cc           JSR Multiply_FAC1_BY_10
b99c 20 d1 cd           JSR FAC1_LSR
b99f a2 02              LDX #2
b9a1 78                 SEI                 ; set jiffy clock
b9a2 b5 60    CLOCK_30  LDA FAC1M2,X
b9a4 95 8d              STA JIFFY_CLOCK,X
b9a6 ca                 DEX
b9a7 10 f9              BPL CLOCK_30
b9a9 58                 CLI
b9aa 60                 RTS ;Size   70 [Assign_String_Variable]

              ; ***************************
b9ab            Add_TI_String_Digit_To_FAC1
              ; ***************************

b9ab b1 1f              LDA (INDEXA),Y
b9ad 20 7d 00           JSR ISNUM
b9b0 90 03              BCC ATSD_20
b9b2 4c 73 c3 ATSD_10   JMP Jump_To_Illegal_Quantity
b9b5 e9 2f    ATSD_20   SBC #$2f            ; '0'-1
b9b7 4c b4 ce           JMP Add_A_To_FAC1

              ; ****************************
b9ba            Assign_Normal_String ; $b9ba
              ; ****************************

              ; 100 a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to static string in code
              ;     STRPTR = $0409
              ;     -> ANS_60 branch

              ; a$ = "hello"
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 5, pointer to dynamic string
              ;     STRPTR = $7ffa
              ;     -> ANS_60 branch

              ; a$ = ds$ (disk status)
              ;     FAC1M3 = pointer to descriptor in string descriptor stack ($0016)
              ;     $0016  = descriptor length = 12, pointer to dynamic string
              ;     STRPTR = $7fd6
              ;     -> ANS_50 branch

b9ba a0 01              LDY #1
b9bc b1 61              LDA (FAC1M3),Y
b9be 85 6c              STA STRPTR          ; STRPTR = string pointer
b9c0 c8                 INY
b9c1 b1 61              LDA (FAC1M3),Y
b9c3 85 6d              STA STRPTR+1        ; STRPTR = DS$ (Disk Status) ?
b9c5 c9 04              CMP #4
b9c7 90 23              BCC ANS_50          ; string is in system area (DS$)

b9c9 a5 6d    ANS_10    LDA STRPTR+1        ; STRPTR < FRETOP ?
b9cb c5 31    ANS_20    CMP FRETOP+1
b9cd 90 16              BCC ANS_40          ; branch if static
b9cf d0 06              BNE ANS_30          ; branch if higher
b9d1 a5 6c              LDA STRPTR
b9d3 c5 30              CMP FRETOP
b9d5 90 0e              BCC ANS_40          ; branch if static
b9d7 a4 62    ANS_30    LDY FAC1M4
b9d9 c4 2b              CPY VARTAB+1
b9db 90 08              BCC ANS_40          ; branch if not variable
b9dd d0 0d              BNE ANS_50
b9df a5 61              LDA FAC1M3
b9e1 c5 2a              CMP VARTAB
b9e3 b0 07              BCS ANS_50
b9e5 a5 61    ANS_40    LDA FAC1M3          ; static string
b9e7 a4 62              LDY FAC1M4
b9e9 4c 05 ba           JMP ANS_60

              ; assign string from string variable

b9ec a0 00    ANS_50    LDY #0              ; allocate & copy string
b9ee b1 61              LDA (FAC1M3),Y      ; length
b9f0 20 a6 c5           JSR Allocate_String_A
b9f3 a6 6c              LDX STRPTR
b9f5 a4 6d              LDY STRPTR+1
b9f7 20 9a c7           JSR Store_String_XY
b9fa a5 61              LDA FAC1M3
b9fc a4 62              LDY FAC1M4
b9fe 20 11 c8           JSR Pop_Descriptor_Stack
ba01 a9 5e              LDA #<FAC1EX        ; allocated descriptor
ba03 a0 00              LDY #>FAC1EX

              ; assign static string and create back reference

ba05 85 4d    ANS_60    STA DESCPT
ba07 84 4e              STY DESCPT+1
ba09 85 1f              STA INDEXA
ba0b 84 20              STY INDEXA+1
ba0d 20 11 c8           JSR Pop_Descriptor_Stack
ba10 20 3d ba           JSR Back_Reference_Position   ; from INDEXA
ba13 90 09              BCC ANS_70          ; -> no back reference
ba15 a5 47              LDA FORPNT+1
ba17 91 4f              STA (INDEXC),Y      ; Y = 1
ba19 88                 DEY
ba1a a5 46              LDA FORPNT          ; store back reference
ba1c 91 4f              STA (INDEXC),Y      ; for garbage collection

              ; invalidate old string

ba1e a5 46    ANS_70    LDA FORPNT
ba20 85 1f              STA INDEXA
ba22 a5 47              LDA FORPNT+1
ba24 85 20              STA INDEXA+1
ba26 20 3d ba           JSR Back_Reference_Position
ba29 90 08              BCC ANS_80
ba2b a9 ff              LDA #$ff            ; mark old string as obsolete
ba2d 91 4f              STA (INDEXC),Y      ; Y = 1
ba2f 88                 DEY                 ; Y = 0
ba30 8a                 TXA                 ; length
ba31 91 4f              STA (INDEXC),Y

              ; copy new value to variable

ba33 a0 02    ANS_80    LDY #2
ba35 b1 4d    ANS_90    LDA (DESCPT),Y
ba37 91 46              STA (FORPNT),Y
ba39 88                 DEY
ba3a 10 f9              BPL ANS_90
ba3c 60                 RTS ;Size  131 [Assign_Normal_String]

              ; ***********************
ba3d            Back_Reference_Position
              ; ***********************

              ; Input:  INDEXA = pointer to string descriptor
              ; Output: INDEXA = points to start of string
              ;         INDEXC = points to the end of string + 1
              ;         X = length of string
              ;         Y = 1
              ;         C = 1 : INDEXA and INDEXC set
              ;         C = 0 : nothing changed

ba3d a0 00              LDY #0
ba3f b1 1f              LDA (INDEXA),Y      ; A = length
ba41 48                 PHA                 ; push length
ba42 f0 28              BEQ BRP_no
ba44 c8                 INY
ba45 b1 1f              LDA (INDEXA),Y
ba47 aa                 TAX                 ; X = pointer low
ba48 c8                 INY
ba49 b1 1f              LDA (INDEXA),Y      ; A = pointer high
ba4b 30 1f              BMI BRP_no          ; return if not in lower RAM
ba4d c5 31              CMP FRETOP+1
ba4f 90 1b              BCC BRP_no          ; return if not dynamic string
ba51 d0 04              BNE BRP_10
ba53 e4 30              CPX FRETOP
ba55 90 15              BCC BRP_no          ; return if not dynamic string
ba57 86 1f    BRP_10    STX INDEXA          ; INDEXA = string pointer
ba59 85 20              STA INDEXA+1
ba5b 68                 PLA                 ; length
ba5c aa                 TAX                 ; return length in X
ba5d 18                 CLC
ba5e 65 1f              ADC INDEXA
ba60 85 4f              STA INDEXC
ba62 a5 20              LDA INDEXA+1
ba64 69 00              ADC #0
ba66 85 50              STA INDEXC+1        ; INDEXC = INDEXA + length
ba68 a0 01              LDY #1              ; expected by callers
ba6a 38                 SEC
ba6b 60                 RTS ;Size   47 [Back_Reference_Position]
ba6c 68       BRP_no    PLA
ba6d 18                 CLC
ba6e 60                 RTS ;Size   50 [Back_Reference_Position]

              ; This subroutines converts a real value to a 16 bit integer.
              ; There is no sign or range check in this routine. So it may
              ; be used for signed integers (-32768 to 32767) or unsigned
              ; integers (0 to 65535).

              ; ********
ba6f            FAC1_INT
              ; ********

ba6f 20 d1 cd           JSR FAC1_LSR
ba72 24 63              BIT FAC1SI
ba74 10 0b              BPL FACI_Ret
ba76 38                 SEC
ba77 98                 TYA
ba78 e5 62              SBC FAC1M4
ba7a 85 62              STA FAC1M4
ba7c 98                 TYA
ba7d e5 61              SBC FAC1M3
ba7f 85 61              STA FAC1M3
ba81 60       FACI_Ret  RTS ;Size   19 [FAC1_INT]

ba82 00 00 00           .FILL $ba88-* (0) ; 6 bytes

              ; ********************
ba88            Basic_PRINTN ; $ba88
              ; ********************

ba88 20 8e ba           JSR Basic_CMD
ba8b 4c b2 bb           JMP Set_Default_Channels

              ; *********
ba8e            Basic_CMD
              ; *********

ba8e 20 d4 c8           JSR Get_Byte_Value  ; X = value
ba91 f0 05              BEQ CMD_10          ; -> no more parameter
ba93 a9 2c              LDA #','
ba95 20 f7 be           JSR Need_A
ba98 08       CMD_10    PHP
ba99 20 c9 ff           JSR CHKOUT          ; set channel
ba9c 86 10              STX IOPMPT          ; mark output redirected
ba9e 28                 PLP
ba9f 4c a8 ba           JMP Basic_PRINT     ; do the printing


baa2 20 20 bb PRINT_10  JSR Print_String_From_Descriptor
baa5 20 76 00 PRINT_20  JSR CHRGOT

              ; ***********
baa8            Basic_PRINT
              ; ***********

baa8 f0 35              BEQ Print_CR
baaa f0 38    PRINT_30  BEQ PRINT_Ret
baac c9 a3              CMP #$a3            ; TAB(   token
baae f0 4d              BEQ Tab_Spc
bab0 c9 a6              CMP #$a6            ; SPC(   token
bab2 18                 CLC
bab3 f0 48              BEQ Tab_Spc
bab5 c9 2c              CMP #','
bab7 f0 37              BEQ Comma_Tab
bab9 c9 3b              CMP #';'
babb f0 5a              BEQ TaSp_50
babd 20 98 bd           JSR Eval_Expression
bac0 24 07              BIT VALTYP
bac2 30 de              BMI PRINT_10
bac4 20 93 cf           JSR Format_FAC1
bac7 20 b0 c5           JSR Create_String_Descriptor
baca 20 20 bb           JSR Print_String_From_Descriptor
bacd 20 3a bb           JSR Cursor_Right_Or_Space
bad0 d0 d3              BNE PRINT_20           ; always

              ; *************
bad2            Terminate_BUF
              ; *************

bad2 a9 00              LDA #0
bad4 9d 00 02           STA BUF,X
bad7 a2 ff              LDX #<[BUF-1]
bad9 a0 01              LDY #>[BUF-1]
badb a5 10              LDA IOPMPT
badd d0 05              BNE PRINT_Ret

              ; ****************
badf            Print_CR ; $badf
              ; ****************

badf a9 0d              LDA #CR
bae1 4c d2 ff           JMP CHROUT
bae4 60       PRINT_Ret RTS ;Size    6 [Print_CR]

bae5 00 00 00           .FILL $baf0-* (0) ; 11 bytes

              ; *****************
baf0            Comma_Tab ; $baf0
              ; *****************

baf0 a5 c6              LDA CursorCol
baf2 38                 SEC
baf3 e9 0a    CoTa_10   SBC #10
baf5 b0 fc              BCS CoTa_10
baf7 49 ff              EOR #$ff
baf9 69 01              ADC #1
bafb d0 10              BNE TaSp_10           ; always

              ; *******
bafd            Tab_Spc
              ; *******

bafd 08                 PHP                 ; C=1 TAB, C=0 SPC
bafe 20 d1 c8           JSR Get_Next_Byte_Value
bb01 c9 29              CMP #')'
bb03 d0 59              BNE SynErr
bb05 28                 PLP
bb06 90 06              BCC TaSp_20         ; SPC -> use X
bb08 8a                 TXA
bb09 e5 c6              SBC CursorCol       ; TAB -> use X - Col
bb0b 90 0a              BCC TaSp_50         ; branch if TAB < Col
bb0d aa       TaSp_10   TAX
bb0e e8       TaSp_20   INX
bb0f d0 03              BNE TaSp_40         ; always
bb11 20 3a bb TaSp_30   JSR Cursor_Right_Or_Space
bb14 ca       TaSp_40   DEX
bb15 d0 fa              BNE TaSp_30
bb17 20 70 00 TaSp_50   JSR CHRGET
bb1a 4c aa ba           JMP PRINT_30

              ; ********************
bb1d            Print_String ; $bb1d
              ; ********************

bb1d 20 b0 c5           JSR Create_String_Descriptor

              ; ************************************
bb20            Print_String_From_Descriptor ; $bb20
              ; ************************************

bb20 20 b8 c7           JSR Free_String_FAC1
bb23 aa                 TAX
bb24 f0 0b              BEQ PSFD_Ret        ; zero length ?
bb26 a0 00              LDY #0
bb28 b1 1f    PSFD_10   LDA (INDEXA),Y
bb2a 20 d2 ff           JSR CHROUT
bb2d c8                 INY
bb2e ca                 DEX
bb2f d0 f7              BNE PSFD_10
bb31 60       PSFD_Ret  RTS ;Size   18 [Print_String_From_Descriptor]

bb32 00 00 00           .FILL $bb3a-* (0) ; 8 bytes

              ; *****************************
bb3a            Cursor_Right_Or_Space ; $bb3a
              ; *****************************

bb3a a5 10              LDA IOPMPT
bb3c f0 03              BEQ CROS_10
bb3e a9 20              LDA #' '
bb40 2c                 .BYTE $2c
bb41 a9 1d    CROS_10   LDA #RIGHT
bb43 2c                 .BYTE $2c

              ; *******************
bb44            Print_Question_Mark
              ; *******************

bb44 a9 3f              LDA #'?'

              ; **********
bb46            Print_Char
              ; **********

bb46 4c d2 ff           JMP CHROUT

bb49 00 00 00           .FILL $bb4c-* (0) ; 3 bytes

              ; *****************
bb4c            Bad_Input ; $bb4c
              ; *****************

bb4c a5 0b              LDA INPFLG
bb4e f0 11              BEQ BaIn_30
bb50 30 04              BMI BaIn_10
bb52 a0 ff              LDY #$ff            ; invalidate CURLIN
bb54 d0 04              BNE BaIn_20
bb56 a5 3c    BaIn_10   LDA DATLIN
bb58 a4 3d              LDY DATLIN+1
bb5a 85 36    BaIn_20   STA CURLIN
bb5c 84 37              STY CURLIN+1
bb5e 4c 00 bf SynErr    JMP Syntax_Error
bb61 a5 10    BaIn_30   LDA IOPMPT
bb63 f0 05              BEQ BaIn_40
bb65 a2 bf              LDX #[Msg_DATA - Msg_Start] ; $bf
bb67 4c cf b3           JMP Basic_Error
bb6a a9 07    BaIn_40   LDA #<Msg_Redo_From_Start
bb6c a0 bd              LDY #>Msg_Redo_From_Start
bb6e 20 1d bb           JSR Print_String
bb71 a5 3a              LDA OLDTXT
bb73 a4 3b              LDY OLDTXT+1
bb75 85 77              STA TXTPTR
bb77 84 78              STY TXTPTR+1
bb79 60                 RTS ;Size   46 [Bad_Input]

              ; *****************
bb7a            Basic_GET ; $bb7a
              ; *****************

bb7a 20 cf c4           JSR Assert_Non_Direct
bb7d c9 23              CMP #'#'
bb7f d0 0e              BNE GET_10
bb81 20 70 00           JSR CHRGET
bb84 20 d4 c8           JSR Get_Byte_Value  ; channel #
bb87 20 f5 be           JSR Need_Comma
bb8a 20 c6 ff           JSR CHKIN
bb8d 86 10              STX IOPMPT
bb8f a2 01    GET_10    LDX #<[BUF+1]
bb91 a0 02              LDY #>[BUF+1]
bb93 a9 00              LDA #0
bb95 8d 01 02           STA BUF+1
bb98 a9 40              LDA #$40            ; no prompt
bb9a 20 0b bc           JSR Read_Get
bb9d a6 10              LDX IOPMPT
bb9f d0 13              BNE SDC_10
bba1 60                 RTS ;Size   40 [Basic_GET]

bba2 00 00              .FILL $bba4-* (0) ; 2 bytes

              ; ********************
bba4            Basic_INPUTN ; $bba4
              ; ********************

bba4 20 d4 c8           JSR Get_Byte_Value
bba7 20 f5 be           JSR Need_Comma
bbaa 20 c6 ff           JSR CHKIN
bbad 86 10              STX IOPMPT
bbaf 20 cd bb           JSR Input_String

              ; ********************
bbb2            Set_Default_Channels
              ; ********************

bbb2 a5 10              LDA IOPMPT
bbb4 20 cc ff SDC_10    JSR CLRCHN
bbb7 a2 00              LDX #0
bbb9 86 10              STX IOPMPT
bbbb 60                 RTS ;Size   10 [Set_Default_Channels]

bbbc 00 00              .FILL $bbbe-* (0) ; 2 bytes

              ; *******************
bbbe            Basic_INPUT ; $bbbe
              ; *******************

bbbe c9 22              CMP #QUOTE
bbc0 d0 0b              BNE Input_String
bbc2 20 b5 be           JSR Make_String_Descriptor_From_Code
bbc5 a9 3b              LDA #';'
bbc7 20 f7 be           JSR Need_A          ; prompt delimiter
bbca 20 20 bb           JSR Print_String_From_Descriptor

              ; ************
bbcd            Input_String
              ; ************

bbcd 20 cf c4           JSR Assert_Non_Direct
bbd0 a9 2c              LDA #','
bbd2 8d ff 01           STA BUF-1
bbd5 20 f5 bb InSt_10   JSR Prompt_And_Input
bbd8 a5 10              LDA IOPMPT
bbda f0 0c              BEQ InSt_20
bbdc a5 96              LDA STATUS
bbde 29 03              AND #3              ; check time out bits
bbe0 f0 06              BEQ InSt_20
bbe2 20 b2 bb           JSR Set_Default_Channels
bbe5 4c 83 b8           JMP Basic_DATA
bbe8 ad 00 02 InSt_20   LDA BUF
bbeb d0 1c              BNE READ_10
bbed 4c 19 bf           JMP Input_String_Patch
bbf0 18       InSt_30   CLC
bbf1 4c d8 b7           JMP END_20

bbf4 00                 .FILL $bbf5-* (0) ; 1 bytes

              ; ************************
bbf5            Prompt_And_Input ; $bbf5
              ; ************************

bbf5 a5 10              LDA IOPMPT
bbf7 d0 06              BNE PAI_10
bbf9 20 44 bb           JSR Print_Question_Mark
bbfc 20 3a bb           JSR Cursor_Right_Or_Space
bbff 4c e2 b4 PAI_10    JMP Read_String

              ; ******************
bc02            Basic_READ ; $bc02
              ; ******************

bc02 a6 3e              LDX DATPTR
bc04 a4 3f              LDY DATPTR+1
bc06 a9 98              LDA #$98            ; flag for READ
bc08 2c                 .BYTE $2c
bc09 a9 00    READ_10    LDA #0

              ; ********
bc0b            Read_Get
              ; ********

bc0b 85 0b              STA INPFLG
bc0d 86 40              STX INPPTR
bc0f 84 41              STY INPPTR+1

              ; loop reading variables

bc11 20 2b c1 READ_15   JSR Parse_Name      ; address of variable
bc14 85 46              STA FORPNT
bc16 84 47              STY FORPNT+1        ; FORPNT = variable pointer
bc18 a5 77              LDA TXTPTR
bc1a a4 78              LDY TXTPTR+1        ; save TXTPTR
bc1c 85 48              STA YSAVE
bc1e 84 49              STY YSAVE+1
bc20 a6 40              LDX INPPTR          ; TXTPTR = INPPTR
bc22 a4 41              LDY INPPTR+1
bc24 86 77              STX TXTPTR
bc26 84 78              STY TXTPTR+1
bc28 20 76 00           JSR CHRGOT
bc2b d0 20              BNE READ_35
bc2d 24 0b              BIT INPFLG
bc2f 50 0c              BVC READ_20         ; bit 6 set: GETIN
bc31 20 e4 ff           JSR GETIN
bc34 8d 00 02           STA BUF
bc37 a2 ff              LDX #<[BUF-1]
bc39 a0 01              LDY #>[BUF-1]
bc3b d0 0c              BNE READ_30         ; always

bc3d 30 75    READ_20   BMI READ_75         ; bit 7 set: READ
bc3f a5 10              LDA IOPMPT          ; else: INPUT
bc41 d0 03              BNE READ_25
bc43 20 44 bb           JSR Print_Question_Mark
bc46 20 f5 bb READ_25   JSR Prompt_And_Input
bc49 86 77    READ_30   STX TXTPTR
bc4b 84 78              STY TXTPTR+1

              ; loop reading character

bc4d 20 70 00 READ_35   JSR CHRGET
bc50 24 07              BIT VALTYP
bc52 10 31              BPL READ_60         ; -> numeric
bc54 24 0b              BIT INPFLG
bc56 50 09              BVC READ_40         ; -> not GET
bc58 e8                 INX
bc59 86 77              STX TXTPTR          ; GET A$
bc5b a9 00              LDA #0
bc5d 85 03              STA CHARAC
bc5f f0 0c              BEQ READ_45         ; always

              ; input or read string

bc61 85 03    READ_40   STA CHARAC
bc63 c9 22              CMP #QUOTE
bc65 f0 07              BEQ READ_50
bc67 a9 3a              LDA #':'
bc69 85 03              STA CHARAC
bc6b a9 2c              LDA #','
bc6d 18       READ_45   CLC
bc6e 85 04    READ_50   STA ENDCHR
bc70 a5 77              LDA TXTPTR
bc72 a4 78              LDY TXTPTR+1
bc74 69 00              ADC #0
bc76 90 01              BCC READ_55
bc78 c8                 INY
bc79 20 b6 c5 READ_55   JSR Create_String_Descriptor_AY
bc7c 20 18 c9           JSR Restore_Execution_Pointer
bc7f 20 65 b9           JSR Assign_String_Variable
bc82 4c 8d bc           JMP READ_65

              ; input or read number

bc85 20 29 ce READ_60   JSR Read_Real_To_FAC1
bc88 a5 08              LDA INTFLG
bc8a 20 4d b9           JSR Assign_Numeric_variable

              ; more to read ?

bc8d 20 76 00 READ_65   JSR CHRGOT
bc90 f0 07              BEQ READ_70         ; -> nothing left
bc92 c9 2c              CMP #','
bc94 f0 03              BEQ READ_70         ; comma or error
bc96 4c 4c bb           JMP Bad_Input

bc99 a5 77    READ_70   LDA TXTPTR
bc9b a4 78              LDY TXTPTR+1
bc9d 85 40              STA INPPTR          ; advance input pointer
bc9f 84 41              STY INPPTR+1
bca1 a5 48              LDA YSAVE
bca3 a4 49              LDY YSAVE+1
bca5 85 77              STA TXTPTR          ; restore text pointer
bca7 84 78              STY TXTPTR+1
bca9 20 76 00           JSR CHRGOT
bcac f0 2c              BEQ READ_85         ; -> goto loop end
bcae 20 f5 be           JSR Need_Comma
bcb1 4c 11 bc           JMP READ_15         ; -> next item

              ; READ from DATA statements

bcb4 20 91 b8 READ_75   JSR Next_Statement
bcb7 c8                 INY
bcb8 aa                 TAX
bcb9 d0 12              BNE READ_80
bcbb a2 2a              LDX #$2a
bcbd c8                 INY
bcbe b1 77              LDA (TXTPTR),Y
bcc0 f0 6b              BEQ NEXT_30
bcc2 c8                 INY
bcc3 b1 77              LDA (TXTPTR),Y
bcc5 85 3c              STA DATLIN
bcc7 c8                 INY
bcc8 b1 77              LDA (TXTPTR),Y
bcca c8                 INY
bccb 85 3d              STA DATLIN+1
bccd b1 77    READ_80   LDA (TXTPTR),Y
bccf aa                 TAX
bcd0 20 86 b8           JSR Add_Y_To_Execution_Pointer
bcd3 e0 83              CPX #$83            ; DATA token
bcd5 d0 dd              BNE READ_75
bcd7 4c 4d bc           JMP READ_35
              ;

bcda a5 40    READ_85   LDA INPPTR
bcdc a4 41              LDY INPPTR+1
bcde a6 0b              LDX INPFLG
bce0 10 03              BPL READ_90
bce2 4c c1 b7           JMP REST_10
bce5 a0 00    READ_90   LDY #0
bce7 b1 40              LDA (INPPTR),Y
bce9 f0 0b              BEQ READ_Ret
bceb a5 10              LDA IOPMPT
bced d0 07              BNE READ_Ret
bcef a9 f7              LDA #<Msg_Extra_Ignored
bcf1 a0 bc              LDY #>Msg_Extra_Ignored
bcf3 4c 1d bb           JMP Print_String
bcf6 60       READ_Ret  RTS ;Size  236 [Read_Get]

bcf7                    .FILL $bcf7-* (0) ; 0 bytes

              ; *************************
bcf7            Msg_Extra_Ignored ; $bcf7
              ; *************************

bcf7 3f 45 58           .BYTE "?EXTRA IGNORED\r",0

              ; *******************
bd07            Msg_Redo_From_Start
              ; *******************

bd07 3f 52 45           .BYTE "?REDO FROM START\r",0

              ; ******************
bd19            Basic_NEXT ; $bd19
              ; ******************

bd19 d0 04              BNE NEXT_10         ; branch if index after NEXT
bd1b a0 00              LDY #0
bd1d f0 05              BEQ NEXT_20
bd1f 20 2b c1 NEXT_10   JSR Parse_Name      ; address of index
bd22 85 46              STA FORPNT
bd24 84 47    NEXT_20   STY FORPNT+1        ; address or zero if no index
bd26 20 22 b3           JSR Find_Active_FOR
bd29 f0 04              BEQ NEXT_40         ; branch if found
bd2b a2 00              LDX #0              ; index for next without for error
bd2d f0 66    NEXT_30   BEQ CVT_40           ; -> basic error
bd2f 9a       NEXT_40   TXS                 ; set stack pointer
bd30 8a                 TXA                 ; A = SP
bd31 18                 CLC
bd32 69 04              ADC #4              ; A = SP + 4 (STEP value)
bd34 48                 PHA
bd35 69 06              ADC #6
bd37 85 21              STA INDEXB          ; address TO   value low
bd39 68                 PLA                 ; address STEP value low
bd3a a0 01              LDY #>[STACK]       ; address STEP value high
bd3c 20 d8 cc           JSR Load_FAC1_AY
bd3f ba                 TSX                 ; X = SP    <-- DELETE obsolete
bd40 bd 09 01           LDA STACK+9,X       ; sign of STEP
bd43 85 63              STA FAC1SI
bd45 a5 46              LDA FORPNT
bd47 a4 47              LDY FORPNT+1           ; address of index
bd49 20 9d c9           JSR Add_Var_AY_To_FAC1 ; FAC1 = index + STEP
bd4c 20 06 cd           JSR FAC1_To_FORPNT
bd4f a0 01              LDY #>[STACK]          ; address TO value high
bd51 20 93 cd           JSR Compare_FAC1_INDEXB_Y
bd54 ba                 TSX
bd55 38                 SEC
bd56 fd 09 01           SBC STACK+9,X          ; STEP sign
bd59 f0 17              BEQ NEXT_60            ; loop finished
bd5b bd 0f 01           LDA STACK+15,X
bd5e 85 36              STA CURLIN
bd60 bd 10 01           LDA STACK+16,X
bd63 85 37              STA CURLIN+1           ; line # of loop body
bd65 bd 12 01           LDA STACK+18,X
bd68 85 77              STA TXTPTR
bd6a bd 11 01           LDA STACK+17,X
bd6d 85 78              STA TXTPTR+1           ; address of loop body
bd6f 4c 4a b7 NEXT_50   JMP Execute            ; next iteration
bd72 8a       NEXT_60   TXA
bd73 69 11              ADC #$11               ; carry was set
bd75 aa                 TAX
bd76 9a                 TXS                    ; remove loop structure from stack
bd77 20 76 00           JSR CHRGOT             ; character after NEXT
bd7a c9 2c              CMP #','               ; comma ?
bd7c d0 f1              BNE NEXT_50            ; continue with follow up statement
bd7e 20 70 00           JSR CHRGET             ; get another index
bd81 20 1f bd           JSR NEXT_10            ; perform NEXT again

              ; ********************
bd84            Eval_Numeric ; $bd84
              ; ********************

bd84 20 98 bd           JSR Eval_Expression

              ; ******************
bd87            Is_Numeric ; $bd87
              ; ******************

bd87 18                 CLC
bd88 24                 .BYTE $24

              ; *****************
bd89            Is_String ; $bd89
              ; *****************

bd89 38                 SEC

              ; **********************
bd8a            Check_Var_Type ; $bd8a
              ; **********************

bd8a 24 07              BIT VALTYP          ; $FF = string   $00 = numeric
bd8c 30 03              BMI CVT_20          ; branch on string type
bd8e b0 03              BCS CVT_30          ; string assert -> TYPE MISMATCH
bd90 60       CVT_10    RTS ;Size    7 [Check_Var_Type]
bd91 b0 fd    CVT_20    BCS CVT_10          ; looking for string, found string
bd93 a2 a3    CVT_30    LDX #[Msg_TYPE - Msg_Start] ; $a3
bd95 4c cf b3 CVT_40    JMP Basic_Error     ; want string got numeric or vice versa

              ; called from $b947 Basic_LET
              ;             $c06b Op_COMPARE

              ; ***********************
bd98            Eval_Expression ; $bd98
              ; ***********************

bd98 a6 77              LDX TXTPTR          ; TXTPTR--
bd9a d0 02              BNE EvEx_05
bd9c c6 78              DEC TXTPTR+1
bd9e c6 77    EvEx_05   DEC TXTPTR
bda0 a2 00              LDX #0
bda2 24                 .BYTE $24           ; skip next PHA
bda3 48       EvEx_10   PHA                 ; push ACCSYM (comparison op + type)
bda4 8a                 TXA
bda5 48                 PHA                 ; push X
bda6 20 93 b3           JSR Check_Stack_Avail
bda9 20 81 be           JSR Evaluate
bdac a9 00              LDA #0
bdae 85 4a              STA ACCSYM          ;clear type comparison flag
bdb0 20 76 00 EvEx_15   JSR CHRGOT
bdb3 38       EvEx_20   SEC
bdb4 e9 b1              SBC #$b1            ; > token ( start of comparison ops)
bdb6 90 16              BCC EvEx_25         ; -> binary operators
bdb8 c9 03              CMP #3              ; ( 3 comparison operators > = < )
bdba b0 12              BCS EvEx_25         ; -> function
bdbc c9 02              CMP #2              ; '>'  A = 1
bdbe 69 01              ADC #1              ; '='  A = 2
bdc0 45 4a              EOR ACCSYM          ; '<'  A = 4
bdc2 c5 4a              CMP ACCSYM
bdc4 90 61              BCC SynErr1           ; -> syntax error
bdc6 85 4a              STA ACCSYM          ; rememer comparison operator
bdc8 20 70 00           JSR CHRGET
bdcb 4c b3 bd           JMP EvEx_20         ; loop (maybe <= or >= or <>)

bdce a6 4a    EvEx_25   LDX ACCSYM
bdd0 d0 2c              BNE EvEx_50
bdd2 b0 7e              BCS Pop_FAC2        ; function ( SGN INT ... MID$ )
bdd4 69 07              ADC #7
bdd6 90 7a              BCC Pop_FAC2        ; ->
bdd8 65 07              ADC VALTYP          ; C=1               0 1 2 3 4  5  6
bdda d0 03              BNE EvEx_30         ; binary operator ( + - * / ^ AND OR )
bddc 4c 4f c7           JMP Concatenate     ; '+' with strings

bddf 69 ff    EvEx_30   ADC #$ff
bde1 85 1f              STA INDEXA          ; op code (0-9 for '+' to '<')
bde3 0a                 ASL A               ; op code * 2
bde4 65 1f              ADC INDEXA          ; op code * 3
bde6 a8                 TAY                 ; Y = index
bde7 68       EvEx_35   PLA                 ; precedence
bde8 d9 94 b0           CMP Basic_Operator_Table,Y
bdeb b0 6a              BCS PoFA_20         ; previous op has higher precedence
bded 20 87 bd           JSR Is_Numeric
bdf0 48       EvEx_40   PHA                 ; save precedence
bdf1 20 17 be EvEx_45   JSR Use_Operator
bdf4 68                 PLA                 ; restore precedence
bdf5 a4 48              LDY YSAVE           ; restore index
bdf7 10 17              BPL EvEx_60
bdf9 aa                 TAX
bdfa f0 59              BEQ PoFA_10
bdfc d0 62              BNE PoFA_40         ; always

bdfe 46 07    EvEx_50   LSR VALTYP          ; clear type
be00 8a                 TXA                 ; comparison operator
be01 2a                 ROL A               ; com op * 2
be02 a6 77              LDX TXTPTR          ; TXTPTR--
be04 d0 02              BNE EvEx_55
be06 c6 78              DEC TXTPTR+1
be08 c6 77    EvEx_55   DEC TXTPTR
be0a a0 1b              LDY #27             ; index to Op_COMPARE
be0c 85 4a              STA ACCSYM          ; com op * 2
be0e d0 d7              BNE EvEx_35
be10 d9 94 b0 EvEx_60   CMP Basic_Operator_Table,Y
be13 b0 4b              BCS PoFA_40         ; higher precedence
be15 90 d9              BCC EvEx_40         ; lower  precedence

              ; ************
be17            Use_Operator
              ; ************

be17 b9 96 b0           LDA Basic_Operator_Table+2,Y
be1a 48                 PHA
be1b b9 95 b0           LDA Basic_Operator_Table+1,Y
be1e 48                 PHA
be1f 20 2a be           JSR Push_Operand
be22 a5 4a              LDA ACCSYM
be24 4c a3 bd           JMP EvEx_10

be27 4c 00 bf SynErr1   JMP Syntax_Error

              ; ************
be2a            Push_Operand
              ; ************

be2a be 94 b0           LDX Basic_Operator_Table,Y ; operator priority
be2d 38                 SEC                        ; push with sign

              ; *********
be2e            Push_FAC1
              ; *********

be2e 68                 PLA                 ; return address-1 low
be2f 85 1f              STA INDEXA
be31 68                 PLA                 ; return address-1 high
be32 85 20              STA INDEXA+1
be34 90 03              BCC PuFA_10
be36 a5 63              LDA FAC1SI          ; sign of operand
be38 48                 PHA
be39 20 51 cd PuFA_10   JSR Round_FAC1
be3c a5 62              LDA FAC1M4
be3e 48                 PHA
be3f a5 61              LDA FAC1M3
be41 48                 PHA
be42 a5 60              LDA FAC1M2
be44 48                 PHA
be45 a5 5f              LDA FAC1M1
be47 48                 PHA
be48 a5 5e              LDA FAC1EX
be4a 48                 PHA
be4b a5 20              LDA INDEXA+1
be4d 48                 PHA
be4e a5 1f              LDA INDEXA
be50 48                 PHA
be51 60                 RTS ;Size   36 [Push_FAC1]

              ; ********
be52            Pop_FAC2
              ; ********

be52 a0 ff              LDY #$ff
be54 68                 PLA
be55 f0 23    PoFA_10   BEQ PoFA_50
be57 c9 64    PoFA_20   CMP #$64            ; precedence of Op_COMPARE
be59 f0 03              BEQ PoFA_30         ; strings may be comapred too
be5b 20 87 bd           JSR Is_Numeric
be5e 84 48    PoFA_30   STY YSAVE
be60 68       PoFA_40   PLA
be61 4a                 LSR A               ; C = VALTYPE
be62 85 0c              STA TANSGN          ; comparison operator
be64 68                 PLA
be65 85 66              STA FAC2EX
be67 68                 PLA
be68 85 67              STA FAC2M1
be6a 68                 PLA
be6b 85 68              STA FAC2M2
be6d 68                 PLA
be6e 85 69              STA FAC2M3
be70 68                 PLA
be71 85 6a              STA FAC2M4
be73 68                 PLA
be74 85 6b              STA FAC2SI
be76 45 63              EOR FAC1SI
be78 85 6c              STA STRPTR
be7a a5 5e    PoFA_50   LDA FAC1EX
be7c 60                 RTS                 ; -> use operator ;Size   43 [Pop_FAC2]

be7d 00 00 00           .FILL $be81-* (0) ; 4 bytes

              ; ****************
be81            Evaluate ; $be81
              ; ****************

be81 a9 00              LDA #0
be83 85 07              STA VALTYP          ; default numeric
be85 20 70 00 Eva_10    JSR CHRGET
be88 b0 03              BCS Eva_30          ; branch if not numeric
be8a 4c 29 ce Eva_20    JMP Read_Real_To_FAC1
be8d 20 b6 c1 Eva_30    JSR Is_Alpha
be90 b0 7a              BCS JMP_Get_Var     ; branch to Get_Var
be92 c9 ff              CMP #$ff            ; Pi token
be94 d0 0f              BNE Eva_40
be96 a9 a0              LDA #<Float_PI
be98 a0 be              LDY #>Float_PI
be9a 20 d8 cc           JSR Load_FAC1_AY
be9d 4c 70 00           JMP CHRGET
bea0 82 49 0f Float_PI  .REAL $82490fdaa1   ; 3.14159265254
bea5 c9 2e    Eva_40    CMP # '.'
bea7 f0 e1              BEQ Eva_20          ; real number starting with '.'
bea9 c9 ab              CMP #$ab            ; '-' token sign
beab f0 58              BEQ Negate
bead c9 aa              CMP #$aa            ; '+' token sign
beaf f0 d4              BEQ Eva_10
beb1 c9 22              CMP #QUOTE
beb3 d0 0f              BNE Eva_50

              ; ********************************
beb5            Make_String_Descriptor_From_Code
              ; ********************************

beb5 a5 77              LDA TXTPTR
beb7 a4 78              LDY TXTPTR+1
beb9 69 00              ADC #0              ; INC (A,Y)
bebb 90 01              BCC MSDF_10
bebd c8                 INY
bebe 20 b0 c5 MSDF_10   JSR Create_String_Descriptor
bec1 4c 18 c9           JMP Restore_Execution_Pointer

bec4 c9 a8    Eva_50    CMP #$a8            ; NOT token
bec6 d0 13              BNE Eva_60
bec8 a0 18              LDY #24             ; NOT index to Op Table
beca d0 3b              BNE Nega_10         ; always

              ; ******
becc            Op_NOT
              ; ******

              ; convert real in FAC1 to integer
              ; do a bitwise EOR (negate)
              ; convert result back to FAC1
              ; 0 : false, <> 0 : true

becc 20 ea c2           JSR Real_To_Integer
becf a5 62              LDA FAC1M4
bed1 49 ff              EOR #$ff
bed3 a8                 TAY
bed4 a5 61              LDA FAC1M3
bed6 49 ff              EOR #$ff
bed8 4c bc c4           JMP AY_To_Real

bedb c9 a5    Eva_60    CMP #$a5            ; FN(  token
bedd d0 03              BNE Eva_70
bedf 4c 1d c5           JMP Eval_FNX
bee2 c9 b4    Eva_70    CMP #$b4            ; SGN( token
bee4 90 03              BCC Eval_In_Parenthesis
bee6 4c 47 c0           JMP Function_Call

              ; *******************
bee9            Eval_In_Parenthesis
              ; *******************

bee9 20 f2 be           JSR Need_Left_Parenthesis
beec 20 98 bd           JSR Eval_Expression

              ; **********************
beef            Need_Right_Parenthesis
              ; **********************

beef a9 29              LDA #')'
bef1 2c                 .BYTE $2c

              ; *********************
bef2            Need_Left_Parenthesis
              ; *********************

bef2 a9 28              LDA #'('
bef4 2c                 .BYTE $2c

              ; **********
bef5            Need_Comma
              ; **********

bef5 a9 2c              LDA #','

              ; ******
bef7            Need_A
              ; ******

bef7 a0 00              LDY #0
bef9 d1 77              CMP (TXTPTR),Y
befb d0 03              BNE Syntax_Error
befd 4c 70 00           JMP CHRGET

              ; ************
bf00            Syntax_Error
              ; ************

bf00 a2 10              LDX #[Msg_SYNTA - Msg_Start]
bf02 4c cf b3           JMP Basic_Error

              ; ******
bf05            Negate
              ; ******

bf05 a0 15              LDY #21             ; index to Op_NEGATE
bf07 68       Nega_10   PLA
bf08 68                 PLA
bf09 4c f1 bd           JMP EvEx_45

              ; ***********
bf0c            JMP_Get_Var
              ; ***********

bf0c 4c 8c bf           JMP Get_Var

              ; *************
bf0f            Any_Except_Pi
              ; *************

bf0f 20 70 00           JSR CHRGET
bf12 c9 ff              CMP #$ff            ; Pi token
bf14 f0 ea              BEQ Syntax_Error
bf16 4c 76 00           JMP CHRGOT

              ; ******************
bf19            Input_String_Patch
              ; ******************

bf19 a5 10              LDA IOPMPT
bf1b d0 03              BNE InSt_40
bf1d 4c f0 bb           JMP InSt_30
bf20 a5 96    InSt_40   LDA STATUS
bf22 29 40              AND #$40            ; check EOF
bf24 d0 03              BNE InSt_50
bf26 4c d5 bb           JMP InSt_10
bf29 4c 09 bc InSt_50   JMP READ_10

              ; ************************
bf2c            Extended_Statement_Table
              ; ************************

bf2c b0 de              .WORD Renumber         - 1
bf2e 41 d4              .WORD Monitor          - 1
bf30 7c e4              .WORD Delete           - 1
bf32 77 ed              .WORD Find_Text        - 1
bf34 59 fe              .WORD Replace          - 1
bf36 e5 f3              .WORD Merge            - 1
bf38 00 e7              .WORD OLD              - 1

              ; **********************
bf3a            Extended_Keyword_Table
              ; **********************

bf3a 52 45 4e           .BYTE "RENUMBER"^
bf42 4d 4f 4e           .BYTE "MONITOR"^
bf49 44 45 4c           .BYTE "DELETE"^
bf4f 46 49 4e           .BYTE "FIND"^
bf53 52 45 50           .BYTE "REPLACE"^
bf5a 4d 45 52           .BYTE "MERGE"^
bf5f 4f 4c c4           .BYTE "OLD"^
bf62 00                 .BYTE 0

bf63 00 00 00           .FILL $bf8c-* (0) ; 41 bytes

              ; *******
bf8c            Get_Var
              ; *******

              ; Parse_Name checks, whether the caller is Get_Var
              ; It does not create a so far unknown variable in this case

              ; Output: FAC1 a) integer value converted to real
              ;              b) real value
              ;              c) address of string (FAC1M3)

bf8c 20 2b c1           JSR Parse_Name      ; call address checked in Create_Var !
bf8f 85 61              STA FAC1M3          ; A = VARPTR
bf91 84 62              STY FAC1M4          ; Y = VARPTR+1
bf93 a5 42              LDA VARNAM
bf95 a4 43              LDY VARNAM+1
bf97 a6 07              LDX VALTYP
bf99 f0 33              BEQ Get_Numeric_Value
bf9b a6 62              LDX FAC1M4          ; VARPTR+1
bf9d 10 2e              BPL GeVa_Ret        ; is assigned: no special variables
bf9f c9 54              CMP #'T'            ; TI$ - 1st. char
bfa1 d0 18              BNE GeVa_10
bfa3 c0 c9              CPY #'I'+$80        ; TI$ - 2nd. char
bfa5 d0 14              BNE GeVa_10
bfa7 20 03 c0           JSR Load_Jiffyclock
bfaa 84 5b              STY TMPVAR+1        ; TMPVAR+1 = 0
bfac 88                 DEY
bfad 84 6e              STY TMPPTD          ; TMPPTD = $ff
bfaf a0 06              LDY #6
bfb1 84 5a              STY TMPVAR          ; # of digits
bfb3 a0 24              LDY #$24            ; index to Decimal_Conversion_Table
bfb5 20 1a d0           JSR Format_Jiffyclock
bfb8 4c 98 c5           JMP STR_10           ; create string and descriptor

bfbb c9 44    GeVa_10   CMP #'D'            ; DS$ - 1st. char
bfbd d0 0e              BNE GeVa_Ret
bfbf c0 d3              CPY #'S'+$80        ; DS$ - 2nd. char
bfc1 d0 0a              BNE GeVa_Ret
bfc3 20 91 d9           JSR Kernal_Read_DS
bfc6 a9 ad              LDA #<DOS_Status
bfc8 a0 03              LDY #>DOS_Status
bfca 4c b0 c5           JMP Create_String_Descriptor
bfcd 60       GeVa_Ret  RTS ;Size   66 [Get_Var]

              ; *****************
bfce            Get_Numeric_Value
              ; *****************

bfce a6 08              LDX INTFLG
bfd0 10 0d              BPL Load_Float
bfd2 a0 00              LDY #0
bfd4 b1 61              LDA (FAC1M3),Y
bfd6 aa                 TAX
bfd7 c8                 INY
bfd8 b1 61              LDA (FAC1M3),Y
bfda a8                 TAY
bfdb 8a                 TXA
bfdc 4c bc c4           JMP AY_To_Real

              ; **********
bfdf            Load_Float
              ; **********

bfdf a6 62              LDX FAC1M4
bfe1 10 5d              BPL Load_Float_Var
bfe3 c9 54              CMP #'T'            ; TI - 1st. char
bfe5 d0 28              BNE Check_ST_Var
bfe7 c0 49              CPY #'I'            ; TI - 2nd. char
bfe9 d0 55              BNE Load_Float_Var
bfeb 20 03 c0           JSR Load_Jiffyclock
bfee 98                 TYA                 ; FROUND := $00  FAC1SI := $00
bfef a2 a0              LDX #$a0            ; FAC1EX := $a0
bff1 4c 85 cd           JMP CITR_10           ; normalize FAC1

bff4 00 00 00           .FILL $c003-* (0) ; 15 bytes

              ; ***********************
c003            Load_Jiffyclock ; $c003
              ; ***********************

c003 a9 8b              LDA #<[JIFFY_CLOCK-2] ; load mixture of random seed
c005 a0 00              LDY #>[JIFFY_CLOCK-2] ; and jiffy clock
c007 78                 SEI
c008 20 d8 cc           JSR Load_FAC1_AY      ; FAC1M2/3/4 = Jiffy Clock
c00b 58                 CLI
c00c 84 5f              STY FAC1M1            ; FAC1M1 = 0
c00e 60                 RTS ;Size   12 [Load_Jiffyclock]

              ; ************
c00f            Check_ST_Var
              ; ************

c00f c9 53              CMP #'S'
c011 d0 09              BNE Check_DS_Var
c013 c0 54              CPY #'T'
c015 d0 05              BNE Check_DS_Var
c017 a5 96              LDA STATUS
c019 4c 72 cd           JMP A_To_FAC1

              ; ************
c01c            Check_DS_Var
              ; ************

c01c c9 44              CMP #'D'
c01e d0 20              BNE Load_Float_Var
c020 c0 53              CPY #'S'
c022 d0 1c              BNE Load_Float_Var
c024 20 91 d9           JSR Kernal_Read_DS
c027 29 0f              AND #15
c029 0a                 ASL A
c02a 85 09              STA GARBFL
c02c 0a                 ASL A
c02d 0a                 ASL A
c02e 65 09              ADC GARBFL
c030 85 09              STA GARBFL
c032 ad ae 03           LDA DOS_Status+1
c035 29 0f              AND #15
c037 65 09              ADC GARBFL
c039 4c 72 cd           JMP A_To_FAC1

c03c 00 00 00           .FILL $c040-* (0) ; 4 bytes

              ; **********************
c040            Load_Float_Var ; $c040
              ; **********************

c040 a5 61              LDA FAC1M3
c042 a4 62              LDY FAC1M4
c044 4c d8 cc           JMP Load_FAC1_AY

              ; *************
c047            Function_Call
              ; *************

              ; called from Evaluate
              ; Input:  A = function token
              ;         token  range = $b4 SGN - $ca MID$
              ;         scaled range = $68 SGN - $92 MID$

c047 0a                 ASL A               ; A = token * 2
c048 48                 PHA                 ; save
c049 aa                 TAX                 ; X = token * 2
c04a 20 70 00           JSR CHRGET
c04d e0 8f              CPX #$8f            ; limit of single numeric argument
c04f 90 20              BCC FuCa_10         ; branch if not LEFT$, RIGHT$, MID$
c051 20 f2 be           JSR Need_Left_Parenthesis
c054 20 98 bd           JSR Eval_Expression
c057 20 f5 be           JSR Need_Comma
c05a 20 89 bd           JSR Is_String       ; 1st. arg must be string
c05d 68                 PLA                 ; scaled token
c05e aa                 TAX                 ; X = $90 LEFT$, $92 RIGHT$, $94 MID$
c05f a5 62              LDA FAC1M4
c061 48                 PHA
c062 a5 61              LDA FAC1M3          ; push pointer to 1st. argUment
c064 48                 PHA
c065 8a                 TXA
c066 48                 PHA                 ; save scaled token
c067 20 d4 c8           JSR Get_Byte_Value  ; get 2nd. argument (byte value)
c06a 68                 PLA
c06b a8                 TAY                 ; Y = scaled token
c06c 8a                 TXA
c06d 48                 PHA                 ; push 2nd. argument
c06e 4c 76 c0           JMP FuCa_20
c071 20 e9 be FuCa_10   JSR Eval_In_Parenthesis
c074 68                 PLA                 ; scaled token
c075 a8                 TAY                 ; Y = index
c076 b9 fe af FuCa_20   LDA Basic_Function_Table-$68,Y
c079 85 52              STA FUNJMP
c07b b9 ff af           LDA Basic_Function_Table-$67,Y
c07e 85 53              STA FUNJMP+1
c080 20 51 00           JSR JUMPER
c083 4c 87 bd           JMP Is_Numeric

              ; *****
c086            Op_OR
              ; *****

c086 38                 SEC
c087 24                 .BYTE $24

              ; ******
c088            Op_AND
              ; ******

c088 18                 CLC
c089 66 03              ROR CHARAC          ; bit7=1:OR bit7=0:AND
c08b 20 ea c2           JSR Real_To_Integer
c08e a5 61              LDA FAC1M3
c090 48                 PHA
c091 a5 62              LDA FAC1M4
c093 48                 PHA
c094 20 32 cd           JSR FAC2_To_FAC1
c097 20 ea c2           JSR Real_To_Integer
c09a 68                 PLA
c09b 24 03              BIT CHARAC
c09d 10 09              BPL ANDOR_10
c09f 05 62              ORA FAC1M4
c0a1 a8                 TAY
c0a2 68                 PLA
c0a3 05 61              ORA FAC1M3
c0a5 4c bc c4           JMP AY_To_Real
c0a8 25 62    ANDOR_10  AND FAC1M4
c0aa a8                 TAY
c0ab 68                 PLA
c0ac 25 61              AND FAC1M3
c0ae 4c bc c4           JMP AY_To_Real

              ; ************
              ; Float_M32768
              ; ************

              ;         .REAL $9080000000   ; -32768

c0b1 00 00 00           .FILL $c0b6-* (0) ; 5 bytes

              ; ******************
c0b6            Op_COMPARE ; $c0b6
              ; ******************

              ; Input:  C = VALTYPE
              ;         TANSGN = comparison mask
              ;         FAC1 = right operand
              ;         FAC2 = left  operand

c0b6 20 8a bd           JSR Check_Var_Type
c0b9 b0 13              BCS OpCO_10         ; -> compare strings
c0bb a5 6b              LDA FAC2SI          ; transfer sign to FAC2M1
c0bd 09 7f              ORA #$7f
c0bf 25 67              AND FAC2M1
c0c1 85 67              STA FAC2M1
c0c3 a9 66              LDA #<FAC2EX
c0c5 a0 00              LDY #>FAC2EX
c0c7 20 91 cd           JSR Compare_FAC1_AY ; -1: FAC1 > FAC2  +1: FAC1 < FAC2
c0ca aa                 TAX                 ; set flags
c0cb 4c 01 c1           JMP OpCO_40
c0ce a9 00    OpCO_10   LDA #0
c0d0 85 07              STA VALTYP          ; result = numeric (-1:true, 0:false)
c0d2 c6 4a              DEC ACCSYM          ; OBSOLETE
c0d4 20 b8 c7           JSR Free_String_FAC1
c0d7 85 5e              STA FAC1EX
c0d9 86 5f              STX FAC1M1          ; 1st. string
c0db 84 60              STY FAC1M2
c0dd a5 69              LDA FAC2M3
c0df a4 6a              LDY FAC2M4
c0e1 20 bc c7           JSR Free_String_AY
c0e4 86 69              STX FAC2M3          ; 2nd. string
c0e6 84 6a              STY FAC2M4
c0e8 aa                 TAX                 ; X = length2
c0e9 38                 SEC
c0ea e5 5e              SBC FAC1EX          ; length difference
c0ec f0 08              BEQ OpCO_20         ; -> equal length
c0ee a9 01              LDA #1
c0f0 90 04              BCC OpCO_20
c0f2 a6 5e              LDX FAC1EX          ; X = length1 (shorter one)
c0f4 a9 ff              LDA #-1
c0f6 85 63    OpCO_20   STA FAC1SI          ; store length1 <=> length2 (-1,0,1)
c0f8 a0 ff              LDY #-1
c0fa e8                 INX
c0fb c8       OpCO_30   INY
c0fc ca                 DEX
c0fd d0 07              BNE OpCO_50
c0ff a6 63              LDX FAC1SI          ; equal so far
c101 30 0f    OpCO_40   BMI OpCO_60         ; left > right
c103 18                 CLC
c104 90 0c              BCC OpCO_60
c106 b1 69    OpCO_50   LDA (FAC2M3),Y
c108 d1 5f              CMP (FAC1M1),Y
c10a f0 ef              BEQ OpCO_30
c10c a2 ff              LDX #-1
c10e b0 02              BCS OpCO_60
c110 a2 01              LDX #1
c112 e8       OpCO_60   INX                 ; C=1 : string2 >= string1
c113 8a                 TXA                 ; C=0 : string2 <  string1
c114 2a                 ROL A
c115 25 0c              AND TANSGN          ; ACCSYM comparison mask
c117 f0 02              BEQ OpCO_70         ; > 1   = 2   < 4
c119 a9 ff              LDA #-1             ; true
c11b 4c 72 cd OpCO_70   JMP A_To_FAC1


c11e 20 f5 be DIM_10    JSR Need_Comma

              ; *********
c121            Basic_DIM
              ; *********

c121 aa                 TAX
c122 20 30 c1           JSR Get_Array_Address
c125 20 76 00           JSR CHRGOT
c128 d0 f4              BNE DIM_10
c12a 60                 RTS ;Size   10 [Basic_DIM]

              ; **********
c12b            Parse_Name
              ; **********

c12b a2 00              LDX #0
c12d 20 76 00           JSR CHRGOT

              ; *****************
c130            Get_Array_Address
              ; *****************

c130 86 06              STX DIMFLG

              ; **************
c132            Get_FN_Address
              ; **************

c132 85 42              STA VARNAM
c134 20 76 00           JSR CHRGOT
c137 20 b6 c1           JSR Is_Alpha
c13a b0 03              BCS Get_Address
c13c 4c 00 bf GFA_Err   JMP Syntax_Error

              ; *******************
c13f            Get_Address ; $c13f
              ; *******************

c13f a2 00              LDX #0              ; set defaults
c141 86 07              STX VALTYP          ; numeric
c143 86 08              STX INTFLG          ; real
c145 20 70 00           JSR CHRGET          ; 2nd. char of name
c148 90 05              BCC GeAd_05         ; -> branch if numeric
c14a 20 b6 c1           JSR Is_Alpha
c14d 90 0b              BCC GeAd_15         ; -> branch if not alpha
c14f aa       GeAd_05   TAX                 ; X = 2nd. char of name
c150 20 70 00 GeAd_10   JSR CHRGET          ; skip all alphanumeric characters
c153 90 fb              BCC GeAd_10         ; after the 2nd. one
c155 20 b6 c1           JSR Is_Alpha
c158 b0 f6              BCS GeAd_10
c15a c9 24    GeAd_15   CMP #'$'            ; string ?
c15c d0 06              BNE GeAd_20
c15e a9 ff              LDA #$ff            ; set string flag
c160 85 07              STA VALTYP          ; $ff = string  $00 = numeric
c162 d0 10              BNE GeAd_25         ; branch always
c164 c9 25    GeAd_20   CMP #'%'            ; integer ?
c166 d0 13              BNE GeAd_30
c168 a5 0a              LDA SUBFLG          ; integer allowed ?
c16a d0 d0              BNE GFA_Err         ; -> not in this context
c16c a9 80              LDA #$80
c16e 85 08              STA INTFLG          ; integer flag
c170 05 42              ORA VARNAM
c172 85 42              STA VARNAM          ; mark variable as integer
c174 8a       GeAd_25   TXA                 ; A = 2nd. char
c175 09 80              ORA #$80            ; set string/integer bit
c177 aa                 TAX                 ; X = 2nd. char OR $80
c178 20 70 00           JSR CHRGET          ; next char after '$' or '%'
c17b 86 43    GeAd_30   STX VARNAM+1        ; store 2nd. char of name
c17d 38                 SEC
c17e 05 0a              ORA SUBFLG          ; Or with FOR, FN flag
c180 e9 28              SBC #'('            ; array ?
c182 d0 03              BNE GeAd_35         ; -> no
c184 4c fc c2           JMP Find_Array      ; read subscripts
c187 a0 00    GeAd_35   LDY #0
c189 84 0a              STY SUBFLG          ; clear integer disable flag
c18b a5 2a              LDA VARTAB
c18d a6 2b              LDX VARTAB+1        ; (A/X) = VARTAB
c18f 86 5d    GeAd_40   STX TMPPTC+1        ; find variable in (VARTAB..ARYTAB)
c191 85 5c    GeAd_45   STA TMPPTC          ; TMPPTC = (A/X)
c193 e4 2d              CPX ARYTAB+1
c195 d0 04              BNE GeAd_50
c197 c5 2c              CMP ARYTAB
c199 f0 25              BEQ Create_Var      ; (A/X) == ARYTAB -> not found
c19b a5 42    GeAd_50   LDA VARNAM
c19d d1 5c              CMP (TMPPTC),Y      ; compare 1st. char
c19f d0 0b              BNE GeAd_60
c1a1 a5 43              LDA VARNAM+1
c1a3 c8                 INY                 ; Y = 1
c1a4 d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c1a6 d0 03              BNE GeAd_55
c1a8 4c b4 c2           JMP CrVa_80           ; -> found
c1ab 88       GeAd_55   DEY                 ; Y = 0
c1ac 18       GeAd_60   CLC
c1ad a5 5c              LDA TMPPTC
c1af 69 07              ADC #7              ; TMPPTC += 7
c1b1 90 de              BCC GeAd_45
c1b3 e8                 INX
c1b4 d0 d9              BNE GeAd_40         ; branch always

              ; ********
c1b6            Is_Alpha
              ; ********

c1b6 c9 41              CMP #'A'
c1b8 90 05              BCC IsAl_Ret
c1ba e9 5b              SBC #'Z'+1
c1bc 38                 SEC
c1bd e9 a5              SBC #$a5            ; restore original content
c1bf 60       IsAl_Ret  RTS                 ; C=1 if (A..Z) ;Size   10 [Is_Alpha]

              ; ******************
c1c0            Create_Var ; $c1c0
              ; ******************

c1c0 68                 PLA
c1c1 48                 PHA                 ; return address low
c1c2 c9 8e              CMP #<[Get_Var+2]   ; $8e called from Get_Var ?
c1c4 d0 05              BNE CrVa_10
c1c6 a9 c9    CrVa_05   LDA #<[Float_0_5 + 2]; void descriptor (0,0,0)
c1c8 a0 d0              LDY #>[Float_0_5 + 2]; or value in ROM
c1ca 60                 RTS ;Size   11 [Create_Var]
c1cb a5 42    CrVa_10   LDA VARNAM
c1cd a4 43              LDY VARNAM+1
c1cf c9 54              CMP #'T'            ; check reserved names
c1d1 d0 0b              BNE CrVa_20
c1d3 c0 c9              CPY #'I'+$80        ; TI$ = "hhmmss"  sets jiffy clock
c1d5 f0 ef              BEQ CrVa_05         ; create void descriptor
c1d7 c0 49              CPY #'I'            ; TI  (read only variable)
c1d9 d0 03              BNE CrVa_20
c1db 4c 00 bf CrVa_15   JMP Syntax_Error    ; tried to use reserved name
c1de c9 53    CrVa_20   CMP #'S'
c1e0 d0 04              BNE CrVa_25
c1e2 c0 54              CPY #'T'            ; ST  (read only variable)
c1e4 f0 f5              BEQ CrVa_15
c1e6 c9 44    CrVa_25   CMP #'D'
c1e8 d0 08              BNE CrVa_30
c1ea c0 53              CPY #'S'            ; DS  (read only variable)
c1ec f0 ed              BEQ CrVa_15
c1ee c0 d3              CPY #'S'+$80        ; DS$ (read only variable)
c1f0 f0 e9              BEQ CrVa_15
c1f2 a5 2c    CrVa_30   LDA ARYTAB
c1f4 a4 2d              LDY ARYTAB+1        ; (A/Y)  = ARYTAB
c1f6 85 5c              STA TMPPTC
c1f8 84 5d              STY TMPPTC+1        ; TMPPTC = ARYTAB
c1fa a5 2e              LDA STREND
c1fc a4 2f              LDY STREND+1        ; (A/Y)  = STREND
c1fe 85 57              STA TMPPTB
c200 84 58              STY TMPPTB+1        ; TMPPTB = STREND
c202 18                 CLC
c203 69 07              ADC #7              ; 7 bytes for a new variable
c205 90 01              BCC CrVa_35
c207 c8                 INY
c208 85 55    CrVa_35   STA TMPPTA
c20a 84 56              STY TMPPTA+1        ; TMPPTA = TMPPTB + 7
c20c 20 50 b3           JSR Open_Up_Space   ; move array space 7 bytes up
c20f a5 55              LDA TMPPTA
c211 a4 56              LDY TMPPTA+1
c213 c8                 INY
c214 85 2c              STA ARYTAB
c216 84 2d              STY ARYTAB+1        ; ARYTAB += 7
c218 85 55              STA TMPPTA
c21a 84 56              STY TMPPTA+1        ; TMPPTA = ARYTAB

              ; scan through array area and adjust all dynamic string
              ; back references to the new descriptor position

c21c a5 55    CrVa_40   LDA TMPPTA
c21e a6 56              LDX TMPPTA+1
c220 e4 2f    CrVa_45   CPX STREND+1        ; TMPPTA == STREND ?
c222 d0 04              BNE CrVa_50
c224 c5 2e              CMP STREND
c226 f0 70              BEQ CrVa_75         ; -> initialize variable
c228 85 1f    CrVa_50   STA INDEXA
c22a 86 20              STX INDEXA+1        ; INDEXA = TMPPTA
c22c a0 00              LDY #0
c22e b1 1f              LDA (INDEXA),Y
c230 aa                 TAX                 ; X = 1st. char
c231 c8                 INY                 ; Y = 1
c232 b1 1f              LDA (INDEXA),Y
c234 08                 PHP                 ; push flags of 2nd. char
c235 c8                 INY                 ; Y = 2
c236 b1 1f              LDA (INDEXA),Y      ; A = array length low
c238 65 55              ADC TMPPTA
c23a 85 55              STA TMPPTA
c23c c8                 INY                 ; Y = 3
c23d b1 1f              LDA (INDEXA),Y      ; A = array length high
c23f 65 56              ADC TMPPTA+1
c241 85 56              STA TMPPTA+1        ; TMPPTA += array length
c243 28                 PLP                 ; flags of 2nd. char
c244 10 d6              BPL CrVa_40         ; -> branch for real array
c246 8a                 TXA                 ; flags for 1st. char
c247 30 d3              BMI CrVa_40         ;-> branch for integer
c249 c8                 INY                 ; Y = 4
c24a b1 1f              LDA (INDEXA),Y      ; A = # of dimensions
c24c a0 00              LDY #0
c24e 0a                 ASL A               ; dimensions * 2
c24f 69 05              ADC #5              ; plus 5 bytes for header
c251 65 1f              ADC INDEXA
c253 85 1f              STA INDEXA
c255 90 02              BCC CrVa_55
c257 e6 20              INC INDEXA+1        ; INDEXA += header size
c259 a6 20    CrVa_55   LDX INDEXA+1
c25b e4 56              CPX TMPPTA+1        ; INDEXA == TMPPTA (end of array) ?
c25d d0 04              BNE CrVa_60
c25f c5 55              CMP TMPPTA
c261 f0 bd              BEQ CrVa_45         ; -> branch on end of array
c263 a0 00    CrVa_60   LDY #0
c265 b1 1f              LDA (INDEXA),Y      ; length
c267 f0 22              BEQ CrVa_70         ; -> next item
c269 c8                 INY                 ; Y = 1
c26a 18                 CLC
c26b 71 1f              ADC (INDEXA),Y      ; A = length + address low
c26d 85 57              STA TMPPTB
c26f aa                 TAX
c270 c8                 INY                 ; Y = 2
c271 b1 1f              LDA (INDEXA),Y      ; address high
c273 69 00              ADC #0
c275 85 58              STA TMPPTB+1        ; TMPPTB = back reference
c277 c5 31              CMP FRETOP+1
c279 90 10              BCC CrVa_70         ; -> branch if not in string area
c27b d0 04              BNE CrVa_65
c27d e4 30              CPX FRETOP
c27f 90 0a              BCC CrVa_70         ; -> branch if not in string area
c281 88       CrVa_65   DEY                 ; Y = 1
c282 a5 20              LDA INDEXA+1        ; back reference high
c284 91 57              STA (TMPPTB),Y      ; store
c286 88                 DEY                 ; Y = 0
c287 a5 1f              LDA INDEXA          ; back reference low
c289 91 57              STA (TMPPTB),Y      ; store
c28b a9 03    CrVa_70   LDA #3
c28d 18                 CLC
c28e 65 1f              ADC INDEXA
c290 85 1f              STA INDEXA
c292 90 c5              BCC CrVa_55
c294 e6 20              INC INDEXA+1        ; INDEXA += 3 (next descriptor)
c296 d0 c1              BNE CrVa_55         ; branch always

c298 a0 00    CrVa_75   LDY #0
c29a a5 42              LDA VARNAM
c29c 91 5c              STA (TMPPTC),Y      ; byte 0: 1st. char
c29e c8                 INY
c29f a5 43              LDA VARNAM+1
c2a1 91 5c              STA (TMPPTC),Y      ; byte 1: 2nd. char
c2a3 a9 00              LDA #0
c2a5 c8                 INY
c2a6 91 5c              STA (TMPPTC),Y      ; byte 2-6: 0
c2a8 c8                 INY
c2a9 91 5c              STA (TMPPTC),Y
c2ab c8                 INY
c2ac 91 5c              STA (TMPPTC),Y
c2ae c8                 INY
c2af 91 5c              STA (TMPPTC),Y
c2b1 c8                 INY
c2b2 91 5c              STA (TMPPTC),Y
c2b4 a5 5c    CrVa_80   LDA TMPPTC
c2b6 18                 CLC
c2b7 69 02              ADC #2
c2b9 a4 5d              LDY TMPPTC+1
c2bb 90 01              BCC CrVa_85
c2bd c8                 INY
c2be 85 44    CrVa_85   STA VARPTR          ; VARPTR = TMPPTC + 2
c2c0 84 45              STY VARPTR+1
c2c2 60                 RTS ;Size  259 [Create_Var]

c2c3 00 00 00           .FILL $c2c8-* (0) ; 5 bytes

              ; ******************************
c2c8            Array_Pointer_To_First ; $c2c8
              ; ******************************

c2c8 a5 05              LDA COUNT           ; # of dimensions
c2ca 0a                 ASL A               ; in bytes
c2cb 69 05              ADC #5              ; plus header size
c2cd 65 5c              ADC TMPPTC          ; plus start of array
c2cf a4 5d              LDY TMPPTC+1
c2d1 90 01              BCC APTF_10
c2d3 c8                 INY
c2d4 85 55    APTF_10   STA TMPPTA          ; pointer to first elemnt
c2d6 84 56              STY TMPPTA+1
c2d8 60                 RTS ;Size   17 [Array_Pointer_To_First]

              ; ************
c2d9            Float_M32768
              ; ************

c2d9 90 80 00           .QUAD $90800000  -1870659584

c2dd                    .FILL $c2dd-* (0) ; 0 bytes

              ; *****************************
c2dd            Eval_Positive_Integer ; $c2dd
              ; *****************************

c2dd 20 70 00           JSR CHRGET
c2e0 20 98 bd           JSR Eval_Expression

              ; ***************************
c2e3            Eval_Positive_Integer_Check
              ; ***************************

c2e3 20 87 bd           JSR Is_Numeric
c2e6 a5 63              LDA FAC1SI
c2e8 30 0d              BMI RIT_10

              ; ***********************
c2ea            Real_To_Integer ; $c2ea
              ; ***********************

c2ea a5 5e              LDA FAC1EX
c2ec c9 90              CMP #$90            ; check if -32767 >= value >= 32767
c2ee 90 09              BCC RIT_20
c2f0 a9 d9              LDA #<Float_M32768  ; check if value = -32768
c2f2 a0 c2              LDY #>Float_M32768
c2f4 20 91 cd           JSR Compare_FAC1_AY
c2f7 d0 7a    RIT_10    BNE Jump_To_Illegal_Quantity
c2f9 4c 6f ba RIT_20    JMP FAC1_INT

              ; ******************
c2fc            Find_Array ; $c2fc
              ; ******************

              ; This routine is jumped at from the Parse_Name routine
              ; after parsing the name of the array (VARNAM) and the
              ; left parenthesis '('

c2fc a5 06              LDA DIMFLG
c2fe 05 08              ORA INTFLG          ; push INTFLG (bit 7) and DIMFLG (6-0)
c300 48                 PHA
c301 a5 07              LDA VALTYP          ; push VALTYP
c303 48                 PHA
c304 a0 00              LDY #0
c306 98       FiAr_05   TYA                 ; start loop evaluating subscripts
c307 48                 PHA                 ; push Y
c308 a5 43              LDA VARNAM+1
c30a 48                 PHA
c30b a5 42              LDA VARNAM          ; push VARNAM
c30d 48                 PHA
c30e 20 dd c2           JSR Eval_Positive_Integer
c311 68                 PLA
c312 85 42              STA VARNAM
c314 68                 PLA
c315 85 43              STA VARNAM+1        ; pull VARNAM
c317 68                 PLA
c318 a8                 TAY                 ; pull Y
c319 ba                 TSX                 ; X = stack pointer
c31a bd 02 01           LDA STACK+2,X
c31d 48                 PHA                 ; push DIMFLG/INTFLG again
c31e bd 01 01           LDA STACK+1,X
c321 48                 PHA                 ; push VALTYP again
c322 a5 61              LDA FAC1M3
c324 9d 02 01           STA STACK+2,X
c327 a5 62              LDA FAC1M4          ; replace value above these flags
c329 9d 01 01           STA STACK+1,X       ; by the subscript pointer
c32c c8                 INY                 ; check next index
c32d 20 76 00           JSR CHRGOT
c330 c9 2c              CMP #','
c332 f0 d2              BEQ FiAr_05         ; evaluate next subscript
c334 84 05              STY COUNT           ; # of subscripts
c336 20 ef be           JSR Need_Right_Parenthesis
c339 68                 PLA
c33a 85 07              STA VALTYP
c33c 68                 PLA
c33d 85 08              STA INTFLG
c33f 29 7f              AND #$7f
c341 85 06              STA DIMFLG          ; restore array flags
c343 a6 2c              LDX ARYTAB
c345 a5 2d              LDA ARYTAB+1        ; start of search
c347 86 5c    FiAr_10   STX TMPPTC
c349 85 5d              STA TMPPTC+1
c34b c5 2f              CMP STREND+1
c34d d0 04              BNE FiAr_15
c34f e4 2e              CPX STREND
c351 f0 39              BEQ FiAr_30           ; not found -> create default size array
c353 a0 00    FiAr_15   LDY #0
c355 b1 5c              LDA (TMPPTC),Y
c357 c8                 INY                 ; Y = 1
c358 c5 42              CMP VARNAM          ; compare 1st. char
c35a d0 06              BNE FiAr_20
c35c a5 43              LDA VARNAM+1
c35e d1 5c              CMP (TMPPTC),Y      ; compare 2nd. char
c360 f0 16              BEQ FiAr_25
c362 c8       FiAr_20   INY                 ; Y = 2
c363 b1 5c              LDA (TMPPTC),Y      ; length of header
c365 18                 CLC
c366 65 5c              ADC TMPPTC
c368 aa                 TAX
c369 c8                 INY
c36a b1 5c              LDA (TMPPTC),Y
c36c 65 5d              ADC TMPPTC+1        ; advance TMPPTC to next array
c36e 90 d7              BCC FiAr_10         ; branch always

              ; -------------
c370            Bad_Subscript
              ; -------------

c370 a2 6b              LDX #[Msg_SUBSC - Msg_Start] ; $6b
c372 2c                 .BYTE $2c

              ; ------------------------
c373            Jump_To_Illegal_Quantity
              ; ------------------------

c373 a2 35              LDX #[Msg_QUANT - Msg_Start] ; $35
c375 4c cf b3 FiAr_Err  JMP Basic_Error

              ; array already declared and dimensioned

c378 a2 78    FiAr_25   LDX #[Msg_REDIM - Msg_Start] ; $78
c37a a5 06              LDA DIMFLG          ; dimension statement ?
c37c d0 f7              BNE FiAr_Err        ; array already created
c37e 20 c8 c2           JSR Array_Pointer_To_First
c381 a5 05              LDA COUNT           ; # of subscripts
c383 a0 04              LDY #4
c385 d1 5c              CMP (TMPPTC),Y      ; compare with # of declared dimensions
c387 d0 e7              BNE Bad_Subscript   ; error if no match
c389 4c 15 c4           JMP FiAr_70

              ; create array

c38c 20 c8 c2 FiAr_30   JSR Array_Pointer_To_First
c38f 20 a0 b3           JSR Check_Mem_Avail
c392 a0 00              LDY #0
c394 84 6f              STY TMPPTD+1
c396 a2 05              LDX #5              ; # of bytes per element (default REAL)
c398 a5 42              LDA VARNAM
c39a 91 5c              STA (TMPPTC),Y      ; store 1st. char
c39c 10 01              BPL FiAr_35         ; branch if REAL or STRING
c39e ca                 DEX                 ; # of bytes = 4
c39f c8       FiAr_35   INY                 ; Y = 1
c3a0 a5 43              LDA VARNAM+1
c3a2 91 5c              STA (TMPPTC),Y      ; store 2nd. char
c3a4 10 02              BPL FiAr_40         ; branch if REAL
c3a6 ca                 DEX
c3a7 ca                 DEX                 ; # of bytes (2 INTEGER, 3 STRING)
c3a8 86 6e    FiAr_40   STX TMPPTD          ; store size of elemnts
c3aa a5 05              LDA COUNT           ; # of subscripts
c3ac c8                 INY                 ; Y = 2
c3ad c8                 INY                 ; Y = 3
c3ae c8                 INY                 ; Y = 4
c3af 91 5c              STA (TMPPTC),Y      ; store # of dimensions
c3b1 a2 0b    FiAr_45   LDX #11             ; default dimension (0..10)
c3b3 a9 00              LDA #0              ; high value
c3b5 24 06              BIT DIMFLG
c3b7 50 08              BVC FiAr_50         ; -> branch for default dimension
c3b9 68                 PLA
c3ba 18                 CLC
c3bb 69 01              ADC #1              ; add 1 because indices start at 0
c3bd aa                 TAX
c3be 68                 PLA
c3bf 69 00              ADC #0              ; (X/A) = (subscript + 1)
c3c1 c8       FiAr_50   INY                 ; Y = 5,7,...
c3c2 91 5c              STA (TMPPTC),Y      ; store dimension high
c3c4 c8                 INY                 ; Y = 6,8,...
c3c5 8a                 TXA
c3c6 91 5c              STA (TMPPTC),Y      ; store dimension low
c3c8 20 77 c4           JSR Mult_16x16
c3cb 86 6e              STX TMPPTD          ; size low
c3cd 85 6f              STA TMPPTD+1        ; size high
c3cf a4 1f              LDY INDEXA
c3d1 c6 05              DEC COUNT           ; decrement dimension counter
c3d3 d0 dc              BNE FiAr_45         ; loop for next dimension
c3d5 65 56              ADC TMPPTA+1
c3d7 b0 5d              BCS FiAr_76           ; -> out of memory
c3d9 85 56              STA TMPPTA+1
c3db a8                 TAY
c3dc 8a                 TXA
c3dd 65 55              ADC TMPPTA
c3df 90 03              BCC FiAr_55
c3e1 c8                 INY
c3e2 f0 52              BEQ FiAr_76           ; -> out of memory
c3e4 20 a0 b3 FiAr_55   JSR Check_Mem_Avail
c3e7 85 2e              STA STREND
c3e9 84 2f              STY STREND+1        ; new top of array area
c3eb a9 00              LDA #0              ; zero array content
c3ed e6 6f              INC TMPPTD+1        ; size high
c3ef a4 6e              LDY TMPPTD          ; Y = size low
c3f1 f0 05              BEQ FiAr_65
c3f3 88       FiAr_60   DEY
c3f4 91 55              STA (TMPPTA),Y      ; clear array
c3f6 d0 fb              BNE FiAr_60
c3f8 c6 56    FiAr_65   DEC TMPPTA+1
c3fa c6 6f              DEC TMPPTD+1
c3fc d0 f5              BNE FiAr_60
c3fe e6 56              INC TMPPTA+1
c400 38                 SEC
c401 a5 2e              LDA STREND
c403 e5 5c              SBC TMPPTC
c405 a0 02              LDY #2
c407 91 5c              STA (TMPPTC),Y      ; store array size low
c409 a5 2f              LDA STREND+1
c40b c8                 INY                 ; Y = 3
c40c e5 5d              SBC TMPPTC+1
c40e 91 5c              STA (TMPPTC),Y      ; store array size high
c410 a5 06              LDA DIMFLG
c412 d0 62              BNE FiAr_Ret
c414 c8                 INY                 ; Y = 4
c415 b1 5c    FiAr_70   LDA (TMPPTC),Y      ; # of dimensions
c417 85 05              STA COUNT
c419 a9 00              LDA #0
c41b 85 6e              STA TMPPTD          ; TMPPTD = 0
c41d 85 6f    FiAr_72   STA TMPPTD+1
c41f c8                 INY                 ; Y = 5,7,...
c420 68                 PLA
c421 aa                 TAX
c422 85 61              STA FAC1M3
c424 68                 PLA
c425 85 62              STA FAC1M4          ; FAC1M3/4 = subscript
c427 d1 5c              CMP (TMPPTC),Y      ; compare with dimension high
c429 90 0e              BCC FiAr_78         ; -> lower
c42b d0 06              BNE FiAr_74         ; greater -> out of range
c42d c8                 INY                 ; Y = 6,8,...
c42e 8a                 TXA
c42f d1 5c              CMP (TMPPTC),Y      ; compare with dimension low
c431 90 07              BCC FiAr_80         ; -> lower
c433 4c 70 c3 FiAr_74   JMP Bad_Subscript
c436 4c cd b3 FiAr_76   JMP Error_Out_Of_Memory
c439 c8       FiAr_78   INY                 ; Y = 6,8,...
c43a a5 6f    FiAr_80   LDA TMPPTD+1
c43c 05 6e              ORA TMPPTD
c43e 18                 CLC
c43f f0 0a              BEQ FiAr_82         ; TMPPTD == 0 ?
c441 20 77 c4           JSR Mult_16x16
c444 8a                 TXA
c445 65 61              ADC FAC1M3
c447 aa                 TAX
c448 98                 TYA
c449 a4 1f              LDY INDEXA
c44b 65 62    FiAr_82   ADC FAC1M4
c44d 86 6e              STX TMPPTD
c44f c6 05              DEC COUNT
c451 d0 ca              BNE FiAr_72         ; next subscript
c453 85 6f              STA TMPPTD+1
c455 a2 05              LDX #5              ; standard item size (REAL)
c457 a5 42              LDA VARNAM
c459 10 01              BPL FiAr_84         ; -> REAL or STRING
c45b ca                 DEX                 ; X = 4
c45c a5 43    FiAr_84   LDA VARNAM+1
c45e 10 02              BPL FiAr_86         ; -> REAL
c460 ca                 DEX
c461 ca                 DEX                 ; X = 2
c462 86 25    FiAr_86   STX FAC3M3          ; item size (I=2, S=3, R=5)
c464 a9 00              LDA #0
c466 20 80 c4           JSR Mult_16x16_A    ; # of items * item size
c469 8a                 TXA
c46a 65 55              ADC TMPPTA
c46c 85 44              STA VARPTR
c46e 98                 TYA
c46f 65 56              ADC TMPPTA+1
c471 85 45              STA VARPTR+1        ; VARPTR = array element
c473 a8                 TAY
c474 a5 44              LDA VARPTR          ; (A/Y) = VARPTR
c476 60       FiAr_Ret  RTS ;Size  379 [Find_Array]

c477                    .FILL $c477-* (0) ; 0 bytes

              ; ******************
c477            Mult_16x16 ; $c477
              ; ******************

c477 84 1f              STY INDEXA
c479 b1 5c              LDA (TMPPTC),Y
c47b 85 25              STA FAC3M3
c47d 88                 DEY
c47e b1 5c              LDA (TMPPTC),Y

              ; ************
c480            Mult_16x16_A
              ; ************

c480 85 26              STA FAC3M4          ; FAC3M3/3 = Dimension
c482 a9 10              LDA #16
c484 85 5a              STA TMPVAR          ; 16 bit multiplication
c486 a2 00              LDX #0
c488 a0 00              LDY #0
c48a 8a       Mu16_10   TXA                 ; (X/Y) = FAC3M3 * TMPPTD
c48b 0a                 ASL A
c48c aa                 TAX
c48d 98                 TYA
c48e 2a                 ROL A
c48f a8                 TAY
c490 b0 a4              BCS FiAr_76
c492 06 6e              ASL TMPPTD
c494 26 6f              ROL TMPPTD+1
c496 90 0b              BCC Mu16_20
c498 18                 CLC
c499 8a                 TXA
c49a 65 25              ADC FAC3M3
c49c aa                 TAX
c49d 98                 TYA
c49e 65 26              ADC FAC3M4
c4a0 a8                 TAY
c4a1 b0 93              BCS FiAr_76
c4a3 c6 5a    Mu16_20   DEC TMPVAR          ; next bit
c4a5 d0 e3              BNE Mu16_10
c4a7 60                 RTS ;Size   40 [Mult_16x16_A]

              ; *****************
c4a8            Basic_FRE ; $c4a8
              ; *****************

c4a8 a5 07              LDA VALTYP
c4aa f0 03              BEQ FRE_10          ; -> numeric argument
c4ac 20 b8 c7           JSR Free_String_FAC1
c4af 20 6a c6 FRE_10    JSR Garbage_Collection
c4b2 38                 SEC
c4b3 a5 30              LDA FRETOP
c4b5 e5 2e              SBC STREND
c4b7 a8                 TAY
c4b8 a5 31              LDA FRETOP+1
c4ba e5 2f              SBC STREND+1

              ; **********
c4bc            AY_To_Real
              ; **********

c4bc a2 00              LDX #0
c4be 86 07              STX VALTYP          ; numeric result
c4c0 85 5f              STA FAC1M1
c4c2 84 60              STY FAC1M2
c4c4 a2 90              LDX #$90            ; exponent
c4c6 4c 7a cd           JMP ATOF_10

              ; *****************
c4c9            Basic_POS ; $c4c9
              ; *****************

c4c9 a4 c6              LDY CursorCol

              ; **********
c4cb            Y_To_Float
              ; **********

c4cb a9 00              LDA #0
c4cd f0 ed              BEQ AY_To_Real      ; always

              ; *****************
c4cf            Assert_Non_Direct
              ; *****************

c4cf a6 37              LDX CURLIN+1
c4d1 e8                 INX
c4d2 d0 a2              BNE FiAr_Ret
c4d4 a2 95              LDX #[Msg_DIREC - Msg_Start] ; $95
c4d6 2c                 .BYTE $2c

              ; ******************
c4d7            Undefined_Function
              ; ******************

c4d7 a2 e9              LDX #[Msg_FUNC - Msg_Start] ; $e9
c4d9 4c cf b3           JMP Basic_Error

              ; *****************
c4dc            Basic_DEF ; $c4dc
              ; *****************

c4dc 20 0a c5           JSR Get_FN          ; read function name
c4df 20 cf c4           JSR Assert_Non_Direct
c4e2 20 f2 be           JSR Need_Left_Parenthesis
c4e5 a9 80              LDA #$80
c4e7 85 0a              STA SUBFLG          ; no integer function
c4e9 20 2b c1           JSR Parse_Name
c4ec 20 87 bd           JSR Is_Numeric      ; only numeric arguments
c4ef 20 ef be           JSR Need_Right_Parenthesis
c4f2 a9 b2              LDA #$b2            ; '=' token
c4f4 20 f7 be           JSR Need_A
c4f7 48                 PHA
c4f8 a5 45              LDA VARPTR+1
c4fa 48                 PHA
c4fb a5 44              LDA VARPTR          ; push function argument address
c4fd 48                 PHA
c4fe a5 78              LDA TXTPTR+1
c500 48                 PHA
c501 a5 77              LDA TXTPTR          ; push function address
c503 48                 PHA
c504 20 83 b8           JSR Basic_DATA      ; skip to next statement
c507 4c 75 c5           JMP FNX_30           ; pull and store attributes

              ; ******
c50a            Get_FN
              ; ******

c50a a9 a5              LDA #$a5            ; FN token
c50c 20 f7 be           JSR Need_A
c50f 09 80              ORA #$80
c511 85 0a              STA SUBFLG          ; no integer function
c513 20 32 c1           JSR Get_FN_Address
c516 85 4b              STA FUNCPT
c518 84 4c              STY FUNCPT+1
c51a 4c 87 bd           JMP Is_Numeric

              ; ********
c51d            Eval_FNX
              ; ********

c51d 20 0a c5           JSR Get_FN          ; address of function descriptor
c520 48                 PHA                 ; push FUNCPT
c521 98                 TYA
c522 48                 PHA                 ; push FUNCPT+1
c523 20 e9 be           JSR Eval_In_Parenthesis
c526 20 87 bd           JSR Is_Numeric      ; force numeric argument
c529 68                 PLA
c52a 85 4c              STA FUNCPT+1
c52c 68                 PLA
c52d 85 4b              STA FUNCPT          ; restore function descriptor
c52f a0 02              LDY #2
c531 b1 4b              LDA (FUNCPT),Y
c533 85 44              STA VARPTR
c535 aa                 TAX
c536 c8                 INY                 ; Y = 3
c537 b1 4b              LDA (FUNCPT),Y
c539 f0 9c              BEQ Undefined_Function
c53b 85 45              STA VARPTR+1        ; VARPTR = address of argument variable
c53d c8                 INY                 ; Y = 4
c53e b1 44    FNX_10    LDA (VARPTR),Y      ; push value of variable (5 bytes)
c540 48                 PHA
c541 88                 DEY
c542 10 fa              BPL FNX_10
c544 a4 45              LDY VARPTR+1
c546 20 0a cd           JSR FAC1_To_XY      ; (X/Y) = VARPTR - Y=0 on return
c549 a5 78              LDA TXTPTR+1
c54b 48                 PHA
c54c a5 77              LDA TXTPTR
c54e 48                 PHA                 ; push TXTPTR
c54f b1 4b              LDA (FUNCPT),Y
c551 85 77              STA TXTPTR
c553 c8                 INY                 ; Y = 1
c554 b1 4b              LDA (FUNCPT),Y
c556 85 78              STA TXTPTR+1        ; TXTPTR = function body
c558 a5 45              LDA VARPTR+1
c55a 48                 PHA
c55b a5 44              LDA VARPTR
c55d 48                 PHA                 ; push VARPTR
c55e 20 84 bd           JSR Eval_Numeric    ; execute function body
c561 68                 PLA
c562 85 4b              STA FUNCPT
c564 68                 PLA
c565 85 4c              STA FUNCPT+1        ; FUNCPT = VARPTR
c567 20 76 00           JSR CHRGOT
c56a f0 03              BEQ FNX_20
c56c 4c 00 bf           JMP Syntax_Error     ; function did not end properly
c56f 68       FNX_20    PLA
c570 85 77              STA TXTPTR
c572 68                 PLA
c573 85 78              STA TXTPTR+1         ; restore execution pointer
c575 a0 00    FNX_30    LDY #0               ; restore value of argument variable
c577 68                 PLA
c578 91 4b              STA (FUNCPT),Y
c57a 68                 PLA
c57b c8                 INY
c57c 91 4b              STA (FUNCPT),Y
c57e 68                 PLA
c57f c8                 INY
c580 91 4b              STA (FUNCPT),Y
c582 68                 PLA
c583 c8                 INY
c584 91 4b              STA (FUNCPT),Y
c586 68                 PLA
c587 c8                 INY
c588 91 4b              STA (FUNCPT),Y
c58a 60                 RTS ;Size  110 [Eval_FNX]

c58b 00 00 00           .FILL $c58e-* (0) ; 3 bytes

              ; *****************
c58e            Basic_STR ; $c58e
              ; *****************

c58e 20 87 bd           JSR Is_Numeric
c591 a0 00              LDY #0
c593 20 95 cf           JSR Format_FAC1_Y
c596 68                 PLA
c597 68                 PLA
c598 a9 ff    STR_10    LDA #<STACK-1
c59a a0 00              LDY #>STACK-1
c59c f0 12              BEQ Create_String_Descriptor

              ; ********************
c59e            Allocate_String_FAC1
              ; ********************

c59e a6 61              LDX FAC1M3
c5a0 a4 62              LDY FAC1M4
c5a2 86 4d              STX DESCPT
c5a4 84 4e              STY DESCPT+1

              ; *****************
c5a6            Allocate_String_A
              ; *****************

c5a6 20 1d c6           JSR Allocate_String_Space
c5a9 86 5f              STX FAC1M1          ; addres low
c5ab 84 60              STY FAC1M2          ; address high
c5ad 85 5e              STA FAC1EX          ; length
c5af 60                 RTS ;Size   10 [Allocate_String_A]

              ; ************************
c5b0            Create_String_Descriptor
              ; ************************

c5b0 a2 22              LDX #QUOTE          ; quote is the only valid delimiter
c5b2 86 03              STX CHARAC
c5b4 86 04              STX ENDCHR

              ; ***************************
c5b6            Create_String_Descriptor_AY
              ; ***************************

c5b6 85 6c              STA STRPTR
c5b8 84 6d              STY STRPTR+1        ; set STRPTR from (A/Y)
c5ba 85 5f              STA FAC1M1
c5bc 84 60              STY FAC1M2          ; set FAC1M1 from (A/Y)
c5be a0 ff              LDY #-1             ; start loop with 0
c5c0 c8       CSD_10    INY
c5c1 b1 6c              LDA (STRPTR),Y
c5c3 f0 0c              BEQ CSD_30          ; end of string
c5c5 c5 03              CMP CHARAC          ; closing delimiter
c5c7 f0 04              BEQ CSD_20
c5c9 c5 04              CMP ENDCHR
c5cb d0 f3              BNE CSD_10          ; loop
c5cd c9 22    CSD_20    CMP #QUOTE
c5cf f0 01              BEQ CSD_40
c5d1 18       CSD_30    CLC
c5d2 84 5e    CSD_40    STY FAC1EX          ; string length
c5d4 98                 TYA
c5d5 65 6c              ADC STRPTR          ; TMPPTD = STRPTR + strlen
c5d7 85 6e              STA TMPPTD
c5d9 a6 6d              LDX STRPTR+1
c5db 90 01              BCC CSD_50
c5dd e8                 INX
c5de 86 6f    CSD_50    STX TMPPTD+1
c5e0 a5 6d              LDA STRPTR+1
c5e2 f0 04              BEQ CSD_60          ; -> allocate if on ZP
c5e4 c9 02              CMP #2              ; -> allocate if in buffer
c5e6 d0 0b              BNE Push_String_Descriptor
c5e8 98       CSD_60    TYA                 ; A = length
c5e9 20 9e c5           JSR Allocate_String_FAC1
c5ec a6 6c              LDX STRPTR
c5ee a4 6d              LDY STRPTR+1
c5f0 20 9a c7           JSR Store_String_XY ; Copy string from (X/Y) to (FRESPC)

              ; **********************
c5f3            Push_String_Descriptor
              ; **********************

c5f3 a6 13              LDX TEMPPT
c5f5 e0 1f              CPX #TEMPST+9       ; top of temp string descriptors
c5f7 d0 05              BNE PuSD_10
c5f9 a2 c8              LDX #Msg_COMPL-Msg_Start ; $c8 FORMULA TOO COMPLEX
c5fb 4c cf b3 PuSD_Err  JMP Basic_Error
c5fe a5 5e    PuSD_10   LDA FAC1EX          ; push FAC1 descriptor
c600 95 00              STA 0,X
c602 a5 5f              LDA FAC1M1
c604 95 01              STA 1,X
c606 a5 60              LDA FAC1M2
c608 95 02              STA 2,X
c60a a0 00              LDY #0
c60c 86 61              STX FAC1M3          ; mark stack position
c60e 84 62              STY FAC1M4
c610 84 6d              STY FROUND
c612 88                 DEY                 ; Y = $ff
c613 84 07              STY VALTYP          ; type = string
c615 86 14              STX LASTPT          ; remember last used position
c617 e8                 INX
c618 e8                 INX
c619 e8                 INX
c61a 86 13              STX TEMPPT          ; increase string stack pointer
c61c 60                 RTS ;Size   42 [Push_String_Descriptor]

              ; *****************************
c61d            Allocate_String_Space ; $c61d
              ; *****************************

              ; Input:  A = length of string

              ; Output: A = length of string
              ;         X = address low
              ;         Y = address high

c61d 46 09              LSR GARBFL          ; clear bit 7 of GARBFL
c61f aa       ASS_10    TAX                 ; string length
c620 f0 38              BEQ ASS_50          ; 0 : nothing to do
c622 48                 PHA                 ; save length
c623 38                 SEC
c624 a5 30              LDA FRETOP
c626 e9 02              SBC #2
c628 85 1f              STA INDEXA
c62a a5 31              LDA FRETOP+1
c62c e9 00              SBC #0
c62e 85 20              STA INDEXA+1        ; INDEXA = FRETOP - 2
c630 a8                 TAY                 ; Y = INDEXA+1
c631 8a                 TXA                 ; A = length
c632 49 ff              EOR #$ff
c634 38                 SEC                 ; add -length
c635 65 1f              ADC INDEXA          ; (A/Y) = INDEXA - length
c637 b0 01              BCS ASS_30
c639 88                 DEY
c63a c4 2f    ASS_30    CPY STREND+1
c63c 90 1d              BCC ASS_60          ; OOM: try garbage collection
c63e d0 04              BNE ASS_40
c640 c5 2e              CMP STREND
c642 90 17              BCC ASS_60          ; OOM: try garbage collection
c644 85 32    ASS_40    STA FRESPC
c646 84 33              STY FRESPC+1        ; FRESPC = INDEXA - length
c648 a0 01              LDY #1
c64a a9 ff              LDA #$ff
c64c 91 1f              STA (INDEXA),Y      ; mark as unassigned
c64e 88                 DEY                 ; Y = 0
c64f 68                 PLA
c650 91 1f              STA (INDEXA),Y      ; store length
c652 a6 32              LDX FRESPC
c654 a4 33              LDY FRESPC+1
c656 86 30              STX FRETOP
c658 84 31              STY FRETOP+1        ; FRETOP = FRESPC
c65a 60       ASS_50    RTS ;Size   62 [Allocate_String_Space]
c65b a2 4d    ASS_60    LDX #[Msg_OOM - Msg_Start] ; $4d
c65d a5 09              LDA GARBFL
c65f 30 9a              BMI PuSD_Err           ; -> Out Of Memory
c661 20 6a c6           JSR Garbage_Collection
c664 38                 SEC
c665 66 09              ROR GARBFL          ; mark: collection done
c667 68                 PLA                 ; length
c668 d0 b5              BNE ASS_10          ; always

c66a                    .FILL $c66a-* (0) ; 0 bytes

              ; **************************
c66a            Garbage_Collection ; $c66a
              ; **************************

c66a a5 34              LDA MEMSIZ
c66c 85 32              STA FRESPC          ; new location of string
c66e 85 4b              STA FUNCPT          ; old location of string
c670 a5 35              LDA MEMSIZ+1
c672 85 33              STA FRESPC+1
c674 85 4c              STA FUNCPT+1

c676 a5 30    GaCo_05   LDA FRETOP          ; if (FRETOP >= FUNCPT)
c678 c5 4b              CMP FUNCPT
c67a a5 31              LDA FRETOP+1
c67c e5 4c              SBC FUNCPT+1
c67e b0 6b              BCS GaCo_45         ; finish

c680 a5 4b              LDA FUNCPT
c682 e9 01              SBC #1              ; subtract 2 (C=0)
c684 85 4b              STA FUNCPT
c686 b0 02              BCS GaCo_10
c688 c6 4c              DEC FUNCPT+1        ; FUNCPT -= 2

c68a a0 01    GaCo_10   LDY #1
c68c b1 4b              LDA (FUNCPT),Y      ; reference high
c68e 88                 DEY                 ; Y = 0
c68f c9 ff              CMP #$ff            ; obsolete flag
c691 d0 0c              BNE GaCo_15         ; branch to string copy
c693 a5 4b              LDA FUNCPT          ; C = 1 from CMP #$ff
c695 f1 4b              SBC (FUNCPT),Y      ; subtract length
c697 85 4b              STA FUNCPT
c699 b0 db              BCS GaCo_05         ; loop
c69b c6 4c              DEC FUNCPT+1
c69d d0 d7              BNE GaCo_05         ; loop always

c69f 85 20    GaCo_15   STA INDEXA+1        ; reference high
c6a1 b1 4b              LDA (FUNCPT),Y
c6a3 85 1f              STA INDEXA          ; reference low
c6a5 38                 SEC
c6a6 a5 4b              LDA FUNCPT
c6a8 f1 1f              SBC (INDEXA),Y      ; subtract length
c6aa 85 4b              STA FUNCPT
c6ac b0 02              BCS GaCo_20
c6ae c6 4c              DEC FUNCPT+1        ; FUNCPT -= length

c6b0 a5 32    GaCo_20   LDA FRESPC
c6b2 d0 02              BNE GaCo_25
c6b4 c6 33              DEC FRESPC+1
c6b6 c6 32    GaCo_25   DEC FRESPC          ; FRESPC--

c6b8 a5 20              LDA INDEXA+1        ; reference high
c6ba 91 32              STA (FRESPC),Y
c6bc 18                 CLC
c6bd a5 32              LDA FRESPC
c6bf f1 1f              SBC (INDEXA),Y      ; subtract length + borrow
c6c1 85 32              STA FRESPC
c6c3 b0 02              BCS GaCo_30
c6c5 c6 33              DEC FRESPC+1        ; FRESPC -= (length+1)

c6c7 c5 4b    GaCo_30   CMP FUNCPT          ; if (FRESPC == FUNCPT)
c6c9 d0 06              BNE GaCo_35         ; copy
c6cb a5 33              LDA FRESPC+1
c6cd c5 4c              CMP FUNCPT+1
c6cf f0 a5              BEQ GaCo_05         ; loop

c6d1 b1 1f    GaCo_35   LDA (INDEXA),Y      ; length
c6d3 a8                 TAY
c6d4 b1 4b    GaCo_40   LDA (FUNCPT),Y      ; copy string & low reference
c6d6 91 32              STA (FRESPC),Y
c6d8 88                 DEY
c6d9 d0 f9              BNE GaCo_40
c6db b1 4b              LDA (FUNCPT),Y
c6dd 91 32              STA (FRESPC),Y
c6df c8                 INY                 ; Y = 1
c6e0 a5 32              LDA FRESPC          ; store new reference
c6e2 91 1f              STA (INDEXA),Y
c6e4 c8                 INY
c6e5 a5 33              LDA FRESPC+1
c6e7 91 1f              STA (INDEXA),Y
c6e9 d0 8b              BNE GaCo_05         ; loop always
c6eb a5 32    GaCo_45   LDA FRESPC
c6ed 85 30              STA FRETOP
c6ef a5 33              LDA FRESPC+1
c6f1 85 31              STA FRETOP+1
c6f3 60                 RTS ;Size  138 [Garbage_Collection]

              ; ********
c6f4            FAC1_LSB
              ; ********

c6f4 a2 5e              LDX #FAC1EX
c6f6 a0 00    FACX_LSB  LDY #0
c6f8 84 65              STY BITS
c6fa c9 f9    FACB_10   CMP #-7
c6fc b0 1e              BCS FACB_Ret
c6fe a8                 TAY
c6ff b5 04              LDA 4,X
c701 85 6d              STA FROUND
c703 05 65              ORA BITS
c705 85 65              STA BITS
c707 b5 03              LDA 3,X
c709 95 04              STA 4,X
c70b b5 02              LDA 2,X
c70d 95 03              STA 3,X
c70f b5 01              LDA 1,X
c711 95 02              STA 2,X
c713 a9 00              LDA #0
c715 95 01              STA 1,X
c717 98                 TYA
c718 69 08              ADC #8
c71a d0 de              BNE FACB_10
c71c a8       FACB_Ret  TAY
c71d 60                 RTS ;Size   42 [FAC1_LSB]

c71e 00 00 00           .FILL $c74f-* (0) ; 49 bytes

              ; *******************
c74f            Concatenate ; $c74f
              ; *******************

c74f a5 62              LDA FAC1M4
c751 48                 PHA
c752 a5 61              LDA FAC1M3
c754 48                 PHA
c755 20 81 be           JSR Evaluate
c758 20 89 bd           JSR Is_String
c75b 68                 PLA
c75c 85 6c              STA STRPTR
c75e 68                 PLA
c75f 85 6d              STA STRPTR+1
c761 a0 00              LDY #0
c763 b1 6c              LDA (STRPTR),Y
c765 18                 CLC
c766 71 61              ADC (FAC1M3),Y
c768 90 05              BCC Conc_10
c76a a2 b0              LDX #Msg_LONG-Msg_Start ; $b0 STRING TOO LONG
c76c 4c cf b3           JMP Basic_Error
c76f 20 9e c5 Conc_10   JSR Allocate_String_FAC1
c772 20 8c c7           JSR Store_String_STRPTR ; store first part
c775 a5 4d              LDA DESCPT
c777 a4 4e              LDY DESCPT+1
c779 20 bc c7           JSR Free_String_AY
c77c 20 9e c7           JSR Store_String_INDEXA ; store second part
c77f a5 6c              LDA STRPTR
c781 a4 6d              LDY STRPTR+1
c783 20 bc c7           JSR Free_String_AY
c786 20 f3 c5           JSR Push_String_Descriptor
c789 4c b0 bd           JMP EvEx_15

              ; *******************
c78c            Store_String_STRPTR
              ; *******************

c78c a0 00              LDY #0
c78e b1 6c              LDA (STRPTR),Y      ; A = length
c790 48                 PHA
c791 c8                 INY
c792 b1 6c              LDA (STRPTR),Y      ; X = address low
c794 aa                 TAX
c795 c8                 INY
c796 b1 6c              LDA (STRPTR),Y      ; Y = address high
c798 a8                 TAY
c799 68                 PLA

              ; ***************
c79a            Store_String_XY
              ; ***************

c79a 86 1f              STX INDEXA
c79c 84 20              STY INDEXA+1

              ; ***************************
c79e            Store_String_INDEXA ; $c79e
              ; ***************************

c79e a8                 TAY
c79f f0 13              BEQ SSI_Ret
c7a1 48                 PHA
c7a2 88       SSI_10    DEY
c7a3 b1 1f              LDA (INDEXA),Y
c7a5 91 32              STA (FRESPC),Y
c7a7 98                 TYA
c7a8 d0 f8              BNE SSI_10
c7aa 68                 PLA
c7ab 18                 CLC
c7ac 65 32              ADC FRESPC          ; FRESPC += length
c7ae 85 32              STA FRESPC          ; (used by Concatenate)
c7b0 90 02              BCC SSI_Ret
c7b2 e6 33              INC FRESPC+1
c7b4 60       SSI_Ret   RTS ;Size   23 [Store_String_INDEXA]

              ; ****************************
c7b5            Eval_And_Free_String ; $c7b5
              ; ****************************

c7b5 20 89 bd           JSR Is_String

              ; ****************
c7b8            Free_String_FAC1
              ; ****************

c7b8 a5 61              LDA FAC1M3
c7ba a4 62              LDY FAC1M4

              ; **********************
c7bc            Free_String_AY ; $c7bc
              ; **********************

              ; Input:  (A/Y) = pointer to descriptor
              ; Output: (X/Y) = INDEXA = pointer to string
              ;         A     = length

c7bc 85 1f              STA INDEXA
c7be 84 20              STY INDEXA+1        ; INDEXA = pointer to descriptor
c7c0 20 11 c8           JSR Pop_Descriptor_Stack
c7c3 d0 28              BNE GSD_40          ; -> load if not temporary
c7c5 20 3d ba           JSR Back_Reference_Position
c7c8 90 23              BCC GSD_40          ; -> branch if not dynamic string
c7ca a9 ff              LDA #$ff
c7cc 91 4f              STA (INDEXC),Y      ; invalidate string
c7ce 88                 DEY                 ; Y = 0
c7cf 8a                 TXA
c7d0 91 4f              STA (INDEXC),Y      ; store length
c7d2 a6 1f              LDX INDEXA
c7d4 a4 20              LDY INDEXA+1
c7d6 c4 31              CPY FRETOP+1
c7d8 d0 25              BNE GSD_Ret
c7da e4 30              CPX FRETOP
c7dc d0 21              BNE GSD_Ret         ; return if INDEXA != FRETOP
c7de 48                 PHA                 ; push length
c7df a5 4f              LDA INDEXC
c7e1 69 01              ADC #1              ; add 2 (1 + carry)
c7e3 85 30              STA FRETOP
c7e5 a5 50              LDA INDEXC+1
c7e7 69 00              ADC #0
c7e9 85 31              STA FRETOP+1
c7eb 68                 PLA
c7ec 60                 RTS ;Size   49 [Free_String_AY]
c7ed a0 00    GSD_40    LDY #0              ; load descriptor from pointer
c7ef b1 1f              LDA (INDEXA),Y
c7f1 48                 PHA
c7f2 c8                 INY
c7f3 b1 1f              LDA (INDEXA),Y
c7f5 aa                 TAX
c7f6 c8                 INY
c7f7 b1 1f              LDA (INDEXA),Y
c7f9 a8                 TAY
c7fa 86 1f              STX INDEXA
c7fc 84 20              STY INDEXA+1
c7fe 68                 PLA
c7ff 60       GSD_Ret   RTS ;Size   68 [Free_String_AY]

c800 00 00 00           .FILL $c811-* (0) ; 17 bytes

              ; ****************************
c811            Pop_Descriptor_Stack ; $c811
              ; ****************************

c811 c4 15              CPY LASTPT+1
c813 d0 0c              BNE PDS_Ret
c815 c5 14              CMP LASTPT
c817 d0 08              BNE PDS_Ret
c819 85 13              STA TEMPPT
c81b e9 03              SBC #3
c81d 85 14              STA LASTPT
c81f a0 00              LDY #0
c821 60       PDS_Ret   RTS ;Size   17 [Pop_Descriptor_Stack]

              ; *********
c822            Basic_CHR
              ; *********

c822 20 d7 c8           JSR Eval_Byte       ; get byte in X
c825 8a                 TXA
c826 48                 PHA
c827 a9 01              LDA #1
c829 20 a6 c5           JSR Allocate_String_A
c82c 68                 PLA
c82d a0 00              LDY #0
c82f 91 5f              STA (FAC1M1),Y
c831 68                 PLA
c832 68                 PLA
c833 4c f3 c5           JMP Push_String_Descriptor

              ; **********
c836            Basic_LEFT
              ; **********

c836 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c839 d1 4d              CMP (DESCPT),Y      ; compare argument with length
c83b 98                 TYA                 ; A = 0
c83c 90 04    LEFT_10   BCC LEFT_20         ; branch if arg < length
c83e b1 4d              LDA (DESCPT),Y      ; get total length
c840 aa                 TAX                 ; string length
c841 98                 TYA                 ; A = 0
c842 48       LEFT_20   PHA                 ; push start index (0 for LEFT$)
c843 8a       LEFT_30   TXA                 ; A  = new length
c844 48       LEFT_40   PHA                 ; push new length
c845 20 a6 c5           JSR Allocate_String_A
c848 a5 4d              LDA DESCPT
c84a a4 4e              LDY DESCPT+1
c84c 20 bc c7           JSR Free_String_AY  ; free string argument
c84f 68                 PLA
c850 a8                 TAY                 ; Y = length
c851 68                 PLA                 ; A = start index
c852 18                 CLC
c853 65 1f              ADC INDEXA
c855 85 1f              STA INDEXA
c857 90 02              BCC LEFT_50
c859 e6 20              INC INDEXA+1        ; INDEX += start index
c85b 98       LEFT_50   TYA                 ; new length
c85c 20 9e c7           JSR Store_String_INDEXA
c85f 4c f3 c5           JMP Push_String_Descriptor

              ; ***********
c862            Basic_RIGHT
              ; ***********

c862 20 97 c8           JSR Pop_DESCPT      ; get string address and 2nd. argument
c865 18                 CLC
c866 f1 4d              SBC (DESCPT),Y      ; argument - length
c868 49 ff              EOR #$ff            ; length - argument
c86a 4c 3c c8           JMP LEFT_10         ; share code with LEFT$

              ; *********
c86d            Basic_MID
              ; *********

c86d a9 ff              LDA #255            ; default value for 3rd. argument
c86f 85 62              STA FAC1M4
c871 20 76 00           JSR CHRGOT
c874 c9 29              CMP #')'
c876 f0 06              BEQ MID_10
c878 20 f5 be           JSR Need_Comma
c87b 20 d4 c8           JSR Get_Byte_Value  ; 3rd. argument to FAC1M4
c87e 20 97 c8 MID_10    JSR Pop_DESCPT      ; get string address and 2nd. argument
c881 f0 4b              BEQ ASC_Err         ; null string -> error
c883 ca                 DEX                 ; start index to offset
c884 8a                 TXA
c885 48                 PHA                 ; push offset
c886 18                 CLC
c887 a2 00              LDX #0
c889 f1 4d              SBC (DESCPT),Y      ; offset - length
c88b b0 b6              BCS LEFT_30
c88d 49 ff              EOR #$ff            ; length - offset
c88f c5 62              CMP FAC1M4
c891 90 b1              BCC LEFT_40         ; new length = rest of string
c893 a5 62              LDA FAC1M4          ; new length
c895 b0 ad              BCS LEFT_40         ; branch always

              ; **********
c897            Pop_DESCPT
              ; **********

c897 20 ef be           JSR Need_Right_Parenthesis
c89a 68                 PLA
c89b a8                 TAY                 ; return address low
c89c 68                 PLA
c89d 85 52              STA FUNJMP          ; return address high
c89f 68                 PLA
c8a0 68                 PLA
c8a1 68                 PLA
c8a2 aa                 TAX                 ; X = length
c8a3 68                 PLA
c8a4 85 4d              STA DESCPT
c8a6 68                 PLA
c8a7 85 4e              STA DESCPT+1        ; DESCPT = string address
c8a9 a5 52              LDA FUNJMP
c8ab 48                 PHA                 ; return address high
c8ac 98                 TYA
c8ad 48                 PHA                 ; return address low
c8ae a0 00              LDY #0
c8b0 8a                 TXA                 ; A = length
c8b1 60                 RTS ;Size   27 [Pop_DESCPT]

              ; *********
c8b2            Basic_LEN
              ; *********

c8b2 20 b8 c8           JSR Eval_String_Desc
c8b5 4c cb c4           JMP Y_To_Float

              ; ****************
c8b8            Eval_String_Desc
              ; ****************

c8b8 20 b5 c7           JSR Eval_And_Free_String
c8bb a2 00              LDX #0
c8bd 86 07              STX VALTYP
c8bf a8                 TAY
c8c0 60                 RTS ;Size    9 [Eval_String_Desc]

              ; *********
c8c1            Basic_ASC
              ; *********

c8c1 20 b8 c8           JSR Eval_String_Desc
c8c4 f0 05              BEQ ASC_10          ; ASC(""") was a syntax error in BASIC 4
c8c6 a0 00              LDY #0              ; here we return 0
c8c8 b1 1f              LDA (INDEXA),Y
c8ca a8                 TAY
c8cb 4c cb c4 ASC_10    JMP Y_To_Float
c8ce 4c 73 c3 ASC_Err   JMP Jump_To_Illegal_Quantity

c8d1                    .FILL $c8d1-* (0) ; 0 bytes

              ; ***************************
c8d1            Get_Next_Byte_Value ; $c8d1
              ; ***************************

c8d1 20 70 00           JSR CHRGET

              ; **************
c8d4            Get_Byte_Value
              ; **************

c8d4 20 84 bd           JSR Eval_Numeric

              ; *********
c8d7            Eval_Byte
              ; *********

c8d7 20 e3 c2           JSR Eval_Positive_Integer_Check
c8da a6 61              LDX FAC1M3
c8dc d0 f0              BNE ASC_Err
c8de a6 62              LDX FAC1M4
c8e0 4c 76 00           JMP CHRGOT

              ; *****************
c8e3            Basic_VAL ; $c8e3
              ; *****************

c8e3 20 b8 c8           JSR Eval_String_Desc
c8e6 d0 03              BNE VAL_10
c8e8 4c 2d ca           JMP Clear_FAC1
c8eb a6 77    VAL_10    LDX TXTPTR
c8ed a4 78              LDY TXTPTR+1
c8ef 86 6e              STX TMPPTD
c8f1 84 6f              STY TMPPTD+1        ; TMPPTD = TXTPTR
c8f3 a6 1f              LDX INDEXA
c8f5 86 77              STX TXTPTR
c8f7 18                 CLC
c8f8 65 1f              ADC INDEXA
c8fa 85 21              STA INDEXB
c8fc a6 20              LDX INDEXA+1
c8fe 86 78              STX TXTPTR+1        ; TXTPTR = INDEXA
c900 90 01              BCC VAL_20          ; INDEXB = INDEXA + length
c902 e8                 INX
c903 86 22    VAL_20    STX INDEXB+1
c905 a0 00              LDY #0
c907 b1 21              LDA (INDEXB),Y      ; back reference low
c909 48                 PHA
c90a 98                 TYA
c90b 91 21              STA (INDEXB),Y      ; add zero delimiter for CHRGET
c90d 20 76 00           JSR CHRGOT
c910 20 29 ce           JSR Read_Real_To_FAC1
c913 68                 PLA
c914 a0 00              LDY #0
c916 91 21              STA (INDEXB),Y      ; restore back reference low

              ; *************************
c918            Restore_Execution_Pointer
              ; *************************

c918 a6 6e              LDX TMPPTD
c91a a4 6f              LDY TMPPTD+1
c91c 86 77              STX TXTPTR
c91e 84 78              STY TXTPTR+1
c920 60                 RTS ;Size    9 [Restore_Execution_Pointer]

c921                    .FILL $c921-* (0) ; 0 bytes

              ; *************************
c921            Get_Word_And_Byte ; $c921
              ; *************************

c921 20 84 bd           JSR Eval_Numeric
c924 20 2d c9           JSR FAC1_To_LINNUM

              ; *******************
c927            Need_Comma_Get_Byte
              ; *******************

c927 20 f5 be           JSR Need_Comma
c92a 4c d4 c8           JMP Get_Byte_Value

              ; **************
c92d            FAC1_To_LINNUM
              ; **************

c92d a5 63              LDA FAC1SI
c92f 30 9d              BMI ASC_Err         ; only positive numbers
c931 a5 5e              LDA FAC1EX
c933 c9 91              CMP #$91
c935 b0 97              BCS ASC_Err         ; -> greater 65536
c937 20 d1 cd           JSR FAC1_LSR
c93a a5 61              LDA FAC1M3
c93c a4 62              LDY FAC1M4
c93e 84 11              STY LINNUM
c940 85 12              STA LINNUM+1
c942 60                 RTS ;Size   22 [FAC1_To_LINNUM]

              ; **********
c943            Basic_PEEK
              ; **********

c943 a5 12              LDA LINNUM+1
c945 48                 PHA
c946 a5 11              LDA LINNUM
c948 48                 PHA
c949 20 2d c9           JSR FAC1_To_LINNUM
c94c a0 00              LDY #0
c94e b1 11              LDA (LINNUM),Y
c950 a8                 TAY
c951 68                 PLA
c952 85 11              STA LINNUM
c954 68                 PLA
c955 85 12              STA LINNUM+1
c957 4c cb c4           JMP Y_To_Float

              ; **********
c95a            Basic_POKE
              ; **********

c95a 20 21 c9           JSR Get_Word_And_Byte
c95d 8a                 TXA
c95e a0 00              LDY #0
c960 91 11              STA (LINNUM),Y
c962 60                 RTS ;Size    9 [Basic_POKE]

              ; **********
c963            Basic_WAIT
              ; **********

c963 20 21 c9           JSR Get_Word_And_Byte
c966 86 46              STX FORPNT
c968 a2 00              LDX #0
c96a 20 76 00           JSR CHRGOT
c96d f0 03              BEQ WAIT_10
c96f 20 27 c9           JSR Need_Comma_Get_Byte
c972 86 47    WAIT_10   STX FORPNT+1
c974 a0 00              LDY #0
c976 b1 11    WAIT_20   LDA (LINNUM),Y
c978 45 47              EOR FORPNT+1
c97a 25 46              AND FORPNT
c97c f0 f8              BEQ WAIT_20
c97e 60       WAIT_Ret  RTS ;Size   28 [Basic_WAIT]

              ; ***************
c97f            Add_0_5_To_FAC1
              ; ***************

c97f a9 c7              LDA #<Float_0_5
c981 a0 d0              LDY #>Float_0_5
c983 4c 9d c9           JMP Add_Var_AY_To_FAC1

              ; *************
c986            AY_Minus_FAC1
              ; *************

c986 20 c2 cb           JSR Load_FAC2_From_AY

              ; ********
c989            Op_MINUS
              ; ********

c989 a5 63              LDA FAC1SI
c98b 49 ff              EOR #$ff
c98d 85 63              STA FAC1SI
c98f 45 6b              EOR FAC2SI
c991 85 6c              STA STRPTR          ; pos = ADD, neg = SUB
c993 a5 5e              LDA FAC1EX
c995 4c a0 c9           JMP Op_PLUS

c998 00 00 00           .FILL $c99d-* (0) ; 5 bytes

              ; ******************
c99d            Add_Var_AY_To_FAC1
              ; ******************

c99d 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***************
c9a0            Op_PLUS ; $c9a0
              ; ***************

c9a0 d0 03              BNE PLUS_10         ; -> branch if FAC1 is not 0
c9a2 4c 32 cd           JMP FAC2_To_FAC1    ; FAC1 = FAC2
c9a5 a6 6d    PLUS_10   LDX FROUND
c9a7 86 53              STX FUNJMP+1        ; copy rounding byte
c9a9 a2 66              LDX #FAC2EX         ; X points to FAC2
c9ab a5 66              LDA FAC2EX

              ; ***************************
c9ad            AddSub_FAC2_To_FAC1 ; $c9ad
              ; ***************************

              ; The mantissa of the FAC with the lower exponent is shifted
              ; right until both exponents become equal.

              ; Input:  A = exponent of FAC2
              ;         X = address  of FAC2
              ;         STRPTR ($00:Add, $80:Subtract)

              ; Output: FAC1 = FAC1 + FAC2 (for STRPTR == $00)
              ;         FAC1 = FAC1 - FAC2 (for STRPTR == $80)

c9ad a8                 TAY                 ; Y = exp 2
c9ae f0 ce              BEQ WAIT_Ret        ; return if FAC2 is zero
c9b0 38                 SEC
c9b1 e5 5e              SBC FAC1EX          ; A = exp 2 - exp 1
c9b3 f0 1b              BEQ AFTF_30         ; -> exponents are equal
c9b5 90 12              BCC AFTF_10         ; -> exp 2 < exp 1
c9b7 84 5e              STY FAC1EX          ; exp 1 = exp 2
c9b9 a4 6b              LDY FAC2SI
c9bb 84 63              STY FAC1SI          ; sign 1 = sign 2
c9bd 49 ff              EOR #$ff
c9bf 69 00              ADC #0              ; A = exp 1 - exp 2
c9c1 a0 00              LDY #0
c9c3 84 53              STY FUNJMP+1        ; clear FAC2 rounding byte
c9c5 a2 5e              LDX #FAC1EX         ; X points to FAC1
c9c7 d0 04              BNE AFTF_20         ; always
c9c9 a0 00    AFTF_10   LDY #0
c9cb 84 6d              STY FROUND          ; clear FAC1 rounding byte
c9cd 20 cf ca AFTF_20   JSR Shift_FACX_A
c9d0 24 6c    AFTF_30   BIT STRPTR          ; add or subtract ?
c9d2 10 60              BPL AFTF_60         ; -> add mantissa of FAC2 to FAC1
c9d4 a0 5e              LDY #FAC1EX
c9d6 e0 66              CPX #FAC2EX         ; if (X == FAC2) Y = FAC1
c9d8 f0 02              BEQ AFTF_40
c9da a0 66              LDY #FAC2EX         ; else           Y = FAC2
c9dc 38       AFTF_40   SEC
c9dd 49 ff              EOR #$ff            ; negate rounding byte
c9df 65 53              ADC FUNJMP+1
c9e1 85 6d              STA FROUND
c9e3 b9 04 00           LDA 4,Y
c9e6 f5 04              SBC 4,X
c9e8 85 62              STA FAC1M4
c9ea b9 03 00           LDA 3,Y
c9ed f5 03              SBC 3,X
c9ef 85 61              STA FAC1M3
c9f1 b9 02 00           LDA 2,Y
c9f4 f5 02              SBC 2,X
c9f6 85 60              STA FAC1M2
c9f8 b9 01 00           LDA 1,Y
c9fb f5 01              SBC 1,X
c9fd 85 5f              STA FAC1M1
c9ff b0 0c    AFTF_50   BCS Normalise_FAC1
ca01 20 7d ca           JSR Negate_FAC1
ca04 4c 0d ca           JMP Normalise_FAC1

ca07 00 00 00           .FILL $ca0d-* (0) ; 6 bytes

              ; **************
ca0d            Normalise_FAC1
              ; **************

ca0d a0 00              LDY #0              ; Y = 0
ca0f 98                 TYA                 ; A = 0
ca10 18                 CLC
ca11 a6 5f    NF1_10    LDX FAC1M1          ; MSB of mantissa
ca13 d0 4a              BNE AFTF_70         ; -> shift bitwise
ca15 a6 60              LDX FAC1M2          ; shift bytes
ca17 86 5f              STX FAC1M1
ca19 a6 61              LDX FAC1M3
ca1b 86 60              STX FAC1M2
ca1d a6 62              LDX FAC1M4
ca1f 86 61              STX FAC1M3
ca21 a6 6d              LDX FROUND
ca23 86 62              STX FAC1M4
ca25 84 6d              STY FROUND          ; = 0
ca27 69 08              ADC #8              ; A = shift count
ca29 c9 20              CMP #32             ; maximum shift = 32 bit
ca2b d0 e4              BNE NF1_10          ; loop

              ; **********
ca2d            Clear_FAC1
              ; **********

ca2d a9 00              LDA #0
ca2f 85 5e    CF1_10    STA FAC1EX
ca31 85 63              STA FAC1SI
ca33 60                 RTS ;Size    7 [Clear_FAC1]

ca34 65 53    AFTF_60   ADC FUNJMP+1        ; FAC1 rounding byte
ca36 85 6d              STA FROUND
ca38 a5 62              LDA FAC1M4          ; add FAC2 mantissa to FAC1
ca3a 65 6a              ADC FAC2M4
ca3c 85 62              STA FAC1M4
ca3e a5 61              LDA FAC1M3
ca40 65 69              ADC FAC2M3
ca42 85 61              STA FAC1M3
ca44 a5 60              LDA FAC1M2
ca46 65 68              ADC FAC2M2
ca48 85 60              STA FAC1M2
ca4a a5 5f              LDA FAC1M1
ca4c 65 67              ADC FAC2M1
ca4e 85 5f              STA FAC1M1
ca50 4c 6c ca           JMP Mantissa_Overflow

ca53 69 01    AFTF_65   ADC #1
ca55 06 6d              ASL FROUND
ca57 26 62              ROL FAC1M4
ca59 26 61              ROL FAC1M3
ca5b 26 60              ROL FAC1M2
ca5d 26 5f              ROL FAC1M1
ca5f 10 f2    AFTF_70   BPL AFTF_65
ca61 38                 SEC
ca62 e5 5e              SBC FAC1EX
ca64 b0 c7              BCS Clear_FAC1
ca66 49 ff              EOR #$ff
ca68 69 01              ADC #1
ca6a 85 5e              STA FAC1EX

              ; *****************
ca6c            Mantissa_Overflow
              ; *****************

ca6c 90 0e              BCC AFTF_Ret
ca6e e6 5e    AFTF_80   INC FAC1EX
ca70 f0 42              BEQ Overflow_Error
ca72 66 5f              ROR FAC1M1
ca74 66 60              ROR FAC1M2
ca76 66 61              ROR FAC1M3
ca78 66 62              ROR FAC1M4
ca7a 66 6d              ROR FROUND
ca7c 60       AFTF_Ret  RTS ;Size   17 [Mantissa_Overflow]

              ; ***********
ca7d            Negate_FAC1
              ; ***********

ca7d a5 63              LDA FAC1SI
ca7f 49 ff              EOR #$ff
ca81 85 63              STA FAC1SI

              ; ********************
ca83            Negate_FAC1_Mantissa
              ; ********************

ca83 a5 5f              LDA FAC1M1
ca85 49 ff              EOR #$ff
ca87 85 5f              STA FAC1M1
ca89 a5 60              LDA FAC1M2
ca8b 49 ff              EOR #$ff
ca8d 85 60              STA FAC1M2
ca8f a5 61              LDA FAC1M3
ca91 49 ff              EOR #$ff
ca93 85 61              STA FAC1M3
ca95 a5 62              LDA FAC1M4
ca97 49 ff              EOR #$ff
ca99 85 62              STA FAC1M4
ca9b a5 6d              LDA FROUND
ca9d 49 ff              EOR #$ff
ca9f 85 6d              STA FROUND
caa1 e6 6d              INC FROUND
caa3 d0 0e              BNE IFM_Ret

              ; *****************
caa5            Inc_FAC1_Mantissa
              ; *****************

caa5 e6 62              INC FAC1M4
caa7 d0 0a              BNE IFM_Ret
caa9 e6 61              INC FAC1M3
caab d0 06              BNE IFM_Ret
caad e6 60              INC FAC1M2
caaf d0 02              BNE IFM_Ret
cab1 e6 5f              INC FAC1M1
cab3 60       IFM_Ret   RTS ;Size   15 [Inc_FAC1_Mantissa]

              ; **************
cab4            Overflow_Error
              ; **************

cab4 a2 45              LDX #Msg_FLOW-Msg_Start ; $45 OVERFLOW
cab6 4c cf b3           JMP Basic_Error

              ; **********
cab9            Shift_FAC3
              ; **********

cab9 a5 26              LDA FAC3M4
cabb 85 6d              STA FROUND
cabd a5 25              LDA FAC3M3
cabf 85 26              STA FAC3M4
cac1 a5 24              LDA FAC3M2
cac3 85 25              STA FAC3M3
cac5 a5 23              LDA FAC3M1
cac7 85 24              STA FAC3M2
cac9 a9 00              LDA #0
cacb 85 23              STA FAC3M1
cacd 60                 RTS ;Size   21 [Shift_FAC3]

cace 00                 .FILL $cacf-* (0) ; 1 bytes

              ; perform a byte shift right on FAC X
              ; the LSB byte goes to FROUND

              ; ************
cacf            Shift_FACX_A
              ; ************

cacf 20 f6 c6           JSR FACX_LSB
cad2 a5 6d              LDA FROUND          ; byte shifted off
cad4 c0 00              CPY #0
cad6 10 0c              BPL SFA_40          ; return if done
cad8 56 01    SFA_10    LSR 1,X
cada 76 02              ROR 2,X
cadc 76 03              ROR 3,X
cade 76 04              ROR 4,X
cae0 6a                 ROR A               ; A gets bits shifted out
cae1 c8                 INY
cae2 d0 f4              BNE SFA_10
cae4 18       SFA_40    CLC
cae5 60                 RTS ;Size   23 [Shift_FACX_A]

cae6 00 00 00           .FILL $caf2-* (0) ; 12 bytes

              ; **************
caf2            REAL_1 ; $caf2
              ; **************

caf2 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000
caf7 03       VLOG_A    .BYTE $03
caf8 7f 5e 56 cb 79     .REAL $7f5e56cb79   ;    0.43425594189
cafd 80 13 9b 0b 64     .REAL $80139b0b64   ;    0.57658454124
cb02 80 76 38 93 16     .REAL $8076389316   ;    0.96180075919
cb07 82 38 aa 3b 20     .REAL $8238aa3b20   ;    2.88539007306

              ; ***********
cb0c            HALF_SQRT_2
              ; ***********

cb0c 80 35 04 f3 34     .REAL $803504f334   ;    0.70710678119
cb11 81 35 04 SQRT_2    .REAL $813504f334   ;    1.41421356238

              ; *********
cb16            MINUS_0_5
              ; *********

cb16 80 80 00 00 00     .REAL $8080000000   ;   -0.50000000000
cb1b 80 31 72 LN_2      .REAL $80317217f8   ;    0.69314718060

              ; *********
cb20            Basic_LOG
              ; *********

cb20 20 61 cd           JSR Get_FAC1_Sign
cb23 f0 02              BEQ LOG_10
cb25 10 03              BPL LOG_20
cb27 4c 73 c3 LOG_10    JMP Jump_To_Illegal_Quantity
cb2a a5 5e    LOG_20    LDA FAC1EX
cb2c e9 7f              SBC #$7f
cb2e 48                 PHA
cb2f a9 80              LDA #$80
cb31 85 5e              STA FAC1EX
cb33 a9 0c              LDA #<HALF_SQRT_2
cb35 a0 cb              LDY #>HALF_SQRT_2
cb37 20 9d c9           JSR Add_Var_AY_To_FAC1
cb3a a9 11              LDA #<SQRT_2
cb3c a0 cb              LDY #>SQRT_2
cb3e 20 45 cc           JSR AY_Divided_By_FAC1
cb41 a9 f2              LDA #<REAL_1
cb43 a0 ca              LDY #>REAL_1
cb45 20 86 c9           JSR AY_Minus_FAC1
cb48 a9 f7              LDA #<VLOG_A
cb4a a0 ca              LDY #>VLOG_A
cb4c 20 d7 d1           JSR Square_And_Series_Eval
cb4f a9 16              LDA #<MINUS_0_5
cb51 a0 cb              LDY #>MINUS_0_5
cb53 20 9d c9           JSR Add_Var_AY_To_FAC1
cb56 68                 PLA
cb57 20 b4 ce           JSR Add_A_To_FAC1
cb5a a9 1b              LDA #<LN_2
cb5c a0 cb              LDY #>LN_2

              ; *********************
cb5e            Multiply_FAC1_With_AY
              ; *********************

cb5e 20 c2 cb           JSR Load_FAC2_From_AY

              ; ***********
cb61            Op_MULTIPLY
              ; ***********

cb61 f0 5b              BEQ MULT_Ret
cb63 20 ed cb           JSR Check_FAC
cb66 a9 00              LDA #0
cb68 85 23              STA FAC3M1
cb6a 85 24              STA FAC3M2
cb6c 85 25              STA FAC3M3
cb6e 85 26              STA FAC3M4
cb70 a5 6d              LDA FROUND
cb72 20 8c cb           JSR Mult_SubA
cb75 a5 62              LDA FAC1M4
cb77 20 8c cb           JSR Mult_SubA
cb7a a5 61              LDA FAC1M3
cb7c 20 8c cb           JSR Mult_SubA
cb7f a5 60              LDA FAC1M2
cb81 20 8c cb           JSR Mult_SubA
cb84 a5 5f              LDA FAC1M1
cb86 20 91 cb           JSR Mult_SubB
cb89 4c c5 cc           JMP FAC3_To_FAC1

              ; *********
cb8c            Mult_SubA
              ; *********

cb8c d0 03              BNE Mult_SubB       ; do multiply if A is not zero
cb8e 4c b9 ca           JMP Shift_FAC3      ; else shift FAC3 right 8 bits

              ; *********
cb91            Mult_SubB
              ; *********

cb91 4a                 LSR A
cb92 09 80              ORA #$80            ; make sure, that A remains not zero
cb94 a8       MULT_20   TAY                 ; until 8 shifts are done
cb95 90 19              BCC MULT_30
cb97 18                 CLC
cb98 a5 26              LDA FAC3M4
cb9a 65 6a              ADC FAC2M4
cb9c 85 26              STA FAC3M4
cb9e a5 25              LDA FAC3M3
cba0 65 69              ADC FAC2M3
cba2 85 25              STA FAC3M3
cba4 a5 24              LDA FAC3M2
cba6 65 68              ADC FAC2M2
cba8 85 24              STA FAC3M2
cbaa a5 23              LDA FAC3M1
cbac 65 67              ADC FAC2M1
cbae 85 23              STA FAC3M1
cbb0 66 23    MULT_30   ROR FAC3M1
cbb2 66 24              ROR FAC3M2
cbb4 66 25              ROR FAC3M3
cbb6 66 26              ROR FAC3M4
cbb8 66 6d              ROR FROUND
cbba 98                 TYA
cbbb 4a                 LSR A
cbbc d0 d6              BNE MULT_20
cbbe 60       MULT_Ret  RTS ;Size   46 [Mult_SubB]

cbbf 00 00 00           .FILL $cbc2-* (0) ; 3 bytes

              ; *************************
cbc2            Load_FAC2_From_AY ; $cbc2
              ; *************************

              ; Input:  (A/Y) = address of packed floating point value
              ; Output: FAC2  = read floating point value
              ;         A     = exponent of FAC1
              ;         Y     = 0

cbc2 85 1f              STA INDEXA
cbc4 84 20              STY INDEXA+1
cbc6 a0 04              LDY #4
cbc8 b1 1f              LDA (INDEXA),Y
cbca 85 6a              STA FAC2M4
cbcc 88                 DEY
cbcd b1 1f              LDA (INDEXA),Y
cbcf 85 69              STA FAC2M3
cbd1 88                 DEY
cbd2 b1 1f              LDA (INDEXA),Y
cbd4 85 68              STA FAC2M2
cbd6 88                 DEY
cbd7 b1 1f              LDA (INDEXA),Y      ; bit7 = sign
cbd9 85 6b              STA FAC2SI          ; transfer sign to FAC2SI bit7
cbdb 45 63              EOR FAC1SI          ; EOR with sign of FAC1
cbdd 85 6c              STA STRPTR          ; flag sign comparison
cbdf a5 6b              LDA FAC2SI          ; load sign/byte 1 of mantissa
cbe1 09 80              ORA #$80            ; replace sign with 1 (normalize)
cbe3 85 67              STA FAC2M1          ; M1 is now in unpacked mode
cbe5 88                 DEY
cbe6 b1 1f              LDA (INDEXA),Y      ; exponent
cbe8 85 66              STA FAC2EX
cbea a5 5e              LDA FAC1EX          ; return with FAC1 exp in A
cbec 60                 RTS ;Size   43 [Load_FAC2_From_AY]

              ; *********
cbed            Check_FAC
              ; *********

cbed a5 66              LDA FAC2EX
cbef f0 1c    ChFA_10   BEQ ChFA_50         ; -> set FAC1 = 0.0
cbf1 18                 CLC
cbf2 65 5e              ADC FAC1EX          ; (exp 1 + exp 2)
cbf4 90 04              BCC ChFA_20         ; -> no overflow
cbf6 30 1a              BMI ChFA_Err        ; -> overflow
cbf8 18                 CLC
cbf9 2c                 .BYTE $2c
cbfa 10 11    ChFA_20   BPL ChFA_50         ; -> underflow
cbfc 69 80              ADC #$80            ; correct bias
cbfe 85 5e              STA FAC1EX          ; exp 1 += exp 2
cc00 f0 02              BEQ ChFA_30
cc02 a5 6c              LDA STRPTR
cc04 85 63    ChFA_30   STA FAC1SI
cc06 60                 RTS ;Size   26 [Check_FAC]
cc07 a5 63    ChFA_40   LDA FAC1SI
cc09 49 ff              EOR #$ff
cc0b 30 05              BMI ChFA_Err
cc0d 68       ChFA_50   PLA
cc0e 68                 PLA
cc0f 4c 2d ca           JMP Clear_FAC1      ; underflow -> set FAC1 = 0.0
cc12 4c b4 ca ChFA_Err  JMP Overflow_Error  ; overflow  -> error

cc15 00 00 00           .FILL $cc18-* (0) ; 3 bytes

              ; ***************************
cc18            Multiply_FAC1_BY_10 ; $cc18
              ; ***************************

cc18 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2   ; FAC2 = FAC1
cc1b aa                 TAX                               ; A = Exponent
cc1c f0 10              BEQ Mul10_Ret
cc1e 18                 CLC
cc1f 69 02              ADC #2                            ; FAC2 *= 4
cc21 b0 ef              BCS ChFA_Err

              ; **************
cc23            Add_And_Double
              ; **************

cc23 a2 00              LDX #0
cc25 86 6c              STX STRPTR                        ; choose ADD
cc27 20 ad c9           JSR AddSub_FAC2_To_FAC1           ; FAC1 += FAC2   (*  5)
cc2a e6 5e              INC FAC1EX                        ; FAC1 *= 2      (* 10)
cc2c f0 e4              BEQ ChFA_Err
cc2e 60       Mul10_Ret RTS ;Size   12 [Add_And_Double]

              ; ********
cc2f            Float_10
              ; ********

cc2f 84 20 00 00 00     .REAL $8420000000   ;   10.00000000000

              ; *****************
cc34            Divide_FAC1_By_10
              ; *****************

cc34 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
cc37 a9 2f              LDA #<Float_10
cc39 a0 cc              LDY #>Float_10
cc3b a2 00              LDX #0

              ; *****************
cc3d            Divide_FAC2_By_AY
              ; *****************

cc3d 86 6c              STX STRPTR
cc3f 20 d8 cc           JSR Load_FAC1_AY
cc42 4c 48 cc           JMP Op_DIVIDE

              ; ******************
cc45            AY_Divided_By_FAC1
              ; ******************

cc45 20 c2 cb           JSR Load_FAC2_From_AY

              ; *********
cc48            Op_DIVIDE
              ; *********

cc48 f0 76              BEQ Divide_By_Zero
cc4a 20 51 cd           JSR Round_FAC1
cc4d a9 00              LDA #0
cc4f 38                 SEC
cc50 e5 5e              SBC FAC1EX
cc52 85 5e              STA FAC1EX
cc54 20 ed cb           JSR Check_FAC
cc57 e6 5e              INC FAC1EX
cc59 f0 b7              BEQ ChFA_Err
cc5b a2 fc              LDX #$fc            ; wrap around index
cc5d a9 01              LDA #1
cc5f a4 67    DIV_10    LDY FAC2M1
cc61 c4 5f              CPY FAC1M1
cc63 d0 10              BNE DIV_20
cc65 a4 68              LDY FAC2M2
cc67 c4 60              CPY FAC1M2
cc69 d0 0a              BNE DIV_20
cc6b a4 69              LDY FAC2M3
cc6d c4 61              CPY FAC1M3
cc6f d0 04              BNE DIV_20
cc71 a4 6a              LDY FAC2M4
cc73 c4 62              CPY FAC1M4
cc75 08       DIV_20    PHP
cc76 2a                 ROL A
cc77 90 09              BCC DIV_30
cc79 e8                 INX
cc7a 95 26              STA FAC3M4,X
cc7c f0 32              BEQ DIV_60
cc7e 10 34              BPL DIV_70
cc80 a9 01              LDA #1
cc82 28       DIV_30    PLP
cc83 b0 0e              BCS DIV_50
cc85 06 6a    DIV_40    ASL FAC2M4
cc87 26 69              ROL FAC2M3
cc89 26 68              ROL FAC2M2
cc8b 26 67              ROL FAC2M1
cc8d b0 e6              BCS DIV_20
cc8f 30 ce              BMI DIV_10
cc91 10 e2              BPL DIV_20
cc93 a8       DIV_50    TAY
cc94 a5 6a              LDA FAC2M4
cc96 e5 62              SBC FAC1M4
cc98 85 6a              STA FAC2M4
cc9a a5 69              LDA FAC2M3
cc9c e5 61              SBC FAC1M3
cc9e 85 69              STA FAC2M3
cca0 a5 68              LDA FAC2M2
cca2 e5 60              SBC FAC1M2
cca4 85 68              STA FAC2M2
cca6 a5 67              LDA FAC2M1
cca8 e5 5f              SBC FAC1M1
ccaa 85 67              STA FAC2M1
ccac 98                 TYA
ccad 4c 85 cc           JMP DIV_40
ccb0 a9 40    DIV_60    LDA #$40
ccb2 d0 ce              BNE DIV_30
ccb4 0a       DIV_70    ASL A
ccb5 0a                 ASL A
ccb6 0a                 ASL A
ccb7 0a                 ASL A
ccb8 0a                 ASL A
ccb9 0a                 ASL A
ccba 85 6d              STA FROUND
ccbc 28                 PLP
ccbd 4c c5 cc           JMP FAC3_To_FAC1

              ; **************
ccc0            Divide_By_Zero
              ; **************

ccc0 a2 85              LDX #Msg_DIV-Msg_Start ; $85
ccc2 4c cf b3           JMP Basic_Error

              ; ************
ccc5            FAC3_To_FAC1
              ; ************

ccc5 a5 23              LDA FAC3M1
ccc7 85 5f              STA FAC1M1
ccc9 a5 24              LDA FAC3M2
cccb 85 60              STA FAC1M2
cccd a5 25              LDA FAC3M3
cccf 85 61              STA FAC1M3
ccd1 a5 26              LDA FAC3M4
ccd3 85 62              STA FAC1M4
ccd5 4c 0d ca           JMP Normalise_FAC1

              ; ********************
ccd8            Load_FAC1_AY ; $ccd8
              ; ********************

ccd8 85 1f              STA INDEXA
ccda 84 20              STY INDEXA+1
ccdc a0 04              LDY #4
ccde b1 1f    LFAY_10   LDA (INDEXA),Y
cce0 99 5e 00           STA FAC1EX,Y
cce3 88                 DEY
cce4 10 f8              BPL LFAY_10
cce6 c8                 INY                 ; Y = 0
cce7 84 6d              STY FROUND          ; rounding byte
cce9 a5 5f              LDA FAC1M1
cceb 85 63              STA FAC1SI
cced 09 80              ORA #$80
ccef 85 5f              STA FAC1M1
ccf1 a5 5e              LDA FAC1EX
ccf3 60                 RTS ;Size   28 [Load_FAC1_AY]

              ; ********
ccf4            Set_FAC1
              ; ********

ccf4 85 5f              STA FAC1M1
ccf6 85 60              STA FAC1M2
ccf8 85 61              STA FAC1M3
ccfa 85 62              STA FAC1M4
ccfc 60                 RTS ;Size    9 [Set_FAC1]

ccfd                    .FILL $ccfd-* (0) ; 0 bytes

              ; **********************
ccfd            FAC1_To_FACTPB ; $ccfd
              ; **********************

ccfd a2 59              LDX #FACTPB ; $59
ccff 2c                 .BYTE $2c

              ; **************
cd00            FAC1_To_FACTPA
              ; **************

cd00 a2 54              LDX #<FACTPA
cd02 a0 00              LDY #>FACTPA
cd04 f0 04              BEQ FAC1_To_XY      ; always

              ; **************
cd06            FAC1_To_FORPNT
              ; **************

cd06 a6 46              LDX FORPNT
cd08 a4 47              LDY FORPNT+1

              ; **********
cd0a            FAC1_To_XY
              ; **********

cd0a 20 51 cd           JSR Round_FAC1
cd0d 86 1f              STX INDEXA
cd0f 84 20              STY INDEXA+1
cd11 a0 04              LDY #4
cd13 a5 62              LDA FAC1M4
cd15 91 1f              STA (INDEXA),Y
cd17 88                 DEY
cd18 a5 61              LDA FAC1M3
cd1a 91 1f              STA (INDEXA),Y
cd1c 88                 DEY
cd1d a5 60              LDA FAC1M2
cd1f 91 1f              STA (INDEXA),Y
cd21 88                 DEY
cd22 a5 63              LDA FAC1SI
cd24 09 7f              ORA #$7f
cd26 25 5f              AND FAC1M1
cd28 91 1f              STA (INDEXA),Y
cd2a 88                 DEY
cd2b a5 5e              LDA FAC1EX
cd2d 91 1f              STA (INDEXA),Y
cd2f 84 6d              STY FROUND
cd31 60                 RTS ;Size   40 [FAC1_To_XY]

              ; ************
cd32            FAC2_To_FAC1
              ; ************

cd32 a5 6b              LDA FAC2SI

              ; *********************
cd34            Copy_ABS_FAC2_To_FAC1
              ; *********************

cd34 85 63              STA FAC1SI
cd36 a2 05              LDX #5
cd38 b5 65    F1F2_10   LDA FAC2EX-1,X
cd3a 95 5d              STA FAC1EX-1,X
cd3c ca                 DEX
cd3d d0 f9              BNE F1F2_10
cd3f 86 6d              STX FROUND ; 0
cd41 60                 RTS ;Size   14 [Copy_ABS_FAC2_To_FAC1]

              ; ***************************
cd42            FAC1_Round_And_Copy_To_FAC2
              ; ***************************

cd42 20 51 cd           JSR Round_FAC1

              ; ************
cd45            FAC1_To_FAC2
              ; ************

cd45 a2 06              LDX #6
cd47 b5 5d    FA12_10   LDA FAC1EX-1,X
cd49 95 65              STA FAC2EX-1,X
cd4b ca                 DEX
cd4c d0 f9              BNE FA12_10
cd4e 86 6d              STX FROUND ; 0
cd50 60       FA12_Ret  RTS ;Size   12 [FAC1_To_FAC2]

              ; **********
cd51            Round_FAC1
              ; **********

cd51 a5 5e              LDA FAC1EX
cd53 f0 fb              BEQ FA12_Ret
cd55 06 6d              ASL FROUND
cd57 90 f7              BCC FA12_Ret

              ; ********
cd59            Inc_FAC1
              ; ********

cd59 20 a5 ca           JSR Inc_FAC1_Mantissa
cd5c d0 f2              BNE FA12_Ret
cd5e 4c 6e ca           JMP AFTF_80

              ; *************
cd61            Get_FAC1_Sign
              ; *************

cd61 a5 5e              LDA FAC1EX
cd63 f0 09              BEQ GFS_Ret
cd65 a5 63    GFS_10    LDA FAC1SI
cd67 2a       GFS_20    ROL A
cd68 a9 ff              LDA #$ff
cd6a b0 02              BCS GFS_Ret
cd6c a9 01              LDA #1
cd6e 60       GFS_Ret   RTS ;Size   14 [Get_FAC1_Sign]

              ; *********
cd6f            Basic_SGN
              ; *********

cd6f 20 61 cd           JSR Get_FAC1_Sign

              ; *********
cd72            A_To_FAC1
              ; *********

cd72 85 5f              STA FAC1M1
cd74 a9 00              LDA #0
cd76 85 60              STA FAC1M2
cd78 a2 88              LDX #$88
cd7a a5 5f    ATOF_10   LDA FAC1M1
cd7c 49 ff              EOR #$ff
cd7e 2a                 ROL A               ; clear carry for negative numbers

              ; ***********************
cd7f            Convert_Integer_To_Real
              ; ***********************

cd7f a9 00              LDA #0
cd81 85 62              STA FAC1M4
cd83 85 61              STA FAC1M3
cd85 86 5e    CITR_10   STX FAC1EX
cd87 85 6d              STA FROUND
cd89 85 63              STA FAC1SI
cd8b 4c ff c9           JMP AFTF_50

              ; *********
cd8e            Basic_ABS
              ; *********

cd8e 46 63              LSR FAC1SI          ; clear bit 7 (sign)
cd90 60                 RTS ;Size    3 [Basic_ABS]

              ; ***************
cd91            Compare_FAC1_AY
              ; ***************

cd91 85 21              STA INDEXB

              ; *********************
cd93            Compare_FAC1_INDEXB_Y
              ; *********************

cd93 84 22              STY INDEXB+1        ; (INDEXB) = operand 2
cd95 a0 00              LDY #0
cd97 b1 21              LDA (INDEXB),Y      ; exp 2
cd99 c8                 INY                 ; Y = 1
cd9a aa                 TAX
cd9b f0 c4              BEQ Get_FAC1_Sign   ; branch if operand 2 is zero
cd9d b1 21              LDA (INDEXB),Y      ; M1
cd9f 45 63              EOR FAC1SI          ; EOR both sign bits
cda1 30 c2              BMI GFS_10          ; branch on different signs
cda3 e4 5e              CPX FAC1EX          ; compare exponents
cda5 d0 21              BNE CFAY_10         ; branch if not equal
cda7 b1 21              LDA (INDEXB),Y      ; M1
cda9 09 80              ORA #$80            ; remove sign
cdab c5 5f              CMP FAC1M1          ; compare M1's
cdad d0 19              BNE CFAY_10
cdaf c8                 INY                 ; Y = 2
cdb0 b1 21              LDA (INDEXB),Y
cdb2 c5 60              CMP FAC1M2          ; compare M2's
cdb4 d0 12              BNE CFAY_10
cdb6 c8                 INY                 ; Y = 3
cdb7 b1 21              LDA (INDEXB),Y
cdb9 c5 61              CMP FAC1M3          ; compare M3's
cdbb d0 0b              BNE CFAY_10
cdbd c8                 INY                 ; Y = 4
cdbe a9 7f              LDA #$7f
cdc0 c5 6d              CMP FROUND          ; $7f >= FROUND ?
cdc2 b1 21              LDA (INDEXB),Y
cdc4 e5 62              SBC FAC1M4          ; compare M4's and FROUND
cdc6 f0 39              BEQ FLSR_Ret
cdc8 a5 63    CFAY_10   LDA FAC1SI
cdca 90 02              BCC CFAY_20
cdcc 49 ff              EOR #$ff
cdce 4c 67 cd CFAY_20   JMP GFS_20

              ; ********
cdd1            FAC1_LSR
              ; ********

              ; Shift FAC1 right until the exponent is at $a0.
              ; This is the value for which the four mantissa bytes
              ; represent a 32 bit integer value.

cdd1 a5 5e              LDA FAC1EX
cdd3 d0 03              BNE FLSR_20
cdd5 4c f4 cc FLSR_10   JMP Set_FAC1        ; clear mantissa for zero exp
cdd8 38       FLSR_20   SEC
cdd9 e9 a0              SBC #$a0
cddb 20 f4 c6           JSR FAC1_LSB        ; shift bytes
cdde f0 1f              BEQ FLSR_40         ; -> done
cde0 a5 65              LDA BITS            ; check integer status
cde2 f0 02              BEQ FLSR_30         ; branch on integer
cde4 a9 80              LDA #$80            ; real
cde6 46 5f    FLSR_30   LSR FAC1M1          ; do a bit shift
cde8 66 60              ROR FAC1M2
cdea 66 61              ROR FAC1M3
cdec 66 62              ROR FAC1M4
cdee 66 6d              ROR FROUND
cdf0 05 6d              ORA FROUND          ; remember bits shifted off
cdf2 c8                 INY
cdf3 d0 f1              BNE FLSR_30
cdf5 24 63              BIT FAC1SI
cdf7 10 06              BPL FLSR_40         ; positive: finished
cdf9 0a                 ASL A               ; any 1 bits shifted off ?
cdfa 90 03              BCC FLSR_40         ; -> number was exact integer
cdfc 20 a5 ca           JSR Inc_FAC1_Mantissa ; subtract 1 from negative number
cdff 84 6d    FLSR_40   STY FROUND          ; FROUND = 0
ce01 60       FLSR_Ret  RTS ;Size   49 [FAC1_LSR]

ce02                    .FILL $ce02-* (0) ; 0 bytes

              ; *****************
ce02            Basic_INT ; $ce02
              ; *****************

              ; The BASIC int function is not restricted to the 16 bit
              ; range of integer variables. Its range is 32 bit.
              ; INT does not round, it looks for the integer lower or
              ; equal to the given value. E.g: int(-1.1) results in -2.

ce02 a5 5e              LDA FAC1EX
ce04 c9 a0              CMP #$a0
ce06 b0 f9              BCS FLSR_Ret        ; -> no bits after decimal point
ce08 20 d1 cd           JSR FAC1_LSR        ; normalise to integer
ce0b a9 a0              LDA #$a0
ce0d 85 5e              STA FAC1EX          ; set exponent for integer mantissa
ce0f a5 62              LDA FAC1M4
ce11 24 63              BIT FAC1SI
ce13 10 05              BPL INT_10
ce15 38                 SEC
ce16 a9 00              LDA #0
ce18 e5 62              SBC FAC1M4
ce1a 85 03    INT_10    STA CHARAC          ; needed from Basic_EXP
ce1c 4c 0d ca           JMP Normalise_FAC1  ; normalise back to real

ce1f 00 00 00           .FILL $ce29-* (0) ; 10 bytes

              ; *************************
ce29            Read_Real_To_FAC1 ; $ce29
              ; *************************

              ; This subroutine parses a string via CHRGET and
              ; converts it into a floating point value in FAC1.

              ;         TMPVAR   = digits after decimal point
              ;         TMPVAR+1 = exponent
              ;         TMPPTC   = bit 7 : flag for '.' decimal point
              ;         TMPPTC+1 = bit 7 : flag for '-' sign

ce29 a0 00              LDY #0
ce2b a2 0a              LDX #10
ce2d 94 5a    RRTF_02   STY TMPVAR,X        ; clear TMPVAR, TMPPTC and FAC1
ce2f ca                 DEX
ce30 10 fb              BPL RRTF_02         ; X = $ff at end
ce32 90 68              BCC RRTF_34         ; -> numeric
ce34 c9 2b              CMP #'+'            ; positive sign ?
ce36 f0 06              BEQ RRTF_04         ; -> get next
ce38 c9 2d              CMP #'-'            ; negative sign ?
ce3a d0 07              BNE RRTF_06
ce3c 86 64              STX SGNFLG          ; sign flag = $ff
ce3e 20 70 00 RRTF_04   JSR CHRGET          ; next character after sign
ce41 90 59              BCC RRTF_34         ; -> numeric
ce43 c9 2e    RRTF_06   CMP #'.'            ; decimal point ?
ce45 f0 2c              BEQ RRTF_20         ; -> now the fractional part
ce47 c9 45              CMP #'E'            ; exponent ?
ce49 d0 2e              BNE RRTF_22
ce4b 20 70 00           JSR CHRGET          ; read character of exponent
ce4e 90 77              BCC RRTF_40         ; -> numeric
ce50 c9 aa              CMP #$aa            ; '+' token
ce52 f0 0e              BEQ RRTF_10
ce54 c9 2b              CMP #'+'            ; '+' sign of exponent
ce56 f0 0a              BEQ RRTF_10
ce58 c9 ab              CMP #$ab            ; '-' token
ce5a f0 04              BEQ RRTF_08
ce5c c9 2d              CMP #'-'            ; '-' sign of exponent
ce5e d0 07              BNE RRTF_12
ce60 66 5d    RRTF_08   ROR TMPPTC+1        ; flag negative sign
ce62 20 70 00 RRTF_10   JSR CHRGET          ; read character of exponent
ce65 90 60              BCC RRTF_40         ; -> numeric
ce67 24 5d    RRTF_12   BIT TMPPTC+1
ce69 10 0e              BPL RRTF_22         ; -> positive exponent
ce6b a9 00              LDA #0
ce6d 38                 SEC
ce6e e5 5b              SBC TMPVAR+1        ; -> negative exponent
ce70 4c 7b ce           JMP RRTF_24

ce73 66 5c    RRTF_20   ROR TMPPTC          ; bit 7 = flag for '.'
ce75 24 5c              BIT TMPPTC
ce77 50 c5              BVC RRTF_04         ; break if 2nd. dot read

ce79 a5 5b    RRTF_22   LDA TMPVAR+1        ; exponent read
ce7b 38       RRTF_24   SEC
ce7c e5 5a              SBC TMPVAR          ; minus # of digits after '.'
ce7e 85 5b              STA TMPVAR+1        ; effective exponent
ce80 f0 12              BEQ RRTF_30         ; -> zero exponent
ce82 10 09              BPL RRTF_28         ; -> pos. exponent

ce84 20 34 cc RRTF_26   JSR Divide_FAC1_By_10 ; neg. exponent
ce87 e6 5b              INC TMPVAR+1
ce89 d0 f9              BNE RRTF_26
ce8b f0 07              BEQ RRTF_30

ce8d 20 18 cc RRTF_28   JSR Multiply_FAC1_BY_10 ; apply positive exponent
ce90 c6 5b              DEC TMPVAR+1
ce92 d0 f9              BNE RRTF_28

ce94 a5 64    RRTF_30   LDA SGNFLG
ce96 30 01              BMI RRTF_32         ; -> negate result
ce98 60                 RTS ;Size  112 [Read_Real_To_FAC1]

ce99 4c 4b d1 RRTF_32   JMP Op_NEGATE

ce9c 48       RRTF_34   PHA                 ; result = result * 10 + digit
ce9d 24 5c              BIT TMPPTC
ce9f 10 02              BPL RRTF_36
cea1 e6 5a              INC TMPVAR          ; count digits after decimal point
cea3 20 18 cc RRTF_36   JSR Multiply_FAC1_BY_10
cea6 68                 PLA
cea7 29 0f              AND #15             ; PETSCII -> binary
cea9 20 b4 ce           JSR Add_A_To_FAC1
ceac 4c 3e ce           JMP RRTF_04

ceaf 00 00 00           .FILL $ceb4-* (0) ; 5 bytes

              ; *********************
ceb4            Add_A_To_FAC1 ; $ceb4
              ; *********************

ceb4 48                 PHA
ceb5 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
ceb8 68                 PLA
ceb9 20 72 cd           JSR A_To_FAC1
cebc a5 6b              LDA FAC2SI
cebe 45 63              EOR FAC1SI
cec0 85 6c              STA STRPTR
cec2 a6 5e              LDX FAC1EX
cec4 4c a0 c9           JMP Op_PLUS

              ; read digits for exponent

cec7 a5 5b    RRTF_40   LDA TMPVAR+1        ; exponent so far
cec9 c9 0a              CMP #10             ; alreay two digits ?
cecb 90 09              BCC RRTF_42         ; -> OK if less than 10
cecd a9 64              LDA #100            ; exponent = 100
cecf 24 5d              BIT TMPPTC+1
ced1 30 11              BMI RRTF_44         ; -> negative exponent
ced3 4c b4 ca           JMP Overflow_Error  ; max value = 37
ced6 0a       RRTF_42   ASL A               ; * 2
ced7 0a                 ASL A               ; * 4
ced8 18                 CLC
ced9 65 5b              ADC TMPVAR+1        ; * 5
cedb 0a                 ASL A               ; * 10
cedc 18                 CLC
cedd a0 00              LDY #0
cedf 71 77              ADC (TXTPTR),Y
cee1 38                 SEC
cee2 e9 30              SBC #'0'
cee4 85 5b    RRTF_44   STA TMPVAR+1        ; new value for exponent
cee6 4c 62 ce           JMP RRTF_10

              ; *********
cee9            REAL_1e8
              ; *********

cee9 9b 3e bc 20 00     .REAL $9b3ebc2000   ; 1e8

              ; *********
ceee            REAL_9x9
              ; *********

ceee 9e 6e 6b 27 fe     .REAL $9e6e6b27fe   ;  999999999.5

              ; *********
cef3            REAL_1e9
              ; *********

cef3 9e 6e 6b 28 00     .REAL $9e6e6b2800   ; 1e9

cef8 42 53 4f BSOS_TEXT .BYTE "BSOS BOOT"

              ; **********
cf01            Option_ROM
              ; **********

cf01 a2 03              LDX #3
cf03 bd 00 90 OpRO_10   LDA $9000,X         ; check $9000 ROM
cf06 dd f8 ce           CMP BSOS_TEXT,X
cf09 d0 06              BNE OpRO_20
cf0b ca                 DEX
cf0c 10 f5              BPL OpRO_10
cf0e 20 04 90           JSR $9004
cf11 a2 03    OpRO_20   LDX #3
cf13 bd 00 a0 OpRO_30   LDA $a000,X         ; check $a000 ROM
cf16 dd f8 ce           CMP BSOS_TEXT,X
cf19 d0 06              BNE OpRO_40
cf1b ca                 DEX
cf1c 10 f5              BPL OpRO_30
cf1e 4c 04 a0           JMP $a004
cf21 60       OpRO_40   RTS ;Size   33 [Option_ROM]

              ; *********
cf22            BOOT_File
              ; *********

cf22 24 98              BIT Key_Flags
cf24 10 fb              BPL OpRO_40         ; skip if SHIFT pressed
cf26 a9 f8              LDA #<BSOS_TEXT     ; look for boot file
cf28 85 da              STA FNADR
cf2a a9 ce              LDA #>BSOS_TEXT
cf2c 85 db              STA FNADR+1
cf2e a9 09              LDA #?BSOS_TEXT
cf30 85 d1              STA FNLEN
cf32 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
cf35 a9 00              LDA #0
cf37 85 d3              STA SA              ; enforce load to $0401
cf39 a5 28              LDA TXTTAB
cf3b a6 29              LDX TXTTAB+1
cf3d 85 c9              STA EAL             ; TXTTAB (normally $0401)
cf3f 86 ca              STX EAL+1
cf41 20 d0 f3           JSR Open_Load_File
cf44 a5 96              LDA STATUS
cf46 f0 06              BEQ BOFi_10
cf48 20 ae f1           JSR UNTLK           ; not there
cf4b 4c 91 d9           JMP Kernal_Read_DS  ; clear status and return
cf4e 20 8e f3 BOFi_10   JSR LoFi_30         ; load boot file
cf51 a5 c9              LDA EAL
cf53 85 2a              STA VARTAB
cf55 a5 ca              LDA EAL+1
cf57 85 2b              STA VARTAB+1
cf59 20 e9 b5           JSR Reset_BASIC_Execution
cf5c 20 b6 b4           JSR Rechain
cf5f 4c 4a b7           JMP Execute

cf62 00 00 00           .FILL $cf78-* (0) ; 22 bytes

              ; ********
cf78            Print_IN
              ; ********

cf78 a9 0d              LDA #<Msg_IN
cf7a a0 b3              LDY #>Msg_IN
cf7c 20 90 cf           JSR To_Print_String
cf7f a5 37              LDA CURLIN+1
cf81 a6 36              LDX CURLIN

              ; ****************
cf83            Print_Integer_XA
              ; ****************

cf83 85 5f              STA FAC1M1
cf85 86 60              STX FAC1M2
cf87 a2 90              LDX #$90
cf89 38                 SEC
cf8a 20 7f cd           JSR Convert_Integer_To_Real
cf8d 20 93 cf           JSR Format_FAC1

              ; ***************
cf90            To_Print_String
              ; ***************

cf90 4c 1d bb           JMP Print_String

              ; *******************
cf93            Format_FAC1 ; $cf93
              ; *******************

cf93 a0 01              LDY #1              ; start of string storage

              ; =====================
cf95            Format_FAC1_Y ; $cf95
              ; =====================

              ; Format floating point number in FAC1
              ; The string is stored starting at $ff for Y=0
              ; and extending into the bottom of the stack

cf95 a9 00              LDA #0
cf97 85 5a              STA TMPVAR          ; 10's exponent

              ; the first character is blank for positive or '-'
              ; for negative numbers

cf99 a9 20              LDA #' '
cf9b 24 63              BIT FAC1SI
cf9d 10 02              BPL FoFA_02
cf9f a9 2d              LDA #'-'
cfa1 99 ff 00 FoFA_02   STA STACK-1,Y       ; 1.st char ' ' or '-'
cfa4 85 63              STA FAC1SI          ; delete sign info from FAC1
cfa6 84 6e              STY TMPPTD          ; save Y
cfa8 c8                 INY                 ; next string position
cfa9 a9 30              LDA #'0'            ; default for value zero

              ; if the value is zero, store '0' and finish

cfab a6 5e              LDX FAC1EX
cfad d0 03              BNE FoFA_04         ; -> non zero
cfaf 4c b6 d0           JMP FoFA_94         ; store '0' and finish

              ; if the value is less than 1.0, scale it with 1.0e+9
              ; and store the scaled 10's exponent (-9) in TMPVAR
              ; this saves 9 iterations in loop FoFA_08

cfb2 a9 00    FoFA_04   LDA #0
cfb4 e0 81              CPX #$81            ; exponent for >= 1.0
cfb6 b0 09              BCS FoFA_06
cfb8 a9 f3              LDA #<REAL_1e9
cfba a0 ce              LDY #>REAL_1e9
cfbc 20 5e cb           JSR Multiply_FAC1_With_AY
cfbf a9 f7              LDA #-9
cfc1 85 5a    FoFA_06   STA TMPVAR          ; current 10's exponent

              ; scale FAC1 up until the number has more than 8 digits

cfc3 a9 e9    FoFA_08   LDA #<REAL_1e8
cfc5 a0 ce              LDY #>REAL_1e8
cfc7 20 91 cd           JSR Compare_FAC1_AY
cfca 10 0c              BPL FoFA_12         ; FAC1 >= REAL_1e8 ->
cfcc 20 18 cc           JSR Multiply_FAC1_BY_10
cfcf c6 5a              DEC TMPVAR          ; decrement 10's exponent
cfd1 d0 f0              BNE FoFA_08         ; always

              ; scale FAC1 down until the number has less than 10 digits

cfd3 20 34 cc FoFA_10   JSR Divide_FAC1_By_10
cfd6 e6 5a              INC TMPVAR          ; increment 10's exponent
cfd8 a9 ee    FoFA_12   LDA #<REAL_9x9
cfda a0 ce              LDY #>REAL_9x9      ; 999999999.5
cfdc 20 91 cd           JSR Compare_FAC1_AY
cfdf 10 f2              BPL FoFA_10         ; FAC1 > REAL_9x9 -> continue scaling

              ; scaling is done - now convert the digits before the decimal
              ; point into a 32 bit integer

cfe1 20 7f c9           JSR Add_0_5_To_FAC1 ; add 0.5 for rounding
cfe4 20 d1 cd           JSR FAC1_LSR        ; convert to integer

              ; choose fixed point format if -2 < exp < 10
              ; else format in exponential format

cfe7 a2 01              LDX #1
cfe9 a5 5a              LDA TMPVAR          ; current 10's exponent
cfeb 18                 CLC
cfec 69 0a              ADC #10             ; exp difference
cfee 30 09              BMI FoFA_14         ; value < 1.0
cff0 c9 0b              CMP #11
cff2 b0 06              BCS FoFA_16         ; value >= 1e9
cff4 69 ff              ADC #$ff
cff6 aa                 TAX                 ; X = exp + 9
cff7 a9 02              LDA #2              ; fixed point
cff9 38       FoFA_14   SEC
cffa e9 02    FoFA_16   SBC #2
cffc 85 5b              STA TMPVAR+1        ; exp print = 0 or exp+8
cffe 86 5a              STX TMPVAR          ; digits before decimal point
d000 8a                 TXA
d001 f0 02              BEQ FoFA_18         ; -> if no digits before point
d003 10 13              BPL FoFA_22
d005 a4 6e    FoFA_18   LDY TMPPTD
d007 a9 2e              LDA #'.'
d009 c8                 INY
d00a 99 ff 00           STA STACK-1,Y       ; insert decimal point
d00d 8a                 TXA
d00e f0 06              BEQ FoFA_20
d010 a9 30              LDA #'0'
d012 c8                 INY
d013 99 ff 00           STA STACK-1,Y       ; insert '0'
d016 84 6e    FoFA_20   STY TMPPTD
d018 a0 00    FoFA_22   LDY #0

              ; =================
d01a            Format_Jiffyclock
              ; =================

d01a a2 80              LDX #$80
d01c 18       FoFA_78   CLC
d01d a5 62              LDA FAC1M4
d01f 79 cf d0           ADC Decimal_Conversion_Table+3,Y
d022 85 62              STA FAC1M4
d024 a5 61              LDA FAC1M3
d026 79 ce d0           ADC Decimal_Conversion_Table+2,Y
d029 85 61              STA FAC1M3
d02b a5 60              LDA FAC1M2
d02d 79 cd d0           ADC Decimal_Conversion_Table+1,Y
d030 85 60              STA FAC1M2
d032 a5 5f              LDA FAC1M1
d034 79 cc d0           ADC Decimal_Conversion_Table,Y
d037 85 5f              STA FAC1M1
d039 e8                 INX
d03a b0 04              BCS FoFA_80
d03c 10 de              BPL FoFA_78
d03e 30 02              BMI FoFA_82

d040 30 da    FoFA_80   BMI FoFA_78
d042 8a       FoFA_82   TXA
d043 90 04              BCC FoFA_84
d045 49 ff              EOR #$ff
d047 69 0a              ADC #10
d049 69 2f    FoFA_84   ADC #'0'-1
d04b c8                 INY
d04c c8                 INY
d04d c8                 INY
d04e c8                 INY                 ; Y += 4
d04f 84 44              STY VARPTR          ; save index to table
d051 a4 6e              LDY TMPPTD          ; get index to string
d053 c8                 INY
d054 aa                 TAX
d055 29 7f              AND #$7f
d057 99 ff 00           STA STACK-1,Y       ; store digit
d05a c6 5a              DEC TMPVAR          ; # of digits
d05c d0 06              BNE FoFA_86         ; -> if not zero
d05e a9 2e              LDA #'.'
d060 c8                 INY
d061 99 ff 00           STA STACK-1,Y       ; store decimal point
d064 84 6e    FoFA_86   STY TMPPTD          ; save string index
d066 a4 44              LDY VARPTR          ; get table index
d068 8a                 TXA
d069 49 ff              EOR #$ff
d06b 29 80              AND #$80
d06d aa                 TAX
d06e c0 24              CPY #$24            ; end of decimal table ?
d070 f0 04              BEQ FoFA_88
d072 c0 3c              CPY #$3c            ; end of jiffy table ?
d074 d0 a6              BNE FoFA_78

              ; remove trailing zeroes

d076 a4 6e    FoFA_88   LDY TMPPTD          ; get string index
d078 b9 ff 00 FoFA_90   LDA STACK-1,Y
d07b 88                 DEY
d07c c9 30              CMP #'0'
d07e f0 f8              BEQ FoFA_90
d080 c9 2e              CMP #'.'
d082 f0 01              BEQ FoFA_91
d084 c8                 INY
d085 a9 2b    FoFA_91   LDA #'+'            ; default sign for exponent
d087 a6 5b              LDX TMPVAR+1
d089 f0 2e              BEQ FoFA_95         ; -> no exponent
d08b 10 08              BPL FoFA_92         ; -> positive exponent
d08d a9 00              LDA #0
d08f 38                 SEC
d090 e5 5b              SBC TMPVAR+1        ; negate exponent
d092 aa                 TAX
d093 a9 2d              LDA #'-'            ; negative sign for exponent
d095 99 01 01 FoFA_92   STA STACK+1,Y
d098 a9 45              LDA #'E'
d09a 99 00 01           STA STACK,Y
d09d 8a                 TXA
d09e a2 2f              LDX #'0'-1
d0a0 38                 SEC
d0a1 e8       FoFA_93   INX
d0a2 e9 0a              SBC #10
d0a4 b0 fb              BCS FoFA_93
d0a6 69 3a              ADC #'0'+10
d0a8 99 03 01           STA STACK+3,Y
d0ab 8a                 TXA
d0ac 99 02 01           STA STACK+2,Y
d0af a9 00              LDA #0
d0b1 99 04 01           STA STACK+4,Y
d0b4 f0 08              BEQ FoFA_96         ; always

d0b6 99 ff 00 FoFA_94   STA STACK-1,Y
d0b9 a9 00    FoFA_95   LDA #0
d0bb 99 00 01           STA STACK,Y
d0be a9 00    FoFA_96   LDA #0
d0c0 a0 01              LDY #1
d0c2 60                 RTS ;Size  304 [Format_FAC1]

d0c3 00 00 00           .FILL $d0c7-* (0) ; 4 bytes

              ; *****************
d0c7            Float_0_5 ; $d0c7
              ; *****************

d0c7 80 00 00 00 00     .REAL $8000000000   ;    0.50000000000

              ; ************************
d0cc            Decimal_Conversion_Table
              ; ************************

d0cc fa 0a 1f           .QUAD $fa0a1f00     ; -100000000
d0d0 00 98 96           .QUAD $00989680     ;   10000000
d0d4 ff f0 bd           .QUAD $fff0bdc0     ;   -1000000
d0d8 00 01 86           .QUAD $000186a0     ;     100000
d0dc ff ff d8           .QUAD $ffffd8f0     ;     -10000
d0e0 00 00 03           .QUAD $000003e8     ;       1000
d0e4 ff ff ff           .QUAD $ffffff9c     ;       -100
d0e8 00 00 00           .QUAD $0000000a     ;         10
d0ec ff ff ff           .QUAD $ffffffff     ;         -1

              ; **********************
d0f0            Jiffy_Conversion_Table
              ; **********************

d0f0 ff df 0a           .QUAD $ffdf0a80     ;   -2160000
d0f4 00 03 4b           .QUAD $00034bc0     ;     216000
d0f8 ff ff 73           .QUAD $ffff7360     ;     -36000
d0fc 00 00 0e           .QUAD $00000e10     ;       3600
d100 ff ff fd           .QUAD $fffffda8     ;       -600
d104 00 00 00           .QUAD $0000003c     ;         60

              ; *****************
d108            Basic_SQR ; $d108
              ; *****************

d108 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d10b a9 c7              LDA #<Float_0_5
d10d a0 d0              LDY #>Float_0_5
d10f 20 d8 cc           JSR Load_FAC1_AY    ; perform (arg)^0.5

              ; ********
d112            Op_POWER
              ; ********

d112 f0 70              BEQ Basic_EXP       ; -> FAC1 == 0
d114 a5 66              LDA FAC2EX
d116 d0 03              BNE PWR_10
d118 4c 2f ca           JMP CF1_10
d11b a2 4b    PWR_10    LDX #<FUNCPT
d11d a0 00              LDY #>FUNCPT
d11f 20 0a cd           JSR FAC1_To_XY
d122 a5 6b              LDA FAC2SI
d124 10 0f              BPL PWR_20
d126 20 02 ce           JSR Basic_INT
d129 a9 4b              LDA #<FUNCPT
d12b a0 00              LDY #>FUNCPT
d12d 20 91 cd           JSR Compare_FAC1_AY
d130 d0 03              BNE PWR_20
d132 98                 TYA
d133 a4 03              LDY CHARAC
d135 20 34 cd PWR_20    JSR Copy_ABS_FAC2_To_FAC1
d138 98                 TYA
d139 48                 PHA
d13a 20 20 cb           JSR Basic_LOG
d13d a9 4b              LDA #<FUNCPT
d13f a0 00              LDY #>FUNCPT
d141 20 5e cb           JSR Multiply_FAC1_With_AY
d144 20 84 d1           JSR Basic_EXP
d147 68                 PLA
d148 4a                 LSR A
d149 90 0a              BCC NEGA_Ret

              ; *********
d14b            Op_NEGATE
              ; *********

d14b a5 5e              LDA FAC1EX
d14d f0 06              BEQ NEGA_Ret
d14f a5 63              LDA FAC1SI
d151 49 ff              EOR #$ff            ; change sign
d153 85 63              STA FAC1SI
d155 60       NEGA_Ret  RTS ;Size   11 [Op_NEGATE]

              ; *********
d156            REV_LOG_2
              ; *********

d156 81 38 aa 3b 29     .REAL $8138aa3b29   ;    1.44269504072
d15b 07       VAR_EXP   .BYTE $07
d15c 71 34 58 3e 56     .REAL $7134583e56   ;    0.00002149876
d161 74 16 7e b3 1b     .REAL $74167eb31b   ;    0.00014352314
d166 77 2f ee e3 85     .REAL $772feee385   ;    0.00134226348
d16b 7a 1d 84 1c 2a     .REAL $7a1d841c2a   ;    0.00961401701
d170 7c 63 59 58 0a     .REAL $7c6359580a   ;    0.05550512686
d175 7e 75 fd e7 c6     .REAL $7e75fde7c6   ;    0.24022638460
d17a 80 31 72 18 10     .REAL $8031721810   ;    0.69314718619
d17f 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; *********
d184            Basic_EXP
              ; *********

d184 a9 56              LDA #<REV_LOG_2
d186 a0 d1              LDY #>REV_LOG_2
d188 20 5e cb           JSR Multiply_FAC1_With_AY
d18b a5 6d              LDA FROUND
d18d 69 50              ADC #$50
d18f 90 03              BCC EXP_10
d191 20 59 cd           JSR Inc_FAC1
d194 85 53    EXP_10    STA FUNJMP+1        ; FROUND + $50
d196 20 45 cd           JSR FAC1_To_FAC2
d199 a5 5e              LDA FAC1EX
d19b c9 88              CMP #$88
d19d 90 03              BCC EXP_30          ; -> value < 128
d19f 20 07 cc EXP_20    JSR ChFA_40         ; Floating Point Exception
d1a2 20 02 ce EXP_30    JSR Basic_INT       ; convert to integer
d1a5 a5 03              LDA CHARAC
d1a7 49 80              EOR #$80
d1a9 48                 PHA
d1aa a2 05              LDX #5
d1ac b5 66    EXP_40    LDA FAC2EX,X
d1ae b4 5e              LDY FAC1EX,X
d1b0 95 5e              STA FAC1EX,X
d1b2 94 66              STY FAC2EX,X
d1b4 ca                 DEX
d1b5 10 f5              BPL EXP_40
d1b7 a5 53              LDA FUNJMP+1
d1b9 85 6d              STA FROUND
d1bb 20 89 c9           JSR Op_MINUS
d1be 20 4b d1           JSR Op_NEGATE
d1c1 a9 5b              LDA #<VAR_EXP
d1c3 a0 d1              LDY #>VAR_EXP
d1c5 20 ed d1           JSR Eval_Series_AY
d1c8 a9 00              LDA #0
d1ca 85 6c              STA STRPTR
d1cc 68                 PLA
d1cd 20 ef cb           JSR ChFA_10
d1d0 60                 RTS ;Size   77 [Basic_EXP]

d1d1 00 00 00           .FILL $d1d7-* (0) ; 6 bytes

              ; ******************************
d1d7            Square_And_Series_Eval ; $d1d7
              ; ******************************

d1d7 85 6e              STA TMPPTD
d1d9 84 6f              STY TMPPTD+1
d1db 20 00 cd           JSR FAC1_To_FACTPA
d1de a9 54              LDA #<FACTPA        ; Y = 0
d1e0 20 5e cb           JSR Multiply_FAC1_With_AY
d1e3 20 f1 d1           JSR Eval_Series
d1e6 a9 54              LDA #<FACTPA
d1e8 a0 00              LDY #>FACTPA
d1ea 4c 5e cb           JMP Multiply_FAC1_With_AY

              ; **************
d1ed            Eval_Series_AY
              ; **************

d1ed 85 6e              STA TMPPTD
d1ef 84 6f              STY TMPPTD+1

              ; ***********
d1f1            Eval_Series
              ; ***********

d1f1 20 fd cc           JSR FAC1_To_FACTPB
d1f4 b1 6e              LDA (TMPPTD),Y
d1f6 85 64              STA SGNFLG          ; # of terms
d1f8 a4 6e              LDY TMPPTD
d1fa c8                 INY
d1fb 98                 TYA
d1fc d0 02              BNE EvSe_10
d1fe e6 6f              INC TMPPTD+1
d200 85 6e    EvSe_10   STA TMPPTD
d202 a4 6f              LDY TMPPTD+1
d204 20 5e cb EvSe_20   JSR Multiply_FAC1_With_AY
d207 a5 6e              LDA TMPPTD
d209 a4 6f              LDY TMPPTD+1
d20b 18                 CLC
d20c 69 05              ADC #5              ; advance polynomial pointer
d20e 90 01              BCC EvSe_30
d210 c8                 INY
d211 85 6e    EvSe_30   STA TMPPTD
d213 84 6f              STY TMPPTD+1
d215 20 9d c9           JSR Add_Var_AY_To_FAC1
d218 a9 59              LDA #<FACTPB
d21a a0 00              LDY #>FACTPB
d21c c6 64              DEC SGNFLG
d21e d0 e4              BNE EvSe_20         ; -> next polynomial
d220 60                 RTS ;Size   48 [Eval_Series]

d221 98 35 44 RND_VA    .QUAD $9835447a     ; -1741339526
d225 68 28 b1 RND_VB    .QUAD $6828b146     ;  1747497286

              ; *********
d229            Basic_RND
              ; *********

              ; The random factor argument from RND(arg) is interpreted:
              ; arg < 0 : use argument as random seed
              ; arg = 0 : use timer 1 and 2 for random seed
              ; arg > 0 : start with fixed random seed from ROM

d229 20 61 cd           JSR Get_FAC1_Sign
d22c 30 2e              BMI RND_20
d22e d0 17              BNE RND_10
d230 ad 44 e8           LDA VIA_Timer_1_Lo  ; timer seed
d233 85 5f              STA FAC1M1
d235 ad 48 e8           LDA VIA_Timer_2_Lo
d238 85 60              STA FAC1M2
d23a ad 45 e8           LDA VIA_Timer_1_Hi
d23d 85 61              STA FAC1M3
d23f ad 49 e8           LDA VIA_Timer_2_Hi
d242 85 62              STA FAC1M4
d244 4c 6c d2           JMP RND_30
d247 a9 88    RND_10    LDA #<RNDX          ; fixed seed
d249 a0 00              LDY #>RNDX
d24b 20 d8 cc           JSR Load_FAC1_AY
d24e a9 21              LDA #<RND_VA
d250 a0 d2              LDY #>RND_VA
d252 20 5e cb           JSR Multiply_FAC1_With_AY
d255 a9 25              LDA #<RND_VB
d257 a0 d2              LDY #>RND_VB
d259 20 9d c9           JSR Add_Var_AY_To_FAC1
d25c a6 62    RND_20    LDX FAC1M4          ; argument seed
d25e a5 5f              LDA FAC1M1
d260 85 62              STA FAC1M4
d262 86 5f              STX FAC1M1
d264 a6 60              LDX FAC1M2
d266 a5 61              LDA FAC1M3
d268 85 60              STA FAC1M2
d26a 86 61              STX FAC1M3
d26c a9 00    RND_30    LDA #0
d26e 85 63              STA FAC1SI
d270 a5 5e              LDA FAC1EX
d272 85 6d              STA FROUND
d274 a9 80              LDA #$80
d276 85 5e              STA FAC1EX
d278 20 0d ca           JSR Normalise_FAC1
d27b a2 88              LDX #<RNDX
d27d a0 00              LDY #>RNDX
d27f 4c 0a cd           JMP FAC1_To_XY

              ; *********
d282            Basic_COS
              ; *********

d282 a9 fe              LDA #<PI_Half
d284 a0 d2              LDY #>PI_Half
d286 20 9d c9           JSR Add_Var_AY_To_FAC1

              ; *****************
d289            Basic_SIN ; $d289
              ; *****************

d289 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d28c a9 03              LDA #<Two_PI
d28e a0 d3              LDY #>Two_PI
d290 a6 6b              LDX FAC2SI
d292 20 3d cc           JSR Divide_FAC2_By_AY ; arg / (2 pi)
d295 20 42 cd           JSR FAC1_Round_And_Copy_To_FAC2
d298 20 02 ce           JSR Basic_INT
d29b a9 00              LDA #0
d29d 85 6c              STA STRPTR
d29f 20 89 c9           JSR Op_MINUS
d2a2 a9 08              LDA #<Float_0_25
d2a4 a0 d3              LDY #>Float_0_25
d2a6 20 86 c9           JSR AY_Minus_FAC1
d2a9 a5 63              LDA FAC1SI
d2ab 48                 PHA
d2ac 10 0d              BPL SIN_10
d2ae 20 7f c9           JSR Add_0_5_To_FAC1
d2b1 a5 63              LDA FAC1SI
d2b3 30 09              BMI SIN_20
d2b5 a5 0c              LDA TANSGN
d2b7 49 ff              EOR #$ff
d2b9 85 0c              STA TANSGN
d2bb 20 4b d1 SIN_10    JSR Op_NEGATE
d2be a9 08    SIN_20    LDA #<Float_0_25
d2c0 a0 d3              LDY #>Float_0_25
d2c2 20 9d c9           JSR Add_Var_AY_To_FAC1
d2c5 68                 PLA
d2c6 10 03              BPL SIN_30
d2c8 20 4b d1           JSR Op_NEGATE
d2cb a9 0d    SIN_30    LDA #<VAR_SIN
d2cd a0 d3              LDY #>VAR_SIN
d2cf 4c d7 d1           JMP Square_And_Series_Eval

              ; *********
d2d2            Basic_TAN
              ; *********

d2d2 20 00 cd           JSR FAC1_To_FACTPA
d2d5 a9 00              LDA #0
d2d7 85 0c              STA TANSGN
d2d9 20 89 d2           JSR Basic_SIN
d2dc a2 4b              LDX #<FUNCPT
d2de a0 00              LDY #>FUNCPT
d2e0 20 0a cd           JSR FAC1_To_XY
d2e3 a9 54              LDA #<FACTPA
d2e5 a0 00              LDY #>FACTPA
d2e7 20 d8 cc           JSR Load_FAC1_AY
d2ea a9 00              LDA #0
d2ec 85 63              STA FAC1SI
d2ee a5 0c              LDA TANSGN
d2f0 20 fa d2           JSR TAN_10
d2f3 a9 4b              LDA #<FUNCPT
d2f5 a0 00              LDY #>FUNCPT
d2f7 4c 45 cc           JMP AY_Divided_By_FAC1

              ; ******
d2fa            TAN_10
              ; ******

d2fa 48                 PHA
d2fb 4c bb d2           JMP SIN_10
d2fe 81 49 0f PI_Half   .REAL $81490fdaa2   ;    1.57079632673
d303 83 49 0f Two_PI    .REAL $83490fdaa2   ;    6.28318530694

              ; **********
d308            Float_0_25
              ; **********

d308 7f 00 00 00 00     .REAL $7f00000000   ;    0.25000000000
d30d 05       VAR_SIN   .BYTE $05
d30e 84 e6 1a 2d 1b     .REAL $84e61a2d1b   ;  -14.38139067218
d313 86 28 07 fb f8     .REAL $862807fbf8   ;   42.00779712200
d318 87 99 68 89 01     .REAL $8799688901   ;  -76.70417025685
d31d 87 23 35 df e1     .REAL $872335dfe1   ;   81.60522368550
d322 86 a5 5d e7 28     .REAL $86a55de728   ;  -41.34170210361
d327 83 49 0f da a2     .REAL $83490fdaa2   ;    6.28318530694

              ; *****************
d32c            Basic_ATN ; $d32c
              ; *****************

d32c a5 63              LDA FAC1SI
d32e 48                 PHA                 ; save sign
d32f a9 00              LDA #0
d331 85 63              STA FAC1SI          ; use symmetry of arctangent
d333 a5 5e              LDA FAC1EX
d335 c9 81              CMP #$81
d337 08                 PHP                 ; save flags
d338 90 07              BCC ATN_20          ; -> arg < 1.0
d33a a9 f2              LDA #<REAL_1
d33c a0 ca              LDY #>REAL_1
d33e 20 45 cc           JSR AY_Divided_By_FAC1
d341 a9 5c    ATN_20    LDA #<VAR_ATN
d343 a0 d3              LDY #>VAR_ATN
d345 20 d7 d1           JSR Square_And_Series_Eval
d348 28                 PLP                 ; restore comparison flags
d349 90 07              BCC ATN_30          ; -> arg < 1.0
d34b a9 fe              LDA #<PI_Half
d34d a0 d2              LDY #>PI_Half
d34f 20 86 c9           JSR AY_Minus_FAC1
d352 68       ATN_30    PLA
d353 85 63              STA FAC1SI          ; use same sign as arguemnt
d355 60                 RTS ;Size   42 [Basic_ATN]

d356 00 00 00           .FILL $d35c-* (0) ; 6 bytes

              ; ***************
d35c            VAR_ATN ; $d35c
              ; ***************

d35c 0b                 .BYTE $0b
d35d 76 b3 83 bd d3     .REAL $76b383bdd3   ;   -0.00068479391
d362 79 1e f4 a6 f5     .REAL $791ef4a6f5   ;    0.00485094216
d367 7b 83 fc b0 10     .REAL $7b83fcb010   ;   -0.01611170184
d36c 7c 0c 1f 67 ca     .REAL $7c0c1f67ca   ;    0.03420963805
d371 7c de 53 cb c1     .REAL $7cde53cbc1   ;   -0.05427913276
d376 7d 14 64 70 4c     .REAL $7d1464704c   ;    0.07245719654
d37b 7d b7 ea 51 7a     .REAL $7db7ea517a   ;   -0.08980239538
d380 7d 63 30 88 7e     .REAL $7d6330887e   ;    0.11093241343
d385 7e 92 44 99 3a     .REAL $7e9244993a   ;   -0.14283980767
d38a 7e 4c cc 91 c7     .REAL $7e4ccc91c7   ;    0.19999912049
d38f 7f aa aa aa 13     .REAL $7faaaaaa13   ;   -0.33333331568
d394 81 00 00 00 00     .REAL $8100000000   ;    1.00000000000

              ; **********
d399            CHRGET_ROM
              ; **********

d399 e6 77              INC TXTPTR
d39b d0 02              BNE CHRG_10
d39d e6 78              INC TXTPTR+1
d39f ad 60 ea CHRG_10   LDA $ea60           ; dummy address
d3a2 c9 3a              CMP #':'
d3a4 b0 0a              BCS CHRG_20
d3a6 c9 20              CMP #' '
d3a8 f0 ef              BEQ CHRGET_ROM
d3aa 38                 SEC
d3ab e9 30              SBC #'0'
d3ad 38                 SEC
d3ae e9 d0              SBC #$d0
d3b0 60       CHRG_20   RTS ;Size   24 [CHRGET_ROM]

d3b1 80 4f c7 52 58     .REAL $804fc75258   ;    0.81163515709

              ; **********************
d3b6            Init_BASIC_RAM_Vectors
              ; **********************

d3b6 20 0e b6           JSR Flush_BASIC_Stack
d3b9 a9 4c              LDA #$4c            ; JMP code
d3bb 85 51              STA JUMPER
d3bd 85 00              STA Basic_USR
d3bf a9 73              LDA #<Jump_To_Illegal_Quantity
d3c1 a0 c3              LDY #>Jump_To_Illegal_Quantity
d3c3 85 01              STA USRVEC
d3c5 84 02              STY USRVEC+1
d3c7 a2 1c              LDX #$1c
d3c9 bd 98 d3 IBRV_10   LDA CHRGET_ROM-1,X
d3cc 95 6f              STA CHRGET-1,X
d3ce ca                 DEX
d3cf d0 f8              BNE IBRV_10         ; X=0 on exit
d3d1 86 10              STX IOPMPT          ; 0
d3d3 86 15              STX LASTPT+1        ; 0
d3d5 8e 00 04           STX $0400           ; BASIC start
d3d8 a0 04              LDY #4              ; X=0  Y=4
d3da 84 29              STY TXTTAB+1        ; >$0401
d3dc 86 11              STX LINNUM
d3de 84 12              STY LINNUM+1        ; $0400
d3e0 a9 08              LDA #8
d3e2 85 ab              STA Wedge_Unit
d3e4 a0 01              LDY #1              ; start RAM test at $0401
d3e6 84 28              STY TXTTAB          ; (TXTTAB) = $0401
d3e8 b1 11    IBRV_20   LDA (LINNUM),Y
d3ea aa                 TAX                 ; save content
d3eb a9 55              LDA #$55            ; test pattern
d3ed 91 11              STA (LINNUM),Y
d3ef d1 11              CMP (LINNUM),Y
d3f1 d0 11              BNE IBRV_30         ; failed
d3f3 0a                 ASL A               ; shift pattern
d3f4 91 11              STA (LINNUM),Y
d3f6 d1 11              CMP (LINNUM),Y
d3f8 d0 0a              BNE IBRV_30         ; failed
d3fa 8a                 TXA                 ; restore content
d3fb 91 11              STA (LINNUM),Y
d3fd c8                 INY                 ; next address
d3fe d0 e8              BNE IBRV_20         ; loop
d400 e6 12              INC LINNUM+1
d402 10 e4              BPL IBRV_20         ; loop for LINNUM < $8000
d404 a5 12    IBRV_30   LDA LINNUM+1
d406 84 34              STY MEMSIZ
d408 85 35              STA MEMSIZ+1        ; top of RAM + 1
d40a 84 30              STY FRETOP
d40c 85 31              STA FRETOP+1
d40e a9 9d              LDA #<Start_Message
d410 a0 de              LDY #>Start_Message
d412 20 1d bb           JSR Print_String
d415 a5 34              LDA MEMSIZ
d417 38                 SEC
d418 e5 28              SBC TXTTAB
d41a aa                 TAX
d41b a5 35              LDA MEMSIZ+1
d41d e5 29              SBC TXTTAB+1
d41f 20 83 cf           JSR Print_Integer_XA
d422 a9 35              LDA #<Bytes_Free_Message
d424 a0 d4              LDY #>Bytes_Free_Message
d426 20 1d bb           JSR Print_String
d429 20 d4 b5           JSR Perform_NEW
d42c 20 01 cf           JSR Option_ROM
d42f 20 22 cf           JSR BOOT_File
d432 4c ff b3           JMP Basic_Ready

              ; ******************
d435            Bytes_Free_Message
              ; ******************

d435 20 42 59           .BYTE " BYTES FREE\r",0

              ; *******
d442            Monitor
              ; *******
d442 a9 b4              LDA #>[Basic_Ready+1]
d444 48                 PHA
d445 a9 00              LDA #<[Basic_Ready+1]
d447 48                 PHA
d448 a9 00              LDA #0              ; clear if not already 0
d44a 48                 PHA                 ; Y
d44b 48                 PHA                 ; X
d44c 48                 PHA                 ; A
d44d 48                 PHA                 ; SR

              ; *************
d44e            MONITOR_BREAK
              ; *************

d44e d8                 CLD
d44f a2 01              LDX #1              ; 1 for BRK
d451 c9 20              CMP #$20            ; T2 single step IRQ
d453 d0 01              BNE MOBR_05
d455 ca                 DEX                 ; 0 for STEP IRQ
d456 86 b3    MOBR_05   STX PC_Adjust
d458 20 a6 f2           JSR Kernal_CLRCHN
d45b 68                 PLA
d45c 8d a7 02           STA Mon_Register+7  ; Y
d45f 68                 PLA
d460 8d a6 02           STA Mon_Register+6  ; X
d463 68                 PLA
d464 8d a5 02           STA Mon_Register+5  ; A
d467 68                 PLA
d468 8d a4 02           STA Mon_Register+4  ; SR
d46b 20 43 ec           JSR Install_Bank_Access ; Carry = 1
d46e 68                 PLA
d46f e5 b3              SBC PC_Adjust
d471 8d a1 02           STA Mon_Register+1  ; PC lo
d474 68                 PLA
d475 e9 00              SBC #0
d477 8d a0 02           STA Mon_Register    ; PC hi
d47a a5 90              LDA CINV
d47c 8d a3 02           STA Mon_Register+3  ; IRQ lo
d47f a5 91              LDA CINV+1
d481 8d a2 02           STA Mon_Register+2  ; IRQ hi
d484 ba                 TSX
d485 8e a8 02           STX Mon_Register+8  ; SP
d488 a5 b6              LDA R_Bank
d48a 8d a9 02           STA Mon_Register+9  ; RB
d48d a5 b7              LDA W_Bank
d48f 8d aa 02           STA Mon_Register+10 ; WB
d492 58                 CLI
d493 a6 b3              LDX PC_Adjust
d495 f0 0e              BEQ MOBR_20         ; no greetings on single step mode
d497 a0 ff              LDY #-1
d499 c8       MOBR_10   INY
d49a b9 23 d5           LDA Mon_Start,Y
d49d f0 06              BEQ MOBR_20
d49f 20 02 e2           JSR EDIT_CHROUT
d4a2 4c 99 d4           JMP MOBR_10
d4a5 a9 52    MOBR_20   LDA #'R'
d4a7 d0 11              BNE Mon_20          ; always

              ; *********
d4a9            Mon_Error
              ; *********

d4a9 a9 3f              LDA #'?'
d4ab 20 02 e2           JSR EDIT_CHROUT

              ; ********
d4ae            Mon_Main
              ; ********

d4ae 20 1e d5           JSR Mon_Print_CR
d4b1 20 f4 d8 Mon_10    JSR Mon_CHRIN
d4b4 f0 f8              BEQ Mon_Main
d4b6 c9 20              CMP #' '
d4b8 f0 f7              BEQ Mon_10
d4ba a2 18    Mon_20    LDX #24
d4bc ca       Mon_30    DEX
d4bd 30 ea              BMI Mon_Error
d4bf dd 2e d5           CMP Mon_Commands,X
d4c2 d0 f8              BNE Mon_30
d4c4 bd 46 d5           LDA Mon_Sub_Hi,X
d4c7 48                 PHA
d4c8 bd 5d d5           LDA Mon_Sub_Lo,X
d4cb 48                 PHA
d4cc 60                 RTS ;Size   31 [Mon_Main]

              ; **********************
d4cd            Mon_Print_A_Hex_Values
              ; **********************

d4cd 85 b5              STA MONCNT
d4cf a0 00              LDY #0
d4d1 20 1b d5 MPAH_10   JSR Mon_Print_Blank
d4d4 20 7a 02           JSR Bank_Fetch
d4d7 20 54 d7           JSR Print_Hex_Byte
d4da c8                 INY
d4db c0 08              CPY #8
d4dd d0 03              BNE MPAH_12
d4df 20 1b d5           JSR Mon_Print_Blank
d4e2 c4 b5    MPAH_12   CPY MONCNT
d4e4 90 eb              BCC MPAH_10
d4e6 20 1b d5           JSR Mon_Print_Blank
d4e9 a5 b5              LDA MONCNT
d4eb c9 10              CMP #16
d4ed d0 20              BNE MPAH_Ret
d4ef a0 00              LDY #0
d4f1 20 7a 02 MPAH_20   JSR Bank_Fetch
d4f4 29 7f              AND #$7f
d4f6 c9 20              CMP #$20
d4f8 90 04              BCC MPAH_30
d4fa c9 60              CMP #$60
d4fc 90 02              BCC MPAH_40
d4fe a9 2e    MPAH_30   LDA #'.'
d500 20 02 e2 MPAH_40   JSR EDIT_CHROUT
d503 c8                 INY
d504 c0 08              CPY #8
d506 d0 03              BNE MPAH_42
d508 20 1b d5           JSR Mon_Print_Blank
d50b c4 b5    MPAH_42   CPY MONCNT
d50d 90 e2              BCC MPAH_20
d50f 60       MPAH_Ret  RTS ;Size   67 [Mon_Print_A_Hex_Values]

              ; *****************
d510            Mon_STAL_Register
              ; *****************

d510 a9 a4              LDA #<[Mon_Register+4]
d512 85 fb              STA STAL
d514 a9 02              LDA #>[Mon_Register+4]
d516 85 fc              STA STAL+1
d518 a9 07              LDA #7              ; 7 bytes to display
d51a 60                 RTS ;Size   11 [Mon_STAL_Register]

              ; ***************
d51b            Mon_Print_Blank
              ; ***************

d51b a9 20              LDA #$20            ; ' '
d51d 2c                 .BYTE $2c

              ; ************
d51e            Mon_Print_CR
              ; ************

d51e a9 0d              LDA #CR
d520 4c 02 e2           JMP EDIT_CHROUT


d523 42 53 20   Mon_Start .BYTE "BS MONITOR "

              ; ************
d52e            Mon_Commands
              ; ************

d52e 23 24 2e           .BYTE "#$./:;@ABCDFGHLMNRSTUWX",0

              ; **********
d546            Mon_Sub_Hi
              ; **********

d546 fd                 .BYTE >[Mon_Unit-1]           ; #
d547 fb                 .BYTE >[Mon_Dir-1]            ; $
d548 fa                 .BYTE >[Assemble-1]           ; .
d549 d6                 .BYTE >[Mon_Load-1]           ; /
d54a d6                 .BYTE >[Modify_Memory-1]      ; :
d54b d6                 .BYTE >[Modify_Register-1]    ; ;
d54c fb                 .BYTE >[Mon_Wedge-1]          ; @
d54d fa                 .BYTE >[Assemble-1]           ; A
d54e d8                 .BYTE >[Mon_Set_Bank-1]       ; B
d54f fb                 .BYTE >[Mon_Compare-1]        ; C
d550 f5                 .BYTE >[Disassemble-1]        ; D
d551 e5                 .BYTE >[Mon_Fill-1]           ; F
d552 d6                 .BYTE >[Mon_Go-1]             ; G
d553 fc                 .BYTE >[Mon_Hunt-1]           ; H
d554 d6                 .BYTE >[Mon_Load-1]           ; L
d555 d5                 .BYTE >[Display_Memory-1]     ; M
d556 fd                 .BYTE >[Mon_Next]             ; N
d557 d5                 .BYTE >[Display_Register-1]   ; R
d558 d6                 .BYTE >[Mon_Save-1]           ; S
d559 fc                 .BYTE >[Mon_Transfer-1]       ; T
d55a e5                 .BYTE >[Mon_Disk-1]           ; U
d55b d8                 .BYTE >[Mon_Write_Bank-1]     ; W
d55c d6                 .BYTE >[Mon_Exit-1]           ; X

              ; **********
d55d            Mon_Sub_Lo
              ; **********

d55d 50                 .BYTE <[Mon_Unit-1]           ; #
d55e 5e                 .BYTE <[Mon_Dir-1]            ; $
d55f 41                 .BYTE <[Assemble-1]           ; .
d560 cd                 .BYTE <[Mon_Load-1]           ; /
d561 58                 .BYTE <[Modify_Memory-1]      ; :
d562 3e                 .BYTE <[Modify_Register-1]    ; ;
d563 3d                 .BYTE <[Mon_Wedge-1]          ; @
d564 41                 .BYTE <[Assemble-1]           ; A
d565 e3                 .BYTE <[Mon_Set_Bank-1]       ; B
d566 e3                 .BYTE <[Mon_Compare-1]        ; C
d567 c1                 .BYTE <[Disassemble-1]        ; D
d568 3e                 .BYTE <[Mon_Fill-1]           ; F
d569 83                 .BYTE <[Mon_Go-1]             ; G
d56a 7f                 .BYTE <[Mon_Hunt-1]           ; H
d56b cd                 .BYTE <[Mon_Load-1]           ; L
d56c f3                 .BYTE <[Display_Memory-1]     ; M
d56d 6e                 .BYTE <[Mon_Next]             ; N
d56e 7b                 .BYTE <[Display_Register-1]   ; R
d56f d0                 .BYTE <[Mon_Save-1]           ; S
d570 15                 .BYTE <[Mon_Transfer-1]       ; T
d571 a6                 .BYTE <[Mon_Disk-1]           ; U
d572 eb                 .BYTE <[Mon_Write_Bank-1]     ; W
d573 bd                 .BYTE <[Mon_Exit-1]           ; X

              ; **********
d574            Mon_Prompt
              ; **********

d574 48                 PHA
d575 20 1e d5           JSR Mon_Print_CR
d578 68                 PLA
d579 4c 02 e2           JMP EDIT_CHROUT

              ; ****************
d57c            Display_Register
              ; ****************

d57c a2 00              LDX #0
d57e bd fb e4 DiRe_10   LDA Mon_Message,X
d581 20 02 e2           JSR EDIT_CHROUT
d584 e8                 INX
d585 e0 2a              CPX #42
d587 d0 f5              BNE DiRe_10
d589 a5 b6              LDA R_Bank
d58b 8d a9 02           STA Mon_Register+9
d58e a5 b7              LDA W_Bank
d590 8d aa 02           STA Mon_Register+10
d593 a9 3b              LDA #';'
d595 20 74 d5           JSR Mon_Prompt
d598 20 1b d5           JSR Mon_Print_Blank
d59b ad a0 02           LDA Mon_Register    ; display PC
d59e 20 54 d7           JSR Print_Hex_Byte
d5a1 ad a1 02           LDA Mon_Register+1
d5a4 20 54 d7           JSR Print_Hex_Byte
d5a7 20 1b d5           JSR Mon_Print_Blank
d5aa ad a2 02           LDA Mon_Register+2  ; display IRQ vector
d5ad 20 54 d7           JSR Print_Hex_Byte
d5b0 ad a3 02           LDA Mon_Register+3
d5b3 20 54 d7           JSR Print_Hex_Byte
d5b6 20 10 d5           JSR Mon_STAL_Register
d5b9 20 cd d4           JSR Mon_Print_A_Hex_Values
d5bc ad a4 02           LDA Mon_Register+4  ; SR
d5bf 85 b5              STA MONCNT
d5c1 a2 08              LDX #8
d5c3 a9 30    DiRe_20   LDA #'0'
d5c5 06 b5              ASL MONCNT
d5c7 69 00              ADC #0
d5c9 20 02 e2           JSR EDIT_CHROUT
d5cc ca                 DEX
d5cd d0 f4              BNE DiRe_20
d5cf a5 b3              LDA PC_Adjust
d5d1 d0 42              BNE To_Mon_Main     ; branch if not stepping
d5d3 ad a1 02           LDA Mon_Register+1
d5d6 85 fb              STA STAL
d5d8 ad a0 02           LDA Mon_Register
d5db 85 fc              STA STAL+1
d5dd 4c cf f5           JMP Disa_15


              ; ************
d5e0            Mon_Cmp_Addr
              ; ************

d5e0 a5 ba              LDA Dis_Line        ; negative: compare addresses
d5e2 30 07              BMI Cmp_STAL_MEMUSS
d5e4 e6 ba              INC Dis_Line
d5e6 a9 10              LDA #16
d5e8 c5 ba              CMP Dis_Line        ; line count > 16 ?
d5ea 60                 RTS ;Size   11 [Mon_Cmp_Addr]

              ; ***************
d5eb            Cmp_STAL_MEMUSS
              ; ***************

d5eb a5 fd              LDA MEMUSS          ; end addr >= start addr ?
d5ed c5 fb              CMP STAL
d5ef a5 fe              LDA MEMUSS+1
d5f1 e5 fc              SBC STAL+1
d5f3 60                 RTS ;Size    9 [Cmp_STAL_MEMUSS]

              ; **************
d5f4            Display_Memory
              ; **************

d5f4 20 18 d6           JSR Mon_Get_Addr
d5f7 20 35 f3 DiMe_10   JSR Check_STOP_Key  ; STOP key pressed?
d5fa f0 19              BEQ To_Mon_Main
d5fc 20 e0 d5           JSR Mon_Cmp_Addr
d5ff 90 14              BCC To_Mon_Main     ; STAL > MEMUSS ?
d601 a9 3a              LDA #':'
d603 20 74 d5           JSR Mon_Prompt
d606 20 4d d7           JSR Mon_Print_STAL
d609 a9 10              LDA #16             ; dump 16 bytes per line
d60b 20 cd d4           JSR Mon_Print_A_Hex_Values
d60e a9 10              LDA #16
d610 20 1b fb           JSR Add_STAL
d613 d0 e2              BNE DiMe_10
d615          To_Mon_Main
d615 4c ae d4           JMP Mon_Main

              ; ************
d618            Mon_Get_Addr
              ; ************

d618 a0 00              LDY #0              ; reset line count
d61a 84 ba              STY Dis_Line
d61c 88                 DEY                 ; Y = $ff
d61d 84 fd              STY MEMUSS
d61f 84 fe              STY MEMUSS+1        ; default end address = $ffff
d621 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d624 f0 13              BEQ MGA_Ret         ; use last value for STAL
d626 20 6a d7           JSR Hex_To_STAL     ; read start address to STAL
d629 90 0f              BCC MGA_Err
d62b 20 f4 d8           JSR Mon_CHRIN       ; detect CR or skip blank
d62e f0 09              BEQ MGA_Ret
d630 a2 fd              LDX #MEMUSS
d632 20 6c d7           JSR Read_Hex_Word  ; read end address
d635 90 03              BCC MGA_Err
d637 c6 ba              DEC Dis_Line        ; disable line count
d639 60       MGA_Ret   RTS ;Size   34 [Mon_Get_Addr]
d63a 68       MGA_Err   PLA
d63b 68                 PLA
d63c          To_Mon_Err
d63c 4c a9 d4           JMP Mon_Error

              ; ***************
d63f            Modify_Register
              ; ***************

d63f a2 00              LDX #0
d641 20 79 d7 MoRe_10   JSR Read_Hex
d644 9d a0 02           STA Mon_Register,X
d647 e8                 INX
d648 e0 0b              CPX #11
d64a 90 f5              BCC MoRe_10
d64c ad a9 02           LDA Mon_Register+9
d64f 85 b6              STA R_Bank
d651 ad aa 02           LDA Mon_Register+10
d654 85 b7              STA W_Bank
d656 4c ae d4           JMP Mon_Main

              ; *************
d659            Modify_Memory
              ; *************

d659 20 6a d7           JSR Hex_To_STAL
d65c 90 de              BCC To_Mon_Err
d65e a9 10              LDA #16
d660 85 b5    MoMe_10   STA MONCNT
d662 a5 fb              LDA STAL
d664 85 f9              STA BPTR
d666 a5 fc              LDA STAL+1
d668 85 fa              STA BPTR+1
d66a a0 00              LDY #0
d66c 20 79 d7 MoMe_20   JSR Read_Hex
d66f 90 cb              BCC To_Mon_Err
d671 85 cb              STA Mon_Tmp
d673 20 8b 02           JSR Bank_Store
d676 20 7a 02           JSR Bank_Fetch
d679 c5 cb              CMP Mon_Tmp
d67b d0 bf              BNE To_Mon_Err      ; not RAM
d67d c8       MoMe_30   INY
d67e c4 b5              CPY MONCNT
d680 90 ea              BCC MoMe_20
d682 b0 91              BCS To_Mon_Main

              ; ******
d684            Mon_Go
              ; ******

d684 20 f4 d8           JSR Mon_CHRIN
d687 f0 10              BEQ MoGo_10
d689 c9 20              CMP #' '
d68b d0 af              BNE To_Mon_Err
d68d 20 79 d7           JSR Read_Hex
d690 8d a0 02           STA Mon_Register
d693 20 79 d7           JSR Read_Hex
d696 8d a1 02           STA Mon_Register+1
d699 78       MoGo_10   SEI
d69a ad a2 02           LDA Mon_Register+2  ; IRQ
d69d 85 91              STA CINV+1
d69f ad a3 02           LDA Mon_Register+3
d6a2 85 90              STA CINV

              ; ********
d6a4            Mon_Step
              ; ********

d6a4 ae a8 02           LDX Mon_Register+8  ; SP
d6a7 9a                 TXS
d6a8 ad a0 02           LDA Mon_Register    ; PC high
d6ab 48                 PHA
d6ac ad a1 02           LDA Mon_Register+1  ; PC low
d6af 48                 PHA
d6b0 ad a4 02           LDA Mon_Register+4  ; SR
d6b3 48                 PHA
d6b4 ad a5 02           LDA Mon_Register+5
d6b7 ae a6 02           LDX Mon_Register+6
d6ba ac a7 02           LDY Mon_Register+7
d6bd 40                 RTI

              ; ********
d6be            Mon_Exit
              ; ********

d6be ae a8 02           LDX Mon_Register+8  ; SP
d6c1 9a                 TXS
d6c2 4c ff b3           JMP Basic_Ready

              ; *************
d6c5            Set_DOS_FNADR
              ; *************

d6c5 a9 42              LDA #<DOS_Filename
d6c7 85 da              STA FNADR
d6c9 a9 03              LDA #>DOS_Filename
d6cb 85 db              STA FNADR+1
d6cd 60                 RTS ;Size    9 [Set_DOS_FNADR]

              ; ********
d6ce            Mon_Load
              ; ********

d6ce a9 00              LDA #0              ; load flag
d6d0 2c                 .BYTE $2c           ; skip 2 bytes

              ; ********
d6d1            Mon_Save
              ; ********

d6d1 a9 80              LDA #$80            ; save flag
d6d3 85 9d              STA VERCK           ; (0) LOAD, ($80) SAVE
d6d5 a0 01              LDY #1
d6d7 84 d3              STY SA              ; use file load address
d6d9 88                 DEY                 ; Y = 0
d6da 20 c5 d6           JSR Set_DOS_FNADR
d6dd 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
d6e0 20 f4 d8 MLS_10    JSR Mon_CHRIN
d6e3 f0 14              BEQ MLS_Err         ; filename required
d6e5 c9 22              CMP #QUOTE          ; filename must be quoted
d6e7 d0 f7              BNE MLS_10          ; skip until leading quote
d6e9 20 f4 d8 MLS_20    JSR Mon_CHRIN       ; next char in string
d6ec f0 0b              BEQ MLS_Err         ; no ending quote
d6ee c9 22              CMP #QUOTE          ; ending quote?
d6f0 f0 14              BEQ MLS_50
d6f2 91 da              STA (FNADR),Y       ; append to filename
d6f4 c8                 INY                 ; next
d6f5 c0 10              CPY #16
d6f7 90 f0              BCC MLS_20          ; loop
d6f9 4c a9 d4 MLS_Err   JMP Mon_Error

d6fc 24 9d    MLS_30    BIT VERCK           ; LOAD or SAVE ?
d6fe 30 f9    MLS_35    BMI MLS_Err         ; SAVE needs range
d700 20 56 f3           JSR Load_File
d703 4c ae d4           JMP Mon_Main        ; OK - done

d706 84 d1    MLS_50    STY FNLEN
d708 20 f4 d8           JSR Mon_CHRIN       ; parameter after filename
d70b f0 ef              BEQ MLS_30
d70d c9 2c              CMP #','            ; comma needed
d70f d0 f5              BNE MLS_50
d711 20 79 d7           JSR Read_Hex        ; read device
d714 85 d4              STA FA
d716 20 f4 d8           JSR Mon_CHRIN
d719 f0 e1              BEQ MLS_30          ; no range -> LOAD
d71b c9 2c              CMP #','            ; comma needed
d71d d0 da              BNE MLS_Err
d71f 20 6a d7           JSR Hex_To_STAL     ; STAL = start address
d722 a9 00              LDA #0
d724 85 d3              STA SA              ; relocate to EAL
d726 20 f4 d8           JSR Mon_CHRIN
d729 c9 2c              CMP #','
d72b d0 cc              BNE MLS_Err
d72d a2 c9              LDX #EAL
d72f 20 6c d7           JSR Read_Hex_Word   ; EAL  = end address
d732 90 c5              BCC MLS_Err
d734 24 9d              BIT VERCK           ; (0) LOAD or ($80) SAVE
d736 10 c1              BPL MLS_Err
d738 20 e3 f6           JSR Save_File
d73b 4c ae d4           JMP Mon_Main

              ; *************
d73e            Make_Hex_Byte
              ; *************

d73e 48                 PHA
d73f 4a                 LSR A
d740 4a                 LSR A
d741 4a                 LSR A
d742 4a                 LSR A
d743 20 60 d7           JSR Nibble_To_Hex
d746 aa                 TAX
d747 68                 PLA
d748 29 0f              AND #15
d74a 4c 60 d7           JMP Nibble_To_Hex

              ; **************
d74d            Mon_Print_STAL
              ; **************

d74d a5 fc              LDA STAL+1
d74f 20 54 d7           JSR Print_Hex_Byte
d752 a5 fb              LDA STAL

              ; **************
d754            Print_Hex_Byte
              ; **************

d754 20 3e d7           JSR Make_Hex_Byte

              ; ************
d757            Mon_Print_XA
              ; ************

d757 48                 PHA
d758 8a                 TXA
d759 20 02 e2           JSR EDIT_CHROUT
d75c 68                 PLA
d75d 4c 02 e2           JMP EDIT_CHROUT

              ; *************
d760            Nibble_To_Hex
              ; *************

d760 18                 CLC
d761 69 f6              ADC #$f6
d763 90 02              BCC NTH_10
d765 69 06              ADC #6
d767 69 3a    NTH_10    ADC #$3a
d769 60                 RTS ;Size   10 [Nibble_To_Hex]

              ; ***********
d76a            Hex_To_STAL
              ; ***********

d76a a2 fb              LDX #STAL

              ; *************
d76c            Read_Hex_Word
              ; *************

d76c 20 79 d7           JSR Read_Hex        ; X points to word address
d76f 90 07              BCC RHW_Ret
d771 95 01              STA 1,X             ; high byte
d773 20 79 d7           JSR Read_Hex
d776 95 00              STA 0,X             ; low  byte
d778 60       RHW_Ret   RTS ;Size   13 [Read_Hex_Word]

              ; ********
d779            Read_Hex
              ; ********

              ; read a two digit hex number, allow leading blanks

d779 20 f4 d8           JSR Mon_CHRIN
d77c c9 20              CMP #' '
d77e f0 f9              BEQ Read_Hex
d780          Read_Hex_A
d780 20 11 d9           JSR Is_Hex
d783 90 17              BCC ReHe_Ret         ; error
d785 20 fa d8           JSR Hex_To_Bin
d788 0a                 ASL A
d789 0a                 ASL A
d78a 0a                 ASL A
d78b 0a                 ASL A
d78c 85 cb              STA Mon_Tmp
d78e 20 f4 d8           JSR Mon_CHRIN
d791 20 11 d9           JSR Is_Hex
d794 90 06              BCC ReHe_Ret         ; error
d796 20 fa d8           JSR Hex_To_Bin
d799 05 cb              ORA Mon_Tmp
d79b 38                 SEC
d79c 60       ReHe_Ret  RTS ;Size   36 [Read_Hex]


d79d 00 00 00           .FILL $d7af - * (0) ; 18 bytes

              ; *************
d7af            Kernal_RECORD
              ; *************

d7af a9 01              LDA #1
d7b1 8d 3a 03           STA DOS_Tmp         ; default for position
d7b4 20 76 00           JSR CHRGOT
d7b7 a9 23              LDA #'#'
d7b9 20 f7 be           JSR Need_A
d7bc 20 8a de           JSR DOS_Get_Byte    ; get lfn
d7bf e0 00              CPX #0
d7c1 f0 3e              BEQ RECO_40
d7c3 86 d2              STX LA
d7c5 20 f5 be           JSR Need_Comma
d7c8 f0 3e              BEQ DOS_JMP_Syntax_Error
d7ca 90 0f              BCC RECO_10         ; -> numeric
d7cc 20 f2 be           JSR Need_Left_Parenthesis
d7cf 20 98 bd           JSR Eval_Expression
d7d2 20 2d c9           JSR FAC1_To_LINNUM
d7d5 20 ef be           JSR Need_Right_Parenthesis
d7d8 4c e1 d7           JMP RECO_20
d7db 20 98 bd RECO_10   JSR Eval_Expression ; get record #
d7de 20 2d c9           JSR FAC1_To_LINNUM
d7e1 20 76 00 RECO_20   JSR CHRGOT
d7e4 f0 18              BEQ RECO_30
d7e6 20 f5 be           JSR Need_Comma
d7e9 f0 1d              BEQ DOS_JMP_Syntax_Error
d7eb 20 8a de           JSR DOS_Get_Byte    ; get position
d7ee e0 00              CPX #0
d7f0 f0 0f              BEQ RECO_40
d7f2 e0 ff              CPX #$ff
d7f4 f0 0b              BEQ RECO_40
d7f6 8e 3a 03           STX DOS_Tmp
d7f9 20 76 00           JSR CHRGOT
d7fc d0 0a              BNE DOS_JMP_Syntax_Error
d7fe 4c 31 da RECO_30   JMP Build_Record_Command
d801 4c 27 de RECO_40   JMP DOS_JMP_Illegal_Quantity

              ; *************************
d804            Allow_Drive_Unit_Filename
              ; *************************

d804 29 e6              AND #$e6
d806 f0 03              BEQ Check_Filename_Given

              ; ********************
d808            DOS_JMP_Syntax_Error
              ; ********************

d808 4c 00 bf           JMP Syntax_Error

              ; ********************
d80b            Check_Filename_Given
              ; ********************

d80b ad 3e 03           LDA DOS_Flags
d80e 29 01              AND #1
d810 c9 01              CMP #1
d812 d0 f4              BNE DOS_JMP_Syntax_Error
d814 ad 3e 03           LDA DOS_Flags
d817 60                 RTS ;Size   13 [Check_Filename_Given]

              ; ********************
d818            Allow_Drive_And_Unit
              ; ********************

d818 29 e7              AND #$e7
d81a d0 ec              BNE DOS_JMP_Syntax_Error
d81c 60                 RTS ;Size    5 [Allow_Drive_And_Unit]

              ; ************
d81d            No_WL_Record
              ; ************

d81d 29 c4              AND #$c4
d81f d0 e7              BNE DOS_JMP_Syntax_Error
d821 ad 3e 03           LDA DOS_Flags

              ; *********************
d824            Check_Filename_Syntax
              ; *********************

d824 29 03              AND #3
d826 c9 03              CMP #3
d828 d0 de              BNE DOS_JMP_Syntax_Error
d82a ad 3e 03           LDA DOS_Flags
d82d 60                 RTS ;Size   10 [Check_Filename_Syntax]

              ; *******************
d82e            Check_Record_Syntax
              ; *******************

d82e 29 05              AND #5
d830 c9 05              CMP #5
d832 d0 d4              BNE DOS_JMP_Syntax_Error
d834 ad 3e 03           LDA DOS_Flags
d837 60                 RTS ;Size   10 [Check_Record_Syntax]

              ; ***************
d838            DOS_Build_Table
              ; ***************

d838 ff                 .BYTE $ff
                        ;-------------------- directory $00
d839 24                 .BYTE "$"
d83a d1                 .BYTE $d1           ; drive 1

                        ;-------------------- dopen     $02
d83b d1                 .BYTE $d1           ; drive 1
d83c 3a                 .BYTE ":"
d83d f1                 .BYTE $f1           ; file 1
d83e 2c                 .BYTE ","
d83f e1                 .BYTE $e1           ; L,S,W
d840 2c                 .BYTE ","
d841 e0                 .BYTE $e0           ; Record length

                        ;-------------------- append    $09
d842 d1                 .BYTE $d1           ; drive 1
d843 3a                 .BYTE ":"
d844 f1                 .BYTE $f1           ; file 1
d845 2c 41              .BYTE ",A"

                        ;-------------------- header    $0e
d847 4e                 .BYTE "N"
d848 d1                 .BYTE $d1           ; drive 1
d849 3a                 .BYTE ":"
d84a f1                 .BYTE $f1           ; file 1
d84b 2c                 .BYTE ","
d84c d0                 .BYTE $d0           ; ID

                        ;-------------------- collect   $14
d84d 56                 .BYTE "V"
d84e d1                 .BYTE $d1           ; drive 1

                        ;-------------------- backup    $16
d84f 44                 .BYTE "D"
d850 d2                 .BYTE $d2           ; drive 2
d851 3d                 .BYTE "="
d852 d1                 .BYTE $d1           ; drive 1

                        ;-------------------- copy      $1a
d853 43                 .BYTE "C"
d854 d2                 .BYTE $d2           ; drive 2
d855 3a                 .BYTE ":"
d856 f2                 .BYTE $f2           ; file 2
d857 3d                 .BYTE "="
d858 d1                 .BYTE $d1           ; drive 1
d859 3a                 .BYTE ":"
d85a f1                 .BYTE $f1           ; file 1

                        ;-------------------- concat    $22
d85b 43                 .BYTE "C"
d85c d2                 .BYTE $d2           ; drive 2
d85d 3a                 .BYTE ":"
d85e f2                 .BYTE $f2           ; file 2
d85f 3d                 .BYTE "="
d860 d2                 .BYTE $d2           ; drive 2
d861 3a                 .BYTE ":"
d862 f2                 .BYTE $f2           ; file 2
d863 2c                 .BYTE ","
d864 d1                 .BYTE $d1           ; drive 1
d865 3a                 .BYTE ":"
d866 f1                 .BYTE $f1           ; file 1

                        ;-------------------- rename    $2e
d867 52                 .BYTE "R"
d868 d1                 .BYTE $d1           ; drive 1
d869 3a                 .BYTE ":"
d86a f2                 .BYTE $f2           ; file 2
d86b 3d                 .BYTE "="
d86c d1                 .BYTE $d1           ; drive 1
d86d 3a                 .BYTE ":"
d86e f1                 .BYTE $f1           ; file 1

                        ;-------------------- scratch   $36
d86f 53                 .BYTE "S"
d870 d1                 .BYTE $d1           ; drive 1
d871 3a                 .BYTE ":"
d872 f1                 .BYTE $f1           ; file 1

              ; ****************
d873            Kernal_DIRECTORY
              ; ****************

d873 20 68 dc           JSR Parse_DOS_Parameter
d876 20 18 d8           JSR Allow_Drive_And_Unit
d879 a0 00              LDY #0
d87b a2 01              LDX #1
d87d ad 3e 03           LDA DOS_Flags
d880 29 10              AND #16
d882 f0 01              BEQ DIRE_10
d884 e8                 INX                 ; drive given
d885 8a       DIRE_10   TXA
d886 20 fa db           JSR Build_DOS_Command

              ; **************
d889            Wedge_Call_Dir
              ; **************

d889 a9 60              LDA #$60            ; secondary address 0 for LOAD
d88b 85 d3              STA SA
d88d a9 0e              LDA #14             ; logical address used for loading directory
d88f 85 d2              STA LA
d891 20 b9 f1           JSR UNLSN
d894 20 65 f5           JSR Open_File
d897 a2 0e              LDX #14
d899 20 af f7           JSR Kernal_CHKIN    ; input from floppy
d89c a0 03              LDY #3              ; 1st time: skip load address + next line link
d89e 20 c0 f1 WCD_10    JSR ACPTR           ; read until length in blocks read
d8a1 aa                 TAX                 ; file size low in X
d8a2 a5 96              LDA STATUS
d8a4 d0 36              BNE WCD_80          ; abort if status bad
d8a6 20 c0 f1           JSR ACPTR           ; file size high in A
d8a9 88                 DEY
d8aa d0 f2              BNE WCD_10          ; if not done
d8ac 20 83 cf           JSR Print_Integer_XA; output number of blocks
d8af a9 20              LDA #' '            ; output separator space
d8b1 20 02 e2           JSR EDIT_CHROUT
d8b4 20 c0 f1 WCD_20    JSR ACPTR           ; get char
d8b7 f0 1a              BEQ WCD_40          ; branch if end of line
d8b9 a6 96              LDX STATUS          ; get status
d8bb d0 1f              BNE WCD_80          ; abort if bad status
d8bd 20 02 e2           JSR EDIT_CHROUT
d8c0 20 35 f3           JSR Check_STOP_Key  ; abort if STOP key pressed
d8c3 f0 17              BEQ WCD_80
d8c5 20 0d f2           JSR GETIN_10        ; read keyboard
d8c8 c9 20              CMP #' '
d8ca d0 e8              BNE WCD_20          ; continue if not SPACE pressed
d8cc 20 0d f2 WCD_30    JSR GETIN_10        ; read keyboard
d8cf f0 fb              BEQ WCD_30          ; loop until any key pressed
d8d1 d0 e1              BNE WCD_20          ; branch always: continue reading dir characters

d8d3 a9 0d    WCD_40    LDA #CR             ; end of line: output CR
d8d5 20 02 e2           JSR EDIT_CHROUT
d8d8 a0 02              LDY #2              ; further passes: skip line link only
d8da d0 c2              BNE WCD_10          ; branch always

d8dc 20 a6 f2 WCD_80    JSR Kernal_CLRCHN   ; exit: clear channel
d8df a9 0e              LDA #14             ; close directory
d8e1 4c e2 f2           JMP Close_LA_in_A

              ; ************
d8e4            Mon_Set_Bank
              ; ************

d8e4 20 79 d7           JSR Read_Hex
d8e7 85 b6              STA R_Bank
d8e9 4c ae d4           JMP Mon_Main

              ; **************
d8ec            Mon_Write_Bank
              ; **************

d8ec 20 79 d7           JSR Read_Hex
d8ef 85 b7              STA W_Bank
d8f1 4c ae d4           JMP Mon_Main

              ; *********
d8f4            Mon_CHRIN
              ; *********

d8f4 20 15 f2           JSR Kernal_CHRIN
d8f7 c9 0d              CMP #CR
d8f9 60                 RTS ;Size    6 [Mon_CHRIN]

              ; **********
d8fa            Hex_To_Bin
              ; **********

d8fa c9 3a              CMP #$3a
d8fc 08                 PHP
d8fd 29 0f              AND #15
d8ff 28                 PLP
d900 90 02              BCC HTB_Ret
d902 69 08              ADC #8
d904 60       HTB_Ret   RTS ;Size   11 [Hex_To_Bin]

              ; ******
d905            Is_Int
              ; ******

d905 c9 24              CMP #'$'
d907 f0 18              BEQ IH_True
d909 c9 2b              CMP #'+'
d90b f0 14              BEQ IH_True
d90d c9 2d              CMP #'-'
d90f f0 10              BEQ IH_True

              ; ******
d911            Is_Hex
              ; ******

d911 c9 47              CMP #'F'+1
d913 b0 0e              BCS IH_False
d915 c9 41              CMP #'A'
d917 b0 08              BCS IH_True

              ; ******
d919            Is_Dec
              ; ******

d919 c9 30              CMP #'0'
d91b 90 06              BCC IH_False
d91d c9 3a              CMP #'9'+1
d91f b0 02              BCS IH_False
d921 38       IH_True   SEC
d922 60                 RTS                 ; carry 1 : true ;Size   10 [Is_Dec]
d923 18       IH_False  CLC
d924 60                 RTS                 ; carry 0 : false ;Size   12 [Is_Dec]

d925 00 00 00           .FILL $d92f - * (0) ; 10 bytes

              ; **************
d92f            Select_Free_SA
              ; **************

d92f a0 61              LDY #$61            ; start with SA = $62
d931 c8       SFSA_10   INY
d932 98                 TYA
d933 a6 ae              LDX LDTND           ; # of open files
d935 ca       SFSA_20   DEX
d936 30 07              BMI SFSA_30         ; -> not in use : take this SA
d938 dd 65 02           CMP SAT,X
d93b f0 f4              BEQ SFSA_10         ; -> in use: try next
d93d d0 f6              BNE SFSA_20
d93f 84 d3    SFSA_30   STY SA
d941 60                 RTS ;Size   19 [Select_Free_SA]

              ; ********************
d942            Kernal_DOPEN ; $d942
              ; ********************

d942 20 68 dc           JSR Parse_DOS_Parameter
d945 20 2e d8           JSR Check_Record_Syntax
d948 29 22              AND #$22            ; 2nd. filename or drive ?
d94a d0 20              BNE DOPEN_Err
d94c 20 2f d9           JSR Select_Free_SA  ; choose free secondary address
d94f a2 00              LDX #0              ; buffer index
d951 a9 03              LDA #3              ; length of build string (open read)
d953 2c 3e 03           BIT DOS_Flags
d956 50 04              BVC DOPEN_20        ; -> not a write file
d958 08                 PHP                 ; save flags
d959 a9 07              LDA #7              ; length of build string (open write)
d95b 28                 PLP                 ; restore flags
d95c 10 06    DOPEN_20  BPL DOPEN_30        ; -> not a replacement
d95e a0 40              LDY #'@'            ; insert save & replace command
d960 8c 53 03           STY DOS_Command_Buffer
d963 e8                 INX                 ; advance buffer index
d964 a0 02    DOPEN_30  LDY #2              ; start  of build string (open)
d966 20 fc db           JSR Build_DOS_Command_X
d969 4c 63 f5           JMP Mf563
d96c 4c 00 bf DOPEN_Err JMP Syntax_Error

d96f                    .SIZE ;   45 [Kernal_DOPEN]

d96f 00 00 00           .FILL $d977-* (0) ; 8 bytes

              ; *********************
d977            Kernal_APPEND ; $d977
              ; *********************

d977 20 68 dc           JSR Parse_DOS_Parameter
d97a 20 2e d8           JSR Check_Record_Syntax
d97d 29 e2              AND #$e2            ; @,W,L,drive 2 or file 2 ?
d97f d0 eb              BNE DOPEN_Err
d981 20 2f d9           JSR Select_Free_SA
d984 a0 09              LDY #9              ; start  of build string (append)
d986 a9 05              LDA #5              ; length of build string (append)
d988 20 fa db           JSR Build_DOS_Command
d98b 4c 63 f5           JMP Mf563

d98e 00 00 00           .FILL $d991-* (0) ; 3 bytes

              ; **********************
d991            Kernal_Read_DS ; $d991
              ; **********************

d991 a5 d4              LDA FA
d993 d0 04              BNE KRD_10
d995 a9 08              LDA #8              ; default 8 if not set
d997 85 d4              STA FA
d999 20 d2 f0 KRD_10    JSR TALK
d99c a9 6f              LDA #$6f
d99e 85 d3              STA SA
d9a0 20 93 f1           JSR TKSA
d9a3 a2 00              LDX #0
d9a5 20 c0 f1 KDR_20    JSR ACPTR
d9a8 9d ad 03           STA DOS_Status,X
d9ab e8                 INX
d9ac c9 20              CMP #' '
d9ae 90 04              BCC KDR_30          ; end (normally CR)
d9b0 e0 29              CPX #41             ; buffer length
d9b2 90 f1              BCC KDR_20
d9b4 a9 00    KDR_30    LDA #0
d9b6 9d ad 03           STA DOS_Status,X
d9b9 20 ae f1           JSR UNTLK
d9bc ad ad 03           LDA DOS_Status      ; load first character
d9bf 60                 RTS ;Size   47 [Kernal_Read_DS]

d9c0 00 00 00           .FILL $d9d2-* (0) ; 18 bytes

              ; *********************
d9d2            Kernal_HEADER ; $d9d2
              ; *********************

d9d2 20 68 dc           JSR Parse_DOS_Parameter
d9d5 20 04 d8           JSR Allow_Drive_Unit_Filename
d9d8 29 11              AND #$11
d9da c9 11              CMP #$11            ; name & drive set ?
d9dc d0 8e              BNE DOPEN_Err
d9de 20 1b da           JSR Close_All_Device_Files
d9e1 20 9e db           JSR Are_You_Sure
d9e4 b0 1f              BCS HEAD_20         ; cancel if not 'YES'
d9e6 a0 0e              LDY #14             ; start  of build string
d9e8 a9 04              LDA #4              ; length of build string
d9ea ae 3f 03           LDX DOS_Id          ; ID given ?
d9ed f0 02              BEQ HEAD_10
d9ef a9 06              LDA #6              ; command includes ID
d9f1 20 98 da HEAD_10   JSR Put_DOS_Command
d9f4 20 91 d9           JSR Kernal_Read_DS
d9f7 c9 32              CMP #'2'
d9f9 90 0a              BCC HEAD_20         ; status < 20 are warnings
d9fb 20 51 f3           JSR In_Direct_Mode
d9fe d0 05              BNE HEAD_20
da00 a0 c5              LDY #<MSG_BAD_DISK  ; $c5
da02 4c 85 f1           JMP Display_Kernal_Message
da05 60       HEAD_20   RTS ;Size   52 [Kernal_HEADER]

da06 00                 .FILL $da07-* (0) ; 1 bytes

              ; *********************
da07            Kernal_DCLOSE ; $da07
              ; *********************

da07 20 68 dc           JSR Parse_DOS_Parameter
da0a 29 f3              AND #$f3            ; allow lfn only
da0c f0 03              BEQ CLOSE_10
da0e 4c 00 bf           JMP Syntax_Error
da11 20 e1 db CLOSE_10  JSR Clear_Status
da14 a5 d2              LDA LA
da16 f0 03              BEQ Close_All_Device_Files
da18 4c e2 f2           JMP Close_LA_in_A

              ; ******************************
da1b            Close_All_Device_Files ; $da1b
              ; ******************************

da1b a5 d4              LDA FA              ; Close all open files on device FA
da1d a6 ae              LDX LDTND
da1f ca       CLOSE_20  DEX
da20 30 0e              BMI CLOSE_Ret
da22 dd 5b 02           CMP FAT,X
da25 d0 f8              BNE CLOSE_20
da27 bd 51 02           LDA LAT,X
da2a 20 e7 f2           JSR Close_File_A
da2d b8                 CLV
da2e 50 eb              BVC Close_All_Device_Files
da30 60       CLOSE_Ret RTS ;Size   22 [Close_All_Device_Files]

              ; ****************************
da31            Build_Record_Command ; $da31
              ; ****************************

da31 a5 d2              LDA LA
da33 20 c1 f2           JSR LOOKUP_LA
da36 f0 05              BEQ BRC_10
da38 a0 17              LDY #<MSG_FILE_NOT_O; $17
da3a 4c af f5           JMP Handle_IO_Error
da3d 20 cd f2 BRC_10    JSR Set_LFS_From_X
da40 20 e1 db           JSR Clear_Status

              ; *********************
da43            DOS_Record_No ; $da43
              ; *********************

da43 a9 50              LDA #'P'
da45 8d 53 03           STA DOS_Command_Buffer
da48 a5 d3              LDA SA
da4a 8d 54 03           STA DOS_Command_Buffer+1
da4d a5 11              LDA LINNUM
da4f 8d 55 03           STA DOS_Command_Buffer+2
da52 a5 12              LDA LINNUM+1
da54 8d 56 03           STA DOS_Command_Buffer+3
da57 ad 3a 03           LDA DOS_Tmp
da5a 8d 57 03           STA DOS_Command_Buffer+4
da5d a2 05              LDX #5
da5f 20 4c dc           JSR DOS_SETNAM
da62 4c 9b da           JMP PDC_10

              ; **********************
da65            Kernal_COLLECT ; $da65
              ; **********************

da65 20 68 dc           JSR Parse_DOS_Parameter
da68 20 18 d8           JSR Allow_Drive_And_Unit
da6b 20 1b da           JSR Close_All_Device_Files
da6e a0 14              LDY #$14
da70 a2 01              LDX #1
da72 ad 3e 03           LDA DOS_Flags
da75 29 10              AND #16             ; drive set ?
da77 f0 01              BEQ COLL_10
da79 e8                 INX
da7a 8a       COLL_10   TXA
da7b 4c 98 da           JMP Put_DOS_Command

              ; *************
da7e            Kernal_BACKUP
              ; *************

da7e 20 68 dc           JSR Parse_DOS_Parameter
da81 29 30              AND #$30
da83 c9 30              CMP #$30            ; two drives set ?
da85 f0 03              BEQ BACK_10
da87 4c 00 bf BACK_Err  JMP Syntax_Error
da8a ad 3e 03 BACK_10   LDA DOS_Flags
da8d 29 c7              AND #$c7
da8f d0 f6              BNE BACK_Err
da91 20 1b da           JSR Close_All_Device_Files
da94 a0 16              LDY #$16
da96 a9 04              LDA #4

              ; ***************
da98            Put_DOS_Command
              ; ***************

da98 20 fa db           JSR Build_DOS_Command
da9b 20 d5 f0 PDC_10    JSR LISTEN
da9e a9 6f              LDA #$6f            ; SA #15
daa0 4c ba f4           JMP Send_DOS_Command

daa3 00 00 00           .FILL $daa7-* (0) ; 4 bytes

              ; *******************
daa7            Kernal_COPY ; $daa7
              ; *******************

daa7 20 68 dc           JSR Parse_DOS_Parameter
daaa a5 9c              LDA Source_Unit     ; check source unit
daac f0 07              BEQ KECO_10         ; not specified
daae c5 d4              CMP FA              ; same as target ?
dab0 f0 03              BEQ KECO_10         ; yes, stay here
dab2 4c 3a ee           JMP DOS_Copy        ; -> extended COPY
dab5 a0 1a    KECO_10   LDY #$1a            ; offset
dab7 a9 08              LDA #8              ; command length
dab9 4c 98 da           JMP Put_DOS_Command

dabc 00 00 00           .FILL $dac7 - * (0) ; 11 bytes

              ; *********************
dac7            Kernal_CONCAT ; $dac7
              ; *********************

dac7 20 68 dc           JSR Parse_DOS_Parameter
daca 20 1d d8           JSR No_WL_Record
dacd a0 22              LDY #$22
dacf a9 0c              LDA #12
dad1 4c 98 da           JMP Put_DOS_Command

              ; ***************************
dad4            Copy_Filename_To_DOS_Buffer
              ; ***************************

dad4 a5 d1              LDA FNLEN
dad6 8d 3a 03           STA DOS_Tmp
dad9 a5 da              LDA FNADR
dadb 85 fd              STA MEMUSS
dadd a5 db              LDA FNADR+1
dadf 85 fe              STA MEMUSS+1

              ; *************************
dae1            Copy_MEMUSS_To_DOS_Buffer
              ; *************************

dae1 98                 TYA
dae2 48                 PHA
dae3 ac 3a 03           LDY DOS_Tmp
dae6 f0 10              BEQ CMDB_20
dae8 a0 00              LDY #0
daea b1 fd    CMDB_10   LDA (MEMUSS),Y
daec 9d 53 03           STA DOS_Command_Buffer,X
daef e8                 INX
daf0 c8                 INY
daf1 cc 3a 03           CPY DOS_Tmp
daf4 d0 f4              BNE CMDB_10
daf6 f0 01              BEQ CMDB_30
daf8 ca       CMDB_20   DEX
daf9 68       CMDB_30   PLA
dafa a8                 TAY
dafb 38                 SEC
dafc 60                 RTS ;Size   28 [Copy_MEMUSS_To_DOS_Buffer]

              ; *************
dafd            Insert_DOS_Id
              ; *************

dafd ad 3f 03           LDA DOS_Id
db00 9d 53 03           STA DOS_Command_Buffer,X
db03 e8                 INX
db04 ad 40 03           LDA DOS_Id+1
db07 9d 53 03           STA DOS_Command_Buffer,X
db0a e8                 INX
db0b 8a                 TXA
db0c 60                 RTS ;Size   16 [Insert_DOS_Id]

              ; ********************
db0d            Kernal_DSAVE ; $db0d
              ; ********************

db0d 20 68 dc           JSR Parse_DOS_Parameter
db10 20 0b d8           JSR Check_Filename_Given
db13 29 66              AND #$66            ; no 2nd. file ?
db15 f0 03              BEQ DSAVE_10
db17 4c 00 bf           JMP Syntax_Error
db1a a0 02    DSAVE_10  LDY #2
db1c ad 3e 03           LDA DOS_Flags
db1f 29 80              AND #$80
db21 f0 0f              BEQ DSAVE_20
db23 a9 40              LDA #'@'            ; save & replace
db25 8d 53 03           STA DOS_Command_Buffer
db28 a2 01              LDX #1
db2a a9 03              LDA #3
db2c 20 fc db           JSR Build_DOS_Command_X
db2f 4c e0 f6           JMP Mf6e0
db32 a9 03    DSAVE_20  LDA #3
db34 20 fa db           JSR Build_DOS_Command
db37 4c e0 f6           JMP Mf6e0

              ; ********************
db3a            Kernal_DLOAD ; $db3a
              ; ********************

db3a 20 68 dc           JSR Parse_DOS_Parameter
db3d 20 0b d8           JSR Check_Filename_Given
db40 29 e6              AND #$e6
db42 f0 03              BEQ DLOAD_20
db44 4c 00 bf DLOAD_10  JMP Syntax_Error
db47 a0 02    DLOAD_20  LDY #2
db49 a9 03              LDA #3
db4b 20 fa db           JSR Build_DOS_Command
db4e a9 00              LDA #0
db50 85 9d              STA VERCK
db52 4c 1d f4           JMP Load_Verify_Params_Set

              ; *********************
db55            Kernal_RENAME ; $db55
              ; *********************

db55 20 68 dc           JSR Parse_DOS_Parameter
db58 20 24 d8           JSR Check_Filename_Syntax
db5b 29 e4              AND #$e4
db5d d0 e5              BNE DLOAD_10
db5f a0 2e              LDY #$2e
db61 a9 08              LDA #8
db63 4c 98 da           JMP Put_DOS_Command

              ; **********************
db66            Kernal_SCRATCH ; $db66
              ; **********************

db66 20 68 dc           JSR Parse_DOS_Parameter
db69 20 04 d8           JSR Allow_Drive_Unit_Filename
db6c 20 9e db           JSR Are_You_Sure
db6f b0 21              BCS DiSt_Ret
db71 a0 36              LDY #$36
db73 a9 04              LDA #4
db75 20 98 da           JSR Put_DOS_Command
db78 20 51 f3           JSR In_Direct_Mode
db7b d0 15              BNE DiSt_Ret
db7d 20 91 d9           JSR Kernal_Read_DS
db80 a9 0d              LDA #CR
db82 20 02 e2           JSR EDIT_CHROUT

              ; **************
db85            Display_Status
              ; **************

db85 a0 00              LDY #0
db87 b9 ad 03 DiSt_10   LDA DOS_Status,Y
db8a c8                 INY
db8b 20 02 e2           JSR EDIT_CHROUT
db8e c9 20              CMP #' '            ; check for end
db90 b0 f5              BCS DiSt_10
db92 60       DiSt_Ret  RTS ;Size   14 [Display_Status]

db93 00 00 00           .FILL $db9e-* (0) ; 11 bytes

              ; ********************
db9e            Are_You_Sure ; $db9e
              ; ********************

db9e 20 51 f3           JSR In_Direct_Mode
dba1 d0 32              BNE AYS_20
dba3 a0 b6              LDY #<MSG_SURE      ; $b6
dba5 20 85 f1           JSR Display_Kernal_Message
dba8 20 a6 f2           JSR Kernal_CLRCHN
dbab 20 15 f2           JSR Kernal_CHRIN
dbae c9 59              CMP #'Y'
dbb0 d0 19              BNE AYS_10
dbb2 20 15 f2           JSR Kernal_CHRIN
dbb5 c9 0d              CMP #CR
dbb7 f0 1c              BEQ AYS_20
dbb9 c9 45              CMP #'E'
dbbb d0 0e              BNE AYS_10
dbbd 20 15 f2           JSR Kernal_CHRIN
dbc0 c9 53              CMP #'S'
dbc2 d0 07              BNE AYS_10
dbc4 20 15 f2           JSR Kernal_CHRIN
dbc7 c9 0d              CMP #CR
dbc9 f0 0a              BEQ AYS_20
dbcb c9 0d    AYS_10    CMP #CR
dbcd 38                 SEC
dbce f0 06              BEQ AYS_Ret
dbd0 20 15 f2           JSR Kernal_CHRIN
dbd3 d0 f6              BNE AYS_10
dbd5 18       AYS_20    CLC
dbd6 60       AYS_Ret   RTS ;Size   57 [Are_You_Sure]

dbd7 00 00 00           .FILL $dbe1-* (0) ; 10 bytes

              ; ********************
dbe1            Clear_Status ; $dbe1
              ; ********************

dbe1 a9 00              LDA #0
dbe3 85 96              STA STATUS          ; clear STATUS
dbe5 60                 RTS ;Size    5 [Clear_Status]

dbe6 00 00 00           .FILL $dbfa-* (0) ; 20 bytes

              ; *************************
dbfa            Build_DOS_Command ; $dbfa
              ; *************************

dbfa a2 00              LDX #0

              ; *******************
dbfc            Build_DOS_Command_X
              ; *******************

dbfc 8d 41 03           STA DOS_Command_Length
dbff 20 e1 db           JSR Clear_Status
dc02 ce 41 03 BDC_10    DEC DOS_Command_Length
dc05 30 45              BMI DOS_SETNAM      ; -> finished
dc07 c8                 INY
dc08 b9 38 d8           LDA DOS_Build_Table,Y
dc0b 10 39              BPL BDC_90          ; -> insert
dc0d c9 f1              CMP #$f1            ; insert file 1
dc0f d0 03              BNE BDC_20
dc11 20 d4 da           JSR Copy_Filename_To_DOS_Buffer
dc14 c9 f2    BDC_20    CMP #$f2            ; insert file 2
dc16 d0 03              BNE BDC_30
dc18 20 e1 da           JSR Copy_MEMUSS_To_DOS_Buffer
dc1b c9 e0    BDC_30    CMP #$e0            ; insert 2nd. attribute
dc1d d0 05              BNE BDC_40          ; W,S or R,record length
dc1f ad 3d 03           LDA DOS_Attr        ; record length
dc22 d0 22              BNE BDC_90          ; always
dc24 c9 d0    BDC_40    CMP #$d0            ; insert ID
dc26 d0 03              BNE BDC_50
dc28 20 fd da           JSR Insert_DOS_Id
dc2b c9 e1    BDC_50    CMP #$e1            ; insert 1st. attribute
dc2d d0 05              BNE BDC_60
dc2f 20 57 dc           JSR Write_Attribute
dc32 d0 12              BNE BDC_90
dc34 c9 d1    BDC_60    CMP #$d1            ; insert drive 1
dc36 d0 05              BNE BDC_70
dc38 ad 3b 03           LDA DOS_Drive_1
dc3b 10 07              BPL BDC_80
dc3d c9 d2    BDC_70    CMP #$d2            ; insert drive 2
dc3f d0 c1              BNE BDC_10
dc41 ad 3c 03           LDA DOS_Drive_2
dc44 09 30    BDC_80    ORA #'0'
dc46 9d 53 03 BDC_90    STA DOS_Command_Buffer,X
dc49 e8                 INX
dc4a d0 b6              BNE BDC_10

              ; **********
dc4c            DOS_SETNAM
              ; **********

dc4c 86 d1              STX FNLEN
dc4e a9 53              LDA #<DOS_Command_Buffer
dc50 85 da              STA FNADR
dc52 a9 03              LDA #>DOS_Command_Buffer
dc54 85 db              STA FNADR+1
dc56 60                 RTS ;Size   11 [DOS_SETNAM]

              ; ***************
dc57            Write_Attribute
              ; ***************

dc57 ad 3d 03           LDA DOS_Attr
dc5a f0 04              BEQ WrAt_10
dc5c a9 4c              LDA #'L'            ; L,record length
dc5e d0 07              BNE WrAt_Ret
dc60 a9 53    WrAt_10   LDA #'S'            ; W,S
dc62 8d 3d 03           STA DOS_Attr
dc65 a9 57              LDA #'W'
dc67 60       WrAt_Ret  RTS ;Size   17 [Write_Attribute]

              ; This is the universal DOS parser
              ; It is called by all BASIC 4 DOS commands and scans and stores

              ; LA              = logical address
              ; FA              = primary address (UNIT)
              ; DOS_Drive_1     = source drive
              ; DOS_Drive_2     = target drive
              ; FNADR, FNLEN    = source filename
              ; MEMUSS, DOS_Tmp = target filename
              ; Access  mode
              ; Replace mode

              ; DOS_Flags for parsing BASIC 4 DOS commands

              ; bit 0: $01 = source Filename given
              ; bit 1: $02 = target Filename given
              ; bit 2: $04 = logical address set in LA
              ; bit 3: $08 = primary address set in FA
              ; bit 4: $10 = drive 1 set
              ; bit 5: $20 = drive 2 set
              ; bit 6: $40 = W (Write) or L (Relative file) given
              ; bit 7: $80 = Save and replace flag '@'

              ; The routine returns with the flags stored in DOS_Flags
              ; and in the accumulator.

              ; ***************************
dc68            Parse_DOS_Parameter ; $dc68
              ; ***************************

dc68 a2 00              LDX #0              ; clear:
dc6a 8e 3e 03           STX DOS_Flags       ; all flags
dc6d 86 d2              STX LA              ; logical address
dc6f 8e 3d 03           STX DOS_Attr        ; attribute
dc72 8e 3b 03           STX DOS_Drive_1     ; source drive
dc75 8e 3c 03           STX DOS_Drive_2     ; target drive
dc78 86 d1              STX FNLEN           ; filename length
dc7a 8e 3a 03           STX DOS_Tmp         ; temporary storage
dc7d 8e 3f 03           STX DOS_Id          ; ID
dc80 86 9c              STX Source_Unit     ; for cross UNIT copy
dc82 a2 08              LDX #8              ; preset DOS device
dc84 86 d4              STX FA              ; with unit 8
dc86 20 76 00           JSR CHRGOT          ; start parsing
dc89 d0 03              BNE PDP_02          ; continue
dc8b 4c f9 dd           JMP PDP_68          ; finish

dc8e c9 23    PDP_02    CMP #'#'            ; logical address ?
dc90 f0 2a              BEQ PDP_10
dc92 c9 57              CMP #'W'            ; write mode ?
dc94 f0 3e              BEQ PDP_12
dc96 c9 4c              CMP #'L'            ; relative file ?
dc98 f0 45              BEQ PDP_14
dc9a c9 52              CMP #'R'            ; read mode ?
dc9c d0 03              BNE PDP_04
dc9e 4c 4a dd           JMP PDP_37

dca1 c9 44    PDP_04    CMP #'D'            ; Drive ?
dca3 f0 63              BEQ PDP_26          ; parse drive #
dca5 c9 91              CMP #$91            ; ON token
dca7 f0 4f              BEQ PDP_22          ; parse unit D(value)
dca9 c9 55              CMP #'U'            ; Unit ?
dcab f0 53              BEQ PDP_24          ; parse unit value
dcad c9 22              CMP #QUOTE
dcaf f0 44              BEQ PDP_20
dcb1 c9 49              CMP #'I'            ; ID parameter on HEADER ?
dcb3 f0 72              BEQ PDP_30
dcb5 c9 28              CMP #'('
dcb7 f0 3c              BEQ PDP_20
dcb9 4c 00 bf PDP_08    JMP Syntax_Error    ; parse error

dcbc ad 3e 03 PDP_10    LDA DOS_Flags       ; get logical address
dcbf 29 04              AND #4              ; test if set already
dcc1 d0 f6              BNE PDP_08          ; error if set
dcc3 20 87 de           JSR DOS_Parse_Value ; get logical address
dcc6 e0 00              CPX #0              ; is address equal zero ?
dcc8 f0 5a              BEQ PDP_28          ; -> illegal quantity
dcca 86 d2              STX LA              ; store logical address
dccc a9 04              LDA #4              ; logical address defined
dcce 20 fd dd           JSR Set_DOS_Flags
dcd1 4c 72 dd           JMP PDP_44

dcd4 2c 3e 03 PDP_12    BIT DOS_Flags       ; process W parameter
dcd7 70 e0              BVS PDP_08          ; bit 6 already set ?
dcd9 20 70 00           JSR CHRGET          ; skip 'W'
dcdc 4c ed dc           JMP PDP_16          ; continue

dcdf 20 87 de PDP_14    JSR DOS_Parse_Value ; get record length
dce2 e0 00              CPX #0              ; is it zero ?
dce4 f0 3e              BEQ PDP_28          ; -> illegal quantity
dce6 e0 ff              CPX #$ff            ; ist it 255 ?
dce8 f0 3a              BEQ PDP_28          ; -> illegal quantity
dcea 8e 3d 03           STX DOS_Attr        ; store record length

dced a9 40    PDP_16    LDA #$40            ; mark W or L set
dcef 20 fd dd           JSR Set_DOS_Flags
dcf2 4c 72 dd           JMP PDP_44

dcf5 4c 50 dd PDP_20    JMP PDP_38

dcf8 20 2c de PDP_22    JSR DOS_Parse_Unit
dcfb 86 9c              STX Source_Unit
dcfd 4c 72 dd           JMP PDP_44
dd00 20 33 de PDP_24    JSR Get_Unit_Value
dd03 86 9c              STX Source_Unit
dd05 4c 72 dd           JMP PDP_44
dd08 ad 3e 03 PDP_26    LDA DOS_Flags
dd0b 29 10              AND #16             ; drive # already set ?
dd0d d0 aa              BNE PDP_08          ; error if so
dd0f 20 87 de           JSR DOS_Parse_Value
dd12 e0 0a              CPX #10             ; original ROM had CPX #2 (D0 and D1 only)
dd14 b0 0e              BCS PDP_28          ; error for drive # > 9
dd16 8e 3b 03           STX DOS_Drive_1     ; store drive #
dd19 8e 3c 03           STX DOS_Drive_2     ; store drive #
dd1c a9 10              LDA #16             ; mark drive # set
dd1e 20 fd dd           JSR Set_DOS_Flags
dd21 4c 72 dd           JMP PDP_44
dd24 4c 27 de PDP_28    JMP DOS_JMP_Illegal_Quantity
dd27 ad 3d 03 PDP_30    LDA DOS_Attr        ; test DOS_Attr
dd2a 29 ff              AND #$ff            ; this is needless
dd2c f0 03              BEQ PDP_32          ; continue if zero
dd2e 4c 00 bf           JMP Syntax_Error    ; error if not zero
dd31 a0 00    PDP_32    LDY #0              ; parse ID string for HEADER
dd33 a2 00              LDX #0
dd35 e6 77    PDP_34    INC TXTPTR          ; advance TXTPTR
dd37 d0 02              BNE PDP_36
dd39 e6 78              INC TXTPTR+1
dd3b b1 77    PDP_36    LDA (TXTPTR),Y      ; get ID string
dd3d 9d 3f 03           STA DOS_Id,X
dd40 e8                 INX
dd41 e0 02              CPX #2              ; maximum 2 characters
dd43 90 f0              BCC PDP_34
dd45 a9 ff              LDA #$ff
dd47 8d 3d 03           STA DOS_Attr        ; mark ID defined
dd4a 20 70 00 PDP_37    JSR CHRGET          ; advance to next character
dd4d 4c 72 dd           JMP PDP_44
dd50 ad 3e 03 PDP_38    LDA DOS_Flags
dd53 29 01              AND #1              ; error if filename defined
dd55 20 49 de           JSR DOS_Parse_Filename
dd58 85 d1              STA FNLEN
dd5a 8d 41 03           STA DOS_Command_Length
dd5d 20 c5 d6           JSR Set_DOS_FNADR
dd60 a0 00              LDY #0
dd62 b1 1f    PDP_40    LDA (INDEXA),Y      ; copy string to filename
dd64 99 42 03           STA DOS_Filename,Y  ; store filename
dd67 c8                 INY
dd68 cc 41 03           CPY DOS_Command_Length
dd6b 90 f5              BCC PDP_40
dd6d a9 01              LDA #1              ; mark filename defined
dd6f 20 fd dd           JSR Set_DOS_Flags
dd72 20 76 00 PDP_44    JSR CHRGOT          ; next character to parse
dd75 d0 03              BNE PDP_46          ; there is more
dd77 4c f9 dd           JMP PDP_68          ; finish parsing
dd7a c9 2c    PDP_46    CMP #','            ; comma ?
dd7c d0 06              BNE PDP_48          ; look for tokens
dd7e 20 70 00           JSR CHRGET          ; next character after comma
dd81 4c 8e dc           JMP PDP_02          ; parse next sequence
dd84 c9 91    PDP_48    CMP #$91            ; ON token
dd86 d0 03              BNE PDP_50
dd88 4c f8 dc           JMP PDP_22          ; parse unit
dd8b c9 a4    PDP_50    CMP #$a4            ; TO token
dd8d f0 03              BEQ PDP_52
dd8f 4c 00 bf           JMP Syntax_Error
dd92 20 70 00 PDP_52    JSR CHRGET
dd95 c9 44              CMP #'D'
dd97 f0 13              BEQ PDP_56          ; parse target drive
dd99 c9 91              CMP #$91            ; ON token
dd9b f0 28              BEQ PDP_58          ; get UNIT
dd9d c9 55              CMP #'U'
dd9f f0 2a              BEQ PDP_60          ; get UNIT value
dda1 c9 22              CMP #QUOTE
dda3 f0 2c              BEQ PDP_62
dda5 c9 28              CMP #'('
dda7 f0 28              BEQ PDP_62
dda9 4c 00 bf PDP_54    JMP Syntax_Error
ddac ad 3e 03 PDP_56    LDA DOS_Flags
ddaf 29 20              AND #$20            ; Drive 2 defined ?
ddb1 d0 f6              BNE PDP_54          ; error if so
ddb3 20 87 de           JSR DOS_Parse_Value
ddb6 e0 0a              CPX #10             ; original ROM: CPX #2 (D0 and D1 only)
ddb8 b0 6d              BCS DOS_JMP_Illegal_Quantity
ddba 8e 3c 03           STX DOS_Drive_2
ddbd a9 20              LDA #$20            ; mark drive 2 defined
ddbf 20 fd dd           JSR Set_DOS_Flags
ddc2 4c e5 dd           JMP PDP_64
ddc5 20 2c de PDP_58    JSR DOS_Parse_Unit
ddc8 4c e5 dd           JMP PDP_64
ddcb 20 33 de PDP_60    JSR Get_Unit_Value
ddce 4c e5 dd           JMP PDP_64
ddd1 ad 3e 03 PDP_62    LDA DOS_Flags
ddd4 29 02              AND #2              ; error if target filename there
ddd6 20 49 de           JSR DOS_Parse_Filename
ddd9 8d 3a 03           STA DOS_Tmp         ; length of target filename
dddc 86 fd              STX MEMUSS          ; save descriptor in MEMUSS
ddde 84 fe              STY MEMUSS+1
dde0 a9 02              LDA #2              ; mark target filename parsed
dde2 20 fd dd           JSR Set_DOS_Flags
dde5 20 76 00 PDP_64    JSR CHRGOT          ; current character
dde8 f0 0f              BEQ PDP_68          ; finish
ddea c9 2c              CMP #','            ; another comma
ddec f0 a4              BEQ PDP_52          ; continue
ddee c9 91              CMP #$91            ; ON token
ddf0 f0 d3              BEQ PDP_58          ; continue
ddf2 c9 55              CMP #'U'
ddf4 f0 d5              BEQ PDP_60          ; get UNIT
ddf6 4c 00 bf PDP_66    JMP Syntax_Error
ddf9 ad 3e 03 PDP_68    LDA DOS_Flags
ddfc 60                 RTS ;Size  405 [Parse_DOS_Parameter]

              ; *************
ddfd            Set_DOS_Flags
              ; *************

ddfd 0d 3e 03           ORA DOS_Flags
de00 8d 3e 03           STA DOS_Flags
de03 60                 RTS ;Size    7 [Set_DOS_Flags]

de04 00 00 00           .FILL $de27 - * (0) ; 35 bytes

              ; ************************
de27            DOS_JMP_Illegal_Quantity
              ; ************************

de27 a2 35              LDX #Msg_QUANT-Msg_Start ; $35
de29 4c cf b3           JMP Basic_Error

              ; **************
de2c            DOS_Parse_Unit
              ; **************

de2c 20 70 00           JSR CHRGET
de2f c9 55              CMP #'U'
de31 d0 c3              BNE PDP_66

              ; **************
de33            Get_Unit_Value
              ; **************

de33 20 87 de           JSR DOS_Parse_Value
de36 e0 20              CPX #32
de38 b0 ed              BCS DOS_JMP_Illegal_Quantity
de3a e0 03              CPX #3
de3c 90 e9              BCC DOS_JMP_Illegal_Quantity
de3e 86 d4              STX FA
de40 a9 08              LDA #8
de42 4c fd dd           JMP Set_DOS_Flags

de45 00 00 00           .FILL $de49 - * (0) ; 4 bytes

              ; ******************
de49            DOS_Parse_Filename
              ; ******************

de49 d0 ab              BNE PDP_66
de4b 20 98 bd           JSR Eval_Expression
de4e 20 b5 c7           JSR Eval_And_Free_String
de51 aa                 TAX                 ; string length
de52 f0 d3              BEQ DOS_JMP_Illegal_Quantity
de54 a0 00              LDY #0
de56 b1 1f              LDA (INDEXA),Y
de58 c9 40              CMP #'@'            ; replace character
de5a d0 14              BNE DPF_30
de5c 2c 3e 03           BIT DOS_Flags       ; @ already used ?
de5f 10 03              BPL DPF_10
de61 4c 00 bf           JMP Syntax_Error
de64 e6 1f    DPF_10    INC INDEXA          ; skip @
de66 d0 02              BNE DPF_20
de68 e6 20              INC INDEXA+1
de6a ca       DPF_20    DEX                 ; length - @
de6b a9 80              LDA #$80
de6d 20 fd dd           JSR Set_DOS_Flags
de70 8a       DPF_30    TXA                 ; string length
de71 f0 b4              BEQ DOS_JMP_Illegal_Quantity
de73 c9 11              CMP #17
de75 90 05              BCC DPF_40
de77 a2 b0              LDX #[Msg_LONG - Msg_Start] ; $b0 : STRING TOO LONG
de79 4c cf b3           JMP Basic_Error
de7c a6 1f    DPF_40    LDX INDEXA          ; string address low
de7e a4 20              LDY INDEXA+1        ; string address high
de80 60                 RTS ;Size   56 [DOS_Parse_Filename]

de81 00 00 00           .FILL $de87 - * (0) ; 6 bytes

              ; ***************
de87            DOS_Parse_Value
              ; ***************

de87 20 70 00           JSR CHRGET

              ; ************
de8a            DOS_Get_Byte
              ; ************

de8a d0 03              BNE DGB_10
de8c 4c 00 bf           JMP Syntax_Error
de8f 90 09    DGB_10    BCC DGB_20
de91 20 f2 be           JSR Need_Left_Parenthesis
de94 20 d4 c8           JSR Get_Byte_Value
de97 4c ef be           JMP Need_Right_Parenthesis
de9a 4c d4 c8 DGB_20    JMP Get_Byte_Value

              ; *************
de9d            Start_Message
              ; *************

de9d 2a 2a 2a           .PET '*** BSOS 8296 ***\r\r',0

              ; ********
deb1            Renumber
              ; ********

              ; check for arguments: RENUMBER new start, increment, old start

deb1 a9 0a              LDA #10
deb3 85 21              STA RENINC          ; preset increment low
deb5 85 23              STA RENNEW          ; preset start low
deb7 a9 00              LDA #0
deb9 85 22              STA RENINC+1
debb 85 24              STA RENNEW+1
debd 20 76 00           JSR CHRGOT
dec0 b0 4d              BCS Renu_15         ; no arguments
dec2 20 f6 b8           JSR Scan_Linenumber
dec5 a5 11              LDA LINNUM
dec7 85 23              STA RENNEW          ; start low
dec9 05 12              ORA LINNUM+1
decb d0 03              BNE Renu_10
decd 4c 73 c3 Renu_Err  JMP Jump_To_Illegal_Quantity
ded0 a5 12    Renu_10   LDA LINNUM+1
ded2 85 24              STA RENNEW+1        ; start high
ded4 20 76 00           JSR CHRGOT
ded7 c9 2c              CMP #','
ded9 d0 34              BNE Renu_15
dedb 20 70 00           JSR CHRGET
dede 20 f6 b8           JSR Scan_Linenumber
dee1 a5 11              LDA LINNUM
dee3 85 21              STA RENINC          ; inc low
dee5 05 12              ORA LINNUM+1
dee7 f0 e4              BEQ Renu_Err
dee9 a5 12              LDA LINNUM+1
deeb 85 22              STA RENINC+1        ; inc high
deed 20 76 00           JSR CHRGOT
def0 c9 2c              CMP #','
def2 d0 1b              BNE Renu_15
def4 20 70 00           JSR CHRGET
def7 20 f6 b8           JSR Scan_Linenumber ; get old start
defa 20 e4 ea           JSR Find_Power_Line ; find start line
defd a0 02              LDY #2
deff b1 57              LDA (TMPPTB),Y      ; previous # low
df01 c5 23              CMP RENNEW
df03 c8                 INY
df04 b1 57              LDA (TMPPTB),Y      ; previous # high
df06 e5 24              SBC RENNEW+1
df08 b0 c3              BCS Renu_Err        ; New line # would be less than previous
df0a 20 2a ed           JSR Reset_BPTR
df0d d0 03              BNE Renu_20         ; always

              ; phase 1: build table of old and new numbers

df0f 20 22 ed Renu_15   JSR Reset_Renumber_Pointer
df12 20 43 ec Renu_20   JSR Install_Bank_Access
df15 a9 80              LDA #$80
df17 85 b6              STA R_Bank
df19 85 b7              STA W_Bank

              ; start of new line numbers

df1b a0 01    Renu_25   LDY #1
df1d b1 5c              LDA (TMPPTC),Y      ; link high
df1f f0 34              BEQ Renu_30         ; finished
df21 c8                 INY                 ; Y = 2

              ; next table entry

df22 b1 5c              LDA (TMPPTC),Y      ; old line low
df24 20 8b 02           JSR Bank_Store
df27 c8                 INY                 ; Y = 3
df28 b1 5c              LDA (TMPPTC),Y      ; old line high
df2a 20 8b 02           JSR Bank_Store
df2d a0 01              LDY #1
df2f a5 24              LDA RENNEW+1        ; new line high
df31 20 8b 02           JSR Bank_Store
df34 88                 DEY                 ; Y = 0
df35 a5 23              LDA RENNEW          ; new line low
df37 20 8b 02           JSR Bank_Store

              ; increment new line

df3a 18                 CLC
df3b a5 23              LDA RENNEW
df3d 65 21              ADC RENINC
df3f 85 23              STA RENNEW
df41 a5 24              LDA RENNEW+1
df43 65 22              ADC RENINC+1
df45 85 24              STA RENNEW+1
df47 c9 fa              CMP #$fa            ; > 64000
df49 b0 82              BCS Renu_Err        ; line # overflow

              ; increment table pointer

df4b a9 04              LDA #4
df4d 20 27 fb           JSR Add_BPTR

              ; next basic line

df50 20 33 ed           JSR Update_Link
df53 d0 c6              BNE Renu_25         ; branch if link is not zero

              ; table finished

df55 a0 03    Renu_30   LDY #3
df57 a9 ff              LDA #$ff            ; end marker
df59 20 8b 02 Renu_35   JSR Bank_Store
df5c 88                 DEY
df5d 10 fa              BPL Renu_35

              ; phase 2: build a renumbered copy in bank 2

df5f a9 8c              LDA #$8c
df61 85 b7              STA W_Bank
df63 20 22 ed           JSR Reset_Renumber_Pointer

              ; copy link - will be recalculated at end

df66 a0 00    Renu_40   LDY #0
df68 b1 5c              LDA (TMPPTC),Y      ; link low
df6a 20 8b 02           JSR Bank_Store
df6d c8                 INY
df6e b1 5c              LDA (TMPPTC),Y      ; link high
df70 20 8b 02           JSR Bank_Store
df73 f0 2b              BEQ Renu_45         ; finished

              ; exchange line number from table or copy if not found

df75 c8                 INY
df76 b1 5c              LDA (TMPPTC),Y      ; line # low
df78 aa                 TAX
df79 c8                 INY
df7a b1 5c              LDA (TMPPTC),Y      ; line # high
df7c 20 07 ec           JSR Find_Entry
df7f a0 02              LDY #2
df81 a5 11              LDA LINNUM
df83 20 8b 02           JSR Bank_Store
df86 c8                 INY
df87 a5 12              LDA LINNUM+1
df89 20 8b 02           JSR Bank_Store
df8c 20 7e ec           JSR Xfer_Line
df8f c8                 INY                 ; Add Y + 1
df90 98                 TYA
df91 20 27 fb           JSR Add_BPTR
df94 20 33 ed           JSR Update_Link
df97 a5 fa              LDA BPTR+1
df99 c9 fb              CMP #$fb
df9b 90 c9              BCC Renu_40
df9d 4c cd b3           JMP Error_Out_Of_Memory

              ; copy new program from bank 2 to BASIC memory

dfa0 a9 8c    Renu_45   LDA #$8c            ; bank 1
dfa2 85 b6              STA R_Bank
dfa4 18                 CLC
dfa5 a5 f9              LDA BPTR
dfa7 69 03              ADC #3
dfa9 85 23              STA RENNEW          ; end address low
dfab a5 fa              LDA BPTR+1
dfad 69 00              ADC #0
dfaf aa                 TAX                 ; end address high
dfb0 a9 00              LDA #0
dfb2 85 fb              STA STAL
dfb4 a9 80              LDA #$80
dfb6 85 fc              STA STAL+1
dfb8 20 22 ed           JSR Reset_Renumber_Pointer
dfbb a0 00              LDY #0
dfbd 20 7a 02 Renu_50   JSR Bank_Fetch
dfc0 91 5c              STA (TMPPTC),Y
dfc2 c4 23              CPY RENNEW
dfc4 d0 04              BNE Renu_55
dfc6 e4 fc              CPX STAL+1
dfc8 f0 09              BEQ Renu_60
dfca c8       Renu_55   INY
dfcb d0 f0              BNE Renu_50
dfcd e6 5d              INC TMPPTC+1
dfcf e6 fc              INC STAL+1
dfd1 d0 ea              BNE Renu_50
dfd3 a5 5d    Renu_60   LDA TMPPTC+1
dfd5 84 2a    Renu_90   STY VARTAB          ; entry for Delete routine
dfd7 85 2b              STA VARTAB+1
dfd9 20 e9 b5           JSR Reset_BASIC_Execution
dfdc 20 b6 b4           JSR Rechain
dfdf 4c ff b3           JMP Basic_Ready

dfe2 00 00 00           .FILL $e000-* (0) ; 30 bytes

              ; *****************
e000            EDITOR_JUMP_TABLE
              ; *****************

e000 4c 37 e0           JMP EDIT_RESET
e003 4c a7 e0           JMP EDIT_GETIN
e006 4c 16 e1           JMP EDIT_CHRIN
e009 4c 02 e2           JMP EDIT_CHROUT
e00c 4c 42 e4           JMP IRQ_MAIN
e00f 4c 55 e4           JMP IRQ_NORMAL
e012 4c 77 e4           JMP IRQ_END
e015 4c 3d e0           JMP EDIT_CLEAR
e018 4c d6 e9           JMP EDIT_CHARSET_TEXT
e01b 4c e4 e9           JMP EDIT_CHARSET_GRAPHICS
e01e 4c d3 e9           JMP EDIT_RESET_CRT
e021 4c 17 e4           JMP EDIT_SCROLL_DOWN
e024 4c 29 e4           JMP EDIT_SCROLL_UP
e027 4c 24 e9           JMP EDIT_KEY_SCAN
e02a 4c 8d e6           JMP EDIT_BEEP
e02d 4c 8d e6           JMP EDIT_BEEP
e030 4c ca e1           JMP EDIT_TOP_LEFT
e033 4c c5 e1           JMP EDIT_BOTTOM_RIGHT
e036 60                 RTS ; EDIT_REPEAT ;Size   55 [EDITOR_JUMP_TABLE]

              ; **********
e037            EDIT_RESET
              ; **********

e037 20 06 e6           JSR Edit_Init
e03a 20 d3 e9           JSR EDIT_RESET_CRT

              ; **********
e03d            EDIT_CLEAR
              ; **********

e03d a6 e0              LDX TopMargin
e03f 20 c9 e6 EDCL_10   JSR Cursor_BOL
e042 20 aa e1           JSR Edit_Erase_To_EOL
e045 e4 e1              CPX BotMargin
e047 e8                 INX
e048 90 f5              BCC EDCL_10         ; fall

              ; *********
e04a            EDIT_HOME
              ; *********

e04a a6 e0              LDX TopMargin
e04c 86 d8              STX CursorRow       ; fall

              ; *********************
e04e            Edit_Goto_Left_Margin
              ; *********************

e04e a4 e2              LDY LefMargin
e050 84 c6              STY CursorCol       ; fall

              ; ******************
e052            Edit_Use_CursorRow
              ; ******************

e052 a6 d8              LDX CursorRow
e054 4c cb e6           JMP Update_ScrPtr

              ; ************
e057            EDIT_SET_CRT
              ; ************

              ; Input:  A = table low
              ;         X = table high
              ;         Y = # of registers

e057 85 c7              STA SAL
e059 86 c8              STX SAL+1
e05b b1 c7    ESC_10    LDA (SAL),Y
e05d 8c 80 e8           STY CRT_Address
e060 8d 81 e8           STA CRT_Value
e063 88                 DEY
e064 10 f5              BPL ESC_10
e066 60                 RTS ;Size   16 [EDIT_SET_CRT]


              ; *****************
e067            Edit_Program_Rows
              ; *****************

              ; Input:  A = maximum raster address (7 or 9)
              ;         Y = screen rows (30 or 25)

e067 84 df              STY ScreenRows
e069 c8                 INY
e06a a2 06              LDX #6
e06c 8e 80 e8           STX CRT_Address
e06f 8c 81 e8           STY CRT_Value
e072 a2 09              LDX #9
e074 8e 80 e8           STX CRT_Address
e077 8d 81 e8           STA CRT_Value
e07a 60                 RTS ;Size   20 [Edit_Program_Rows]

e07b 00 00 00           .FILL $e0a7-* (0) ; 44 bytes

              ; ******************
e0a7            EDIT_GETIN ; $e0a7
              ; ******************

e0a7 ac 6f 02           LDY KEYD            ; get next character
e0aa a2 00              LDX #0              ; scroll keyboard buffer
e0ac bd 70 02 EDGE_10   LDA KEYD+1,X
e0af 9d 6f 02           STA KEYD,X
e0b2 e8                 INX
e0b3 e4 9e              CPX CharsInBuffer
e0b5 90 f5              BCC EDGE_10
e0b7 c6 9e              DEC CharsInBuffer
e0b9 98                 TYA                 ; return character in (A)
e0ba 58                 CLI
e0bb 60                 RTS ;Size   21 [EDIT_GETIN]

              ; *************
e0bc            Edit_Get_Line
              ; *************

e0bc 20 02 e2           JSR EDIT_CHROUT
e0bf a5 9e    EGL_10    LDA CharsInBuffer
e0c1 85 a7              STA BLNSW           ; empty buffer -> blink cursor
e0c3 f0 fa              BEQ EGL_10          ; loop until char in buffer
e0c5 78                 SEI                 ; disable IRQ while working with buffer
e0c6 a5 aa              LDA BLNON           ; blink phase
e0c8 f0 0d              BEQ EGL_20          ; normal ?
e0ca a0 00              LDY #0
e0cc 84 aa              STY BLNON           ; blink phase normal
e0ce c8                 INY
e0cf 84 a8              STY BLNCT           ; start with visible cursor
e0d1 a5 a9              LDA GDBLN           ; character under cursor
e0d3 a4 c6              LDY CursorCol
e0d5 91 c4              STA (ScrPtr),Y
e0d7 20 a7 e0 EGL_20    JSR EDIT_GETIN
e0da c9 83              CMP #$83            ; RUN key ?
e0dc d0 0f              BNE EGL_40
e0de a2 08              LDX #8
e0e0 86 9e              STX CharsInBuffer
e0e2 bd dc e6 EGL_30    LDA RUN_String-1,X  ; DLOAD"*" RUN
e0e5 9d 6e 02           STA KEYD-1,X
e0e8 ca                 DEX
e0e9 d0 f7              BNE EGL_30
e0eb f0 d2              BEQ EGL_10          ; always
e0ed c9 0d    EGL_40    CMP #CR             ; RETURN ?
e0ef d0 cb              BNE Edit_Get_Line
e0f1 a4 d5              LDY RigMargin
e0f3 84 ac              STY CRSW            ; not 0 -> Screen Input
e0f5 a9 20              LDA #' '            ; Ignore trailing blanks
e0f7 d1 c4    EGL_50    CMP (ScrPtr),Y
e0f9 d0 03              BNE EGL_60
e0fb 88                 DEY
e0fc d0 f9              BNE EGL_50
e0fe c8       EGL_60    INY
e0ff 84 a1              STY LastInputCol    ; position after last non blank char
e101 20 b4 e1           JSR Edit_To_Left_Margin
e104 84 cd              STY QTSW            ; = 0 (off)
e106 a5 a3              LDA InputRow
e108 c5 d8              CMP CursorRow
e10a d0 15              BNE Edit_CHRIN_Screen
e10c a5 a4              LDA InputCol
e10e 85 c6              STA CursorCol
e110 c5 a1              CMP LastInputCol
e112 90 0d              BCC Edit_CHRIN_Screen
e114 b0 36              BCS ECS_40

e116                    .SIZE ;   90 [Edit_Get_Line]

e116                    .FILL $e116-* (0) ; 0 bytes

              ; ******************
e116            EDIT_CHRIN ; $e116
              ; ******************

e116 98                 TYA
e117 48                 PHA
e118 8a                 TXA
e119 48                 PHA
e11a 6c e9 00           JMP (SCRIV)         ; default: jump to next statement

              ; *******************
e11d            Edit_CHRIN_Standard
              ; *******************

e11d a5 ac              LDA CRSW
e11f f0 9e              BEQ EGL_10

              ; *****************
e121            Edit_CHRIN_Screen
              ; *****************

e121 a4 c6              LDY CursorCol
e123 b1 c4              LDA (ScrPtr),Y      ; get char at cursor position
e125 c9 74              CMP #$74            ; code for Pi
e127 d0 04              BNE ECS_05
e129 a9 ff              LDA #$ff
e12b d0 16              BNE ECS_30
e12d 85 d9    ECS_05    STA DATAX           ; save it in DATAX
e12f 29 3f              AND #$3f            ; lower case, symbols and digits
e131 06 d9              ASL DATAX           ; reverse bit 7 -> carry
e133 24 d9              BIT DATAX           ; uppercase or graphics ?
e135 10 02              BPL ECS_10          ; branch if not
e137 09 80              ORA #$80            ; convert upper case to PETSCII
e139 90 04    ECS_10    BCC ECS_20          ; branch if not reversed
e13b a6 cd              LDX QTSW            ; quote mode ?
e13d d0 04              BNE ECS_30          ; no conversion in quote mode
e13f 70 02    ECS_20    BVS ECS_30          ; no conversion for graphics
e141 09 40              ORA #$40            ; display code to PETSCII
e143 e6 c6    ECS_30    INC CursorCol       ; advance cursor
e145 20 64 e1           JSR Edit_Quote_Toggle
e148 c4 a1              CPY LastInputCol    ; at end of input ?
e14a 90 0f              BCC ECS_50          ; return if not
e14c a9 00    ECS_40    LDA #0
e14e 85 ac              STA CRSW            ; switch input to keyboard
e150 a9 0d              LDA #CR             ; load CR
e152 a2 03              LDX #3              ; screen channel
e154 e4 b0              CPX DFLTO           ; output = screen ?
e156 f0 03              BEQ ECS_50          ; don't echo CR
e158 20 02 e2           JSR EDIT_CHROUT
e15b 85 d9    ECS_50    STA DATAX           ; save character in DATAX
e15d 68                 PLA
e15e aa                 TAX                 ; restore X
e15f 68                 PLA
e160 a8                 TAY                 ; restore Y
e161 a5 d9              LDA DATAX
e163 60       ECS_Ret   RTS ;Size   67 [Edit_CHRIN_Screen]

              ; *****************
e164            Edit_Quote_Toggle
              ; *****************

e164 c9 22              CMP #QUOTE
e166 d0 06              BNE EQT_Ret
e168 e5 cd              SBC QTSW
e16a 85 cd              STA QTSW
e16c a9 22              LDA #QUOTE
e16e 60       EQT_Ret   RTS ;Size   11 [Edit_Quote_Toggle]

              ; *****************
e16f            Edit_Display_Char
              ; *****************

e16f a6 9f              LDX ReverseFlag
e171 f0 02              BEQ EDC_10
e173 09 80              ORA #$80
e175 a6 dc    EDC_10    LDX INSRT        ;  3  ; # of inserts outstanding
e177 f0 02              BEQ EDC_20       ;  3
e179 c6 dc              DEC INSRT
e17b 91 c4    EDC_20    STA (ScrPtr),Y   ;  6
e17d a9 01              LDA #1           ;  2
e17f 85 a8              STA BLNCT        ;  3
e181 c4 d5              CPY RigMargin    ;  3
e183 c8                 INY              ;  2
e184 90 05              BCC EDC_30       ;  3 = 28 [total 85]

              ; ************************
e186           Edit_Chrout_Epilog_Return
              ; ************************

e186 20 e1 e3           JSR Edit_Cursor_Down
e189 a4 e2              LDY LefMargin
e18b 84 c6    EDC_30    STY CursorCol    ;  3

              ; ******************
e18d            Edit_Chrout_Epilog
              ; ******************

e18d 68                 PLA              ;  4
e18e a8                 TAY              ;  2 ; restore Y
e18f 68                 PLA              ;  4
e190 aa                 TAX              ;  2 ; restore X
e191 68                 PLA              ;  4
e192 85 e8              STA PrevChar     ;  3 ; save last used character
e194 58                 CLI              ;  2
e195 60                 RTS              ;  6 = 27 [total 112] ;Size    9 [Edit_Chrout_Epilog]

              ; **************
e196            Edit_Wrap_Back
              ; **************

e196 a4 e2              LDY LefMargin
e198 a6 e0              LDX TopMargin
e19a e4 d8              CPX CursorRow
e19c b0 07              BCS EWB_10          ; don't wrap on top row
e19e a4 d5              LDY RigMargin
e1a0 c6 d8              DEC CursorRow
e1a2 20 52 e0           JSR Edit_Use_CursorRow
e1a5 84 c6    EWB_10    STY CursorCol
e1a7 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *****************
e1aa            Edit_Erase_To_EOL
              ; *****************

e1aa a9 20              LDA #' '
e1ac 91 c4    EETE_10   STA (ScrPtr),Y
e1ae c4 d5              CPY RigMargin
e1b0 c8                 INY
e1b1 90 f9              BCC EETE_10
e1b3 60                 RTS ;Size   10 [Edit_Erase_To_EOL]

              ; *******************
e1b4            Edit_To_Left_Margin
              ; *******************

e1b4 a4 e2              LDY LefMargin
e1b6 84 c6              STY CursorCol
e1b8 a0 00              LDY #0
e1ba 60                 RTS ;Size    7 [Edit_To_Left_Margin]

              ; ****************
e1bb            Edit_Full_Screen
              ; ****************

e1bb a9 00              LDA #0
e1bd 85 e0              STA TopMargin
e1bf 85 e2              STA LefMargin
e1c1 a5 df              LDA ScreenRows      ; bottom margin
e1c3 a2 4f              LDX #79             ; right  margin

              ; *****************
e1c5            EDIT_BOTTOM_RIGHT
              ; *****************

e1c5 85 e1              STA BotMargin
e1c7 86 d5              STX RigMargin
e1c9 60                 RTS ;Size    5 [EDIT_BOTTOM_RIGHT]

              ; *************
e1ca            EDIT_TOP_LEFT
              ; *************

e1ca 85 e0              STA TopMargin
e1cc 86 e2              STX LefMargin
e1ce 60                 RTS ;Size    5 [EDIT_TOP_LEFT]

e1cf 4c 16 e3 CO_Shift  JMP Edit_CHROUT_Shifted

              ; ******
e1d2            CO_Tab
              ; ******

e1d2 a4 c6              LDY CursorCol
e1d4 c4 d5              CPY RigMargin
e1d6 b0 11              BCS EdDC_05         ; CO_Exit
e1d8 e6 c6              INC CursorCol
e1da 20 25 e5           JSR IS_TAB
e1dd f0 f3              BEQ CO_Tab
e1df 4c 66 e2           JMP CO_Exit

e1e2                    .SIZE ;   16 [CO_Tab]

e1e2 4c e2 e2 CO_Size   JMP Edit_Screen_25

              ; ****************
e1e5            Edit_Delete_Char
              ; ****************

e1e5 a6 e2              LDX LefMargin
e1e7 e4 c6              CPX CursorCol
e1e9 b0 7b    EdDC_05   BCS CO_Exit        ; no delete on left margin
e1eb c6 c6              DEC CursorCol
e1ed b1 c4    EdDC_10   LDA (ScrPtr),Y
e1ef 88                 DEY
e1f0 91 c4              STA (ScrPtr),Y
e1f2 c8                 INY
e1f3 c4 d5              CPY RigMargin
e1f5 c8                 INY
e1f6 90 f5              BCC EdDC_10
e1f8 88                 DEY
e1f9 a9 20              LDA #' '
e1fb 91 c4              STA (ScrPtr),Y
e1fd d0 67              BNE CO_Exit

e1ff                    .SIZE ;   26 [Edit_Delete_Char]

e1ff 00 00 00           .FILL $e202-* (0) ; 3 bytes

              ; *******************
e202            EDIT_CHROUT ; $e202
              ; *******************

e202 48                 PHA            ;  3
e203 85 d9              STA DATAX      ;  3
e205 8a                 TXA            ;  2
e206 48                 PHA            ;  3
e207 98                 TYA            ;  2
e208 48                 PHA            ;  3
e209 6c eb 00           JMP (SCROV)    ;  5    ; -> Edit_CHROUT_Standard
                                       ; 19

              ; ****************************
e20c            Edit_CHROUT_Standard ; $e20c
              ; ****************************

e20c a9 00              LDA #0         ;  2
e20e 85 ac              STA CRSW       ;  3 ; input from keyboard
e210 a4 c6              LDY CursorCol  ;  3
e212 a5 d9              LDA DATAX      ;  3 ; char to display (PETSCII)
e214 30 b9              BMI CO_Shift   ;  2
e216 c9 20              CMP #' '       ;  2 ; printable ?
e218 b0 4f              BCS CO_Normal  ;  3 = 16 [total 35]
e21a c9 0d              CMP #CR             ; RETURN
e21c f0 71              BEQ CO_Return
e21e c9 1b              CMP #ESC            ; ESCAPE
e220 f0 70              BEQ CO_Escape
e222 a6 dc              LDX INSRT           ; insert mode ?
e224 d0 76              BNE CO_Rev
e226 c9 14              CMP #DEL            ; DELETE
e228 f0 bb              BEQ Edit_Delete_Char
e22a a6 cd              LDX QTSW            ; quote mode ?
e22c d0 6e              BNE CO_Rev
e22e c9 1d              CMP #RIGHT          ; cursor RIGHT
e230 f0 3f              BEQ CO_Right
e232 c9 11              CMP #DOWN           ; cursor DOWN
e234 f0 44              BEQ CO_Down
e236 c9 12              CMP #RVS            ; REVERSE
e238 f0 45              BEQ CO_RVS
e23a c9 07              CMP #BELL           ; ring bell
e23c f0 47              BEQ CO_Bell
e23e c9 0e              CMP #CTRLN          ; select text character set
e240 f0 48              BEQ CO_ChText
e242 c9 02              CMP #CTRLB          ; select new character set
e244 f0 4f              BEQ CO_ChNew
e246 c9 0f              CMP #CTRLO          ; set top left window corner
e248 f0 57              BEQ CO_Top
e24a c9 09              CMP #TAB            ; TAB
e24c f0 84              BEQ CO_Tab
e24e c9 19              CMP #CTRLY          ; scroll window up
e250 f0 5a              BEQ CO_ScUp
e252 c9 16              CMP #CTRLV          ; Delete to EOL
e254 f0 61              BEQ CO_DEOL
e256 c9 15              CMP #CTRLU          ; delete line
e258 f0 68              BEQ CO_DLine
e25a c9 04              CMP #CTRLD          ; toggle screen size
e25c f0 84              BEQ CO_Size
e25e c9 13              CMP #HOME           ; HOME
e260 f0 6d              BEQ CO_Home
e262 c9 01              CMP #CTRLA          ; scroll window down
e264 f0 43              BEQ CO_ScDown
e266 4c 8d e1 CO_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Standard

e269 29 3f    CO_Normal AND #$3f               ;  2 ; PETSCII -> display code
e26b 20 64 e1           JSR Edit_Quote_Toggle  ; 17
e26e 4c 6f e1           JMP Edit_Display_Char  ;  3 = 22 [total 57]

e271 c4 d5    CO_Right  CPY RigMargin
e273 e6 c6              INC CursorCol
e275 90 ef              BCC CO_Exit
e277 4c 86 e1           JMP Edit_Chrout_Epilog_Return

e27a 20 e1 e3 CO_Down   JSR Edit_Cursor_Down
e27d d0 e7              BNE CO_Exit         ; always

e27f a9 80    CO_RVS    LDA #$80
e281 85 9f              STA ReverseFlag
e283 d0 e1              BNE CO_Exit         ; always

e285 20 8d e6 CO_Bell   JSR EDIT_BEEP
e288 f0 dc              BEQ CO_Exit         ; always

e28a 20 d6 e9 CO_ChText JSR EDIT_CHARSET_TEXT
e28d 30 d7              BMI CO_Exit         ; always

e28f 4c f4 e3 CO_Return JMP CO_Screen_Return

e292 4c ff e3 CO_Escape JMP CO_JMP_Escape

e295 a9 10    CO_ChNew  LDA #$10
e297 20 ca e9 CO_Switch JSR Edit_Switch_Char_ROM
e29a d0 ca              BNE CO_Exit         ; always

e29c 09 80    CO_Rev    ORA #$80
e29e 4c 6f e1           JMP Edit_Display_Char

e2a1 a6 d8    CO_Top    LDX CursorRow
e2a3 86 e0              STX TopMargin
e2a5 84 e2              STY LefMargin
e2a7 10 bd              BPL CO_Exit         ; always

e2a9 4c b5 e3 CO_ScDown JMP CS_ScDown

e2ac 20 29 e4 CO_ScUp   JSR EDIT_SCROLL_UP
e2af 20 39 ea           JSR Power_Scroll_Up
e2b2 20 52 e0           JSR Edit_Use_CursorRow
e2b5 d0 af              BNE CO_Exit         ; always

e2b7 a9 20    CO_DEOL   LDA #' '
e2b9 91 c4    CODE_10   STA (ScrPtr),Y
e2bb c4 d5              CPY RigMargin
e2bd c8                 INY
e2be 90 f9              BCC CODE_10
e2c0 b0 a4              BCS CO_Exit

e2c2 a5 e0    CO_DLine  LDA TopMargin
e2c4 48                 PHA
e2c5 a5 d8              LDA CursorRow
e2c7 85 e0              STA TopMargin
e2c9 20 29 e4           JSR EDIT_SCROLL_UP
e2cc 4c d8 e3           JMP TM_Epi

e2cf c5 e8    CO_Home   CMP PrevChar             ; twice pressed ?
e2d1 d0 03              BNE COHo_10
e2d3 20 bb e1 CoHo_05   JSR Edit_Full_Screen     ; 2nd. <HOME> resets margins
e2d6 20 4a e0 COHo_10   JSR EDIT_HOME
e2d9 4c 8d e1           JMP Edit_Chrout_Epilog

e2dc          Edit_Screen_30
e2dc a9 07              LDA #7              ; maximum raster address
e2de a0 1d              LDY #29             ; 30 rows
e2e0 d0 04              BNE Edit_Screen_Program
e2e2          Edit_Screen_25
e2e2 a9 09              LDA #9              ; maximum raster address
e2e4 a0 18              LDY #24             ; 25 rows (default)
e2e6          Edit_Screen_Program
e2e6 20 67 e0           JSR Edit_Program_Rows
e2e9 20 bb e1           JSR Edit_Full_Screen
e2ec 4c 79 e3           JMP CS_Clear

e2ef 4c f4 e3 CS_Return JMP CO_Screen_Return

              ; ****************
e2f2            Edit_Insert_Char
              ; ****************

e2f2 a4 d5              LDY RigMargin
e2f4 b1 c4              LDA (ScrPtr),Y
e2f6 c9 20              CMP #' '
e2f8 d0 66              BNE CS_Exit       ; right most char not blank
e2fa 88       InCh_10   DEY
e2fb c4 c6              CPY CursorCol     ; clc if left from cursor
e2fd b1 c4              LDA (ScrPtr),Y
e2ff c8                 INY
e300 90 05              BCC InCh_20
e302 91 c4              STA (ScrPtr),Y
e304 88                 DEY
e305 d0 f3              BNE InCh_10       ; at first column
e307 a9 20    InCh_20   LDA #' '
e309 91 c4              STA (ScrPtr),Y
e30b 98                 TYA
e30c 65 dc              ADC INSRT
e30e c5 d5              CMP RigMargin
e310 b0 4e              BCS CS_Exit
e312 e6 dc              INC INSRT
e314 d0 4a              BNE CS_Exit         ; always

e316                    .SIZE ;   36 [Edit_Insert_Char]

              ; *******************
e316            Edit_CHROUT_Shifted
              ; *******************

e316 29 7f              AND #$7f
e318 c9 7f              CMP #$7f            ; Pi
e31a f0 4a              BEQ CS_Pi
e31c c9 20              CMP #' '            ; printable ?
e31e b0 49              BCS CS_Print
e320 c9 0d              CMP #CR             ; shifted RETURN
e322 f0 cb              BEQ CS_Return
e324 a6 cd              LDX QTSW            ; quote mode
e326 d0 46              BNE CS_Rev
e328 c9 14              CMP #DEL            ; INSERT
e32a f0 c6              BEQ Edit_Insert_Char
e32c a6 dc              LDX INSRT           ; insert mode ?
e32e d0 3e              BNE CS_Rev
e330 c9 1d              CMP #RIGHT          ; cursor LEFT
e332 f0 5d              BEQ CS_Left
e334 c9 11              CMP #DOWN           ; cursor UP
e336 f0 73              BEQ CS_Up
e338 c9 12              CMP #RVS            ; REVERSE OFF
e33a f0 37              BEQ CS_RVS
e33c c9 13              CMP #HOME           ; CLEAR
e33e f0 39              BEQ CS_Clear
e340 c9 09              CMP #TAB            ; shifted TAB
e342 f0 58              BEQ CS_Tab
e344 c9 16              CMP #CTRLV          ; shifted Ctrl-V
e346 f0 79              BEQ CS_Delete_BOL
e348 c9 02              CMP #CTRLB          ; select old character set
e34a f0 32              BEQ CS_ChOld
e34c c9 19              CMP #CTRLY          ; scroll window down
e34e f0 65              BEQ CS_ScDown
e350 c9 0f              CMP #CTRLO          ; set window bottom right
e352 f0 2f              BEQ CS_Bottom
e354 c9 0e              CMP #CTRLN          ; select graphics character set
e356 f0 33              BEQ CS_Graph
e358 c9 15              CMP #CTRLU          ; shifted Ctrl-U
e35a f0 72              BEQ CS_Insert_Line
e35c c9 04              CMP #CTRLD          ; switch to 26 row screen
e35e f0 03              BEQ CS_Size
e360 4c 8d e1 CS_Exit   JMP Edit_Chrout_Epilog

              ; Dispatch area for Edit_CHROUT_Shifted

e363 4c dc e2 CS_Size   JMP Edit_Screen_30
e366 a9 74    CS_Pi     LDA #$74
e368 2c                 .BYTE $2c
e369 09 40    CS_Print  ORA #$40            ; PETSCII to display
e36b 4c 6f e1           JMP Edit_Display_Char

e36e 09 c0    CS_Rev    ORA #$c0            ; reverse upper case
e370 4c 6f e1           JMP Edit_Display_Char

e373 a9 00    CS_RVS    LDA #0
e375 85 9f              STA ReverseFlag
e377 f0 e7              BEQ CS_Exit         ; always

e379 20 3d e0 CS_Clear  JSR EDIT_CLEAR
e37c d0 e2              BNE CS_Exit         ; always

e37e a9 30    CS_ChOld  LDA #$30
e380 4c 97 e2           JMP CO_Switch

e383 a5 d8    CS_Bottom LDA CursorRow
e385 85 e1              STA BotMargin
e387 84 d5              STY RigMargin
e389 10 d5              BPL CS_Exit       ; always

e38b 20 e4 e9 CS_Graph  JSR EDIT_CHARSET_GRAPHICS
e38e 4c 8d e1           JMP Edit_Chrout_Epilog

e391 a4 e2    CS_Left   LDY LefMargin
e393 c4 c6              CPY CursorCol
e395 c6 c6              DEC CursorCol
e397 90 c7              BCC CS_Exit
e399 4c 96 e1           JMP Edit_Wrap_Back

e39c 20 25 e5 CS_Tab    JSR IS_TAB
e39f bd ee 03           LDA TABS_SET,X
e3a2 59 37 e5           EOR BITPOS,Y        ; toggle TAB bit
e3a5 9d ee 03           STA TABS_SET,X
e3a8 4c 8d e1           JMP Edit_Chrout_Epilog

e3ab a6 e0    CS_Up     LDX TopMargin
e3ad e4 d8              CPX CursorRow
e3af b0 04              BCS CS_ScDown
e3b1 c6 d8              DEC CursorRow
e3b3 10 06              BPL COSW_10         ; always

e3b5 20 17 e4 CS_ScDown JSR EDIT_SCROLL_DOWN
e3b8 20 71 ea           JSR Power_Scroll_Down
e3bb 20 52 e0 COSW_10   JSR Edit_Use_CursorRow
e3be 4c 8d e1           JMP Edit_Chrout_Epilog

              ; *************
e3c1            CS_Delete_BOL
              ; *************

e3c1 a9 20              LDA #' '
e3c3 a4 e2              LDY LefMargin
e3c5 c4 c6    CSDB_10   CPY CursorCol
e3c7 b0 97              BCS CS_Exit
e3c9 91 c4              STA (ScrPtr),Y
e3cb c8                 INY
e3cc d0 f7              BNE CSDB_10

e3ce                    .SIZE ;   13 [CS_Delete_BOL]

              ; **************
e3ce            CS_Insert_Line
              ; **************

e3ce a5 e0              LDA TopMargin
e3d0 48                 PHA
e3d1 a5 d8              LDA CursorRow
e3d3 85 e0              STA TopMargin
e3d5 20 17 e4           JSR EDIT_SCROLL_DOWN
e3d8 68       TM_Epi    PLA
e3d9 85 e0              STA TopMargin
e3db 20 4e e0           JSR Edit_Goto_Left_Margin
e3de 4c 8d e1           JMP Edit_Chrout_Epilog

e3e1                    .SIZE ;   19 [CS_Insert_Line]

              ; ****************
e3e1            Edit_Cursor_Down
              ; ****************

e3e1 46 a3              LSR InputRow        ; invalidate InputRow
e3e3 a6 d8              LDX CursorRow
e3e5 e4 e1              CPX BotMargin
e3e7 90 06              BCC CSCD_10
e3e9 20 29 e4           JSR EDIT_SCROLL_UP
e3ec 4c 39 ea           JMP Power_Scroll_Up
e3ef e6 d8    CSCD_10   INC CursorRow
e3f1 4c 52 e0           JMP Edit_Use_CursorRow

e3f4                    .SIZE ;   19 [Edit_Cursor_Down]

              ; ****************
e3f4            CO_Screen_Return
              ; ****************

e3f4 a0 00              LDY #0
e3f6 84 99              STY Power_Flag
e3f8 a4 e2              LDY LefMargin
e3fa 84 c6              STY CursorCol
e3fc 20 e1 e3           JSR Edit_Cursor_Down

              ; *************
e3ff            CO_JMP_Escape
              ; *************

e3ff a9 00              LDA #0
e401 85 dc              STA INSRT           ; clear insert mode
e403 85 9f              STA ReverseFlag     ; clear reverse mode
e405 85 cd              STA QTSW            ; clear quote mode
e407 4c 8d e1           JMP Edit_Chrout_Epilog

              ; ***********
e40a            Edit_Scroll
              ; ***********

e40a 20 b7 e6           JSR Set_Screen_SAL  ; 25
e40d b1 c7    ES_10     LDA (SAL),Y         ;  5
e40f 91 c4              STA (ScrPtr),Y      ;  6
e411 c4 d5              CPY RigMargin       ;  3
e413 c8                 INY                 ;  2
e414 90 f7              BCC ES_10           ;  3
e416 60                 RTS ;Size   13 [Edit_Scroll]
                                            ; total = 25 + 80 * 19 + 2 = 1547

              ; ****************
e417            EDIT_SCROLL_DOWN
              ; ****************

e417 a6 e1              LDX BotMargin       ;    3
e419 20 c9 e6 ESD_10    JSR Cursor_BOL      ;   28
e41c e4 e0              CPX TopMargin       ;    3
e41e f0 06              BEQ ESD_30          ;    2
e420 ca                 DEX                 ;    2
e421 20 0a e4           JSR Edit_Scroll     ; 1552
e424 b0 f3              BCS ESD_10          ;    3
e426 4c aa e1 ESD_30    JMP Edit_Erase_To_EOL  ; total = 1100 + 24 * 1590 = 39260

e429                    .SIZE ;   18 [EDIT_SCROLL_DOWN]

              ; **************
e429            EDIT_SCROLL_UP
              ; **************

e429 a6 e0              LDX TopMargin
e42b 20 c9 e6 ESU_10    JSR Cursor_BOL
e42e e4 e1              CPX BotMargin
e430 b0 06              BCS ESU_30
e432 e8                 INX
e433 20 0a e4           JSR Edit_Scroll
e436 b0 f3              BCS ESU_10
e438 4c aa e1 ESU_30    JMP Edit_Erase_To_EOL

e43b                    .SIZE ;   18 [EDIT_SCROLL_UP]

e43b 00 00 00           .FILL $e442-* (0) ; 7 bytes

              ; ********
e442            IRQ_MAIN
              ; ********

e442 48                 PHA
e443 8a                 TXA
e444 48                 PHA
e445 98                 TYA
e446 48                 PHA
e447 ba                 TSX
e448 bd 04 01           LDA STACK+4,X
e44b 29 10              AND #16
e44d f0 03              BEQ IRQ_05
e44f 6c 92 00           JMP (CBINV)
e452 6c 90 00 IRQ_05    JMP (CINV)

              ; **********
e455            IRQ_NORMAL
              ; **********

e455 20 68 f7           JSR Kernal_UDTIM    ; increment jiffy clock
e458 a5 a7              LDA BLNSW           ; software cursor
e45a d0 18              BNE IRQ_20          ; branch if not visible
e45c c6 a8              DEC BLNCT           ; blink count down
e45e d0 14              BNE IRQ_20
e460 a9 14              LDA #20             ; reset blink count down
e462 85 a8              STA BLNCT
e464 a4 c6              LDY CursorCol
e466 46 aa              LSR BLNON           ; BLNON = 0 : C = old value
e468 b1 c4              LDA (ScrPtr),Y
e46a b0 04              BCS IRQ_10
e46c e6 aa              INC BLNON           ; BLNON = 1 : reverse character
e46e 85 a9              STA GDBLN           ; save character under cursor
e470 49 80    IRQ_10    EOR #$80
e472 91 c4              STA (ScrPtr),Y      ; invert character
e474 20 24 e9 IRQ_20    JSR EDIT_KEY_SCAN
e477 68       IRQ_END   PLA
e478 a8                 TAY
e479 68                 PLA
e47a aa                 TAX
e47b 68                 PLA
e47c 40                 RTI

              ; ******
e47d            Delete
              ; ******

e47d 20 76 00           JSR CHRGOT
e480 20 f6 b8           JSR Scan_Linenumber ; start #
e483 20 a3 b5           JSR Find_BASIC_Line
e486 a5 5c              LDA TMPPTC
e488 85 21              STA RENINC
e48a a5 5d              LDA TMPPTC+1
e48c 85 22              STA RENINC+1
e48e 20 76 00           JSR CHRGOT
e491 c9 2d              CMP #'-'
e493 d0 30              BNE DelErr
e495 20 70 00           JSR CHRGET
e498 20 f6 b8           JSR Scan_Linenumber ; end #
e49b a5 11              LDA LINNUM
e49d 05 12              ORA LINNUM+1
e49f d0 02              BNE Del_10
e4a1 c6 12              DEC LINNUM+1        ; end number = $ff00
e4a3 20 a3 b5 Del_10    JSR Find_BASIC_Line
e4a6 90 03              BCC Del_20          ; -> not found
e4a8 20 33 ed           JSR Update_Link     ; First line after DELETE range
e4ab a6 2b    Del_20    LDX VARTAB+1
e4ad a0 00              LDY #0              ; Y = 0
e4af b1 5c    Del_30    LDA (TMPPTC),Y      ; copy upper part of program
e4b1 91 21              STA (RENINC),Y      ; into area to delete
e4b3 c8                 INY
e4b4 d0 f9              BNE Del_30
e4b6 e6 22              INC RENINC+1
e4b8 e6 5d              INC TMPPTC+1
e4ba e4 5d              CPX TMPPTC+1        ; reached VARTAB ?
e4bc b0 f1              BCS Del_30
e4be a4 21              LDY RENINC
e4c0 a5 22              LDA RENINC+1
e4c2 4c d5 df           JMP Renu_90         ; set VARTAB, reset BASIC
e4c5 4c 73 c3 DelErr    JMP Jump_To_Illegal_Quantity
e4c8                    .SIZE ;   75 [Delete]

              ; ***************
e4c8            Get_Record_Size
              ; ***************

e4c8 a0 00              LDY #0
e4ca 84 96              STY STATUS
e4cc 20 af f4           JSR Send_Filename
e4cf 20 91 d9           JSR Kernal_Read_DS
e4d2 a9 6d              LDA #$6d
e4d4 85 d3              STA SA
e4d6 ad ad 03           LDA DOS_Status
e4d9 c9 35              CMP #'5'
e4db d0 1d              BNE GRS_90
e4dd c6 b9              DEC DOS_RL
e4df a9 9d              LDA #$9d
e4e1 20 d2 ff           JSR CHROUT
e4e4 20 d2 ff           JSR CHROUT
e4e7 a5 b9              LDA DOS_RL
e4e9 20 54 d7           JSR Print_Hex_Byte
e4ec a5 b9              LDA DOS_RL
e4ee c9 02              CMP #2
e4f0 90 08              BCC GRS_90
e4f2 a4 d1              LDY FNLEN
e4f4 88                 DEY
e4f5 91 da              STA (FNADR),Y       ; try next record length
e4f7 4c c8 e4           JMP Get_Record_Size
e4fa 60       GRS_90    RTS ;Size   51 [Get_Record_Size]

              ; ***********
e4fb            Mon_Message
              ; ***********

e4fb 0d 20 20           .BYTE "\r   PC  IRQ  SR AC XR YR SP RB WB SV-BDIZC"

              ; ******
e525            IS_TAB
              ; ******

e525 a5 c6              LDA CursorCol
e527 29 07              AND #7
e529 a8                 TAY                 ; bit position
e52a a5 c6              LDA CursorCol
e52c 4a                 LSR A
e52d 4a                 LSR A
e52e 4a                 LSR A               ; Column / 8
e52f aa                 TAX                 ; word index
e530 b9 37 e5           LDA BITPOS,Y
e533 3d ee 03           AND TABS_SET,X
e536 60                 RTS ;Size   18 [IS_TAB]

              ; ******
e537            BITPOS
              ; ******

e537 80 40 20           .BYTE $80,$40,$20,$10,$08,$04,$02,$01

              ; ********
e53f            Mon_Fill
              ; ********

e53f a2 f9              LDX #BPTR           ; start address
e541 20 6c d7           JSR Read_Hex_Word
e544 90 26              BCC MoFi_Err
e546 a2 fd              LDX #MEMUSS         ; end   address
e548 20 6c d7           JSR Read_Hex_Word
e54b 90 1f              BCC MoFi_Err
e54d 20 79 d7           JSR  Read_Hex       ; fill byte
e550 90 1a              BCC MoFi_Err
e552 aa                 TAX
e553 a0 00              LDY #0
e555 a5 fd    MoFi_10   LDA MEMUSS
e557 c5 f9              CMP BPTR            ; set or clear carry
e559 a5 fe              LDA MEMUSS+1
e55b e5 fa              SBC BPTR+1
e55d 90 0a              BCC MoFi_End        ; BPTR > MEMUSS ?
e55f 8a                 TXA
e560 20 8b 02           JSR Bank_Store
e563 20 25 fb           JSR Inc_BPTR
e566 4c 55 e5           JMP MoFi_10
e569 4c ae d4 MoFi_End  JMP Mon_Main
e56c 4c a9 d4 MoFi_Err  JMP Mon_Error

e56f                    .SIZE ;   48 [Mon_Fill]


              ; ****************
e56f            Open_Disk_Buffer
              ; ****************

e56f 20 ae e7           JSR Preset_U1
e572 20 15 f2           JSR Kernal_CHRIN
e575 8d 54 03           STA DOS_Command_Buffer+1
e578 20 6a d7           JSR Hex_To_STAL
e57b 20 15 f2           JSR Kernal_CHRIN    ; skip blank
e57e a2 05              LDX #5
e580 20 f4 d8 ODB_20    JSR Mon_CHRIN
e583 9d 53 03           STA DOS_Command_Buffer,X
e586 e8                 INX
e587 e0 28              CPX #40
e589 b0 04              BCS ODB_30
e58b c9 20              CMP #' '
e58d b0 f1              BCS ODB_20
e58f 20 4c dc ODB_30    JSR DOS_SETNAM
e592 20 c7 f8           JSR Wedge_Prepare   ; set FA, clear status
e595 85 ba              STA Dis_Line        ; Dis_Line = 0
e597 20 d5 f0           JSR LISTEN          ; open fa,9,"#"
e59a a9 f9              LDA #$f9            ; sa = 9
e59c 20 43 f1           JSR SECOND
e59f a9 23              LDA #'#'            ; open buffer
e5a1 20 9e f1           JSR CIOUT
e5a4 4c b9 f1           JMP UNLSN


              ; ********
e5a7            Mon_Disk
              ; ********

              ;         U1 1000 0 18 01 - memory,drive,track,sector

e5a7 20 6f e5           JSR Open_Disk_Buffer
e5aa ad 54 03           LDA DOS_Command_Buffer+1
e5ad c9 32              CMP #'2'
e5af f0 20              BEQ Mon_Output_Block
e5b1 20 ba e7           JSR Mon_Disk_Comm
e5b4 20 d2 f0           JSR TALK
e5b7 a9 69              LDA #$69
e5b9 85 d3              STA SA
e5bb 20 93 f1           JSR TKSA
e5be a0 00              LDY #0
e5c0 20 c0 f1 MIB_30    JSR ACPTR
e5c3 91 fb              STA (STAL),Y
e5c5 c8                 INY
e5c6 d0 f8              BNE MIB_30
e5c8 20 ae f1           JSR UNTLK
e5cb 20 2a f7           JSR Close_Disk_File
e5ce 4c f7 d5           JMP DiMe_10         ; display loaded block

              ; ****************
e5d1            Mon_Output_Block
              ; ****************

              ;         U2 1000 0 18 01 - memory,drive,track,sector

e5d1 20 9b e7           JSR Reset_BP
e5d4 20 d5 f0           JSR LISTEN
e5d7 a9 69              LDA #$69
e5d9 85 d3              STA SA
e5db 20 43 f1           JSR SECOND
e5de a0 00              LDY #0
e5e0 b1 fb    MOB_10    LDA (STAL),Y
e5e2 20 9e f1           JSR CIOUT
e5e5 c8                 INY
e5e6 d0 f8              BNE MOB_10
e5e8 20 b9 f1           JSR UNLSN
e5eb 20 ba e7           JSR Mon_Disk_Comm
e5ee 20 2a f7           JSR Close_Disk_File
e5f1 4c f7 d5           JMP DiMe_10         ; display output block

e5f4 00 00 00           .FILL $e606-* (0) ; 18 bytes

              ; *********
e606            Edit_Init
              ; *********

e606 a9 7f              LDA #$7f
e608 8d 4e e8           STA VIA_IER         ; disable all interrupts
e60b a2 6d              LDX #$6d
e60d a9 00              LDA #0
e60f 85 e8              STA PrevChar        ; clear # of HOME key pressed
e611 95 8d    EdIn_10   STA JIFFY_CLOCK,X   ; clear all kernal variables
e613 ca                 DEX
e614 10 fb              BPL EdIn_10
e616 86 98              STX Key_Flags       ; $FF = Clear all flags
e618 ad 99 b3           LDA BSOS_Bank_Init
e61b 85 9a              STA Default_Bank
e61d a9 55              LDA #<IRQ_NORMAL    ; set default IRQ vector
e61f 85 90              STA CINV
e621 a9 e4              LDA #>IRQ_NORMAL
e623 85 91              STA CINV+1
e625 a9 09              LDA #9
e627 85 e3              STA XMAX            ; size of keyboard bufferX
e629 a9 03              LDA #3
e62b 85 b0              STA DFLTO           ; standard output channel
e62d a9 0f              LDA #15
e62f 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e632 0a                 ASL A
e633 8d 40 e8           STA VIA_Port_B
e636 8d 42 e8           STA VIA_DDR_B
e639 8e 22 e8           STX PIA2_Port_B
e63c 8e 45 e8           STX VIA_Timer_1_Hi  ; Timer 1 latch hi = $ff
e63f a9 3d              LDA #$3d
e641 8d 13 e8           STA PIA1_Cont_B
e644 2c 12 e8           BIT PIA1_Port_B     ; Keyboard row
e647 a9 3c              LDA #$3c
e649 8d 21 e8           STA PIA2_Cont_A
e64c 8d 23 e8           STA PIA2_Cont_B
e64f 8d 11 e8           STA PIA1_Cont_A
e652 8e 22 e8           STX PIA2_Port_B
e655 a9 0e              LDA #14
e657 85 a8              STA BLNCT
e659 85 a7              STA BLNSW
e65b 85 e6              STA DELAY
e65d 85 e5              STA KOUNT
e65f 8d 4e e8           STA VIA_IER         ; enable CA1, SR, CB2 interrupt
e662 a9 18              LDA #24
e664 85 df              STA ScreenRows
e666 20 bb e1           JSR Edit_Full_Screen
e669 a2 0c              LDX #12
e66b a9 00              LDA #0
e66d 9d ee 03 EdIn_20   STA TABS_SET,X
e670 ca                 DEX
e671 10 fa              BPL EdIn_20
e673 a9 1d              LDA #<Edit_CHRIN_Standard
e675 a2 e1              LDX #>Edit_CHRIN_Standard
e677 85 e9              STA SCRIV
e679 86 ea              STX SCRIV+1
e67b a9 0c              LDA #<Edit_CHROUT_Standard
e67d a2 e2              LDX #>Edit_CHROUT_Standard
e67f 85 eb              STA SCROV
e681 86 ec              STX SCROV+1
e683 a9 10              LDA #16
e685 85 e7              STA CHIME
e687 20 8a e6           JSR Double_Beep

              ; ***********
e68a            Double_Beep
              ; ***********

e68a 20 8d e6           JSR EDIT_BEEP

              ; *********
e68d            EDIT_BEEP
              ; *********

e68d a4 e7              LDY CHIME
e68f f0 25              BEQ BEEP_Ret
e691 a9 10              LDA #16             ; shift out - rate controlled by timer 2
e693 8d 4b e8           STA VIA_ACR         ; free running mode
e696 a9 0f              LDA #15
e698 8d 4a e8           STA VIA_Shift       ; set shift pattern 0000 1111
e69b a2 07              LDX #7
e69d bd 4d e7 BEEP_10   LDA SOUND_TAB-1,X
e6a0 8d 48 e8           STA VIA_Timer_2_Lo  ; set sustain time
e6a3 a5 e7              LDA CHIME
e6a5 88       BEEP_20   DEY
e6a6 d0 fd              BNE BEEP_20           ; inner wait loop
e6a8 38                 SEC
e6a9 e9 01              SBC #1
e6ab d0 f8              BNE BEEP_20           ; outer wait loop
e6ad ca                 DEX
e6ae d0 ed              BNE BEEP_10           ; next note
e6b0 8e 4a e8           STX VIA_Shift       ; x=0 clear shift register
e6b3 8e 4b e8           STX VIA_ACR         ; x=0 clear access control register
e6b6 60       BEEP_Ret  RTS ;Size   42 [EDIT_BEEP]

              ; **************
e6b7            Set_Screen_SAL
              ; **************

e6b7 8a                 TXA
e6b8 48                 PHA
e6b9 29 0f              AND #15
e6bb aa                 TAX
e6bc bd 55 e7           LDA Line_Addr_Lo,X
e6bf 85 c7              STA SAL
e6c1 68                 PLA
e6c2 aa                 TAX
e6c3 bd 6e e7           LDA Line_Addr_Hi,X
e6c6 85 c8              STA SAL+1
e6c8 60                 RTS ;Size   18 [Set_Screen_SAL]

              ; **********
e6c9            Cursor_BOL
              ; **********

              ; Input:  X       = cursor row (0 - 24)
              ; Output: ScrPtr  = screen address of row X
              ;         Y       = left margin

e6c9 a4 e2              LDY LefMargin

              ; *************
e6cb            Update_ScrPtr
              ; *************

e6cb 8a                 TXA
e6cc 48                 PHA
e6cd 29 0f              AND #15             ; Line lo repeats after 16 lines
e6cf aa                 TAX
e6d0 bd 55 e7           LDA Line_Addr_Lo,X
e6d3 85 c4              STA ScrPtr
e6d5 68                 PLA
e6d6 aa                 TAX
e6d7 bd 6e e7           LDA Line_Addr_Hi,X
e6da 85 c5              STA ScrPtr+1
e6dc 60                 RTS ;Size   18 [Update_ScrPtr]

              ; **********
e6dd            RUN_String
              ; **********

              ;               dL"*<CR>rU<CR>
e6dd 44 cc 22           .BYTE $44,$cc,$22,$2a,$0d,$52,$d5,$0d

              ; ********
e6e5            CRT_TEXT
              ; ********

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6e5 3a                 .BYTE  58           ;  0: Horizontal Total
e6e6 28                 .BYTE  40           ;  1: Horizontal Displayed
e6e7 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6e8 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6e9 20                 .BYTE  32           ;  4: Vertical Total
e6ea 09                 .BYTE   9           ;  5: Vertical Total Adjust
e6eb 19                 .BYTE  25           ;  6: Vertical Displayed
e6ec 1e                 .BYTE  30           ;  7: Vertical Sync position
e6ed 00                 .BYTE   0           ;  8: Interlace and Skew
e6ee 09                 .BYTE   9           ;  9: Maximum Raster Address
e6ef 00                 .BYTE   0           ; 10: Cursor Start Raster
e6f0 00                 .BYTE   0           ; 11: Cursor End Raster
e6f1 10                 .BYTE $10           ; 12: Display Start Address (High)
e6f2 00                 .BYTE $00           ; 13: Display Start Address (Low)
e6f3 00                 .BYTE $00           ; 14: Cursor Address (High)
e6f4 00                 .BYTE $00           ; 15: Cursor Address (Low)
e6f5 00                 .BYTE $00           ; 16: Light Pen Address (High)
e6f6 00                 .BYTE $00           ; 17: Light Pen Address (Low)


              ; ************
e6f7            CRT_GRAPHICS
              ; ************

              ;              Value  6845 CRT Register
              ;         ---------------------------------------------------
e6f7 3a                 .BYTE  58           ;  0: Horizontal Total
e6f8 28                 .BYTE  40           ;  1: Horizontal Displayed
e6f9 2c                 .BYTE  44           ;  2: Horizontal Sync Position
e6fa 08                 .BYTE   8           ;  3: Horizontal and Vertical Sync Widths
e6fb 29                 .BYTE  41           ;  4: Vertical Total                  !!!
e6fc 03                 .BYTE   3           ;  5: Vertical Total Adjust           !!!
e6fd 19                 .BYTE  25           ;  6: Vertical Displayed
e6fe 22                 .BYTE  34           ;  7: Vertical Sync position          !!!
e6ff 00                 .BYTE   0           ;  8: Interlace and Skew
e700 07                 .BYTE   7           ;  9: Maximum Raster Address          !!!


              ; ***
e701            OLD
              ; ***
e701 a9 01              LDA #1
e703 a8                 TAY
e704 91 28              STA (TXTTAB),Y      ; non zero link
e706 88                 DEY
e707 91 28              STA (TXTTAB),Y
e709 20 b6 b4           JSR Rechain         ; restore all links
e70c 18                 CLC
e70d a5 1f              LDA INDEXA
e70f 69 02              ADC #2
e711 a8                 TAY
e712 a5 20              LDA INDEXA+1
e714 69 00              ADC #0
e716 4c d5 df           JMP Renu_90         ; set VARTAB and reset BASIC

e719 00 00 00           .FILL $e74e-* (0) ; 53 bytes

              ; ****************
e74e            SOUND_TAB ; e74e
              ; ****************

e74e 0e 1e 3e           .BYTE $0e,$1e,$3e,$7e,$3e,$1e,$0e

              ; ********************
e755            Line_Addr_Lo ; $e755
              ; ********************

e755 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e75d 80 d0 20           .BYTE $80,$d0,$20,$70,$c0,$10,$60,$b0
e765 00 50 a0           .BYTE $00,$50,$a0,$f0,$40,$90,$e0,$30
e76d 80                 .BYTE $80

              ; ********************
e76e            Line_Addr_Hi ; $e76e
              ; ********************

e76e 80 80 80           .BYTE $80,$80,$80,$80,$81,$81,$81,$82 ;  0 -  7
e776 82 82 83           .BYTE $82,$82,$83,$83,$83,$84,$84,$84 ;  8 - 15
e77e 85 85 85           .BYTE $85,$85,$85,$85,$86,$86,$86,$87 ; 16 - 23
e786 87 87 88           .BYTE $87,$87,$88,$88,$88,$89,$89,$89 ; 24 - 31

e78e 42 2d 50 B_P_0     .BYTE "B-P 9 0\r"
e796 55 31 3a U1        .BYTE "U1:9 "

              ; ********
e79b            Reset_BP
              ; ********

e79b 20 31 fb           JSR DOS_Open_Comm_Write
e79e a0 00              LDY #0
e7a0 b9 8e e7 RBP_30    LDA B_P_0,Y
e7a3 20 9e f1           JSR CIOUT
e7a6 c8                 INY
e7a7 c0 08              CPY #?B_P_0
e7a9 90 f5              BCC RBP_30
e7ab 4c b9 f1           JMP UNLSN

              ; *********
e7ae            Preset_U1
              ; *********

e7ae a2 04              LDX #4
e7b0 bd 96 e7 PU1_10    LDA U1,X
e7b3 9d 53 03           STA DOS_Command_Buffer,X
e7b6 ca                 DEX
e7b7 10 f7              BPL PU1_10
e7b9 60                 RTS ;Size   12 [Preset_U1]

              ; *************
e7ba            Mon_Disk_Comm
              ; *************

e7ba 20 31 fb           JSR DOS_Open_Comm_Write
e7bd a2 00              LDX #0
e7bf bd 53 03 MDC_10    LDA DOS_Command_Buffer,X
e7c2 e8                 INX
e7c3 20 9e f1           JSR CIOUT
e7c6 c9 20              CMP #' '
e7c8 b0 f5              BCS MDC_10
e7ca 4c b9 f1           JMP UNLSN

e7cd 00 00 00           .FILL $e800-* (0) ; 51 bytes

e800 48 41 4c           .BYTE "HALL OF FAME:"
e80d 43 48 55           .BYTE "CHUCK PEDDLE - "
e81c 42 49 4c           .BYTE "BILL MENSCH - "
e82a 4a 41 43           .BYTE "JACK TRAMIEL - "
e839 49 52 41           .BYTE "IRA VELINSKY - "
e848 4a 4f 48           .BYTE "JOHN FEAGANS - "
e857 42 49 4c           .BYTE "BILL GATES - "
e864 4a 49 4d           .BYTE "JIM BUTTERFIELD - "
e876 42 52 41           .BYTE "BRAD TEMPLETON - "
e887 4a 49 4d           .BYTE "JIM CONELLEY - "
e896 4e 49 4c           .BYTE "NILS EILERS - "
e8a4 56 49 43           .BYTE "VICE TEAM - "


e8b0 00 00 00           .FILL $e924-* (0) ; 116 bytes

              ; *************
e924            EDIT_KEY_SCAN
              ; *************

              ; Initialize

e924 ad 10 e8           LDA PIA1_Port_A     ; Keyboard row select
e927 29 f0              AND #%11110000      ; Select row 0
e929 8d 10 e8           STA PIA1_Port_A     ; Keyboard row select
e92c a5 98              LDA Key_Flags
e92e 09 c0              ORA #%11000000      ; 7 no <shift> and 6 no <ctrl>
e930 85 98              STA Key_Flags
e932 a9 ff              LDA #$ff
e934 85 97              STA Key_Index       ; invalidate Key_Index
e936 85 a6              STA SFDX            ; invalidate SFDX
e938 a2 4f              LDX #$4f            ; check key 79 -> 0

              ; Load next keyboard row int oaccumulator

e93a ad 12 e8 ScKbd_02  LDA PIA1_Port_B     ; Keyboard row
e93d cd 12 e8           CMP PIA1_Port_B     ; Keyboard row
e940 d0 f8              BNE ScKbd_02        ; repeat until no bounce

              ; Rotate accumulator for all 8 keys of this row

e942 a0 08              LDY #8              ; Test the 8 keys of the row
e944 4a       ScKbd_04  LSR A               ; next key -> carry
e945 b0 1a              BCS ScKbd_10        ; 1 -> not pressed
e947 48                 PHA                 ; Save scanned row

              ; Test for right or left shift key

e948 a9 7f              LDA #%01111111      ; mask for <shift> pressed
e94a e0 19              CPX #$19            ; Right Shift ?
e94c f0 0e              BEQ ScKbd_06        ; -> pressed
e94e e0 1f              CPX #$1f            ; Left Shift ?
e950 f0 0a              BEQ ScKbd_06        ; -> pressed

              ; Test for control key (RVS on older keyboards)

e952 a9 bf              LDA #%10111111      ; mask for <ctrl> pressed
e954 e0 0f              CPX #15             ; <RVS = CTRL> ?
e956 f0 04              BEQ ScKbd_06        ; -> pressed

              ; normal key, save key index

e958 86 97              STX Key_Index
e95a d0 04              BNE ScKbd_08        ; branch always

              ; flag shift or control in Key_Flags

e95c 25 98    ScKbd_06  AND Key_Flags
e95e 85 98              STA Key_Flags       ; save shift and control status

              ; continue with next index

e960 68       ScKbd_08  PLA                 ; restore row
e961 ca       ScKbd_10  DEX                 ; next key index
e962 30 08              BMI ScKbd_12        ; finished

              ; next key in this row

e964 88                 DEY                 ; next column
e965 d0 dd              BNE ScKbd_04

              ; row scan finished -> next row

e967 ee 10 e8           INC PIA1_Port_A     ; next keyboard row
e96a d0 ce              BNE ScKbd_02        ; Branch always

              ; keyboard scan finished - check if a keypress occured

e96c a6 97    ScKbd_12  LDX Key_Index       ; any key ?
e96e 10 03              BPL ScKbd_13        ; branch on key press
e970 86 e4              STX LSTX            ; invalidate last key pressed
e972 60       ScKbd_22  RTS ;Size   79 [EDIT_KEY_SCAN]

              ; is it the same key index as in the last scan ?

e973 e4 e4    ScKbd_13  CPX LSTX            ; still holding the same key ?
e975 d0 18              BNE ScKbd_16        ; other key
e977 a4 e6              LDY DELAY
e979 f0 04              BEQ ScKbd_14        ; branch if delay expired
e97b c6 e6              DEC DELAY           ; else decrement repeat delay counter
e97d d0 f3              BNE ScKbd_22        ; branch if delay not expired
e97f c6 e5    ScKbd_14  DEC KOUNT           ; decrement repeat speed counter
e981 d0 ef              BNE ScKbd_22        ; branch if repeat speed count not expired
e983 a0 04              LDY #4              ; set for 4/60ths of a second
e985 e0 0b              CPX #$0b            ; index for cursor <- ->
e987 d0 02              BNE ScKbd_15        ; normaö repeat speed
e989 a0 02              LDY #2              ; cursor left right repeat faster
e98b 84 e5    ScKbd_15  STY KOUNT           ; set repeat speed counter
e98d d0 06              BNE ScKbd_18        ; branch always

              ; new key press - reset delay

e98f 86 e4    ScKbd_16  STX LSTX            ; save key index
e991 a9 15              LDA #21
e993 85 e6              STA DELAY           ; set repeat delay count
e995 20 b4 e9 ScKbd_18  JSR Lookup_Keycode
e998 e0 0f              CPX #15
e99a f0 15              BEQ ScKbd_30        ; <CONTROL> doesn't go into buffer
e99c a6 9e              LDX CharsInBuffer
e99e e4 e3              CPX XMAX
e9a0 b0 05              BCS ScKbd_26        ; buffer full

              ; add key to keyboard buffer

e9a2 9d 6f 02 ScKbd_24  STA KEYD,X
e9a5 e6 9e              INC CharsInBuffer   ; put key into buffer

              ; check for STOP key

e9a7 a0 ff    ScKbd_26  LDY #$ff            ; Clear STOP flag
e9a9 c9 03              CMP #3              ; <STOP>
e9ab d0 02              BNE ScKbd_28
e9ad a0 ef              LDY #$ef            ; Set STOP flag
e9af 84 9b    ScKbd_28  STY Stop_Flag
e9b1 85 a6    ScKbd_30  STA SFDX
e9b3 60                 RTS ;Size  144 [EDIT_KEY_SCAN]

              ; **************
e9b4            Lookup_Keycode
              ; **************

e9b4 bd b6 eb           LDA KEYBOARD_CONTROL,X
e9b7 24 98              BIT Key_Flags
e9b9 70 05              BVS LoKe_20         ; no control
e9bb 30 02              BMI LoKe_10
e9bd 09 80              ORA #$80            ; shift control
e9bf 60       LoKe_10   RTS ;Size   12 [Lookup_Keycode]
e9c0 30 04    LoKe_20   BMI LoKe_30         ; no shift
e9c2 bd 65 eb           LDA KEYBOARD_SHIFTED,X
e9c5 60                 RTS ;Size   18 [Lookup_Keycode]
e9c6 bd 15 eb LoKe_30   LDA KEYBOARD_NORMAL,X
e9c9 60                 RTS ;Size   22 [Lookup_Keycode]

              ; ********************
e9ca            Edit_Switch_Char_ROM
              ; ********************

              ; Input:   A = $10 (new charset)   $30 (old charset)

e9ca a0 0c               LDY #12
e9cc 8c 80 e8            STY CRT_Address
e9cf 8d 81 e8            STA CRT_Value
e9d2 60                  RTS ;Size    9 [Edit_Switch_Char_ROM]


              ; **************
e9d3            EDIT_RESET_CRT
              ; **************

e9d3 a0 11              LDY #17
e9d5 2c                 .BYTE $2c           ; skip next instruction

              ; *****************
e9d6            EDIT_CHARSET_TEXT
              ; *****************

e9d6 a0 09              LDY #9
e9d8 a9 0e              LDA #14
e9da 8d 4c e8           STA VIA_PCR
e9dd a9 e5              LDA #<CRT_TEXT
e9df a2 e6              LDX #>CRT_TEXT
e9e1 4c 57 e0           JMP EDIT_SET_CRT

              ; *********************
e9e4            EDIT_CHARSET_GRAPHICS
              ; *********************

e9e4 a0 09              LDY #9
e9e6 a9 0c              LDA #12
e9e8 8d 4c e8           STA VIA_PCR
e9eb a9 f7              LDA #<CRT_GRAPHICS
e9ed a2 e6              LDX #>CRT_GRAPHICS
e9ef 4c 57 e0           JMP EDIT_SET_CRT

              ; *****************
e9f2            Read_Power_String
              ; *****************

e9f2 a9 ff              LDA #$ff
e9f4 85 99              STA Power_Flag
e9f6 20 e2 b4           JSR Read_String
e9f9 e6 99              INC Power_Flag
e9fb 60                 RTS ;Size   10 [Read_Power_String]

              ; ****************
e9fc            Check_Linenumber
              ; ****************

e9fc 8a                 TXA                 ; X = Row
e9fd 48                 PHA
e9fe 48                 PHA
e9ff 29 0f              AND #15
ea01 aa                 TAX
ea02 18                 CLC
ea03 bd 55 e7           LDA Line_Addr_Lo,X
ea06 65 e2              ADC LefMargin
ea08 85 77              STA TXTPTR
ea0a 68                 PLA
ea0b aa                 TAX
ea0c bd 6e e7           LDA Line_Addr_Hi,X
ea0f 69 00              ADC #0
ea11 85 78              STA TXTPTR+1
ea13 20 76 00           JSR CHRGOT
ea16 b0 04              BCS ChLi_Ret        ; no  number
ea18 20 f6 b8           JSR Scan_Linenumber
ea1b 18                 CLC                 ; has number
ea1c 68       ChLi_Ret  PLA
ea1d aa                 TAX
ea1e 60                 RTS ;Size   35 [Check_Linenumber]

              ; ******************
ea1f            Check_Line_Upwards
              ; ******************

ea1f a6 e1              LDX BotMargin
ea21 e4 e0    CLU_10    CPX TopMargin
ea23 f0 06              BEQ CLU_Ret         ; carry set -> no number
ea25 ca                 DEX
ea26 20 fc e9           JSR Check_Linenumber
ea29 b0 f6              BCS CLU_10
ea2b 60       CLU_Ret   RTS ;Size   13 [Check_Line_Upwards]

              ; ********************
ea2c            Check_Line_Downwards
              ; ********************

ea2c a6 e0              LDX TopMargin
ea2e e4 e1    CLD_10    CPX BotMargin
ea30 f0 06              BEQ CLD_Ret         ; carry set -> no number
ea32 e8                 INX
ea33 20 fc e9           JSR Check_Linenumber
ea36 b0 f6              BCS CLD_10
ea38 60       CLD_Ret   RTS ;Size   13 [Check_Line_Downwards]

              ; ***************
ea39            Power_Scroll_Up
              ; ***************

ea39 24 99              BIT Power_Flag      ; active ?
ea3b 10 33              BPL PSU_Ret
ea3d a5 d8              LDA CursorRow       ; save row
ea3f 48                 PHA
ea40 a5 c6              LDA CursorCol
ea42 48                 PHA                 ; save col
ea43 a6 e1              LDX BotMargin
ea45 ca                 DEX
ea46 20 c9 e6           JSR Cursor_BOL      ; one row above bottom line
ea49 a9 20              LDA #' '            ; check, if this line is blank
ea4b d1 c4    PSU_10    CMP (ScrPtr),Y
ea4d d0 18              BNE PSU_30          ; don't list on non empty line
ea4f c8                 INY
ea50 c4 d5              CPY RigMargin
ea52 90 f7              BCC PSU_10
ea54 86 d8              STX CursorRow
ea56 20 1f ea           JSR Check_Line_Upwards
ea59 b0 0c              BCS PSU_30
ea5b e6 11              INC LINNUM
ea5d d0 02              BNE PSU_20
ea5f e6 12              INC LINNUM+1
ea61 20 e4 ea PSU_20    JSR Find_Power_Line
ea64 20 ce ea           JSR List_BASIC_Line
ea67 68       PSU_30    PLA
ea68 85 c6              STA CursorCol
ea6a 68                 PLA
ea6b 85 d8              STA CursorRow       ; restore row
ea6d 20 52 e0           JSR Edit_Use_CursorRow
ea70 60       PSU_Ret   RTS ;Size   56 [Power_Scroll_Up]

              ; *****************
ea71            Power_Scroll_Down
              ; *****************

ea71 24 99              BIT Power_Flag
ea73 10 fb              BPL PSU_Ret
ea75 a5 d8              LDA CursorRow       ; save row
ea77 48                 PHA
ea78 a5 c6              LDA CursorCol
ea7a 48                 PHA                 ; save col
ea7b 20 2c ea           JSR Check_Line_Downwards
ea7e b0 e7              BCS PSU_30
ea80 20 e4 ea           JSR Find_Power_Line
ea83 a5 5c              LDA TMPPTC
ea85 c5 28              CMP TXTTAB
ea87 d0 06              BNE PSD_20
ea89 a5 5d              LDA TMPPTC+1
ea8b c5 29              CMP TXTTAB+1
ea8d f0 d8              BEQ PSU_30
ea8f a5 57    PSD_20    LDA TMPPTB
ea91 85 5c              STA TMPPTC
ea93 a5 58              LDA TMPPTB+1
ea95 85 5d              STA TMPPTC+1
ea97 20 4a e0           JSR EDIT_HOME
ea9a 20 ce ea           JSR List_BASIC_Line
ea9d a6 d8              LDX CursorRow
ea9f e4 e0              CPX TopMargin
eaa1 f0 c4              BEQ PSU_30
eaa3 a4 c6              LDY CursorCol       ; Basic line was oversize
eaa5 a9 20              LDA #' '            ; erase to EOL and scroll again
eaa7 91 c4    PSD_30    STA (ScrPtr),Y
eaa9 c4 d5              CPY RigMargin
eaab c8                 INY
eaac 90 f9              BCC PSD_30
eaae a5 e0              LDA TopMargin
eab0 48                 PHA
eab1 e8                 INX
eab2 86 e0              STX TopMargin
eab4 20 17 e4           JSR EDIT_SCROLL_DOWN
eab7 68                 PLA
eab8 85 e0              STA TopMargin
eaba a0 01              LDY #1
eabc b1 5c              LDA (TMPPTC),Y      ; link hi
eabe aa                 TAX
eabf 88                 DEY
eac0 b1 5c              LDA (TMPPTC),Y      ; link lo
eac2 85 5c              STA TMPPTC
eac4 86 5d              STX TMPPTC+1
eac6 e6 d8              INC CursorRow
eac8 20 ce ea           JSR List_BASIC_Line
eacb 4c 67 ea           JMP PSU_30          ; always

eace                    .SIZE ;   93 [Power_Scroll_Down]

              ; ***************
eace            List_BASIC_Line
              ; ***************

eace 20 4e e0           JSR Edit_Goto_Left_Margin
ead1 a0 01              LDY #1
ead3 b1 5c              LDA (TMPPTC),Y      ; check link for valid line
ead5 f0 0c              BEQ LBL_Ret
ead7 c8                 INY
ead8 b1 5c              LDA (TMPPTC),Y      ; line # lo
eada aa                 TAX
eadb c8                 INY
eadc b1 5c              LDA (TMPPTC),Y      ; line # hi
eade 20 89 b6           JSR List_Line       ; returns A=0
eae1 85 cd              STA QTSW
eae3 60       LBL_Ret   RTS ;Size   22 [List_BASIC_Line]

              ; ***************
eae4            Find_Power_Line
              ; ***************

eae4 a5 28              LDA TXTTAB
eae6 a6 29              LDX TXTTAB+1
eae8 85 57              STA TMPPTB
eaea 86 58              STX TMPPTB+1
eaec 85 5c    FPL_10    STA TMPPTC
eaee 86 5d              STX TMPPTC+1
eaf0 a0 01              LDY #1
eaf2 b1 5c              LDA (TMPPTC),Y      ; link hi
eaf4 f0 1e              BEQ FPL_40
eaf6 c8                 INY                 ; Y = 2
eaf7 b1 5c              LDA (TMPPTC),Y      ; line # lo
eaf9 c5 11              CMP LINNUM
eafb c8                 INY                 ; Y = 3
eafc b1 5c              LDA (TMPPTC),Y      ; line # hi
eafe e5 12              SBC LINNUM+1
eb00 b0 12              BCS FPL_40          ; >= LINNUM
eb02 a5 5c              LDA TMPPTC
eb04 85 57              STA TMPPTB
eb06 a6 5d              LDX TMPPTC+1        ; last ptr
eb08 86 58              STX TMPPTB+1
eb0a 88                 DEY                 ; Y = 2
eb0b 88                 DEY                 ; Y = 1
eb0c b1 5c              LDA (TMPPTC),Y      ; link hi
eb0e aa                 TAX
eb0f 88                 DEY                 ; Y = 0
eb10 b1 5c              LDA (TMPPTC),Y      ; link lo
eb12 90 d8              BCC FPL_10          ; branch always
eb14 60       FPL_40    RTS ;Size   49 [Find_Power_Line]

              ; ***************
eb15            KEYBOARD_NORMAL
              ; ***************

              ; The keyboard table has 80 ($50) entries scanned backwards
              ; The map is organized in 10 rows x 8 columns
              ; Val = Scancode assigned to this key
              ; X   = Index of this key
              ; R   = Physical row on keyboard (1-5)
              ; C   = Physical column on keyboard (1-16 and k1-k3 for keypad)
              ; Key = Description

              ;               Val     X  R  C Key
              ;         --------------------------------
eb15 16                 .PET $16  ; 00  -  - Ctrl V
eb16 00                 .PET $00  ; 01  -  -
eb17 be                 .PET $be  ; 02  1 12 SZ  ?
0000 TRUE     #if BSOS_KBD
eb18 14                 .PET $14  ; 03  1 16 DEL INST
              #else
SKIP                    .PET $13  ; 03  1 16 HOME CLR
              #endif
eb19 39                 .PET '9'  ; 04  1 10 9   )
eb1a 36                 .PET '6'  ; 05  1  7 6   &
eb1b 33                 .PET '3'  ; 06  1  4 3   Paragraph
eb1c 3c                 .PET '<'  ; 07  1  1 <   >

eb1d 31                 .PET '1'  ; 08  3 k1 1
eb1e 2d                 .PET '-'  ; 09  4 12 -   _
eb1f 15                 .PET $15  ; 0a  -  - Ctrl U
0000 TRUE     #if BSOS_KBD
eb20 1d                 .PET $1d  ; 0b  4 15 RIGHT LEFT
              #else
SKIP                    .PET $14  ; 0b  4 15 DEL INST
              #endif
eb21 4d                 .PET 'm'  ; 0c  4  9 m
eb22 20                 .PET ' '  ; 0d  5  1 SPACE
eb23 58                 .PET 'x'  ; 0e  4  4 x
eb24 00                 .PET $00  ; 0f  4  1 CTRL (used by index)

eb25 32                 .PET '2'  ; 10  3 k2 2
0000 TRUE     #if BSOS_KBD
eb26 11                 .PET $11  ; 11  4 14 DOWN UP
              #else
SKIP                    .PET $03  ; 11  4 14 STOP RUN
              #endif
eb27 0f                 .PET $0f  ; 12  -  - Ctrl O
eb28 30                 .PET '0'  ; 13  4 k1 0
eb29 2c                 .PET ','  ; 14  4 10 ,
eb2a 4e                 .PET 'n'  ; 15  4  8 n
eb2b 56                 .PET 'v'  ; 16  4  6 v
eb2c 59                 .PET 'y'  ; 17  4  3 y

eb2d 33                 .PET '3'  ; 18  3 k3 3
eb2e 00                 .PET $00  ; 19  4 13 Right SHIFT (used by index)
eb2f 19                 .PET $19  ; 1a  -  - Ctrl Y
eb30 2e                 .PET '.'  ; 1b  4 11 .
eb31 2e                 .PET '.'  ; 1c  4 k2 .
eb32 42                 .PET 'b'  ; 1d  4  7 b
eb33 43                 .PET 'c'  ; 1e  4  5 c
eb34 00                 .PET $00  ; 1f  4  2 Left SHIFT (used by index)

eb35 34                 .PET '4'  ; 20  2 k1 4
eb36 bd                 .PET $bd  ; 21  2 12 u umlaut
eb37 4f                 .PET 'o'  ; 22  2 10 o
eb38 5b                 .PET '['  ; 23  2 14 [   ^
eb39 55                 .PET 'u'  ; 24  2  8 u
eb3a 54                 .PET 't'  ; 25  2  6 t
eb3b 45                 .PET 'e'  ; 26  2  4 e
eb3c 51                 .PET 'q'  ; 27  2  2 q

eb3d 5d                 .PET ']'  ; 28  2 15 ]   \
eb3e 50                 .PET 'p'  ; 29  2 11 p
eb3f 49                 .PET 'i'  ; 2a  2  9 i
eb40 2b                 .PET '+'  ; 2b  2 13 +
eb41 5a                 .PET 'z'  ; 2c  2  7 z
eb42 52                 .PET 'r'  ; 2d  2  5 r
eb43 57                 .PET 'w'  ; 2e  2  3 w
eb44 09                 .PET $09  ; 2f  2  1 TAB

eb45 36                 .PET '6'  ; 30  2 k3 6
eb46 bb                 .PET $bb  ; 31  3 13 a umlaut
eb47 4c                 .PET 'l'  ; 32  3 11 l
eb48 0d                 .PET $0d  ; 33  3 15 RETURN
eb49 4a                 .PET 'j'  ; 34  3  9 j
eb4a 47                 .PET 'g'  ; 35  3  7 g
eb4b 44                 .PET 'd'  ; 36  3  5 d
eb4c 41                 .PET 'a'  ; 37  3  3 a

eb4d 35                 .PET '5'  ; 38  2 k2 5
eb4e bc                 .PET $bc  ; 39  3 12 o umlaut
eb4f 4b                 .PET 'k'  ; 3a  3 10 k
eb50 23                 .PET '#'  ; 3b  3 14 #
eb51 48                 .PET 'h'  ; 3c  3  8 h
eb52 46                 .PET 'f'  ; 3d  3  6 f
eb53 53                 .PET 's'  ; 3e  3  4 s
eb54 1b                 .PET $1b  ; 3f  3  1 ESC

eb55 39                 .PET '9'  ; 40  1 k3 9
eb56 00                 .PET $00  ; 41  -  -
0000 TRUE     #if BSOS_KBD
eb57 13                 .PET $13  ; 42  1 16 HOME
              #else
SKIP                    .PET $11  ; 42  1 16 DOWN UP
              #endif
eb58 37                 .PET '7'  ; 43  1 k1 7
eb59 30                 .PET '0'  ; 44  1 11 0
eb5a 37                 .PET '7'  ; 45  1  8 7
eb5b 34                 .PET '4'  ; 46  1  5 4
eb5c 31                 .PET '1'  ; 47  1  2 1

eb5d 00                 .PET $00  ; 48  -  -
eb5e 0e                 .PET $0e  ; 49  -  - Ctrl N
0000 TRUE     #if BSOS_KBD
eb5f 03                 .PET $03  ; 4a  1 15 STOP (RUN)
              #else
SKIP                    .PET $1d  ; 4a  1 15 RIGHT LEFT
              #endif
eb60 38                 .PET '8'  ; 4b  1 k2 Keypad 8
eb61 af                 .PET $af  ; 4c  1 13 ACUTE (GRAVE)
eb62 38                 .PET '8'  ; 4d  1  9
eb63 35                 .PET '5'  ; 4e  1  6
eb64 32                 .PET '2'  ; 4f  1  3

              ; ****************
eb65            KEYBOARD_SHIFTED
              ; ****************

eb65 96                 .PET $96  ; 00    Shift Ctrl V
eb66 00                 .PET $00  ; 01
eb67 3f                 .PET '?'  ; 02
0000 TRUE     #if BSOS_KBD
eb68 94                 .PET $94  ; 03    INST
              #else
SKIP                    .PET $93  ; 03    CLR
              #endif
eb69 29                 .PET ')'  ; 04    )
eb6a 26                 .PET '&'  ; 05    &
eb6b 40                 .PET '@'  ; 06    Paragraph
eb6c 3e                 .PET '>'  ; 07    >

eb6d a2                 .PET $a2  ; 08    Graph a2  KP 1
eb6e 5f                 .PET '_'  ; 09    UNDERLINE
eb6f 95                 .PET $95  ; 0a    Shift Ctrl U
0000 TRUE     #if BSOS_KBD
eb70 9d                 .PET $9d  ; 0b    LEFT
              #else
SKIP                    .PET $94  ; 0b    INST
              #endif
eb71 cd                 .PET 'M'  ; 0c    M
eb72 a0                 .PET $a0  ; 0d    SHIFT SPACE
eb73 d8                 .PET 'X'  ; 0e    X
eb74 00                 .PET $00  ; 0f    CTRL (used by index)

eb75 a3                 .PET $a3  ; 10    Graph a3
0000 TRUE     #if BSOS_KBD
eb76 91                 .PET $91  ; 11    Cursor UP
              #else
SKIP                    .PET $93  ; 11    RUN
              #endif
eb77 8f                 .PET $8f  ; 12    Shift Ctrl O
eb78 a1                 .PET $a1  ; 13    Graph a1  KP 0
eb79 3b                 .PET ';'  ; 14    ;
eb7a ce                 .PET 'N'  ; 15    N
eb7b d6                 .PET 'V'  ; 16    V
eb7c d9                 .PET 'Y'  ; 17    Y

eb7d a4                 .PET $a4  ; 18    Graph a4   KP 3
eb7e 00                 .PET $00  ; 19    Right SHIFT (used by index)
eb7f 99                 .PET $99  ; 1a    Shift Ctrl Y
eb80 ff                 .PET $ff  ; 1b    KP . Pi
eb81 3a                 .PET ':'  ; 1c    :
eb82 c2                 .PET 'B'  ; 1d    B
eb83 c3                 .PET 'C'  ; 1e    C
eb84 00                 .PET $00  ; 1f    Left SHIFT (used by index)

eb85 a5                 .PET $a5  ; 20    Graph a5   KP 4
eb86 f3                 .PET $f3  ; 21    U umlaut
eb87 cf                 .PET 'O'  ; 22    O
eb88 5e                 .PET '^'  ; 23    Circumflex
eb89 d5                 .PET 'U'  ; 24    U
eb8a d4                 .PET 'T'  ; 25    T
eb8b c5                 .PET 'E'  ; 26    E
eb8c d1                 .PET 'Q'  ; 27    Q

eb8d 5c                 .PET $5c  ; 28    Backslash
eb8e d0                 .PET 'P'  ; 29    P
eb8f c9                 .PET 'I'  ; 2a    I
eb90 2a                 .PET '*'  ; 2b    *
eb91 da                 .PET 'Z'  ; 2c    Z
eb92 d2                 .PET 'R'  ; 2d    R
eb93 d7                 .PET 'W'  ; 2e    W
eb94 89                 .PET $89  ; 2f    Shift TAB

eb95 a7                 .PET $a7  ; 30    Graph a7   KP 6
eb96 f1                 .PET $f1  ; 31    A umlaut
eb97 cc                 .PET 'L'  ; 32    L
eb98 8d                 .PET $8d  ; 33    SHIFT RETURN
eb99 ca                 .PET 'J'  ; 34    J
eb9a c7                 .PET 'G'  ; 35    G
eb9b c4                 .PET 'D'  ; 36    D
eb9c c1                 .PET 'A'  ; 37    A

eb9d a6                 .PET $a6  ; 38    Graph a6   KP 5
eb9e f2                 .PET $f2  ; 39    O umlaut
eb9f cb                 .PET 'K'  ; 3a    K
eba0 27                 .PET $27  ; 3b    '
eba1 c8                 .PET 'H'  ; 3c    H
eba2 c6                 .PET 'F'  ; 3d    F
eba3 d3                 .PET 'S'  ; 3e    S
eba4 1b                 .PET $1b  ; 3f    ESC

eba5 aa                 .PET $aa  ; 40    Graph aa   KP 9
eba6 00                 .PET $00  ; 41
0000 TRUE     #if BSOS_KBD
eba7 93                 .PET $93  ; 42    CLR
              #else
SKIP                    .PET $91  ; 42    CURSOR UP
              #endif
eba8 a8                 .PET $a8  ; 43    Graph a8   KP 7
eba9 3d                 .PET '='  ; 44    =
ebaa 2f                 .PET '/'  ; 45    /
ebab 24                 .PET '$'  ; 46    $
ebac 21                 .PET '!'  ; 47    !

ebad 00                 .PET $00  ; 48
ebae 8e                 .PET $8e  ; 49    Shift Ctrl N
0000 TRUE     #if BSOS_KBD
ebaf 83                 .PET $83  ; 4a    RUN
              #else
SKIP                    .PET $9d  ; 4a    CURSOR LEFT
              #endif
ebb0 a9                 .PET $a9  ; 4b    Graph a9   KP 8
ebb1 c0                 .PET $c0  ; 4c    GRAVE
ebb2 28                 .PET '('  ; 4d    (
ebb3 25                 .PET '%'  ; 4e    %
ebb4 22                 .PET '"'  ; 4f    "

ebb5 00                 .PET 0

              ; ****************
ebb6            KEYBOARD_CONTROL
              ; ****************

ebb6 00                 .BYTE $00           ;                                  10h  -------
ebb7 00                 .BYTE $00           ; SHIFT                            10g  LEFT SHIFT
ebb8 00                 .BYTE $00           ; ?                                10f  SZ ?
ebb9 00                 .BYTE $00           ; INS                              10e  DEL INST
ebba dd                 .BYTE $dd           ; }                                10d  9 )
ebbb 00                 .BYTE $00           ; &                                10c  6 &
ebbc 00                 .BYTE $00           ; `                                10b  3 Paragraph
ebbd 00                 .BYTE $00           ; >                                10a  < >

ebbe 00                 .BYTE $00           ; Graph a2                         9h  KP 1
ebbf 00                 .BYTE $00           ; UNDERLINE                        9g  - _
ebc0 00                 .BYTE $00           ; Shift Ctrl U                     9f  -------
ebc1 00                 .BYTE $00           ; LEFT                             9e  CURSOR <->
ebc2 00                 .BYTE $00           ; M                                9d  M
ebc3 00                 .BYTE $00           ; SHIFT SPC                        9c  SPACE
ebc4 18                 .BYTE $18           ; X                                9b  X
ebc5 00                 .BYTE $00           ; Control                          9a  CTRL (by index)

ebc6 00                 .BYTE $00           ; Graph a3                         8h  KP 2
ebc7 00                 .BYTE $00           ; 8g  CURSOR V^
ebc8 00                 .BYTE $00           ; Shift Ctrl O                     8f  -------
ebc9 00                 .BYTE $00           ; Graph a1                         8e  KP 0
ebca 00                 .BYTE $00           ; ;                                8d  ,
ebcb 0e                 .BYTE $0e           ; N                                8c  N
ebcc 16                 .BYTE $16           ; V                                8b  V
ebcd 19                 .BYTE $19           ; Y                                8a  Y

ebce 00                 .BYTE $00           ; Graph a4                         7h  KP 3
ebcf 00                 .BYTE $00           ; SHIFT                            7g  RIGHT SHIFT
ebd0 00                 .BYTE $00           ; Shift Ctrl Y                     7f  -------
ebd1 de                 .BYTE $de           ; ~                                7e  KP . Pi
ebd2 00                 .BYTE $00           ; :                                7d  . :
ebd3 02                 .BYTE $02           ; B                                7c  B
ebd4 03                 .BYTE $03           ; C                                7b  C
ebd5 00                 .BYTE $00           ; SHIFT                            7a  LEFT SHIFT

ebd6 00                 .BYTE $00           ; Graph a5                         6h  KP 4
ebd7 00                 .BYTE $00           ;                                  6g  UE
ebd8 0f                 .BYTE $0f           ; O                                6f  O
ebd9 00                 .BYTE $00           ; ARROW UP                         6e  Arrow up
ebda 15                 .BYTE $15           ; U                                6d  U
ebdb 14                 .BYTE $14           ; T                                6c  T
ebdc 05                 .BYTE $05           ; E                                6b  E
ebdd 11                 .BYTE $11           ; Q                                6a  Q

ebde 00                 .BYTE $00           ; 5h  ] Backslash
ebdf 10                 .BYTE $10           ; P                                5g  P
ebe0 09                 .BYTE $09           ; I                                5f  I
ebe1 00                 .BYTE $00           ; *                                5e  + *
ebe2 1a                 .BYTE $1a           ; Z                                5d  Z
ebe3 12                 .BYTE $12           ; R                                5c  R
ebe4 17                 .BYTE $17           ; W                                5b  W
ebe5 00                 .BYTE $00           ; SET TAB                          5a  TAB

ebe6 00                 .BYTE $00           ; Graph a7                         4h  KP 6
ebe7 00                 .BYTE $00           ;                                  4g  AE
ebe8 0c                 .BYTE $0c           ; L                                4f  L
ebe9 00                 .BYTE $00           ; SHIFT RET                        4e  RETURN
ebea 0a                 .BYTE $0a           ; J                                4d  J
ebeb 07                 .BYTE $07           ; G                                4c  G
ebec 04                 .BYTE $04           ; D                                4b  D
ebed 01                 .BYTE $01           ; A                                4a  A

ebee 00                 .BYTE $00           ; Graph a6                         3h  KP 5
ebef 00                 .BYTE $00           ;                                  3g  OE
ebf0 0b                 .BYTE $0b           ; K                                3f  K
ebf1 00                 .BYTE $00           ; '                                3e  # '
ebf2 08                 .BYTE $08           ; H                                3d  H
ebf3 06                 .BYTE $06           ; F                                3c  F
ebf4 13                 .BYTE $13           ; S                                3b  S
ebf5 1b                 .BYTE $1b           ; ESC                              3a  ESC

ebf6 00                 .BYTE $00           ; Graph aa                         2h  KP 9
ebf7 00                 .BYTE $00           ; SHIFT                            2g  -------
ebf8 00                 .BYTE $00           ; CLR                              2f  HOME CLR
ebf9 00                 .BYTE $00           ; Graph a8                         2e  KP 7
ebfa 00                 .BYTE $00           ; =                                2d  0 =
ebfb dc                 .BYTE $dc           ; |                                2c  7 /
ebfc 00                 .BYTE $00           ; $                                2b  4 $
ebfd 00                 .BYTE $00           ; !                                2a  1 !

ebfe 00                 .BYTE $00           ; SHIFT                            1h  -------
ebff 00                 .BYTE $00           ; Shift Ctrl N                     1g  -------
ec00 00                 .BYTE $00           ; 1f  [ \
ec01 00                 .BYTE $00           ; Graph a9                         1e  KP 8
ec02 00                 .BYTE $00           ;                                  1d  ACUTE GRAVE
ec03 db                 .BYTE $db           ; {                                1c  8 (
ec04 00                 .BYTE $00           ; %                                1b  5 %
ec05 00                 .BYTE $00           ; "                                1a  2 "
ec06 00                 .BYTE $00           ; SHIFT

              ; **********
ec07            Find_Entry
              ; **********

ec07 86 11              STX LINNUM          ; save old #
ec09 85 12              STA LINNUM+1

              ; ***********
ec0b            Find_LINNUM
              ; ***********

ec0b 98                 TYA
ec0c 48                 PHA
ec0d a0 00              LDY #0
ec0f 84 fb              STY STAL            ; STAL = $8000
ec11 a9 80              LDA #$80
ec13 85 fc              STA STAL+1
ec15 85 b6              STA R_Bank
ec17 a0 03    FiEn_10   LDY #3              ; old line high
ec19 20 7a 02           JSR Bank_Fetch
ec1c c9 ff              CMP #$ff            ; EOT
ec1e f0 18              BEQ FiEn_20
ec20 c5 12              CMP LINNUM+1
ec22 d0 17              BNE FiEn_30
ec24 88                 DEY                 ; old line low
ec25 20 7a 02           JSR Bank_Fetch
ec28 c5 11              CMP LINNUM
ec2a d0 0f              BNE FiEn_30
ec2c 88                 DEY                 ; new line high
ec2d 20 7a 02           JSR Bank_Fetch
ec30 85 12              STA LINNUM+1
ec32 88                 DEY                 ; new line low
ec33 20 7a 02           JSR Bank_Fetch
ec36 85 11              STA LINNUM
ec38 68       FiEn_20   PLA
ec39 a8                 TAY
ec3a 60                 RTS ;Size   48 [Find_LINNUM]
ec3b a9 04    FiEn_30   LDA #4
ec3d 20 1b fb           JSR Add_STAL
ec40 d0 d5              BNE FiEn_10
ec42 60                 RTS ;Size   56 [Find_LINNUM]

              ; *******************
ec43            Install_Bank_Access
              ; *******************

ec43 a2 00              LDX #0
ec45 bd 51 ec FSC_10    LDA Bank_Fetch_Start,X
ec48 9d 7a 02           STA Bank_Fetch,X
ec4b e8                 INX
ec4c e0 24              CPX #[Bank_Store_End - Bank_Fetch_Start]
ec4e 90 f5              BCC FSC_10
ec50 60                 RTS ;Size   14 [Install_Bank_Access]

              ; ****************
ec51            Bank_Fetch_Start
              ; ****************

ec51 a5 b6              LDA R_Bank
ec53 78                 SEI
ec54 8d f0 ff           STA $FFF0
ec57 b1 fb              LDA (STAL),Y
ec59 48                 PHA
ec5a a5 9a              LDA Default_Bank
ec5c 8d f0 ff           STA $FFF0
ec5f 58                 CLI
ec60 68                 PLA
ec61 60                 RTS ;Size   17 [Bank_Fetch_Start]

              ; **************
ec62            Bank_Fetch_End
              ; **************

              ; ****************
ec62            Bank_Store_Start
              ; ****************

ec62 48                 PHA
ec63 a5 b7              LDA W_Bank
ec65 78                 SEI
ec66 8d f0 ff           STA $FFF0
ec69 68                 PLA
ec6a 91 f9              STA (BPTR),Y
ec6c 48                 PHA
ec6d a5 9a              LDA Default_Bank
ec6f 8d f0 ff           STA $FFF0
ec72 58                 CLI
ec73 68                 PLA
ec74 60                 RTS ;Size   19 [Bank_Store_Start]

              ; **************
ec75            Bank_Store_End
              ; **************


              ; ********
ec75            Get_Next
              ; ********

ec75 e6 77              INC TXTPTR
ec77 d0 02              BNE GeNe_10
ec79 e6 78              INC TXTPTR+1
ec7b a1 77    GeNe_10   LDA (TXTPTR,X)      ; X = 0
ec7d 60                 RTS ;Size    9 [Bank_Store_End]

              ; *********
ec7e            Xfer_Line
              ; *********

              ; copy BASIC line and adjust targets for

              ; GOTO
              ; GOSUB
              ; THEN
              ; GO TO
              ; RUN

              ; Set TXTPTR to start of BASIC line

ec7e 18                 CLC
ec7f a5 5c              LDA TMPPTC
ec81 69 03              ADC #3
ec83 85 77              STA TXTPTR
ec85 a5 5d              LDA TMPPTC+1
ec87 69 00              ADC #0
ec89 85 78              STA TXTPTR+1
ec8b a2 00              LDX #0              ; source index
ec8d a0 03              LDY #3              ; destination index
ec8f c8       XfLi_10   INY
ec90 20 75 ec           JSR Get_Next        ; next byte
ec93 20 8b 02           JSR Bank_Store      ; store
ec96 f0 4d              BEQ XfLi_Ret        ; finished
ec98 c9 22              CMP #QUOTE
ec9a d0 0f              BNE XfLi_30
ec9c c8       XfLi_20   INY
ec9d 20 75 ec           JSR Get_Next        ; inside string
eca0 20 8b 02           JSR Bank_Store      ; store
eca3 f0 40              BEQ XfLi_Ret        ; finished
eca5 c9 22              CMP #QUOTE
eca7 d0 f3              BNE XfLi_20         ; continue string copy
eca9 f0 e4              BEQ XfLi_10         ; reenter normal loop
ecab c9 8f    XfLi_30   CMP #$8f            ; REM token
ecad d0 0a              BNE XfLi_50
ecaf c8       XfLi_40   INY
ecb0 20 75 ec           JSR Get_Next        ; after REM
ecb3 20 8b 02           JSR Bank_Store      ; store
ecb6 d0 f7              BNE XfLi_40
ecb8 60                 RTS ;Size   59 [Xfer_Line]
ecb9 c9 89    XfLi_50   CMP #$89            ; GOTO token
ecbb 90 d2              BCC XfLi_10         ; no further action
ecbd f0 1f              BEQ XfLi_70
ecbf c9 8a              CMP #$8a            ; RUN token
ecc1 f0 1b              BEQ XfLi_70
ecc3 c9 8d              CMP #$8d            ; GOSUB token
ecc5 f0 17              BEQ XfLi_70
ecc7 c9 a7              CMP #$a7            ; THEN token
ecc9 f0 13              BEQ XfLi_70
eccb c9 cb              CMP #$cb            ; GO token
eccd d0 0b              BNE XfLi_60
eccf c8       XfLi_55   INY
ecd0 20 75 ec           JSR Get_Next
ecd3 20 8b 02           JSR Bank_Store
ecd6 c9 20              CMP #' '            ; skip blanks after GO
ecd8 f0 f5              BEQ XfLi_55
ecda c9 a4    XfLi_60   CMP #$a4            ; TO token
ecdc d0 b1              BNE XfLi_10         ; continue
ecde 20 e6 ec XfLi_70   JSR Exchange_Number
ece1 c9 00              CMP #0
ece3 d0 d4              BNE XfLi_50         ; continue if not EOL
ece5 60       XfLi_Ret  RTS ;Size  104 [Xfer_Line]


              ; ***************
ece6            Exchange_Number
              ; ***************

ece6 c8                 INY                 ; char after token
ece7 20 70 00           JSR CHRGET
ecea b0 29              BCS ExNu_20         ; no number e.g. after THEN
ecec 20 f6 b8           JSR Scan_Linenumber
ecef 20 0b ec           JSR Find_LINNUM
ecf2 98                 TYA
ecf3 48                 PHA
ecf4 a5 11              LDA LINNUM
ecf6 85 60              STA FAC1M2
ecf8 a5 12              LDA LINNUM+1
ecfa 85 5f              STA FAC1M1
ecfc a2 90              LDX #$90
ecfe 38                 SEC
ecff 20 7f cd           JSR Convert_Integer_To_Real
ed02 20 93 cf           JSR Format_FAC1
ed05 68                 PLA
ed06 a8                 TAY
ed07 a2 01              LDX #1
ed09 bd 00 01 ExNu_10   LDA STACK,X
ed0c f0 07              BEQ ExNu_20
ed0e 20 8b 02           JSR Bank_Store
ed11 c8                 INY
ed12 e8                 INX
ed13 d0 f4              BNE ExNu_10
ed15 a2 00    ExNu_20   LDX#0
ed17 20 76 00           JSR CHRGOT          ; char after target
ed1a 20 8b 02           JSR Bank_Store
ed1d c9 2c              CMP #','            ; on .. goto or on .. gosub ?
ed1f f0 c5              BEQ Exchange_Number
ed21 60       ExNu_Ret  RTS ;Size   60 [Exchange_Number]

              ; **********************
ed22            Reset_Renumber_Pointer
              ; **********************

              ; read basic program with pointer TMPPTC

ed22 a5 28              LDA TXTTAB
ed24 85 5c              STA TMPPTC
ed26 a5 29              LDA TXTTAB+1
ed28 85 5d              STA TMPPTC+1

              ; **********
ed2a            Reset_BPTR
              ; **********

ed2a a9 00              LDA #0
ed2c 85 f9              STA BPTR
ed2e a9 80              LDA #$80
ed30 85 fa              STA BPTR+1
ed32 60                 RTS ;Size    9 [Reset_BPTR]

              ; ***********
ed33            Update_Link
              ; ***********

ed33 a0 00              LDY #0
ed35 b1 5c              LDA (TMPPTC),Y      ; link low
ed37 aa                 TAX
ed38 c8                 INY                 ; Y = 1
ed39 b1 5c              LDA (TMPPTC),Y      ; link high
ed3b 86 5c              STX TMPPTC
ed3d 85 5d              STA TMPPTC+1        ; Z flag set if link high is zero
ed3f 60                 RTS ;Size   13 [Update_Link]


              ; ****************
ed40            Extended_Command
              ; ****************

ed40 a0 00              LDY #0
ed42 84 05              STY COUNT           ; count command #
ed44 88       ExCo_10   DEY
ed45 a6 77              LDX TXTPTR
ed47 ca                 DEX
ed48 e8       ExCo_20   INX
ed49 c8                 INY
ed4a bd 00 02           LDA BUF,X
ed4d 38                 SEC
ed4e f9 3a bf           SBC Extended_Keyword_Table,Y
ed51 f0 f5              BEQ ExCo_20         ; character match
ed53 c9 80              CMP #$80            ; match with difference $80 -> OK
ed55 d0 13              BNE ExCo_30         ; not this keyword
ed57 68                 PLA                 ; remove CALL
ed58 68                 PLA
ed59 86 77              STX TXTPTR
ed5b a5 05              LDA COUNT           ; command #
ed5d 0a                 ASL A
ed5e a8                 TAY
ed5f b9 2d bf           LDA Extended_Statement_Table+1,Y
ed62 48                 PHA
ed63 b9 2c bf           LDA Extended_Statement_Table,Y
ed66 48                 PHA
ed67 4c 70 00           JMP CHRGET          ; RTS from CHRGET jumps to statement code
ed6a e6 05    ExCo_30   INC COUNT           ; try next keyword
ed6c c8       ExCo_40   INY
ed6d b9 39 bf           LDA Extended_Keyword_Table-1,Y
ed70 10 fa              BPL ExCo_40
ed72 b9 2c bf           LDA Extended_Statement_Table,Y
ed75 d0 cd              BNE ExCo_10         ; next keyword if not end of table
ed77 60                 RTS                 ; finished scan ;Size   56 [Extended_Command]


              ; *********
ed78            Find_Text
              ; *********

ed78 20 fb b4           JSR Tokenize_Line
ed7b 20 70 00           JSR CHRGET
ed7e 85 23              STA RENNEW          ; delimiter
ed80 20 22 ed           JSR Reset_Renumber_Pointer
ed83 a0 03    FiTe_10   LDY #3
ed85 84 24              STY RENNEW+1
ed87 20 9a ed           JSR Contains_Pattern
ed8a d0 06              BNE FiTe_20
ed8c 20 ce ea           JSR List_BASIC_Line
ed8f 20 1e d5           JSR Mon_Print_CR
ed92 20 33 ed FiTe_20   JSR Update_Link
ed95 d0 ec              BNE FiTe_10
ed97 4c ff b3           JMP Basic_Ready

              ; ****************
ed9a            Contains_Pattern
              ; ****************

ed9a a6 77    CoPa_10   LDX TXTPTR          ; text to find - 1
ed9c a4 24              LDY RENNEW+1
ed9e c8       CoPa_20   INY
ed9f e8                 INX
eda0 bd 00 02           LDA BUF,X           ; next pattern
eda3 f0 10              BEQ CoPa_Ret        ; match
eda5 c5 23              CMP RENNEW          ; delimiter
eda7 f0 0c              BEQ CoPa_Ret        ; match
eda9 d1 5c              CMP (TMPPTC),Y      ; next program byte
edab f0 f1              BEQ CoPa_20         ; continue compare
edad e6 24              INC RENNEW+1        ; advance search pos
edaf b1 5c              LDA (TMPPTC),Y
edb1 d0 e7              BNE CoPa_10
edb3 a9 01              LDA #1
edb5 60       CoPa_Ret  RTS ;Size   28 [Contains_Pattern]

              ; **************
edb6            Load_Directory
              ; **************

edb6 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
edb9 a4 2f              LDY STREND+1        ; load directory into free RAM
edbb c8                 INY
edbc 84 ca              STY EAL+1
edbe a0 00              LDY #0
edc0 84 c9              STY EAL
edc2 84 96              STY STATUS
edc4 a0 02              LDY #2              ; header start
edc6 a6 ca    LoDi_10   LDX EAL+1           ; next page
edc8 e8                 INX
edc9 e4 31              CPX FRETOP+1        ; end of free RAM
edcb 90 03              BCC LoDi_20         ; branch if OK
edcd 4c cd b3           JMP Error_Out_Of_Memory
edd0 86 ca    LoDi_20   STX EAL+1
edd2 20 c0 f1 LoDi_30   JSR ACPTR           ; read next byte
edd5 91 c9              STA (EAL),Y
edd7 a5 96              LDA STATUS
edd9 d0 05              BNE LoDi_40         ; branch on EOI
eddb c8                 INY
eddc d0 f4              BNE LoDi_30         ; loop
edde f0 e6              BEQ LoDi_10         ; increment page
ede0 4c c1 f3 LoDi_40   JMP LoFi_70         ; Untalk & Close

              ; *****************
ede3            DOS_Get_Dir_Entry
              ; *****************

              ; Read directory entry from loaded $ file
              ; and store results in FNLEN and DOS_FC
              ; Store filename address in FNADR
              ; X = 0 flags no entry found on exit

ede3 18                 CLC                 ; advance to next entry
ede4 a5 bb              LDA DosPtr          ; start address
ede6 69 20              ADC #32
ede8 85 bb              STA DosPtr
edea 90 02              BCC DGDE_05
edec e6 bc              INC DosPtr+1

edee a0 03    DGDE_05   LDY #3              ; scan after size word

edf0 c8       DGDE_10   INY
edf1 b1 bb              LDA (DosPtr),Y
edf3 c9 22              CMP #QUOTE
edf5 90 f9              BCC DGDE_10         ; skip blanks before filename
edf7 d0 3a              BNE DGDE_80         ; no quote -> blocks free
edf9 88                 DEY                 ; byte for drive
edfa 88                 DEY                 ; byte for 'S' command
edfb 98                 TYA
edfc 05 bb              ORA DosPtr          ; set FNADR
edfe 85 da              STA FNADR
ee00 a5 bc              LDA DosPtr+1
ee02 85 db              STA FNADR+1
ee04 a0 00              LDY #0              ; prepare scratch command
ee06 a9 53              LDA #'S'
ee08 91 da              STA (FNADR),Y
ee0a c8                 INY
ee0b ad 3c 03           LDA DOS_Drive_2     ; target drive
ee0e 09 30              ORA #'0'
ee10 91 da              STA (FNADR),Y
ee12 c8                 INY
ee13 a9 3a              LDA #':'
ee15 91 da              STA (FNADR),Y       ; overwrite opening quote

ee17 c8       DGDE_20   INY
ee18 b1 da              LDA (FNADR),Y
ee1a c9 22              CMP #QUOTE          ; closing quote
ee1c f0 04              BEQ DGDE_40
ee1e c0 13              CPY #19             ; max length + "S0:"
ee20 90 f5              BCC DGDE_20

ee22 84 d1    DGDE_40   STY FNLEN           ; length of filename

ee24 c8       DGDE_60   INY
ee25 b1 da              LDA (FNADR),Y
ee27 c9 20              CMP #' '            ; skip blanks
ee29 f0 f9              BEQ DGDE_60
ee2b c9 2a              CMP #'*'            ; splat file ?
ee2d f0 b4              BEQ DOS_Get_Dir_Entry
ee2f 85 b1              STA DOS_FC          ; PRG, SEQ, USR, REL
ee31 a0 00              LDY #0              ; flag success

ee33 60       DGDE_80   RTS                 ; Y != 0 for no file ;Size   81 [DOS_Get_Dir_Entry]

              ; *************
ee34            DOS_Add_Comma
              ; *************

ee34 a9 2c              LDA #','
ee36 91 da              STA (FNADR),Y
ee38 c8                 INY
ee39 60                 RTS ;Size    6 [DOS_Add_Comma]

              ; DOS_Copy is an enhancement of the BASIC 4 COPY command.
              ; It is called from the original COPY if Source Unit and
              ; Target unit differ
              ; DOS_Copy uses the free RAM between variable storage and
              ; string storage (STREND - FRETOP)
              ; First a call to the Garbage_Collection maximises the
              ; free RAM area. The first 256 byte block after STREND is
              ; used as a transfer buffer. The area STREND + 256 is used
              ; to store the directory of the source unit. If the
              ; remaining space is not sufficient to load the directory
              ; an OOM (Out Of Memory) error occurs.

              ; ********
ee3a            DOS_Copy
              ; ********

ee3a 20 6a c6           JSR Garbage_Collection
ee3d a5 d4              LDA FA              ; target unit
ee3f 85 ad              STA Target_Unit     ; save it
ee41 a5 9c              LDA Source_Unit
ee43 85 d4              STA FA
ee45 a9 24              LDA #'$'            ; directory command
ee47 8d 53 03           STA DOS_Command_Buffer
ee4a a9 03              LDA #3              ; 3 parameter
ee4c a2 01              LDX #1              ; write after $
ee4e a0 02              LDY #2              ; build d1:f1
ee50 20 fc db           JSR Build_DOS_Command_X
ee53 20 b6 ed           JSR Load_Directory
ee56 a9 00              LDA #0              ; start of directory
ee58 85 bb              STA DosPtr
ee5a a6 2f              LDX STREND+1
ee5c e8                 INX
ee5d e8                 INX
ee5e 86 bc              STX DosPtr+1

ee60 20 e3 ed DOSC_10   JSR DOS_Get_Dir_Entry
ee63 98                 TYA                 ; 0: success
ee64 f0 01              BEQ DOSC_15
ee66 60                 RTS ;Size   45 [DOS_Copy]

ee67 84 b9    DOSC_15   STY DOS_RL          ; record length
ee69 84 11              STY LINNUM          ; initialize record #
ee6b 84 12              STY LINNUM+1
ee6d c8                 INY
ee6e 8c 3a 03           STY DOS_Tmp         ; pos in record# = 1
ee71 a4 d1              LDY FNLEN
ee73 20 34 ee           JSR DOS_Add_Comma
ee76 a5 b1              LDA DOS_FC          ; Filetype
ee78 c9 52              CMP #'R'            ; REL file ?
ee7a d0 0e              BNE DOSC_20
ee7c a9 4c              LDA #'L'            ; REL type
ee7e 91 da              STA (FNADR),Y
ee80 c8                 INY
ee81 20 34 ee           JSR DOS_Add_Comma   ; "St:FILENAME,L,CHR$(RL)"
ee84 a9 fe              LDA #254            ; max record length
ee86 85 b9              STA DOS_RL
ee88 d0 08              BNE DOSC_25         ; branch always

ee8a 91 da    DOSC_20   STA (FNADR),Y       ; "St:FILENAME,S"
ee8c c8                 INY
ee8d 20 34 ee           JSR DOS_Add_Comma
ee90 a9 57              LDA #'W'

ee92 91 da    DOSC_25   STA (FNADR),Y       ; "St:FILENAME,S,W"

              ; Scratch target file (avoid @ syntax)

ee94 a5 ad              LDA Target_Unit
ee96 85 d4              STA FA
ee98 20 9b da           JSR PDC_10          ; send DOS command

              ; Remove 'S' from Scratch command

ee9b e6 da              INC FNADR           ; always inside page

              ; Add ",S" ",P" ",U" or ",L,CHR$(RL)"

ee9d e6 d1              INC FNLEN           ; "t:FILENAME,S"
ee9f a5 b9              LDA DOS_RL          ; REL file ?
eea1 f0 04              BEQ DOSC_35         ; branch if not
eea3 e6 d1              INC FNLEN           ; "t:FILENAME,L,"
eea5 e6 d1              INC FNLEN           ; "t:FILENAME,L,(RL)"

              ; print filename

eea7 20 5d ef DOSC_35   JSR Print_Filename
eeaa 20 87 ef           JSR Open_Read_File

              ; Open write file

eead a5 b9    DOSC_47   LDA DOS_RL
eeaf d0 04              BNE DOSC_50
eeb1 e6 d1              INC FNLEN           ; "s:FILENAME,S,W"
eeb3 e6 d1              INC FNLEN

eeb5 20 a4 ef DOSC_50   JSR Open_Write_File

              ; Copy file

eeb8 a5 9c    DOSC_55   LDA Source_Unit
eeba 85 d4              STA FA
eebc 20 d2 f0           JSR TALK
eebf a9 6d              LDA #$6d
eec1 85 d3              STA SA
eec3 20 93 f1           JSR TKSA
eec6 a0 00              LDY #0
eec8 84 96              STY STATUS

eeca 20 c0 f1 DOSC_60   JSR ACPTR
eecd 91 2e              STA (STREND),Y
eecf c8                 INY
eed0 a5 96              LDA STATUS
eed2 85 b2              STA DOS_EOF
eed4 d0 04              BNE DOSC_65
eed6 c4 b9              CPY DOS_RL          ; copy max DOS_RL bytes
eed8 d0 f0              BNE DOSC_60         ; DOS_RL=0 -> copy 256 bytes

eeda 84 b1    DOSC_65   STY DOS_FC          ; Byte count
eedc 20 ae f1           JSR UNTLK
eedf a5 b9              LDA DOS_RL
eee1 f0 07              BEQ DOSC_66
eee3 20 91 d9           JSR Kernal_Read_DS
eee6 c9 30              CMP #'0'
eee8 d0 41              BNE DOSC_75

eeea a5 ad    DOSC_66   LDA Target_Unit
eeec 85 d4              STA FA
eeee a9 6e              LDA #$6e
eef0 85 d3              STA SA
eef2 a0 00              LDY #0
eef4 84 96              STY STATUS
eef6 a5 b9              LDA DOS_RL
eef8 f0 03              BEQ DOSC_67
eefa 20 4c ef           JSR Send_Record_No

eefd 20 d5 f0 DOSC_67   JSR LISTEN
ef00 a9 6e              LDA #$6e
ef02 85 d3              STA SA
ef04 20 43 f1           JSR SECOND

ef07 b1 2e    DOSC_70   LDA (STREND),Y
ef09 20 9e f1           JSR CIOUT
ef0c a5 96              LDA STATUS
ef0e d0 1b              BNE DOSC_75
ef10 c8                 INY
ef11 c4 b1              CPY DOS_FC
ef13 d0 f2              BNE DOSC_70
ef15 20 b9 f1           JSR UNLSN
ef18 a5 b2              LDA DOS_EOF
ef1a f0 9c              BEQ DOSC_55
ef1c a5 b9              LDA DOS_RL
ef1e f0 0b              BEQ DOSC_75
ef20 20 91 d9           JSR Kernal_Read_DS
ef23 c9 30              CMP #'0'
ef25 f0 91              BEQ DOSC_55
ef27 c9 35              CMP #'5'            ; ignore record not present
ef29 f0 8d              BEQ DOSC_55

ef2b 20 b9 f1 DOSC_75   JSR UNLSN
ef2e a5 ad              LDA Target_Unit
ef30 85 d4              STA FA
ef32 a9 6e              LDA #$6e
ef34 85 d3              STA SA
ef36 20 2a f7           JSR Close_Disk_File ; close write file
ef39 a9 0d              LDA #CR
ef3b 20 d2 ff           JSR CHROUT
ef3e a5 9c              LDA Source_Unit
ef40 85 d4              STA FA
ef42 a9 6d              LDA #$6d
ef44 85 d3              STA SA
ef46 20 2a f7           JSR Close_Disk_File ; close read file
ef49 4c 60 ee           JMP DOSC_10         ; next file

              ; **************
ef4c            Send_Record_No
              ; **************

ef4c e6 11              INC LINNUM
ef4e d0 02              BNE SRN_10
ef50 e6 12              INC LINNUM+1
ef52 20 43 da SRN_10    JSR DOS_Record_No
ef55 20 91 d9           JSR Kernal_Read_DS
ef58 a0 00              LDY #0
ef5a 84 96              STY STATUS
ef5c 60                 RTS ;Size   17 [Send_Record_No]

              ; **************
ef5d            Print_Filename
              ; **************

ef5d 20 51 f3           JSR In_Direct_Mode
ef60 d0 24              BNE PrFi_90
ef62 a0 00              LDY #0
ef64 b1 da    PrFi_10   LDA (FNADR),Y
ef66 c8                 INY
ef67 20 d2 ff           JSR CHROUT
ef6a c9 4c              CMP #'L'
ef6c d0 14              BNE PrFi_20
ef6e b1 da              LDA (FNADR),Y
ef70 c9 2c              CMP#','
ef72 d0 0e              BNE PrFi_20
ef74 20 d2 ff           JSR CHROUT
ef77 a9 24              LDA #'$'
ef79 20 d2 ff           JSR CHROUT
ef7c c8                 INY
ef7d b1 da              LDA (FNADR),Y
ef7f 4c 54 d7           JMP Print_Hex_Byte
ef82 c4 d1    PrFi_20   CPY FNLEN
ef84 90 de              BCC PrFi_10
ef86 60       PrFi_90   RTS ;Size   42 [Print_Filename]

              ; **************
ef87            Open_Read_File
              ; **************

ef87 a5 9c              LDA Source_Unit
ef89 85 d4              STA FA
ef8b a9 6d              LDA #$6d            ; channel 13
ef8d 85 d3              STA SA
ef8f a0 00              LDY #0
ef91 84 96              STY STATUS          ; clear status
ef93 ad 3b 03           LDA DOS_Drive_1     ; source drive
ef96 09 30              ORA #'0'
ef98 91 da              STA (FNADR),Y       ; into filename
ef9a a5 b9              LDA DOS_RL          ; REL file ?
ef9c f0 03              BEQ ORF_10          ; branch if not
ef9e 4c c8 e4           JMP Get_Record_Size
efa1 4c af f4 ORF_10    JMP Send_Filename

              ; ***************
efa4            Open_Write_File
              ; ***************

efa4 a5 ad              LDA Target_Unit
efa6 85 d4              STA FA
efa8 a9 6e              LDA #$6e
efaa 85 d3              STA SA
efac a0 00              LDY #0
efae 84 96              STY STATUS
efb0 ad 3c 03           LDA DOS_Drive_2
efb3 09 30              ORA #'0'
efb5 91 da              STA (FNADR),Y
efb7 4c af f4           JMP Send_Filename


efba 00 00 00           .FILL $f000 - * (0) ; 70 bytes

              ; ***************
f000            KERNAL_MESSAGES
              ; ***************

f000 54 4f 4f MSG_TOO_MANY    .BYTE "TOO MANY FILES"^
f00e 46 49 4c MSG_FILE_OPEN   .BYTE "FILE OPEN"^
f017 46 49 4c MSG_FILE_NOT_O  .BYTE "FILE NOT OPEN"^
f024 46 49 4c MSG_FILE_NOT_F  .BYTE "FILE NOT FOUND"^
f032 0d 53 45 MSG_SEARCHING   .BYTE "\rSEARCHING "^
f03d 46 4f 52 MSG_FOR         .BYTE "FOR "^
f041 0d 50 52 MSG_PRESS       .BYTE "\rPRESS PLAY "^
f04d 26 20 52 MSG_RECORD      .BYTE "& RECORD "^
f056 4f 4e 20 MSG_ON_TAPE     .BYTE "ON TAPE #"^
f05f 0d 4c 4f MSG_LOAD        .BYTE "\rLOAD"^
f064 0d 57 52 MSG_WRITING     .BYTE "\rWRITING "^
f06d 0d 56 45 MSG_VERIFY      .BYTE "\rVERIFY"^
f074 44 45 56 MSG_DEVICE_NOT  .BYTE "DEVICE NOT PRESENT"^
f086 4e 4f 54 MSG_NOT_INPUT   .BYTE "NOT INPUT FILE"^
f094 4e 4f 54 MSG_NOT_OUTPUT  .BYTE "NOT OUTPUT FILE"^
f0a3 0d 46 4f MSG_FOUND       .BYTE "\rFOUND "^
f0aa 0d 4f 4b MSG_OK          .BYTE "\rOK\r"^
f0ae 0d 52 45 MSG_READY       .BYTE "\rREADY.\r"^
f0b6 0d 41 52 MSG_SURE        .BYTE "\rARE YOU SURE ?"^
f0c5 0d 3f 20 MSG_BAD_DISK    .BYTE "\r? BAD DISK \r"^

              ; ****
f0d2            TALK
              ; ****

f0d2 a9 40              LDA #%01000000      ; TALK cmd: $40..$5e
f0d4 2c                 .BYTE $2c           ; skip next statement

              ; ******
f0d5            LISTEN
              ; ******

f0d5 a9 20              LDA #%00100000      ; LISTEN cmd: $20..$3e

              ; *******
f0d7            TALI_10
              ; *******

f0d7 48                 PHA                 ; save talk or listen bit
f0d8 ad 40 e8           LDA VIA_Port_B
f0db 09 02              ORA #%00000010      ; $02
f0dd 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f0e0 a9 3c              LDA #%00111100      ; $3c
f0e2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f0e5 24 a0              BIT C3PO            ; data in output buffer ?
f0e7 f0 11              BEQ TALI_20         ; branch if not
f0e9 a9 34              LDA #%00110100      ; $34
f0eb 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) low
f0ee 20 09 f1           JSR Send_IEEE_Byte  ; flush buffer (BSOUR)
f0f1 a9 00              LDA #0
f0f3 85 a0              STA C3PO            ; clear buffer flag
f0f5 a9 3c              LDA #%00111100      ; $3c
f0f7 8d 11 e8           STA PIA1_Cont_A     ; set NDAC (bit 3) high
f0fa 68       TALI_20   PLA                 ; restore talk or listen bit
f0fb 05 d4              ORA FA              ; combine signal with adress
f0fd 85 a5              STA BSOUR           ; store in output buffer
f0ff ad 40 e8 TALI_30   LDA VIA_Port_B      ; load signals
f102 10 fb              BPL TALI_30         ; wait until DAV high
f104 29 fb              AND #%11111011      ; $fb
f106 8d 40 e8           STA VIA_Port_B      ; set ATN (bit 2) low

              ; **************
f109            Send_IEEE_Byte
              ; **************

f109 a9 3c              LDA #%00111100      ; $3c
f10b 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f10e ad 40 e8           LDA VIA_Port_B      ; loadsignals
f111 29 41              AND #%01000001      ; mask NRFD & NDAC
f113 c9 41              CMP #%01000001      ; both high ?
f115 f0 55              BEQ Device_Not_Present
f117 a5 a5              LDA BSOUR           ; load byte to send
f119 49 ff              EOR #$ff            ; invert it
f11b 8d 22 e8           STA PIA2_Port_B     ; DATA OUT
f11e 2c 40 e8 SIB_10    BIT VIA_Port_B      ; test signals
f121 50 fb              BVC SIB_10          ; wait until NRFD high
f123 a9 34              LDA #%00110100      ; $34
f125 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) low
f128 a9 ff    SIB_20    LDA #$ff            ; set timer to MAX
f12a 8d 45 e8           STA VIA_Timer_1_Hi
f12d ad 40 e8 SIB_30    LDA VIA_Port_B      ; load signals
f130 2c 4d e8           BIT VIA_IFR         ; check timer, expect NDAC high in ca. 65 ms
f133 70 1c              BVS Time_Out_Writing
f135 4a                 LSR A               ; NDAC -> carry
f136 90 f5              BCC SIB_30          ; repeat until NDAC high
f138 a9 3c    tby6      LDA #%00111100      ; $3c
f13a 8d 23 e8           STA PIA2_Cont_B     ; set DAV (bit 3) high
f13d a9 ff              LDA #$ff            ; release data lines
f13f 8d 22 e8           STA PIA2_Port_B
f142 60                 RTS ;Size   58 [Send_IEEE_Byte]

              ; ******
f143            SECOND
              ; ******

f143 85 a5              STA BSOUR           ; output buffer
f145 20 09 f1           JSR Send_IEEE_Byte  ; send it

              ; *******
f148            Set_ATN
              ; *******

f148 ad 40 e8           LDA VIA_Port_B
f14b 09 04              ORA #%00000100      ; $04
f14d 8d 40 e8           STA VIA_Port_B      ; set ATN high
f150 60                 RTS ;Size    9 [Set_ATN]

              ; ****************
f151            Time_Out_Writing
              ; ****************

f151 ad fc 03           LDA Ignore_Timeout  ; load timeout flag (addr. 1020, bit 7)
f154 10 0f              BPL Timo_W          ; timeout if flag cleared (default value)
f156 20 43 f3           JSR Kernal_STOP
f159 d0 cd              BNE SIB_20          ; restart timer and try again to transmit

              ; ****************
f15b            Time_Out_Reading
              ; ****************

f15b ad fc 03           LDA Ignore_Timeout
f15e 10 10              BPL Timo_R
f160 20 43 f3           JSR Kernal_STOP
f163 d0 68              BNE Acptr_10
f165 a9 01    Timo_W    LDA #1              ; flag time out on writing
f167 20 c4 fb Timo_S    JSR Set_STATUS
f16a d0 cc              BNE tby6            ; branch always

              ; ******************
f16c            Device_Not_Present
              ; ******************

f16c a9 80              LDA #$80
f16e 30 f7              BMI Timo_S
f170 a9 02    Timo_R    LDA #2              ; flag time out reading
f172 20 c4 fb           JSR Set_STATUS

              ; *****************
f175            Set_NRFD_NDAC_low
              ; *****************

f175 ad 40 e8           LDA VIA_Port_B
f178 29 fd              AND #%11111101      ; $fd
f17a 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f17d a9 34              LDA #%00110100      ; $34
f17f 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f182 a9 0d              LDA #CR             ; load CR
f184 60                 RTS ;Size   16 [Set_NRFD_NDAC_low]

              ; **********************
f185            Display_Kernal_Message
              ; **********************

f185 b9 00 f0           LDA KERNAL_MESSAGES,Y  ; Y = offset for string
f188 08                 PHP                 ; save status (possible end marker)
f189 29 7f              AND #$7f            ; clear bit 7
f18b 20 02 e2           JSR EDIT_CHROUT     ; dispay it
f18e c8                 INY                 ; next character
f18f 28                 PLP                 ; restore status
f190 10 f3              BPL Display_Kernal_Message
f192 60                 RTS                 ; bit 7 = end marker ;Size   14 [Display_Kernal_Message]

              ; ****
f193            TKSA
              ; ****

f193 85 a5              STA BSOUR           ; SA (A) to Buffer
f195 20 09 f1           JSR Send_IEEE_Byte  ; send it
f198 20 75 f1           JSR Set_NRFD_NDAC_low
f19b 4c 48 f1           JMP Set_ATN

              ; *****
f19e            CIOUT
              ; *****

f19e 24 a0              BIT C3PO            ; C3PO = 0 flags empty buffer
f1a0 30 04              BMI Ciout_10        ; branch if not empty
f1a2 c6 a0              DEC C3PO            ; set flag for not empty
f1a4 d0 05              BNE Ciout_20        ; branch always
f1a6 48       Ciout_10  PHA                 ; save current byte
f1a7 20 09 f1           JSR Send_IEEE_Byte  ; send byte from buffer
f1aa 68                 PLA                 ; restore current byte
f1ab 85 a5    Ciout_20  STA BSOUR           ; put it into buffer
f1ad 60                 RTS ;Size   16 [CIOUT]

              ; *****
f1ae            UNTLK
              ; *****

f1ae ad 40 e8           LDA VIA_Port_B
f1b1 29 fb              AND #%11111011      ; $fb
f1b3 8d 40 e8           STA VIA_Port_B      ; set ATN low
f1b6 a9 5f              LDA #%01011111      ; $5f
f1b8 2c                 .BYTE $2c           ; skip next statement

              ; *****
f1b9            UNLSN
              ; *****

f1b9 a9 3f              LDA #%00111111      ; $3f
f1bb 20 d7 f0           JSR TALI_10
f1be d0 88              BNE Set_ATN         ; branch always

              ; *****
f1c0            ACPTR
              ; *****

f1c0 a9 34              LDA #%00110100      ; $34
f1c2 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f1c5 ad 40 e8           LDA VIA_Port_B
f1c8 09 02              ORA #%00000010      ; $02
f1ca 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) high
f1cd a9 ff    Acptr_10  LDA #$ff
f1cf 8d 45 e8           STA VIA_Timer_1_Hi  ; set timer
f1d2 2c 4d e8 Acptr_20  BIT VIA_IFR
f1d5 70 84              BVS Time_Out_Reading; timeout after 65 ms
f1d7 2c 40 e8           BIT VIA_Port_B      ; test DAV (bit 7)
f1da 30 f6              BMI Acptr_20        ; loop until DAV (bit 7) low
f1dc ad 40 e8           LDA VIA_Port_B
f1df 29 fd              AND #%11111101      ; $fd
f1e1 8d 40 e8           STA VIA_Port_B      ; set NRFD (bit 1) low
f1e4 2c 10 e8           BIT PIA1_Port_A     ; test for EOI
f1e7 70 05              BVS Acptr_30        ; branch if not
f1e9 a9 40              LDA #%01000000      ; set EOI flag
f1eb 20 c4 fb           JSR Set_STATUS
f1ee ad 20 e8 Acptr_30  LDA PIA2_Port_A     ; read data byte
f1f1 49 ff              EOR #$ff            ; invert it
f1f3 48                 PHA                 ; save read byte
f1f4 a9 3c              LDA #%00111100      ; $3c
f1f6 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) high
f1f9 2c 40 e8 Acptr_40  BIT VIA_Port_B      ; test DAV
f1fc 10 fb              BPL Acptr_40        ; loop until DAV (bit 7) high
f1fe a9 34              LDA #%00110100      ; $34
f200 8d 21 e8           STA PIA2_Cont_A     ; set NDAC (bit 3) low
f203 68                 PLA                 ; restore read byte
f204 60                 RTS ;Size   69 [ACPTR]

              ; ************
f205            Kernal_GETIN
              ; ************

f205 a9 00              LDA #0
f207 85 96              STA STATUS          ; clear status
f209 a5 af              LDA DFLTN           ; current input device
f20b d0 17              BNE KeIn_10         ; branch if not keyboard
f20d a5 9e    GETIN_10  LDA CharsInBuffer   ; test keyboard queue
f20f f0 26              BEQ KeIn_30         ; return if empty
f211 78                 SEI                 ; disable interrupt
f212 4c a7 e0           JMP EDIT_GETIN      ; get character from keyboard queue

              ; ************
f215            Kernal_CHRIN
              ; ************

f215 a5 af              LDA DFLTN           ; current input device
f217 d0 0b              BNE KeIn_10         ; branch if not keyboard
f219 a5 c6              LDA CursorCol       ; get current cursor column
f21b 85 a4              STA InputCol        ; start input here
f21d a5 d8              LDA CursorRow       ; get current cursor row
f21f 85 a3              STA InputRow        ; start input here
f221 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f224 c9 04    KeIn_10   CMP #4              ; test device number
f226 b0 09              BCS KeIn_20         ; branch if IEEE-488 device
f228 85 ac              STA CRSW            ; device is screen (3)
f22a a5 d5              LDA RigMargin       ; limit input column
f22c 85 a1              STA LastInputCol    ; at right margin
f22e 4c 16 e1           JMP EDIT_CHRIN      ; continue at EDIT_CHRIN
f231 a5 96    KeIn_20   LDA STATUS          ; It's IEEE-488 input
f233 f0 03              BEQ KeIn_40         ; continue at ACPTR if status is OK
f235 a9 0d              LDA #CR             ; status flags some error, return CR
f237 60       KeIn_30   RTS                 ; return ;Size   35 [Kernal_CHRIN]
f238 4c c0 f1 KeIn_40   JMP ACPTR           ; continue at ACPTR

f23b 00 00 00           .FILL $f266 - * (0) ; 43 bytes

              ; *************
f266            Kernal_CHROUT
              ; *************

f266 48                 PHA                 ; save character
f267 a5 b0              LDA DFLTO           ; load current output device
f269 c9 04              CMP #4              ; 4 = start of IEEE-488 devices
f26b 68                 PLA                 ; restore character
f26c b0 03              BCS KeCH_10         ; branch if IEEE-488 device
f26e 4c 02 e2           JMP EDIT_CHROUT     ; continue at display on screen
f271 4c 9e f1 KeCH_10   JMP CIOUT           ; continue on IEEE-488 output

f274 00 00 00           .FILL $f2a2 - * (0) ; 46 bytes

              ; ************
f2a2            Kernal_CLALL
              ; ************

f2a2 a9 00              LDA #0
f2a4 85 ae              STA LDTND           ; set # of open files to zero

              ; *************
f2a6            Kernal_CLRCHN
              ; *************

f2a6 a5 b0              LDA DFLTO           ; default output device
f2a8 c9 04              CMP #4              ; screen or IEEE-488 ?
f2aa 90 03              BCC KeCL_10         ; branch if screen
f2ac 20 b9 f1           JSR UNLSN           ; send unlisten
f2af a5 af    KeCL_10   LDA DFLTN           ; default input device
f2b1 c9 04              CMP #4              ; IEEE-488 or not ?
f2b3 90 03              BCC Set_Default_IO
f2b5 20 ae f1           JSR UNTLK           ; send untalk

              ; **************
f2b8            Set_Default_IO
              ; **************

f2b8 a9 03              LDA #3
f2ba 85 b0              STA DFLTO
f2bc a9 00              LDA #0
f2be 85 af              STA DFLTN
f2c0 60                 RTS ;Size    9 [Set_Default_IO]

              ; *********
f2c1            LOOKUP_LA
              ; *********

f2c1 a6 ae              LDX LDTND           ; # of open files
f2c3 ca       LOOK_10   DEX
f2c4 30 05              BMI LOOK_Ret        ; -> not found
f2c6 dd 51 02           CMP LAT,X
f2c9 d0 f8              BNE LOOK_10
f2cb 60       LOOK_Ret  RTS ;Size   11 [LOOKUP_LA]

f2cc 00                 .FILL $f2cd-* (0) ; 1 bytes

              ; **********************
f2cd            Set_LFS_From_X ; $f2cd
              ; **********************

              ; Input:  X = index to file
              ; Output: A = FA

f2cd bd 51 02           LDA LAT,X
f2d0 85 d2              STA LA
f2d2 bd 65 02           LDA SAT,X
f2d5 85 d3              STA SA
f2d7 bd 5b 02           LDA FAT,X
f2da 85 d4              STA FA
f2dc 60                 RTS ;Size   16 [Set_LFS_From_X]

              ; ************
f2dd            Kernal_CLOSE
              ; ************

f2dd 20 0d f5           JSR Get_Open_Close_Parameter
f2e0 a5 d2              LDA LA

              ; *************
f2e2            Close_LA_in_A
              ; *************

f2e2 20 c1 f2           JSR LOOKUP_LA
f2e5 d0 24              BNE ClFi_20

              ; ************
f2e7            Close_File_A
              ; ************

f2e7 20 cd f2           JSR Set_LFS_From_X
f2ea c9 04              CMP #4
f2ec 90 03              BCC ClFi_10         ; keyboard or screen
f2ee 20 2a f7           JSR Close_Disk_File
f2f1 c6 ae    ClFi_10   DEC LDTND
f2f3 e4 ae              CPX LDTND
f2f5 f0 14              BEQ ClFi_20
f2f7 a4 ae              LDY LDTND
f2f9 b9 51 02           LDA LAT,Y
f2fc 9d 51 02           STA LAT,X
f2ff b9 5b 02           LDA FAT,Y
f302 9d 5b 02           STA FAT,X
f305 b9 65 02           LDA SAT,Y
f308 9d 65 02           STA SAT,X
f30b 60       ClFi_20   RTS ;Size   37 [Close_File_A]

f30c 00 00 00           .FILL $f335 - * (0) ; 41 bytes

              ; **************
f335            Check_STOP_Key
              ; **************

f335 a5 9b              LDA Stop_Flag
f337 c9 ef              CMP #$ef
f339 d0 07              BNE ChST_Ret
f33b 08                 PHP
f33c 20 a6 f2           JSR Kernal_CLRCHN
f33f 85 9e              STA CharsInBuffer
f341 28                 PLP
f342 60       ChST_Ret  RTS ;Size   14 [Check_STOP_Key]

              ; ***********
f343            Kernal_STOP
              ; ***********

f343 20 35 f3           JSR Check_STOP_Key
f346 4c c6 b7           JMP Basic_STOP

              ; ************************
f349            Kernal_Message_If_Direct
              ; ************************

f349 20 51 f3           JSR In_Direct_Mode
f34c d0 f4              BNE ChST_Ret
f34e 4c 85 f1           JMP Display_Kernal_Message

              ; **************
f351            In_Direct_Mode
              ; **************

f351 a5 78              LDA TXTPTR+1
f353 c9 02              CMP #2
f355 60                 RTS ;Size    5 [In_Direct_Mode]

              ; *********
f356            Load_File
              ; *********

f356 a5 d4              LDA FA              ; primary device address
f358 c9 04              CMP #4              ; start of IEEE-488 devices
f35a b0 03              BCS LoFi_15
f35c 4c 00 bf LoFi_10   JMP Syntax_Error    ; no loading from devices 0-3
f35f a4 d1    LoFi_15   LDY FNLEN
f361 f0 f9              BEQ LoFi_10         ; error for zero length filenames
f363 a6 d3              LDX SA              ; 1: use load address from file
f365 20 d0 f3           JSR Open_Load_File  ; open file with SA = $60
f368 e0 00              CPX #0              ; ignore load address ?
f36a f0 04              BEQ LoFi_20
f36c 84 c9              STY EAL
f36e 85 ca              STA EAL+1
f370 a5 96    LoFi_20   LDA STATUS          ; check time out bit
f372 f0 03              BEQ LoFi_25         ; no time out -> continue
f374 4c ad f5           JMP Display_File_Not_Found
f377 20 51 f3 LoFi_25   JSR In_Direct_Mode
f37a d0 12              BNE LoFi_30
f37c 20 6d f4           JSR Display_Load_Or_Verify
f37f a5 ca              LDA EAL+1
f381 20 54 d7           JSR Print_Hex_Byte
f384 a5 c9              LDA EAL
f386 20 54 d7           JSR Print_Hex_Byte
f389 a9 2d              LDA #'-'
f38b 20 02 e2           JSR EDIT_CHROUT
f38e a0 00    LoFi_30   LDY #0              ; remains zero for loop
f390 84 96    LoFi_35   STY STATUS          ; clear status bits
f392 20 43 f3 LoFi_40   JSR Kernal_STOP     ; STOP key pressed?
f395 20 c0 f1           JSR ACPTR           ; read next byte
f398 24 9d              BIT VERCK           ; load (0) or verify ($80)
f39a 10 0b              BPL LoFi_45         ; branch if loading
f39c d1 c9              CMP (EAL),Y         ; verify
f39e f0 0f              BEQ LoFi_55         ; branch if OK
f3a0 a9 10              LDA #%00010000      ; flag verify error $10
f3a2 20 c4 fb           JSR Set_STATUS      ; and stop verifying
f3a5 d0 1a              BNE LoFi_70         ; branch always
f3a7 91 c9    LoFi_45   STA (EAL),Y         ; store byte
f3a9 b1 c9    LoFi_50   LDA (EAL),Y         ; this comparison is false for an
f3ab d1 c9              CMP (EAL),Y         ; unfinished write cycle to EEPROM
f3ad d0 fa              BNE LoFi_50         ; repeat until EEPROM bit toggle ceased
f3af e6 c9    LoFi_55   INC EAL             ; increment write address
f3b1 d0 0a              BNE LoFi_60
f3b3 e6 ca              INC EAL+1
f3b5 20 51 f3           JSR In_Direct_Mode
f3b8 d0 03              BNE LoFi_60
f3ba 20 40 f4           JSR Print_EAL
f3bd 24 96    LoFi_60   BIT STATUS          ; Get EOF marker in bit 6
f3bf 50 d1              BVC LoFi_40         ; repeat until EOF
f3c1 20 ae f1 LoFi_70   JSR UNTLK
f3c4 20 2a f7           JSR Close_Disk_File
f3c7 20 51 f3           JSR In_Direct_Mode
f3ca f0 01              BEQ LoFi_80
f3cc 60                 RTS ;Size  119 [Load_File]
f3cd 4c 40 f4 LoFi_80   JMP Print_EAL

              ; **************
f3d0            Open_Load_File
              ; **************

f3d0 a9 60              LDA #$60            ; secondary address for loading
f3d2 85 d3              STA SA
f3d4 20 af f4           JSR Send_Filename
f3d7 20 d2 f0           JSR TALK            ; send primary address
f3da a5 d3              LDA SA
f3dc 20 93 f1           JSR TKSA            ; send secondary address
f3df 20 c0 f1           JSR ACPTR           ; load address low
f3e2 a8                 TAY                 ; Y = load address low
f3e3 4c c0 f1           JMP ACPTR           ; A = load address high

              ; *****
f3e6            Merge
              ; *****

f3e6 a9 40              LDA #$40            ; load and merge file
f3e8 d0 19              BNE KeLO_10         ; always

f3ea 00 00 00           .FILL $f401 - * (0) ; 23 bytes

              ; ***********
f401            Kernal_LOAD
              ; ***********

f401 a9 00              LDA #0
f403 85 9d    KeLO_10   STA VERCK

              ; ***********
f405            Load_Verify
              ; ***********

f405 20 7d f4           JSR Get_File_Parameter
f408 24 9d              BIT VERCK
f40a 50 11              BVC Load_Verify_Params_Set
f40c 38                 SEC
f40d a5 2a              LDA VARTAB          ; set merge address
f40f e9 02              SBC #2
f411 85 c9              STA EAL
f413 a5 2b              LDA VARTAB+1
f415 e9 00              SBC #0
f417 85 ca              STA EAL+1
f419 a9 00              LDA #0
f41b 85 d3              STA SA

              ; **********************
f41d            Load_Verify_Params_Set
              ; **********************

f41d 20 56 f3           JSR Load_File       ; load file into RAM
f420 24 9d              BIT VERCK           ; (0) LOAD, ($80) VERIFY
f422 30 1b              BMI LVPS_Ret        ; done for verify
f424 a0 ae              LDY #<MSG_READY     ; $ae
f426 20 49 f3           JSR Kernal_Message_If_Direct
f429 20 51 f3           JSR In_Direct_Mode
f42c d0 0b              BNE LVPS_20
f42e a5 ca              LDA EAL+1
f430 85 2b              STA VARTAB+1        ; update VARPTR
f432 a5 c9              LDA EAL
f434 85 2a              STA VARTAB
f436 4c ad b4           JMP Reset_And_Rechain
f439 20 22 b6 LVPS_20   JSR Reset_BASIC_Exec_Pointer
f43c 4c 0b b6           JMP RVP_10
f43f 60       LVPS_Ret  RTS ;Size   35 [Load_Verify_Params_Set]

              ; *********
f440            Print_EAL
              ; *********

f440 a5 ca              LDA EAL+1
f442 20 54 d7           JSR Print_Hex_Byte
f445 a5 c9              LDA EAL
f447 20 54 d7           JSR Print_Hex_Byte
f44a a2 04              LDX #4
f44c a9 9d              LDA #$9d            ; cursor left
f44e 20 02 e2 PrEA_10   JSR EDIT_CHROUT
f451 ca                 DEX
f452 d0 fa              BNE PrEA_10
f454 60       PrEA_Ret  RTS ;Size   21 [Print_EAL]

f455 00 00 00           .FILL $f46d - * (0) ; 24 bytes

              ; **********************
f46d            Display_Load_Or_Verify
              ; **********************

f46d a0 5f              LDY #<MSG_LOAD      ; $5f
f46f 24 9d              BIT VERCK
f471 10 02              BPL DLOV_10
f473 a0 6d              LDY #<MSG_VERIFY    ; $6d
f475 20 49 f3 DLOV_10   JSR Kernal_Message_If_Direct
f478 a0 39              LDY #<[MSG_SEARCHING + 7];$39 add "ING"
f47a 4c 49 f3           JMP Kernal_Message_If_Direct

              ; ******************
f47d            Get_File_Parameter
              ; ******************

f47d a2 00              LDX #0
f47f 86 96              STX STATUS
f481 86 d1              STX FNLEN
f483 e8                 INX
f484 86 d3              STX SA              ; SA = 1
f486 a2 08              LDX #8
f488 86 d4              STX FA              ; FA = 8
f48a 20 4d f5           JSR ChrGot_Or_RTS
f48d 20 3c f5           JSR Set_Filename_From_String
f490 20 4d f5           JSR ChrGot_Or_RTS
f493 20 a9 f4           JSR Get_Comma_And_Byte
f496 86 d4              STX FA
f498 20 4d f5           JSR ChrGot_Or_RTS
f49b 20 a9 f4           JSR Get_Comma_And_Byte
f49e 86 d3              STX SA
f4a0 a6 28              LDX TXTTAB          ; default: start of BASIC
f4a2 a5 29              LDA TXTTAB+1
f4a4 86 c9              STX EAL
f4a6 85 ca              STA EAL+1
f4a8 60       GFP_Ret   RTS ;Size   44 [Get_File_Parameter]

              ; ******************
f4a9            Get_Comma_And_Byte
              ; ******************

f4a9 20 55 f5           JSR Get_Comma_And_Chr
f4ac 4c d4 c8           JMP Get_Byte_Value

              ; *************
f4af            Send_Filename
              ; *************

f4af a4 d1              LDY FNLEN
f4b1 f0 f5              BEQ GFP_Ret
f4b3 20 d5 f0           JSR LISTEN
f4b6 a5 d3              LDA SA
f4b8 09 f0              ORA #$f0

              ; ****************
f4ba            Send_DOS_Command
              ; ****************

f4ba 20 43 f1           JSR SECOND
f4bd a5 96              LDA STATUS
f4bf 10 05              BPL SeDC_10
f4c1 a0 74              LDY #<MSG_DEVICE_NOT; $74
f4c3 4c af f5           JMP Handle_IO_Error
f4c6 a0 00    SeDC_10   LDY #0
f4c8 b1 da    SeDC_20   LDA (FNADR),Y
f4ca 20 9e f1           JSR CIOUT
f4cd c8                 INY
f4ce c4 d1              CPY FNLEN
f4d0 d0 f6              BNE SeDC_20
f4d2 4c b9 f1           JMP UNLSN

f4d5 00 00 00           .FILL $f4f6 - * (0) ; 33 bytes

              ; *************
f4f6            Kernal_VERIFY
              ; *************

f4f6 a9 80              LDA #$80
f4f8 85 9d              STA VERCK
f4fa 20 05 f4           JSR Load_Verify
f4fd a5 96              LDA STATUS
f4ff 29 10              AND #16
f501 f0 05              BEQ VERI_OK
f503 a0 6e              LDY #<[MSG_VERIFY+1]; $6e
f505 4c af f5           JMP Handle_IO_Error
f508 a0 aa    VERI_OK   LDY #<MSG_OK        ; $aa
f50a 4c 85 f1           JMP Display_Kernal_Message

              ; ************************
f50d            Get_Open_Close_Parameter
              ; ************************

f50d a2 00              LDX #0              ; clear
f50f 86 d3              STX SA              ; secondary address
f511 86 96              STX STATUS          ; status
f513 86 d1              STX FNLEN           ; length of filename
f515 20 4c fd           JSR Set_FA_to_8     ; default device 8
f518 20 58 f5           JSR Assert_Not_At_End
f51b 20 d4 c8           JSR Get_Byte_Value
f51e 86 d2              STX LA              ; store logical address
f520 20 4d f5           JSR ChrGot_Or_RTS
f523 20 a9 f4           JSR Get_Comma_And_Byte
f526 86 d4              STX FA              ; store primary address
f528 20 4d f5           JSR ChrGot_Or_RTS
f52b 20 a9 f4           JSR Get_Comma_And_Byte
f52e 86 d3              STX SA              ; store secondary address
f530 20 4d f5           JSR ChrGot_Or_RTS
f533 20 55 f5           JSR Get_Comma_And_Chr
f536 4c 3c f5           JMP Set_Filename_From_String

f539 00 00 00           .FILL $f53c - * (0) ; 3 bytes

              ; ************************
f53c            Set_Filename_From_String
              ; ************************

f53c 20 98 bd           JSR Eval_Expression
f53f 20 b5 c7           JSR Eval_And_Free_String
f542 85 d1              STA FNLEN
f544 a5 1f              LDA INDEXA
f546 85 da              STA FNADR
f548 a5 20              LDA INDEXA+1
f54a 85 db              STA FNADR+1
f54c 60                 RTS ;Size   17 [Set_Filename_From_String]

              ; *************
f54d            ChrGot_Or_RTS
              ; *************

f54d 20 76 00           JSR CHRGOT
f550 d0 02              BNE Get_Ret
f552 68                 PLA
f553 68                 PLA
f554 60       Get_Ret   RTS ;Size    8 [ChrGot_Or_RTS]

              ; *****************
f555            Get_Comma_And_Chr
              ; *****************

f555 20 f5 be           JSR Need_Comma

              ; *****************
f558            Assert_Not_At_End
              ; *****************

f558 20 76 00           JSR CHRGOT
f55b d0 f7              BNE Get_Ret
f55d 4c 00 bf Err_f55d  JMP Syntax_Error

              ; ***********
f560            Kernal_OPEN
              ; ***********

f560 20 0d f5           JSR Get_Open_Close_Parameter
f563 a5 d2    Mf563     LDA LA

              ; *********
f565            Open_File
              ; *********

f565 f0 f6              BEQ Err_f55d
f567 a0 0e              LDY #<MSG_FILE_OPEN
f569 20 c1 f2           JSR LOOKUP_LA
f56c f0 41              BEQ Handle_IO_Error
f56e a6 ae              LDX LDTND
f570 a0 00              LDY #0              ; also MSG # for TOO MANY FILES
f572 84 96              STY STATUS
f574 e0 0a              CPX #10
f576 f0 37              BEQ Handle_IO_Error
f578 e6 ae              INC LDTND
f57a a5 d2              LDA LA
f57c 9d 51 02           STA LAT,X
f57f a5 d3              LDA SA
f581 09 60              ORA #$60
f583 85 d3              STA SA
f585 9d 65 02           STA SAT,X
f588 a5 d4              LDA FA
f58a 9d 5b 02           STA FAT,X
f58d f0 c5              BEQ Get_Ret         ; open keyboard
f58f c9 03              CMP #3
f591 f0 c1              BEQ Get_Ret         ; open screen
f593 90 c8              BCC Err_f55d        ; no tape support
f595 4c af f4           JMP Send_Filename

f598 00 00 00           .FILL $f5ad - * (0) ; 21 bytes


              ; **********************
f5ad            Display_File_Not_Found
              ; **********************

f5ad a0 24              LDY #<MSG_FILE_NOT_F; $24

              ; ***************
f5af            Handle_IO_Error
              ; ***************

f5af 20 a2 f2           JSR Kernal_CLALL
f5b2 a9 0d              LDA #CR
f5b4 20 66 f2           JSR Kernal_CHROUT
f5b7 a9 3f              LDA #$3f            ; '?'
f5b9 20 66 f2           JSR Kernal_CHROUT
f5bc 20 85 f1           JSR Display_Kernal_Message
f5bf 4c ed b3           JMP Berr_30

              ; ***********
f5c2            Disassemble
              ; ***********

f5c2 20 18 d6           JSR Mon_Get_Addr
f5c5 20 35 f3 Disa_10   JSR Check_STOP_Key  ; STOP key pressed?
f5c8 f0 19              BEQ Disa_Main
f5ca 20 e0 d5           JSR Mon_Cmp_Addr
f5cd 90 14              BCC Disa_Main       ; STAL > MEMUSS ?
f5cf a9 2e    Disa_15   LDA #'.'
f5d1 20 74 d5           JSR Mon_Prompt
f5d4 20 1b d5           JSR Mon_Print_Blank
f5d7 20 14 f6           JSR Dis_Inst        ; Disassemble
f5da 20 e6 f5           JSR Print_Dis_Line
f5dd a5 b3              LDA PC_Adjust
f5df d0 e4              BNE Disa_10
f5e1 e6 b3              INC PC_Adjust
f5e3 4c ae d4 Disa_Main JMP Mon_Main

              ; **************
f5e6            Print_Dis_Line
              ; **************

f5e6 48                 PHA                 ; save mne index
f5e7 a0 00              LDY #0
f5e9 b9 c1 00 Disa_20   LDA Mon_Op,Y        ; next byte
f5ec 20 54 d7           JSR Print_Hex_Byte
f5ef 4c f8 f5           JMP Disa_50
f5f2 20 1b d5 Disa_40   JSR Mon_Print_Blank
f5f5 20 1b d5           JSR Mon_Print_Blank
f5f8 20 1b d5 Disa_50   JSR Mon_Print_Blank
f5fb c4 be              CPY Dis_Length
f5fd c8                 INY
f5fe 90 e9              BCC Disa_20         ; next byte
f600 c0 03              CPY #3
f602 90 ee              BCC Disa_40         ; blanks
f604 68                 PLA                 ; restore mne index
f605 20 39 f7           JSR Store_Mnemonic
f608 20 8d f9           JSR Store_Address
f60b 20 f9 f9           JSR Print_Dis_Buf
f60e 38                 SEC
f60f a5 be              LDA Dis_Length      ; carry is set
f611 4c 1c fb           JMP AdST_00



              ; ********
f614            Dis_Inst
              ; ********

f614 20 4d d7           JSR Mon_Print_STAL
f617 20 1b d5           JSR Mon_Print_Blank
f61a a0 02              LDY #2              ; fetch 3 bytes
f61c 20 7a 02 DiIn_10   JSR Bank_Fetch
f61f 99 c1 00           STA Mon_Op,Y
f622 88                 DEY
f623 10 f7              BPL DiIn_10         ; opcode in A

              ; **************
f625            Analyze_Opcode
              ; **************

              ; instruction pattern: aaa bbb cc
              ; aaa = instruction
              ; bbb = addressing mode
              ; cc  = group

              ; 1. analyze group cc
              ; ------------------------------------------
              ; cc = 00  one byte instructions, branches
              ; cc = 01  ORA,AND,EOR,ADC,STA,LDA,CMP,SBC
              ; cc = 10  ASL,ROL,LSR,ROR,STX,LDX,DEC,INC
              ; cc = 11  illegal opcodes

f625 a8                 TAY                 ; save opcode
f626 4a                 LSR A               ; bit 0 -> carry
f627 90 0b              BCC AnOp_10
f629 4a                 LSR A               ; bit 1 -> carry
f62a b0 17              BCS AnOp_30         ; 11 -> no valid opcode
f62c c9 22              CMP #$22            ; invalid opcode $89 ?
f62e f0 13              BEQ AnOp_30
f630 29 07              AND #7              ; mask addressing mode bbb
f632 09 80              ORA #$80            ; set bit 7
f634 4a       AnOp_10   LSR A               ; A,X = aaa bbb (cc = x0)
f635 aa                 TAX                 ; A,X = aaa bb  (cc = 10)
f636 bd 6b f6           LDA admode_index,X  ; get addressing mode index
f639 b0 04              BCS AnOp_20         ; branch on cc = 10
f63b 4a                 LSR A               ; move nibble for cc = 00
f63c 4a                 LSR A
f63d 4a                 LSR A
f63e 4a                 LSR A
f63f 29 0f    AnOp_20   AND #15             ; mask addressing mode index
f641 d0 04              BNE AnOp_40         ; branch for valid mode
f643 a0 80    AnOp_30   LDY #$80            ; set invalid opcode
f645 a9 00              LDA #0
f647 aa       AnOp_40   TAX                 ; X = addressing mode index
f648 bd 73 f9           LDA admode_format,X ; A = addressing mode format
f64b 85 bd              STA Mon_Format      ; format
f64d 29 03              AND #3
f64f 85 be              STA Dis_Length      ; length
f651 98                 TYA                 ; restore opcode
f652 29 8f              AND #$8f            ; mask
f654 aa                 TAX                 ; X =
f655 98                 TYA                 ; restore opcode
f656 a0 03              LDY #3              ; Y = 3
f658 e0 8a              CPX #$8a            ; TXS,TAX,TSX,DEX,NOP
f65a f0 0b              BEQ AnOp_70
f65c 4a       AnOp_50   LSR A
f65d 90 08              BCC AnOp_70
f65f 4a                 LSR A
f660 4a       AnOp_60   LSR A
f661 09 20              ORA #$20
f663 88                 DEY
f664 d0 fa              BNE AnOp_60
f666 c8                 INY
f667 88       AnOp_70   DEY
f668 d0 f2              BNE AnOp_50
f66a 60                 RTS ;Size   70 [Analyze_Opcode]

              ; ************
f66b            admode_index
              ; ************

f66b 40                 .BYTE $40           ; $4 BRK        $0 ---
f66c 02                 .BYTE $02           ; $0 ---        $2 ASL zz
f66d 45                 .BYTE $45           ; $4 PHP        $5 ASL A
f66e 03                 .BYTE $03           ; $0 ---        $3 ASL nnnn

f66f d0                 .BYTE $d0           ; $d BPL oo     $0 ---
f670 08                 .BYTE $08           ; $0 ---        $8 ASL zz,X
f671 40                 .BYTE $40           ; $4 CLC        $0 ---
f672 09                 .BYTE $09           ; $0 ---        $9 ASL nnnn,X

f673 30                 .BYTE $30           ; $3 JSR nnnn   $0 --
f674 22                 .BYTE $22           ; $2 BIT zz     $2 ROL zz
f675 45                 .BYTE $45           ; $4 PLP        $5 ROL A
f676 33                 .BYTE $33           ; $3 BIT nnnn   $3 ROL nnnn

f677 d0                 .BYTE $d0           ; $d BMI oo     $0 ---
f678 08                 .BYTE $08           ; $0 ---        $8 ROL zz,X
f679 40                 .BYTE $40           ; $4 SEC        $0 ---
f67a 09                 .BYTE $09           ; $0 ---        $9 ROL nnnn,X

f67b 40                 .BYTE $40           ; $4 RTI        $0 ---
f67c 02                 .BYTE $02           ; $0 ---        $2 LSR zz
f67d 45                 .BYTE $45           ; $4 PHA        $5 LSR A
f67e 33                 .BYTE $33           ; $3 JMP nnnn   $3 LSR nnnn

f67f d0                 .BYTE $d0           ; $d BVC oo     $0 ---
f680 08                 .BYTE $08           ; $0 ---        $8 LSR zz,X
f681 40                 .BYTE $40           ; $4 CLI        $0 ---
f682 09                 .BYTE $09           ; $0 ---        $9 LSR nnnn,X

f683 40                 .BYTE $40           ; $4 RTS        $0 ---
f684 02                 .BYTE $02           ; $0 ---        $2 ROR zz
f685 45                 .BYTE $45           ; $4 PLA        $5 ROR A
f686 b3                 .BYTE $b3           ; $b JMP (nnnn) $3 ROR nnnn

f687 d0                 .BYTE $d0           ; $d BVS oo     $0 ---
f688 08                 .BYTE $08           ; $0 ---        $8 ROR zz,X
f689 40                 .BYTE $40           ; $4 SEI        $0 ---
f68a 09                 .BYTE $09           ; $0 ---        $9 ROR nnnn,X

f68b 00                 .BYTE $00           ; $0 ---        $0 ---
f68c 22                 .BYTE $22           ; $2 STY zz     $2 STX zz
f68d 44                 .BYTE $44           ; $4 DEY        $4 TXA
f68e 33                 .BYTE $33           ; $3 STY nnnn   $3 STX nnnn

f68f d0                 .BYTE $d0           ; $d BCC oo     $0 ---
f690 8c                 .BYTE $8c           ; $8 STY zz,X   $c STX zz,Y
f691 44                 .BYTE $44           ; $4 TYA        $4 TXS
f692 00                 .BYTE $00           ; $0 ---        $0 ---

f693 11                 .BYTE $11           ; $1 LDY #      $1 LDX #
f694 22                 .BYTE $22           ; $2 LDY zz     $2 LDX zz
f695 44                 .BYTE $44           ; $4 TAY        $4 TAX
f696 33                 .BYTE $33           ; $3 LDY nnnn   $3 LDX nnnn

f697 d0                 .BYTE $d0           ; $d BCS oo     $0 ---
f698 8c                 .BYTE $8c           ; $8 LDY zz,X   $c LDX zz,Y
f699 44                 .BYTE $44           ; $4 CLV        $4 TSX
f69a 9a                 .BYTE $9a           ; $9 LDY nnnn,X $a LDX nnnn,Y

f69b 10                 .BYTE $10           ; $1 CPY #      $0 ---
f69c 22                 .BYTE $22           ; $2 CPY zz     $2 DEC zz
f69d 44                 .BYTE $44           ; $4 INY        $4 DEX
f69e 33                 .BYTE $33           ; $3 CPY nnnn   $3 DEC nnnn

f69f d0                 .BYTE $d0           ; $d BNE oo     $0 ---
f6a0 08                 .BYTE $08           ; $0 ---        $8 DEC zz,X
f6a1 40                 .BYTE $40           ; $4 CLD        $0 ---
f6a2 09                 .BYTE $09           ; $0 ---        $9 DEC nnnn,X

f6a3 10                 .BYTE $10           ; $1 CPX #      $0 ---
f6a4 22                 .BYTE $22           ; $2 CPX zz     $2 INC zz
f6a5 44                 .BYTE $44           ; $4 INX        $4 NOP
f6a6 33                 .BYTE $33           ; $3 CPX nnnn   $3 INC nnnn

f6a7 d0                 .BYTE $d0           ; $d BEQ oo     $0 ---
f6a8 08                 .BYTE $08           ; $0 ---        $8 INC zz,X
f6a9 40                 .BYTE $40           ; $4 SED        $0 ---
f6aa 09                 .BYTE $09           ; $0 ---        $9 INC nnnn,X

f6ab 62                 .BYTE $62           ; $6 (zz,X)     $2 zz
f6ac 13                 .BYTE $13           ; $1 #          $3 nnnn
f6ad 78                 .BYTE $78           ; $7 (zz),Y     $8 zz,X
f6ae a9                 .BYTE $a9           ; $a nnnn,Y     $9 nnnn,X

f6af 00 00 00            .FILL $f6c3 - * (0) ; 20 bytes


              ; **********
f6c3            Kernal_SYS
              ; **********

f6c3 20 84 bd           JSR Eval_Numeric
f6c6 20 2d c9           JSR FAC1_To_LINNUM
f6c9 6c 11 00           JMP (LINNUM)

              ; **************
f6cc            Set_Save_Range
              ; **************

f6cc a5 2a              LDA VARTAB
f6ce 85 c9              STA EAL
f6d0 a5 2b              LDA VARTAB+1
f6d2 85 ca              STA EAL+1
f6d4 a5 29              LDA TXTTAB+1
f6d6 85 fc              STA STAL+1
f6d8 a5 28              LDA TXTTAB
f6da 85 fb              STA STAL
f6dc 60                 RTS ;Size   17 [Set_Save_Range]

              ; ***********
f6dd            Kernal_SAVE
              ; ***********

f6dd 20 7d f4           JSR Get_File_Parameter
f6e0 20 cc f6 Mf6e0     JSR Set_Save_Range

              ; *********
f6e3            Save_File
              ; *********

f6e3 a5 d4              LDA FA              ; primary address
f6e5 c9 04              CMP #4              ; unit number >= 4
f6e7 b0 03              BCS SaFi_20         ; branch if OK
f6e9 4c 00 bf SaFi_10   JMP Syntax_Error    ; wrong unit or no filename
f6ec a9 61    SaFi_20   LDA #$61            ; secondary address for saving
f6ee 85 d3              STA SA
f6f0 a4 d1              LDY FNLEN           ; length of filename
f6f2 f0 f5              BEQ SaFi_10         ; error if zero
f6f4 20 af f4           JSR Send_Filename
f6f7 20 d5 f0           JSR LISTEN          ; Send Listen
f6fa a5 d3              LDA SA
f6fc 20 43 f1           JSR SECOND          ; Send Listen Secondary
f6ff a4 fb              LDY STAL            ; save start low
f701 a6 fc              LDX STAL+1          ; save start high
f703 98                 TYA
f704 20 9e f1           JSR CIOUT           ; send start low
f707 8a                 TXA
f708 20 9e f1           JSR CIOUT           ; send start high
f70b a9 00              LDA #0
f70d 85 fb              STA STAL            ; clear pointer low
f70f c4 c9    SaFi_30   CPY EAL             ; compare to end address low
f711 d0 04              BNE SaFi_40         ; not yet
f713 e4 ca              CPX EAL+1           ; compare to end address high
f715 f0 10              BEQ SaFi_50         ; branch if at end
f717 b1 fb    SaFi_40   LDA (STAL),Y        ; load next byte
f719 20 9e f1           JSR CIOUT           ; send it
f71c 20 43 f3           JSR Kernal_STOP     ; check STOP key
f71f c8                 INY                 ; increment Y (low address)
f720 d0 ed              BNE SaFi_30         ; continue loop if not zero
f722 e8                 INX                 ; increment X (high address)
f723 86 fc              STX STAL+1          ; update piointer
f725 d0 e8              BNE SaFi_30         ; branch always
f727 20 b9 f1 SaFi_50   JSR UNLSN           ; Unlisten and fall through

              ; ***************
f72a            Close_Disk_File
              ; ***************

f72a 20 d5 f0           JSR LISTEN          ; send listen
f72d a5 d3              LDA SA
f72f 29 ef              AND #%11101111      ; $ef
f731 09 e0              ORA #%11100000      ; $e0 + unit
f733 20 43 f1           JSR SECOND          ; send secondary listen
f736 4c b9 f1           JMP UNLSN           ; send unlisten

              ; **************
f739            Store_Mnemonic
              ; **************

f739 a2 00              LDX #0
f73b a8                 TAY
f73c b9 f3 f8           LDA Mnemonic_Left,Y
f73f 85 bf              STA Mon_A
f741 b9 33 f9           LDA Mnemonic_Right,Y
f744 85 c0              STA Mon_B
f746 a9 00    PrMn_10   LDA #0
f748 a0 05              LDY #5
f74a 06 c0    PrMn_20   ASL Mon_B
f74c 26 bf              ROL Mon_A
f74e 2a                 ROL A
f74f 88                 DEY
f750 d0 f8              BNE PrMn_20
f752 69 3f              ADC #$3f
f754 9d b1 02           STA Dis_Buf,X
f757 e8                 INX
f758 e0 03              CPX #3
f75a 90 ea              BCC PrMn_10
f75c 60                 RTS ;Size   36 [Store_Mnemonic]


f75d 00 00 00           .FILL $f768 - * (0) ; 11 bytes

              ; ************
f768            Kernal_UDTIM
              ; ************

f768 e6 8f              INC JIFFY_CLOCK+2   ; 1 jiffy = 1/60 sec
f76a d0 18              BNE ud_20
f76c e6 8e              INC JIFFY_CLOCK+1
f76e d0 02              BNE ud_10
f770 e6 8d              INC JIFFY_CLOCK
f772 a5 8d    ud_10     LDA JIFFY_CLOCK
f774 c9 4f              CMP #$4f            ; MSB of $4f1a00 = 24 * 60 * 60 * 60
f776 90 0c              BCC ud_20
f778 a5 8e              LDA JIFFY_CLOCK+1
f77a c9 1a              CMP #$1a
f77c 90 06              BCC ud_20
f77e a9 00              LDA #0
f780 85 8d              STA JIFFY_CLOCK
f782 85 8e              STA JIFFY_CLOCK+1
f784 c6 f8    ud_20     DEC JIFFY6          ; insert additional jiffy count every 5th. call
f786 d0 06              BNE ud_30           ; to generate 60Hz jiffy clock from 50Hz signal
f788 a9 06              LDA #6
f78a 85 f8              STA JIFFY6
f78c d0 da              BNE Kernal_UDTIM    ; branch always
f78e 60       ud_30     RTS ;Size   39 [Kernal_UDTIM]

f78f 00 00 00           .FILL $f7af - * (0) ; 32 bytes

              ; ************
f7af            Kernal_CHKIN
              ; ************

              ; Input:  X = local address
              ; Output: DFLTN (Default Input) set to device FA
              ;         IEEE-488 device will be talker

f7af 48                 PHA                 ; save A
f7b0 a9 00              LDA #0
f7b2 85 96              STA STATUS          ; clear status
f7b4 8a                 TXA
f7b5 48                 PHA                 ; save X
f7b6 20 c1 f2           JSR LOOKUP_LA
f7b9 d0 1b              BNE CHERR_17
f7bb 20 cd f2           JSR Set_LFS_From_X
f7be c9 04              CMP #4              ; A = FA
f7c0 90 0e              BCC CHKIN_10        ; keyboard or screen
f7c2 20 d2 f0           JSR TALK
f7c5 a5 d3              LDA SA
f7c7 20 93 f1           JSR TKSA
f7ca a5 96              LDA STATUS
f7cc 30 0b              BMI CHERR_74
f7ce a5 d4              LDA FA
f7d0 85 af    CHKIN_10  STA DFLTN
f7d2 68                 PLA
f7d3 aa                 TAX
f7d4 68                 PLA
f7d5 60                 RTS ;Size   39 [Kernal_CHKIN]

f7d6 a0 17    CHERR_17  LDY #<MSG_FILE_NOT_O
f7d8 2c                 .BYTE $2c
f7d9 a0 74    CHERR_74  LDY #<MSG_DEVICE_NOT
f7db 2c                 .BYTE $2c
f7dc a0 94    CHERR_94  LDY #<MSG_NOT_OUTPUT
f7de 4c af f5 CHERR_IO  JMP Handle_IO_Error

f7e1 00 00 00           .FILL $f7fe - * (0) ; 29 bytes

              ; *************
f7fe            Kernal_CHKOUT
              ; *************

              ; Input:  X = local address
              ; Output: DFLTO (Default Output) set to device FA
              ;         IEEE-488 device will be listener

f7fe 48                 PHA                 ; save A
f7ff a9 00              LDA #0
f801 85 96              STA STATUS          ; clear status
f803 8a                 TXA
f804 48                 PHA                 ; save X
f805 20 c1 f2           JSR LOOKUP_LA
f808 d0 cc              BNE CHERR_17        ; file not open
f80a 20 cd f2           JSR Set_LFS_From_X
f80d f0 cd              BEQ CHERR_94        ; cannot write to keyboard
f80f c9 04              CMP #4
f811 90 0e              BCC KeCo_10         ; -> screen
f813 20 d5 f0           JSR LISTEN
f816 a5 d3              LDA SA
f818 20 43 f1           JSR SECOND
f81b a5 96              LDA STATUS
f81d 30 ba              BMI CHERR_74
f81f a5 d4              LDA FA
f821 85 b0    KeCo_10   STA DFLTO
f823 68                 PLA
f824 aa                 TAX
f825 68                 PLA
f826 60                 RTS ;Size   41 [Kernal_CHKOUT]

              ; **************
f827            Set_Wedge_Unit
              ; **************

f827 20 70 00           JSR CHRGET
f82a 90 0c              BCC SWUN_10
f82c a6 ab              LDX Wedge_Unit      ; X = Unit
f82e 98                 TYA                 ; A = 0
f82f 20 83 cf           JSR Print_Integer_XA
f832 20 df ba           JSR Print_CR
f835 4c ff b3           JMP Basic_Ready
f838 20 f6 b8 SWUN_10   JSR Scan_Linenumber
f83b a5 11              LDA LINNUM
f83d 85 ab              STA Wedge_Unit
f83f 4c ff b3           JMP Basic_Ready

              ; ************
f842            Wedge_Parser
              ; ************

f842 a0 00              LDY #0
f844 84 9d              STY VERCK           ; no verify
f846 b1 77              LDA (TXTPTR),Y
f848 c9 40              CMP #'@'            ; wedge control
f84a f0 1d              BEQ Command_Or_Status
f84c c9 3e              CMP #'>'            ; wedge control
f84e f0 19              BEQ Command_Or_Status
f850 c9 24              CMP #'$'            ; directory
f852 f0 38              BEQ Wedge_Directory
f854 c9 23              CMP #'#'
f856 f0 cf              BEQ Set_Wedge_Unit
f858 c9 2f              CMP #'/'
f85a f0 57              BEQ Wedge_Load
f85c c9 5e              CMP #'^'
f85e f0 46              BEQ Wedge_Run
f860 20 40 ed           JSR Extended_Command
f863 20 fb b4           JSR Tokenize_Line
f866 4c 7c b7           JMP Start_Program

              ; *****************
f869            Command_Or_Status
              ; *****************

f869 e6 77              INC TXTPTR
f86b b1 77              LDA (TXTPTR),Y
f86d f0 14              BEQ Get_Status
f86f c9 24              CMP #'$'            ; dir command
f871 f0 19              BEQ Wedge_Directory

              ; ************
f873            Send_Command
              ; ************

f873 20 31 fb           JSR DOS_Open_Comm_Write
f876 b1 77    SeCo_10   LDA (TXTPTR),Y
f878 f0 06              BEQ SeCo_20
f87a 20 9e f1           JSR CIOUT
f87d c8                 INY
f87e 10 f6              BPL SeCo_10
f880 20 b9 f1 SeCo_20   JSR UNLSN

              ; **********
f883            Get_Status
              ; **********

f883 20 c7 f8           JSR Wedge_Prepare
f886 20 98 f8           JSR Print_Status
f889 4c ff b3           JMP Basic_Ready

              ; ***************
f88c            Wedge_Directory
              ; ***************

f88c 20 d0 f8           JSR Wedge_Filename
f88f 20 c7 f8           JSR Wedge_Prepare
f892 20 89 d8           JSR Wedge_Call_Dir
f895 4c ff b3           JMP Basic_Ready

              ; ************
f898            Print_Status
              ; ************

f898 20 e1 db           JSR Clear_Status
f89b 20 91 d9           JSR Kernal_Read_DS
f89e 4c 85 db           JMP Display_Status

f8a1 52 55 4e RUN_Now   .BYTE "RUN:\r"

              ; *********
f8a6            Wedge_Run
              ; *********

f8a6 a2 05              LDX #5              ; put "RUN" into keyboard buffer
f8a8 86 9e              STX CharsInBuffer
f8aa bd a0 f8 WeRu_10   LDA RUN_Now-1,X
f8ad 9d 6e 02           STA KEYD-1,X
f8b0 ca                 DEX
f8b1 d0 f7              BNE WeRu_10

              ; **********
f8b3            Wedge_Load
              ; **********

f8b3 20 70 00           JSR CHRGET
f8b6 c9 30              CMP #'0'            ; Skip size info in dir listings
f8b8 90 04              BCC WeLo_10
f8ba c9 3a              CMP #'9'+1
f8bc 90 f5              BCC Wedge_Load
f8be 20 d0 f8 WeLo_10   JSR Wedge_Filename
f8c1 20 c7 f8           JSR Wedge_Prepare
f8c4 4c 1d f4           JMP Load_Verify_Params_Set

              ; *************
f8c7            Wedge_Prepare
              ; *************

f8c7 a5 ab              LDA Wedge_Unit
f8c9 85 d4              STA FA
f8cb a9 00              LDA #0
f8cd 85 96              STA STATUS
f8cf 60                 RTS ;Size    9 [Wedge_Prepare]

              ; **************
f8d0            Wedge_Filename
              ; **************

f8d0 a0 ff              LDY #-1
f8d2 20 76 00           JSR CHRGOT
f8d5 c9 22              CMP #$22            ; quote
f8d7 d0 02              BNE WeFi_10
f8d9 e6 77              INC TXTPTR          ; skip quote
f8db c8       WeFi_10   INY
f8dc b1 77              LDA (TXTPTR),y
f8de f0 04              BEQ WeFi_20
f8e0 c9 22              CMP #$22            ; quote
f8e2 d0 f7              BNE WeFi_10
f8e4 84 d1    WeFi_20   STY FNLEN           ; store length
f8e6 a5 77              LDA TXTPTR
f8e8 85 da              STA FNADR
f8ea a5 78              LDA TXTPTR + 1
f8ec 85 db              STA FNADR + 1
f8ee a5 ab              LDA Wedge_Unit
f8f0 85 d4              STA FA
f8f2 60                 RTS ;Size   35 [Wedge_Filename]

              ; *************
f8f3            Mnemonic_Left
              ; *************

f8f3 1c                 .BYTE >"BRK"
f8f4 8a                 .BYTE >"PHP"
f8f5 1c                 .BYTE >"BPL"
f8f6 23                 .BYTE >"CLC"
f8f7 5d                 .BYTE >"JSR"
f8f8 8b                 .BYTE >"PLP"
f8f9 1b                 .BYTE >"BMI"
f8fa a1                 .BYTE >"SEC"
f8fb 9d                 .BYTE >"RTI"
f8fc 8a                 .BYTE >"PHA"
f8fd 1d                 .BYTE >"BVC"
f8fe 23                 .BYTE >"CLI"
f8ff 9d                 .BYTE >"RTS"
f900 8b                 .BYTE >"PLA"
f901 1d                 .BYTE >"BVS"
f902 a1                 .BYTE >"SEI"
f903 00                 .BYTE >"???"
f904 29                 .BYTE >"DEY"
f905 19                 .BYTE >"BCC"
f906 ae                 .BYTE >"TYA"
f907 69                 .BYTE >"LDY"
f908 a8                 .BYTE >"TAY"
f909 19                 .BYTE >"BCS"
f90a 23                 .BYTE >"CLV"
f90b 24                 .BYTE >"CPY"
f90c 53                 .BYTE >"INY"
f90d 1b                 .BYTE >"BNE"
f90e 23                 .BYTE >"CLD"
f90f 24                 .BYTE >"CPX"
f910 53                 .BYTE >"INX"
f911 19                 .BYTE >"BEQ"
f912 a1                 .BYTE >"SED"
f913 00                 .BYTE >"???"
f914 1a                 .BYTE >"BIT"
f915 5b                 .BYTE >"JMP"
f916 5b                 .BYTE >"JMP"
f917 a5                 .BYTE >"STY"
f918 69                 .BYTE >"LDY"
f919 24                 .BYTE >"CPY"
f91a 24                 .BYTE >"CPX"
f91b ae                 .BYTE >"TXA"
f91c ae                 .BYTE >"TXS"
f91d a8                 .BYTE >"TAX"
f91e ad                 .BYTE >"TSX"
f91f 29                 .BYTE >"DEX"
f920 00                 .BYTE >"???"
f921 7c                 .BYTE >"NOP"
f922 00                 .BYTE >"???"
f923 15                 .BYTE >"ASL"
f924 9c                 .BYTE >"ROL"
f925 6d                 .BYTE >"LSR"
f926 9c                 .BYTE >"ROR"
f927 a5                 .BYTE >"STX"
f928 69                 .BYTE >"LDX"
f929 29                 .BYTE >"DEC"
f92a 53                 .BYTE >"INC"
f92b 84                 .BYTE >"ORA"
f92c 13                 .BYTE >"AND"
f92d 34                 .BYTE >"EOR"
f92e 11                 .BYTE >"ADC"
f92f a5                 .BYTE >"STA"
f930 69                 .BYTE >"LDA"
f931 23                 .BYTE >"CMP"
f932 a0                 .BYTE >"SBC"

              ; **************
f933            Mnemonic_Right
              ; **************

f933 d8                 .BYTE <"BRK"
f934 62                 .BYTE <"PHP"
f935 5a                 .BYTE <"BPL"
f936 48                 .BYTE <"CLC"
f937 26                 .BYTE <"JSR"
f938 62                 .BYTE <"PLP"
f939 94                 .BYTE <"BMI"
f93a 88                 .BYTE <"SEC"
f93b 54                 .BYTE <"RTI"
f93c 44                 .BYTE <"PHA"
f93d c8                 .BYTE <"BVC"
f93e 54                 .BYTE <"CLI"
f93f 68                 .BYTE <"RTS"
f940 44                 .BYTE <"PLA"
f941 e8                 .BYTE <"BVS"
f942 94                 .BYTE <"SEI"
f943 00                 .BYTE <"???"
f944 b4                 .BYTE <"DEY"
f945 08                 .BYTE <"BCC"
f946 84                 .BYTE <"TYA"
f947 74                 .BYTE <"LDY"
f948 b4                 .BYTE <"TAY"
f949 28                 .BYTE <"BCS"
f94a 6e                 .BYTE <"CLV"
f94b 74                 .BYTE <"CPY"
f94c f4                 .BYTE <"INY"
f94d cc                 .BYTE <"BNE"
f94e 4a                 .BYTE <"CLD"
f94f 72                 .BYTE <"CPX"
f950 f2                 .BYTE <"INX"
f951 a4                 .BYTE <"BEQ"
f952 8a                 .BYTE <"SED"
f953 00                 .BYTE <"???"
f954 aa                 .BYTE <"BIT"
f955 a2                 .BYTE <"JMP"
f956 a2                 .BYTE <"JMP"
f957 74                 .BYTE <"STY"
f958 74                 .BYTE <"LDY"
f959 74                 .BYTE <"CPY"
f95a 72                 .BYTE <"CPX"
f95b 44                 .BYTE <"TXA"
f95c 68                 .BYTE <"TXS"
f95d b2                 .BYTE <"TAX"
f95e 32                 .BYTE <"TSX"
f95f b2                 .BYTE <"DEX"
f960 00                 .BYTE <"???"
f961 22                 .BYTE <"NOP"
f962 00                 .BYTE <"???"
f963 1a                 .BYTE <"ASL"
f964 1a                 .BYTE <"ROL"
f965 26                 .BYTE <"LSR"
f966 26                 .BYTE <"ROR"
f967 72                 .BYTE <"STX"
f968 72                 .BYTE <"LDX"
f969 88                 .BYTE <"DEC"
f96a c8                 .BYTE <"INC"
f96b c4                 .BYTE <"ORA"
f96c ca                 .BYTE <"AND"
f96d 26                 .BYTE <"EOR"
f96e 48                 .BYTE <"ADC"
f96f 44                 .BYTE <"STA"
f970 44                 .BYTE <"LDA"
f971 a2                 .BYTE <"CMP"
f972 c8                 .BYTE <"SBC"

              ; *************
f973            admode_format
              ; *************

              ;                 76543210
              ;                 --------
              ;                 x         $
              ;                  x        ($
              ;                   x       #$
              ;                    x      ,X
              ;                     x     )
              ;                      x    ,Y
              ;                       xx  length - 1

f973 00                  .BYTE %00000000  ; 0         implicit
f974 21                  .BYTE %00100001  ; 1  $#     immediate
f975 81                  .BYTE %10000001  ; 2  $zz    zeropage
f976 82                  .BYTE %10000010  ; 3  $nnnn  absolute
f977 00                  .BYTE %00000000  ; 4         implicit
f978 00                  .BYTE %00000000  ; 5         implicit
f979 59                  .BYTE %01011001  ; 6 ($zz,X) indexed indirect
f97a 4d                  .BYTE %01001101  ; 7 ($zz),Y indirect indexed
f97b 91                  .BYTE %10010001  ; 8 $zz,X   zeropage,X
f97c 92                  .BYTE %10010010  ; 9 $nnnn,X absolute,X
f97d 86                  .BYTE %10000110  ; a $nnnn,Y absolute,Y
f97e 4a                  .BYTE %01001010  ; b ($nnnn) indirect
f97f 85                  .BYTE %10000101  ; c $zz,Y   zeropage,Y
f980 9d                  .BYTE %10011101  ; d $nnnn   relative

f981 2c 29 2c adr_char1  .BYTE ",),#($"
f987 59 00 58 adr_char2  .BYTE "Y",0,"X$$",0

              ; *************
f98d            Store_Address
              ; *************

f98d a5 bd              LDA Mon_Format
f98f 85 bf              STA Mon_A
f991 a0 03              LDY #3              ; buffer pointer after mnemonic
f993 a5 be              LDA Dis_Length
f995 f0 41              BEQ StAd_Ret        ; finish for implied address
f997 a9 20              LDA #' '            ; store blank
f999 8d b4 02           STA Dis_Buf+3
f99c c8                 INY                 ; inc buffer pointer
f99d a2 05              LDX #5              ; 6 flags to process
f99f e0 02    StAd_10   CPX #2              ; flag2: address
f9a1 d0 16              BNE StAd_30
f9a3 a5 be              LDA Dis_Length
f9a5 c9 01              CMP #1
f9a7 f0 05              BEQ StAd_20         ; 8 bit operand
f9a9 a5 c3              LDA Mon_Hi
f9ab 20 e2 f9           JSR Store_Hex
f9ae a5 bf    StAd_20   LDA Mon_A
f9b0 c9 e8              CMP #$e8            ; branch ?
f9b2 b0 1e              BCS StAd_50         ; compute target
f9b4 a5 c2              LDA Mon_Lo          ; low  byte of operand
f9b6 20 e2 f9           JSR Store_Hex
f9b9 06 bf    StAd_30   ASL Mon_A
f9bb 90 10              BCC StAd_40
f9bd bd 81 f9           LDA adr_char1,X
f9c0 99 b1 02           STA Dis_Buf,Y
f9c3 c8                 INY
f9c4 bd 87 f9           LDA adr_char2,X
f9c7 f0 04              BEQ StAd_40
f9c9 99 b1 02           STA Dis_Buf,Y
f9cc c8                 INY
f9cd ca       StAd_40   DEX
f9ce 10 cf              BPL StAd_10
f9d0 30 06              BMI StAd_Ret
f9d2 20 46 fe StAd_50   JSR Offset_To_Target
f9d5 20 dc f9           JSR Store_Hex_XA
f9d8 8c b0 02 StAd_Ret  STY Dis_Buf_Length
f9db 60                 RTS ;Size   79 [Store_Address]


              ; ************
f9dc            Store_Hex_XA
              ; ************
f9dc 48                 PHA
f9dd 8a                 TXA
f9de 20 e2 f9           JSR Store_Hex
f9e1 68                 PLA

              ; *********
f9e2            Store_Hex
              ; *********

f9e2 48                 PHA
f9e3 4a                 LSR A
f9e4 4a                 LSR A
f9e5 4a                 LSR A
f9e6 4a                 LSR A
f9e7 20 60 d7           JSR Nibble_To_Hex
f9ea 99 b1 02           STA Dis_Buf,Y
f9ed c8                 INY
f9ee 68                 PLA
f9ef 29 0f              AND #15
f9f1 20 60 d7           JSR Nibble_To_Hex
f9f4 99 b1 02           STA Dis_Buf,Y
f9f7 c8                 INY
f9f8 60                 RTS ;Size   23 [Store_Hex]


              ; *************
f9f9            Print_Dis_Buf
              ; *************

f9f9 a0 00              LDY #0
f9fb b9 b1 02 PDB_10    LDA Dis_Buf,Y
f9fe 20 02 e2           JSR EDIT_CHROUT
fa01 c8                 INY
fa02 cc b0 02           CPY Dis_Buf_Length
fa05 90 f4              BCC PDB_10
fa07 60                 RTS ;Size   15 [Print_Dis_Buf]

              ; ***********
fa08            Ass_Operand
              ; ***********

fa08 20 f4 d8           JSR Mon_CHRIN
fa0b f0 11              BEQ AsOp_30         ; finished
fa0d c9 20              CMP #' '
fa0f f0 f7              BEQ Ass_Operand     ; ignore blanks
fa11 20 99 fd           JSR Get_Constant
fa14 f0 08              BEQ AsOp_30         ; no chars left
fa16 99 c1 02           STA Ass_Buf,Y
fa19 c8                 INY
fa1a c0 10              CPY #16
fa1c 90 ea              BCC Ass_Operand
fa1e ad c1 02 AsOp_30   LDA Ass_Buf         ; 1.st char of mnemonic
fa21 c9 42              CMP #'B'
fa23 d0 19              BNE AsOp_Ret        ; no branch
fa25 ad c2 02           LDA Ass_Buf+1       ; 2nd. char of mnemonic
fa28 c9 49              CMP #'I'
fa2a f0 12              BEQ AsOp_Ret        ; BIT
fa2c c9 52              CMP #'R'
fa2e f0 0e              BEQ AsOp_Ret        ; BRK
fa30 a5 c3              LDA Mon_Hi
fa32 f0 0b              BEQ AsOp_40
fa34 38                 SEC                 ; convert target to offset
fa35 a5 c2              LDA Mon_Lo
fa37 e5 fb              SBC STAL
fa39 38                 SEC
fa3a e9 02              SBC #2
fa3c 85 c2              STA Mon_Lo
fa3e 60       AsOp_Ret  RTS ;Size   55 [Ass_Operand]
fa3f 4c 36 fe AsOp_40   JMP Expand_Target


              ; ********
fa42            Assemble
              ; ********

              ; Strategy: convert operand to disassembler format
              ; Loop opcode from 0 to 255 and call disassembler
              ; until mnemonic and operand match.

fa42 20 6a d7           JSR Hex_To_STAL      ; target address
fa45 90 63              BCC Ass_Err
fa47 a0 00    Ass_010   LDY #0               ; reset buffer pointer
fa49 84 c1              STY Mon_Op
fa4b 84 c2              STY Mon_Lo
fa4d 84 c3              STY Mon_Hi
fa4f 8c d1 02           STY Ass_Dollar
fa52 8c d2 02           STY Ass_Length
fa55 20 f4 d8 Ass_020   JSR Mon_CHRIN        ; get next char
fa58 f0 50              BEQ Ass_Err
fa5a c9 20              CMP #' '
fa5c f0 e9              BEQ Ass_010          ; restart on blank
fa5e 99 c1 02           STA Ass_Buf,Y        ; save char
fa61 c8                 INY
fa62 c0 03              CPY #3
fa64 d0 ef              BNE Ass_020          ; look for more
fa66 20 f4 d8           JSR Mon_CHRIN
fa69 f0 0b              BEQ Ass_040          ; Mnemonic only
fa6b c9 20              CMP #' '
fa6d d0 3b              BNE Ass_Err          ; blank after mnemonic is mandatory
fa6f 8d c4 02           STA Ass_Buf+3
fa72 c8                 INY
fa73 20 08 fa           JSR Ass_Operand
fa76 8c c0 02 Ass_040   STY Ass_Buf_Length
fa79 a5 c1    Ass_050   LDA Mon_Op
fa7b 20 25 f6           JSR Analyze_Opcode
fa7e 8d d0 02           STA Ass_Index
fa81 20 39 f7           JSR Store_Mnemonic
fa84 20 8d f9           JSR Store_Address
fa87 ae c0 02           LDX Ass_Buf_Length
fa8a ec b0 02           CPX Dis_Buf_Length
fa8d d0 0b              BNE Ass_070
fa8f ca       Ass_060   DEX
fa90 30 1b              BMI Ass_080         ; match
fa92 bd c1 02           LDA Ass_Buf,X
fa95 dd b1 02           CMP Dis_Buf,X
fa98 f0 f5              BEQ Ass_060
fa9a e6 c1    Ass_070   INC Mon_Op          ; try next op code
fa9c d0 db              BNE Ass_050
fa9e a5 cc              LDA Mon_ZP          ; was a zP mode ?
faa0 d0 08              BNE Ass_Err
faa2 c6 cc              DEC Mon_ZP          ; invalidate
faa4 20 17 fe           JSR Expand_Address
faa7 4c 79 fa           JMP Ass_050         ; now try two byte operands
faaa 4c a9 d4 Ass_Err   JMP Mon_Error
faad 86 ba    Ass_080   STX Dis_Line        ; disable disassembler line count
faaf a5 fb              LDA STAL
fab1 85 f9              STA BPTR
fab3 a5 fc              LDA STAL+1
fab5 85 fa              STA BPTR+1
fab7 a4 be              LDY Dis_Length
fab9 b9 c1 00 Ass_090   LDA Mon_Op,Y        ; store instruction
fabc 20 8b 02           JSR Bank_Store
fabf 20 7a 02           JSR Bank_Fetch
fac2 d9 c1 00           CMP Mon_Op,Y        ; successfull ?
fac5 d0 e3              BNE Ass_Err
fac7 88                 DEY
fac8 10 ef              BPL Ass_090
faca 20 b4 e1           JSR Edit_To_Left_Margin
facd a9 9d              LDA #$9d            ; Cursor UP
facf 20 02 e2           JSR EDIT_CHROUT
fad2 a9 41              LDA #'A'
fad4 20 74 d5           JSR Mon_Prompt
fad7 20 1b d5           JSR Mon_Print_Blank
fada 20 4d d7           JSR Mon_Print_STAL
fadd 20 1b d5           JSR Mon_Print_Blank
fae0 ad d0 02           LDA Ass_Index
fae3 20 e6 f5           JSR Print_Dis_Line
fae6 a9 0d              LDA #CR
fae8 20 02 e2           JSR EDIT_CHROUT
faeb 78                 SEI                 ; prompt to keyboard buffer
faec a9 41              LDA #'A'
faee 8d 6f 02           STA KEYD
faf1 a9 20              LDA #' '
faf3 8d 70 02           STA KEYD+1
faf6 a5 fc              LDA STAL+1
faf8 20 3e d7           JSR Make_Hex_Byte
fafb 8e 71 02           STX KEYD+2
fafe 8d 72 02           STA KEYD+3
fb01 a5 fb              LDA STAL
fb03 20 3e d7           JSR Make_Hex_Byte
fb06 8e 73 02           STX KEYD+4
fb09 8d 74 02           STA KEYD+5
fb0c a9 20              LDA #' '
fb0e 8d 75 02           STA KEYD+6
fb11 a2 07              LDX #7
fb13 86 9e              STX CharsInBuffer
fb15 58                 CLI
fb16 4c b1 d4           JMP Mon_10

              ; ********
fb19            Inc_STAL
              ; ********

fb19 a9 01              LDA #1

              ; ********
fb1b            Add_STAL
              ; ********

fb1b 18                 CLC
fb1c 65 fb    AdST_00   ADC STAL
fb1e 85 fb              STA STAL
fb20 90 02              BCC AdST_Ret
fb22 e6 fc    AdST_10   INC STAL+1
fb24 60       AdST_Ret  RTS ;Size   10 [Add_STAL]


              ; ********
fb25            Inc_BPTR
              ; ********

fb25 a9 01              LDA #1

              ; ********
fb27            Add_BPTR
              ; ********

fb27 18                 CLC
fb28 65 f9    AdBP_00   ADC BPTR
fb2a 85 f9              STA BPTR
fb2c 90 02              BCC AdBP_Ret
fb2e e6 fa    AdBP_10   INC BPTR+1
fb30 60       AdBP_Ret  RTS ;Size   10 [Add_BPTR]


              ; *******************
fb31            DOS_Open_Comm_Write
              ; *******************

fb31 20 c7 f8           JSR Wedge_Prepare   ; set FA and STATUS
fb34 20 d5 f0           JSR LISTEN
fb37 a9 6f              LDA #$6f
fb39 85 d3              STA SA
fb3b 4c 43 f1           JMP SECOND

              ; *********
fb3e            Mon_Wedge
              ; *********

fb3e 20 f4 d8           JSR Mon_CHRIN
fb41 f0 10              BEQ Mon_Wedge_Status
fb43 48                 PHA
fb44 20 31 fb           JSR DOS_Open_Comm_Write
fb47 68                 PLA
fb48 20 9e f1 MoWe_10   JSR CIOUT
fb4b 20 f4 d8           JSR Mon_CHRIN
fb4e d0 f8              BNE MoWe_10
fb50 20 b9 f1           JSR UNLSN

              ; ****************
fb53            Mon_Wedge_Status
              ; ****************

fb53 20 1e d5           JSR Mon_Print_CR
fb56 20 c7 f8           JSR Wedge_Prepare
fb59 20 98 f8           JSR Print_Status
fb5c 4c ae d4           JMP Mon_Main

              ; *******
fb5f            Mon_Dir
              ; *******

fb5f a0 00              LDY #0
fb61 a9 24              LDA #'$'
fb63 99 42 03 MoDi_10   STA DOS_Filename,Y
fb66 c8                 INY
fb67 20 f4 d8           JSR Mon_CHRIN
fb6a d0 f7              BNE MoDi_10
fb6c 84 d1              STY FNLEN
fb6e 20 c5 d6           JSR Set_DOS_FNADR
fb71 20 1e d5           JSR Mon_Print_CR
fb74 20 c7 f8           JSR Wedge_Prepare
fb77 20 89 d8           JSR Wedge_Call_Dir
fb7a 4c ae d4           JMP Mon_Main

fb7d 00 00 00           .FILL $fbc4 - * (0) ; 71 bytes

              ; **********
fbc4            Set_STATUS
              ; **********

fbc4 05 96              ORA STATUS
fbc6 85 96              STA STATUS
fbc8 60                 RTS ;Size    5 [Set_STATUS]


              ; *********
fbc9            Mon_Get_3
              ; *********

fbc9 20 6a d7           JSR Hex_To_STAL
fbcc 90 11              BCC MG3_Err
fbce a2 fd              LDX #MEMUSS
fbd0 20 6c d7           JSR Read_Hex_Word
fbd3 90 0a              BCC MG3_Err
fbd5 a2 f9              LDX #BPTR
fbd7 20 6c d7           JSR Read_Hex_Word
fbda 90 03              BCC MG3_Err
fbdc a0 00              LDY #0
fbde 60                 RTS ;Size   22 [Mon_Get_3]
fbdf 68       MG3_Err   PLA
fbe0 68                 PLA
fbe1 4c a9 d4           JMP Mon_Error

              ; ***********
fbe4            Mon_Compare
              ; ***********

fbe4 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fbe7 20 1e d5           JSR Mon_Print_CR
fbea a9 f9    MoCo_10   LDA #BPTR
fbec 8d 81 02           STA Bank_Fetch+7
fbef a5 b7              LDA W_Bank
fbf1 20 7c 02           JSR Bank_Fetch+2    ; LDA (BPTR),Y
fbf4 85 bf              STA Mon_A
fbf6 a9 fb              LDA #STAL
fbf8 8d 81 02           STA Bank_Fetch+7
fbfb 20 7a 02           JSR Bank_Fetch      ; LDA (STAL),Y
fbfe c5 bf              CMP Mon_A
fc00 f0 06              BEQ MoCo_20
fc02 20 4d d7           JSR Mon_Print_STAL
fc05 20 1b d5           JSR Mon_Print_Blank
fc08 20 19 fb MoCo_20   JSR Inc_STAL
fc0b 20 25 fb           JSR Inc_BPTR
fc0e 20 eb d5           JSR Cmp_STAL_MEMUSS
fc11 b0 d7              BCS MoCo_10
fc13 4c ae d4           JMP Mon_Main

              ; ************
fc16            Mon_Transfer
              ; ************

fc16 20 c9 fb           JSR Mon_Get_3       ; STAL MEMUSS BPTR
fc19 a5 f9              LDA BPTR            ; BPTR > STAL ?
fc1b c5 fb              CMP STAL
fc1d a5 fa              LDA BPTR+1
fc1f e5 fc              SBC STAL+1
fc21 b0 17              BCS MoTr_20         ; BPTR > STAL: copy backward
fc23 20 7a 02 MoTr_10   JSR Bank_Fetch
fc26 20 8b 02           JSR Bank_Store
fc29 20 19 fb           JSR Inc_STAL
fc2c 20 25 fb           JSR Inc_BPTR
fc2f 20 eb d5           JSR Cmp_STAL_MEMUSS
fc32 b0 ef              BCS MoTr_10
fc34 4c ae d4 MoTr_Ret  JMP Mon_Main
fc37 4c a9 d4 MoTr_Err  JMP Mon_Error
fc3a 38       MoTr_20   SEC
fc3b a5 fd              LDA MEMUSS          ; exchange STAL <-> MEMUSS
fc3d a6 fb              LDX STAL
fc3f 86 fd              STX MEMUSS
fc41 85 fb              STA STAL
fc43 e5 fd              SBC MEMUSS
fc45 85 bf              STA Mon_A           ; Mon_A = MEMUSS - STAL
fc47 a5 fe              LDA MEMUSS+1
fc49 a6 fc              LDX STAL+1
fc4b 86 fe              STX MEMUSS+1
fc4d 85 fc              STA STAL+1
fc4f e5 fe              SBC MEMUSS+1
fc51 85 c0              STA Mon_A+1
fc53 90 e2              BCC MoTr_Err        ; Error: MEMUSS < STAL
fc55 18                 CLC
fc56 a5 f9              LDA BPTR            ; BPTR += (MEMUSS - STAL)
fc58 65 bf              ADC Mon_A
fc5a 85 f9              STA BPTR
fc5c a5 fa              LDA BPTR+1
fc5e 65 c0              ADC Mon_A+1
fc60 85 fa              STA BPTR+1
fc62 20 7a 02 MoTr_30   JSR Bank_Fetch
fc65 20 8b 02           JSR Bank_Store
fc68 20 eb d5           JSR Cmp_STAL_MEMUSS ; STAL == MEMUSS -> finished
fc6b b0 c7              BCS MoTr_Ret
fc6d a5 fb              LDA STAL
fc6f d0 02              BNE MoTr_40
fc71 c6 fc              DEC STAL+1
fc73 c6 fb    MoTr_40   DEC STAL
fc75 a5 f9              LDA BPTR
fc77 d0 02              BNE MoTr_50
fc79 c6 fa              DEC BPTR+1
fc7b c6 f9    MoTr_50   DEC BPTR
fc7d 4c 62 fc           JMP MoTr_30

              ; ********
fc80            Mon_Hunt
              ; ********

fc80 20 18 d6           JSR Mon_Get_Addr    ; get range
fc83 a0 00              LDY #0
fc85 20 f4 d8 MoHu_10   JSR Mon_CHRIN       ; skip blanks
fc88 f0 5b              BEQ MoHu_Err
fc8a c9 20              CMP #' '
fc8c f0 f7              BEQ MoHu_10
fc8e c9 22              CMP #$22            ; quote ?
fc90 f0 16              BEQ MoHu_40         ; string
fc92 20 80 d7           JSR Read_Hex_A      ; get first byte
fc95 90 4e              BCC MoHu_Err
fc97 b0 05              BCS MoHu_30         ; continue reading hex
fc99 20 79 d7 MoHu_20   JSR Read_Hex        ; loop for reading hex bytes
fc9c 90 1b              BCC MoHu_50         ; end of line
fc9e 99 42 03 MoHu_30   STA DOS_Filename,Y
fca1 c8                 INY
fca2 c0 10              CPY #16
fca4 90 f3              BCC MoHu_20
fca6 b0 11              BCS MoHu_50
fca8 20 f4 d8 MoHu_40   JSR Mon_CHRIN       ; loop for reading string
fcab f0 0c              BEQ MoHu_50
fcad c9 22              CMP #$22            ; quote
fcaf f0 08              BEQ MoHu_50
fcb1 99 42 03           STA DOS_Filename,Y
fcb4 c8                 INY
fcb5 c0 10              CPY #16
fcb7 90 ef              BCC MoHu_40
fcb9 84 b5    MoHu_50   STY MONCNT
fcbb 20 1e d5           JSR Mon_Print_CR
fcbe 20 35 f3 MoHu_60   JSR Check_STOP_Key  ; STOP key pressed?
fcc1 f0 1f              BEQ MoHu_Ret
fcc3 20 e0 d5           JSR Mon_Cmp_Addr
fcc6 90 1a              BCC MoHu_Ret
fcc8 a0 00              LDY #0
fcca 20 7a 02 MoHu_70   JSR Bank_Fetch
fccd d9 42 03           CMP DOS_Filename,Y
fcd0 d0 0b              BNE MoHu_80         ; no match
fcd2 c8                 INY
fcd3 c4 b5              CPY MONCNT
fcd5 90 f3              BCC MoHu_70
fcd7 20 4d d7           JSR Mon_Print_STAL
fcda 20 1b d5           JSR Mon_Print_Blank
fcdd 20 19 fb MoHu_80   JSR Inc_STAL
fce0 d0 dc              BNE MoHu_60
fce2 4c ae d4 MoHu_Ret  JMP Mon_Main
fce5 4c a9 d4 MoHu_Err  JMP Mon_Error


fce8 00 00 00           .FILL $fd16 - * (0) ; 46 bytes

              ; ***********
fd16            Entry_RESET
              ; ***********

fd16 a2 ff              LDX #$ff
fd18 78                 SEI
fd19 9a                 TXS
fd1a d8                 CLD
fd1b 20 37 e0           JSR EDIT_RESET
fd1e a9 ff              LDA #<Basic_Ready
fd20 85 94              STA NMINV
fd22 a9 b3              LDA #>Basic_Ready
fd24 85 95              STA NMINV+1
fd26 a9 4e              LDA #<MONITOR_BREAK
fd28 85 92              STA CBINV
fd2a a9 d4              LDA #>MONITOR_BREAK
fd2c 85 93              STA CBINV+1
fd2e a9 a9              LDA #<Mon_Error
fd30 8d fa 03           STA Reset_Vector
fd33 a9 d4              LDA #>Mon_Error
fd35 8d fb 03           STA Reset_Vector+1
fd38 a9 00              LDA #0
fd3a 8d fc 03           STA Ignore_Timeout
fd3d 58                 CLI
fd3e 4c b6 d3           JMP Init_BASIC_RAM_Vectors

fd41 00 00 00           .FILL $fd49 - * (0) ; 8 bytes

              ; *********
fd49            Entry_NMI
              ; *********

fd49 6c 94 00           JMP (NMINV)

              ; ***********
fd4c            Set_FA_to_8
              ; ***********

fd4c a2 08              LDX #8
fd4e 86 d4              STX FA
fd50 60                 RTS ;Size    5 [Set_FA_to_8]

              ; ********
fd51            Mon_Unit
              ; ********

fd51 20 79 d7           JSR Read_Hex
fd54 90 0a              BCC MoUn_10
fd56 c9 10              CMP #16
fd58 b0 06              BCS MoUn_10
fd5a c9 04              CMP #4
fd5c 90 02              BCC MoUn_10
fd5e 85 ab              STA Wedge_Unit
fd60 20 1b d5 MoUn_10   JSR Mon_Print_Blank
fd63 a5 ab              LDA Wedge_Unit
fd65 20 54 d7           JSR Print_Hex_Byte
fd68 20 1e d5           JSR Mon_Print_CR
fd6b 4c ae d4           JMP Mon_Main

              ; ********
fd6e            Mon_Next
              ; ********

fd6e 78                 SEI
fd6f a9 89              LDA #<Mon_Step_IRQ
fd71 85 90              STA CINV
fd73 a9 fd              LDA #>Mon_Step_IRQ
fd75 85 91              STA CINV+1
fd77 a9 a0              LDA #$a0            ; enable T2 time out interrupt
fd79 8d 4e e8           STA VIA_IER         ; interrupt enable register
fd7c a9 2f              LDA #47             ; overhead + 1 cycle
fd7e 8d 48 e8           STA VIA_Timer_2_Lo
fd81 a9 00              LDA #0
fd83 8d 49 e8           STA VIA_Timer_2_Hi  ; trigger start of timer T2
fd86 4c a4 d6           JMP Mon_Step

              ; ************
fd89            Mon_Step_IRQ
              ; ************

fd89 ad 4d e8           LDA VIA_IFR
fd8c 29 20              AND #$20            ; T2 timeout interrupt ?
fd8e f0 06              BEQ MSI_10
fd90 2c 48 e8           BIT VIA_Timer_2_Lo  ; clear interrupt
fd93 6c 92 00           JMP (CBINV)
fd96 4c 55 e4 MSI_10    JMP IRQ_NORMAL


              ; ************
fd99            Get_Constant
              ; ************

fd99 20 05 d9           JSR Is_Int
fd9c 90 51              BCC GeCo_Ret
fd9e c9 24              CMP #'$'
fda0 d0 50              BNE GeCo_45
fda2 20 f4 d8 GeCo_10   JSR Mon_CHRIN       ; parse hex constant
fda5 20 11 d9           JSR Is_Hex
fda8 90 25              BCC GeCo_30
fdaa 20 fa d8           JSR Hex_To_Bin
fdad a2 04              LDX #4
fdaf 06 c2    GeCo_20   ASL Mon_Lo
fdb1 26 c3              ROL Mon_Hi
fdb3 ca                 DEX
fdb4 d0 f9              BNE GeCo_20
fdb6 05 c2              ORA Mon_Lo
fdb8 85 c2              STA Mon_Lo
fdba 4c a2 fd           JMP GeCo_10
fdbd a6 cb    GeCo_25   LDX Mon_Tmp
fdbf e0 2d              CPX #'-'
fdc1 d0 0c              BNE GeCo_30
fdc3 a6 c3              LDX Mon_Hi
fdc5 d0 28              BNE GeCo_Ret        ; no negative 16 bit values
fdc7 48                 PHA
fdc8 a9 00              LDA #0
fdca e5 c2              SBC Mon_Lo          ; carry was set from CPX
fdcc 85 c2              STA Mon_Lo
fdce 68                 PLA
fdcf 48       GeCo_30   PHA                 ; push char after constant
fdd0 a9 24              LDA #'$'
fdd2 99 c1 02           STA Ass_Buf,Y
fdd5 c8                 INY
fdd6 98                 TYA
fdd7 18                 CLC
fdd8 69 10              ADC #16
fdda a8                 TAY
fddb a5 c3              LDA Mon_Hi
fddd 85 cc              STA Mon_ZP
fddf f0 03              BEQ GeCo_40
fde1 20 e2 f9           JSR Store_Hex
fde4 a5 c2    GeCo_40   LDA Mon_Lo
fde6 20 e2 f9           JSR Store_Hex
fde9 98                 TYA
fdea 38                 SEC
fdeb e9 10              SBC #16
fded a8                 TAY
fdee 68                 PLA                 ; pop char after constant
fdef c9 0d    GeCo_Ret  CMP #CR             ; EOI
fdf1 60                 RTS ;Size   89 [Get_Constant]
fdf2 85 cb    GeCo_45   STA Mon_Tmp         ; save sign
fdf4 c9 2b              CMP #'+'
fdf6 f0 15              BEQ GeCo_70
fdf8 c9 2d              CMP #'-'
fdfa f0 11              BEQ GeCo_70
fdfc a6 c2    GeCo_50   LDX Mon_Lo
fdfe 86 11              STX LINNUM
fe00 a6 c3              LDX Mon_Hi
fe02 86 12              STX LINNUM+1
fe04 20 0d b9           JSR Dec_Char
fe07 85 c2              STA Mon_Lo
fe09 a5 12              LDA LINNUM+1
fe0b 85 c3              STA Mon_Hi
fe0d 20 f4 d8 GeCo_70   JSR Mon_CHRIN
fe10 20 19 d9           JSR Is_Dec
fe13 b0 e7              BCS GeCo_50
fe15 90 a6              BCC GeCo_25         ; finished


              ; **************
fe17            Expand_Address
              ; **************

fe17 ac c0 02           LDY Ass_Buf_Length
fe1a b9 c0 02 ExAd_10   LDA Ass_Buf-1,Y
fe1d c9 24              CMP #'$'
fe1f f0 06              BEQ ExAd_20
fe21 99 c2 02           STA Ass_Buf+1,Y
fe24 88                 DEY
fe25 d0 f3              BNE ExAd_10
fe27 a9 30    ExAd_20   LDA #'0'
fe29 99 c1 02           STA Ass_Buf,Y
fe2c 99 c2 02           STA Ass_Buf+1,Y
fe2f ee c0 02           INC Ass_Buf_Length
fe32 ee c0 02           INC Ass_Buf_Length
fe35 60                 RTS ;Size   31 [Expand_Address]

              ; *************
fe36            Expand_Target
              ; *************

              ; Take branch offset, stored in Mon_Lo
              ; Convert it it to ASCII target of format $xxxx
              ; Store it in Ass_Buf after the branch mnemonic
              ; E.g.: BEQ $1234
              ;       ^   ^    ^
              ;       0   4    9

fe36 a9 24              LDA #'$'
fe38 8d c5 02           STA Ass_Buf+4
fe3b a0 15              LDY #21             ; 5 + 16
fe3d 20 46 fe           JSR Offset_To_Target
fe40 20 dc f9           JSR Store_Hex_XA
fe43 a0 09              LDY #9              ; length of branch instruction
fe45 60                 RTS ;Size   16 [Expand_Target]


              ; ****************
fe46            Offset_To_Target
              ; ****************

              ; Input:  Mon_Lo  = Offset
              ;         STAL    = PC
              ; Output: X       = Target Hi
              ;         A       = Target Lo

fe46 a6 fc              LDX STAL+1
fe48 a5 c2              LDA Mon_Lo
fe4a 10 01              BPL OTT_10
fe4c ca                 DEX
fe4d 18       OTT_10    CLC
fe4e 65 fb              ADC STAL
fe50 90 01              BCC OTT_20
fe52 e8                 INX
fe53 18       OTT_20    CLC
fe54 69 02              ADC #2
fe56 90 01              BCC OTT_30
fe58 e8                 INX
fe59 60       OTT_30    RTS ;Size   20 [Offset_To_Target]

fe5a                    .SIZE ;   20 [Offset_To_Target]

              ; *******
fe5a            Replace
              ; *******

fe5a 20 76 00           JSR CHRGOT
fe5d c9 22              CMP #QUOTE
fe5f f0 06              BEQ Repl_00
fe61 20 fb b4           JSR Tokenize_Line
fe64 20 70 00           JSR CHRGET
fe67 85 23    Repl_00   STA RENNEW          ; 1st. delimiter
fe69 a6 77              LDX TXTPTR
fe6b e8       Repl_01   INX
fe6c bd 00 02           LDA BUF,X
fe6f f0 4a              BEQ Repl_Err
fe71 c5 23              CMP RENNEW          ; 2nd. delimiter ?
fe73 d0 f6              BNE Repl_01
fe75 86 25              STX RENNEW+2        ; remember position
fe77 a9 00              LDA #0
fe79 9d 00 02           STA BUF,X
fe7c 8a                 TXA
fe7d 18                 CLC                 ; subtract one more
fe7e e5 77              SBC TXTPTR
fe80 85 26              STA RENNEW+3        ; length of search string
fe82 e8       Repl_02   INX
fe83 bd 00 02           LDA BUF,X
fe86 f0 33              BEQ Repl_Err
fe88 c5 23              CMP RENNEW          ; 3rd. delimiter ?
fe8a d0 f6              BNE Repl_02
fe8c a9 00              LDA #0
fe8e 9d 00 02           STA BUF,X
fe91 8a                 TXA
fe92 18                 CLC                 ; subtract one more
fe93 e5 25              SBC RENNEW+2
fe95 85 27              STA RENNEW+4        ; length of replace string
fe97 20 22 ed           JSR Reset_Renumber_Pointer
fe9a a0 03    Repl_08   LDY #3
fe9c 84 24              STY RENNEW+1        ; start position for scan
fe9e 20 35 f3 Repl_10   JSR Check_STOP_Key  ; STOP key pressed?
fea1 f0 15              BEQ Repl_Ret
fea3 20 9a ed           JSR Contains_Pattern
fea6 d0 08              BNE Repl_20
fea8 20 be fe           JSR Replace_String
feab e6 24              INC RENNEW+1
fead 4c 9e fe           JMP Repl_10
feb0 20 33 ed Repl_20   JSR Update_Link
feb3 d0 e5              BNE Repl_08
feb5 20 f0 b5           JSR Reset_Variable_Pointer
feb8 4c ff b3 Repl_Ret  JMP Basic_Ready
febb 4c 00 bf Repl_Err  JMP Syntax_Error


              ; **************
febe            Replace_String
              ; **************

febe 38                 SEC
febf a5 27              LDA RENNEW+4        ; length of replacement string
fec1 e5 26              SBC RENNEW+3        ; length of search string
fec3 85 23              STA RENNEW          ; difference
fec5 d0 20              BNE ReSt_30
fec7 98       ReSt_05   TYA
fec8 38                 SEC
fec9 e5 26              SBC RENNEW+3        ; length of search string
fecb a8                 TAY
fecc a6 25              LDX RENNEW+2        ; position of replacement
fece e8       ReSt_10   INX
fecf bd 00 02           LDA BUF,X
fed2 f0 05              BEQ ReSt_20
fed4 91 5c              STA (TMPPTC),Y
fed6 c8                 INY
fed7 d0 f5              BNE ReSt_10         ; always
fed9 a5 23    ReSt_20   LDA RENNEW
fedb f0 03              BEQ ReSt_25
fedd 20 b6 b4           JSR Rechain
fee0 20 ce ea ReSt_25   JSR List_BASIC_Line
fee3 20 1e d5           JSR Mon_Print_CR
fee6 60                 RTS ;Size   41 [Replace_String]
fee7 90 38    ReSt_30   BCC ReSt_50
fee9 98                 TYA
feea 48                 PHA
feeb a5 5c              LDA TMPPTC
feed 48                 PHA
feee a5 5d              LDA TMPPTC+1
fef0 48                 PHA
fef1 18                 CLC
fef2 98                 TYA
fef3 65 5c              ADC TMPPTC
fef5 85 5c              STA TMPPTC
fef7 90 02              BCC ReSt_35
fef9 e6 5d              INC TMPPTC+1
fefb a5 2a    ReSt_35   LDA VARTAB          ; search str < replace str
fefd 85 57              STA TMPPTB
feff 65 23              ADC RENNEW
ff01 85 55              STA TMPPTA
ff03 a4 2b              LDY VARTAB+1
ff05 84 58              STY TMPPTB+1
ff07 90 01              BCC ReSt_40
ff09 c8                 INY
ff0a 84 56    ReSt_40   STY TMPPTA+1
ff0c 20 50 b3           JSR Open_Up_Space
ff0f a5 2e              LDA STREND
ff11 85 2a              STA VARTAB
ff13 a5 2f              LDA STREND+1
ff15 85 2b              STA VARTAB+1
ff17 68                 PLA
ff18 85 5d              STA TMPPTC+1
ff1a 68                 PLA
ff1b 85 5c              STA TMPPTC
ff1d 68       ReSt_45   PLA
ff1e a8                 TAY
ff1f d0 a6              BNE ReSt_05         ; always
ff21 98       ReSt_50   TYA
ff22 48                 PHA
ff23 65 5c              ADC TMPPTC
ff25 85 55              STA TMPPTA
ff27 a5 5d              LDA TMPPTC+1
ff29 69 00              ADC #0
ff2b 85 56              STA TMPPTA+1
ff2d 38                 SEC
ff2e a5 26              LDA RENNEW+3        ; length of search string
ff30 e5 27              SBC RENNEW+4        ; length of replacement string
ff32 85 23              STA RENNEW
ff34 38                 SEC
ff35 a5 55              LDA TMPPTA
ff37 e5 23              SBC RENNEW
ff39 85 57              STA TMPPTB
ff3b a5 56              LDA TMPPTA+1
ff3d e9 00              SBC #0
ff3f 85 58              STA TMPPTB+1
ff41 a0 00              LDY #0
ff43 b1 55    ReSt_60   LDA (TMPPTA),Y
ff45 91 57              STA (TMPPTB),Y
ff47 e6 57              INC TMPPTB
ff49 d0 02              BNE ReSt_62
ff4b e6 58              INC TMPPTB+1
ff4d e6 55    ReSt_62   INC TMPPTA
ff4f d0 02              BNE ReSt_64
ff51 e6 56              INC TMPPTA+1
ff53 a5 2a    ReSt_64   LDA VARTAB
ff55 c5 55              CMP TMPPTA
ff57 d0 ea              BNE ReSt_60
ff59 a6 2b              LDX VARTAB+1
ff5b e4 56              CPX TMPPTA+1
ff5d d0 e4              BNE ReSt_60
ff5f e5 23              SBC RENNEW
ff61 85 2a              STA VARTAB
ff63 85 2e              STA STREND
ff65 8a                 TXA
ff66 e9 00              SBC #0
ff68 85 2b              STA VARTAB+1
ff6a 85 2f              STA STREND+1
ff6c 4c 1d ff           JMP ReSt_45
ff6f 60       ReSt_Ret  RTS ;Size  178 [Replace_String]

ff70 00 00 00           .FILL $ff93-* (0) ; 35 bytes

              ; ************
ff93            Basic_CONCAT
              ; ************

ff93 4c c7 da           JMP Kernal_CONCAT

              ; ***********
ff96            Basic_DOPEN
              ; ***********

ff96 4c 42 d9           JMP Kernal_DOPEN

              ; ************
ff99            Basic_DCLOSE
              ; ************

ff99 4c 07 da           JMP Kernal_DCLOSE

              ; ************
ff9c            Basic_RECORD
              ; ************

ff9c 4c af d7           JMP Kernal_RECORD

              ; ************
ff9f            Basic_HEADER
              ; ************

ff9f 4c d2 d9           JMP Kernal_HEADER

              ; *************
ffa2            Basic_COLLECT
              ; *************

ffa2 4c 65 da           JMP Kernal_COLLECT

              ; ************
ffa5            Basic_BACKUP
              ; ************

ffa5 4c 7e da           JMP Kernal_BACKUP

              ; **********
ffa8            Basic_COPY
              ; **********

ffa8 4c a7 da           JMP Kernal_COPY

              ; ************
ffab            Basic_APPEND
              ; ************

ffab 4c 77 d9           JMP Kernal_APPEND

              ; ***********
ffae            Basic_DSAVE
              ; ***********

ffae 4c 0d db           JMP Kernal_DSAVE

              ; ***********
ffb1            Basic_DLOAD
              ; ***********

ffb1 4c 3a db           JMP Kernal_DLOAD

              ; ***************
ffb4            Basic_DIRECTORY
              ; ***************

ffb4 4c 73 d8           JMP Kernal_DIRECTORY

              ; ************
ffb7            Basic_RENAME
              ; ************

ffb7 4c 55 db           JMP Kernal_RENAME

              ; *************
ffba            Basic_SCRATCH
              ; *************

ffba 4c 66 db           JMP Kernal_SCRATCH

              ; *******
ffbd            Read_DS
              ; *******

ffbd 4c 91 d9           JMP Kernal_Read_DS

              ; ****
ffc0            OPEN
              ; ****

ffc0 4c 60 f5           JMP Kernal_OPEN

              ; *****
ffc3            CLOSE
              ; *****

ffc3 4c dd f2           JMP Kernal_CLOSE

              ; *****
ffc6            CHKIN
              ; *****

ffc6 4c af f7           JMP Kernal_CHKIN

              ; ******
ffc9            CHKOUT
              ; ******

ffc9 4c fe f7           JMP Kernal_CHKOUT

              ; ******
ffcc            CLRCHN
              ; ******

ffcc 4c a6 f2           JMP Kernal_CLRCHN

              ; *****
ffcf            CHRIN
              ; *****

ffcf 4c 15 f2           JMP Kernal_CHRIN

              ; ******
ffd2            CHROUT
              ; ******

ffd2 4c 66 f2           JMP Kernal_CHROUT

              ; **********
ffd5            Basic_LOAD
              ; **********

ffd5 4c 01 f4           JMP Kernal_LOAD

              ; **********
ffd8            Basic_SAVE
              ; **********

ffd8 4c dd f6           JMP Kernal_SAVE

              ; ************
ffdb            Basic_VERIFY
              ; ************

ffdb 4c f6 f4           JMP Kernal_VERIFY

              ; *********
ffde            Basic_SYS
              ; *********

ffde 4c c3 f6           JMP Kernal_SYS

              ; ****
ffe1            STOP
              ; ****

ffe1 4c 43 f3           JMP Kernal_STOP

              ; *****
ffe4            GETIN
              ; *****

ffe4 4c 05 f2           JMP Kernal_GETIN

              ; *****
ffe7            CLALL
              ; *****

ffe7 4c a2 f2           JMP Kernal_CLALL

              ; *****
ffea            UDTIM
              ; *****

ffea 4c 68 f7           JMP Kernal_UDTIM
ffed 8c 8c 8c           .FILL $fffa-* ($8c) ; 13 bytes

              ; ***************
fffa            HardwareVectors
              ; ***************

fffa 49 fd              .WORD Entry_NMI
fffc 16 fd              .WORD Entry_RESET
fffe 42 e4              .WORD IRQ_MAIN


 1854 Symbols
-------------
Basic_USR                      $0000   252D  1120   7028
BSOS_KBD                       $0001    15D 10650  10663  10674  10733
                                     10746  10764  10777  10788  10847
                                     10860
CTRLA                          $0001   228D  9409
USRVEC                         $0001   253D  7031   7032
CTRLB                          $0002   229D  9393   9550
CHARAC                         $0003   255D  2317   2321   2322   3017
                                      3022   3026   3726   3735   4623
                                      4638   6185   6680   6737
CTRLD                          $0004   230D  9405   9560
ENDCHR                         $0004   256D  1668   1716   1719   2319
                                      2320   2323   2326   3029   4624
                                      4640
COUNT                          $0005   257D  1527   1576   1592   1683
                                      1700   1726   4092   4179   4233
                                      4257   4281   4319   4351  11215
                                     11230  11238
DIMFLG                         $0006   264D  3844   4147   4186   4230
                                      4264   4315
VALTYP                         $0007   270D  2443   2730   3010   3200
                                      3248   3270   3371   3557   3777
                                      3861   3875   4150   4182   4422
                                      4438   4683   5136
BELL                           $0007   231D  9389
INTFLG                         $0008   276D  2441   3043   3589   3862
                                      3882   4148   4184
GARBFL                         $0009   291D  1659   1671   1712   3651
                                      3654   3655   3658   4701   4738
                                      4742
TAB                            $0009   232D  9397   9546
SUBFLG                         $000a   297D  1852   2008   3879   3891
                                      3896   4482   4507
INPFLG                         $000b   301D  2845   2972   2991   3012
                                      3094
TANSGN                         $000c   311D  3346   3815   6896   6898
                                      6916   6926
DS_Len                         $000d   315
CR                             $000d   233D  1643   2753   7240   7913
                                      7943   8350   8380   8388   8390
                                      9115   9185   9373   9530  11546
                                     11779  11902  12392  13320  13724
DS_Ptr                         $000e   316
CTRLN                          $000e   234D  9391   9556
CTRLO                          $000f   235D  9395   9554
IOPMPT                         $0010   323D  1468   1472   2706   2746
                                      2820   2855   2879   2886   2899
                                      2906   2909   2933   2952   3000
                                      3100   3505   7038
DOWN                           $0011   236D  9385   9540
LINNUM                         $0011   331D  1584   1585   1762   1767
                                      1887   1888   1890   1913   1915
                                      2240   2387   2388   2390   2411
                                      2413   2415   2416   2417   2419
                                      2420   2421   2422   2424   2425
                                      2427   5246   5247   5254   5256
                                      5260y  5263   5265   5275y  5290y
                                      7043   7044   7049y  7052y  7053y
                                      7056y  7057y  7060y  7063   7065
                                      8160   8162   8801   8803   8806
                                      8813   8815   8817   8919   8922
                                      9785   9786   9788  10517  10519
                                     10615  10618  10972  10973  10990
                                     10994  10998  11001  11151  11153
                                     11423  11424  11559  11561  12616
                                     12824  13732  13734  13737
RVS                            $0012   237D  9387   9542
TEMPPT                         $0013   336D  1841   4667   4688   5010
HOME                           $0013   238D  9407   9544
DEL                            $0014   239D  9379   9534
LASTPT                         $0014   341D  4684   5006   5008   5012
                                      7039
CTRLU                          $0015   240D  9403   9558
CTRLV                          $0016   241D  9401   9548
TEMPST                         $0016   348D  1840   4668
CTRLY                          $0019   242D  9399   9552
ESC                            $001b   243D  9375
RIGHT                          $001d   244D  2824   9383   9538
INDEXA                         $001f   352D  1376   1386   1392   1532
                                      1534   1557   1559   1561y  1565
                                      1617y  1621   1624y  1626   1628y
                                      1629   1630   1631y  1686   1688
                                      1691   1693   1696y  1727y  1729
                                      1731   1734y  1977   1979   1983
                                      1985   1986y  1990y  2514y  2588
                                      2589   2602   2604   2635y  2639y
                                      2642y  2649   2650   2654   2656
                                      2807y  3253   3255   3310   3312
                                      3327   3329   3994   3995   3997y
                                      4000y  4003y  4007y  4015y  4019
                                      4020   4022   4023   4029y  4033y
                                      4037y  4046   4049   4053   4054
                                      4056   4280   4348   4381   4708
                                      4711   4716   4728y  4731y  4783
                                      4785   4788y  4798   4802y  4813y
                                      4823y  4826y  4916   4917   4927y
                                      4960   4961   4971   4972   4987y
                                      4990y  4993y  4995   4996   5054
                                      5055   5057   5147y  5187   5190
                                      5192   5703   5704   5706y  5709y
                                      5712y  5715y  5723y  5903   5904
                                      5906y  5958   5959   5962y  5965y
                                      5968y  5973y  5976y  8622y  8738y
                                      8744   8746   8756   8757  10166
                                     10169  12313  12315
RENINC                         $0021   360D  8793   8796   8814   8818
                                      8868   8871   9777   9779   9795y
                                      9798   9802   9803
INDEXB                         $0021   356D  1536   1543   1555   1562y
                                      1566   3141   5191   5196   5198y
                                      5201y  5206y  6088   6094   6096y
                                      6100y  6105y  6110y  6114y  6120
QUOTE                          $0022   245D  1950   1959   2329   2918
                                      3023   3390   4622   4642   7543
                                      7547   8542   8649   9202   9206
                                     11100  11106  11332  11355  13813
FAC3M1                         $0023   364D  5536   5539   5638   5679
                                      5681   5682   5889
RENNEW                         $0023   373D  8794   8797   8802   8807
                                      8827   8830   8858   8861   8867
                                      8869   8870   8872   8941   8953
                                     11253  11256  11270  11275  11279
                                     13817  13822  13824  13830  13834
                                     13840  13841  13844  13850  13864
                                     13865  13866  13870  13872  13879
                                     13900  13927  13928  13929  13932
                                     13952
FAC3M2                         $0024   365D  5534   5537   5639   5676
                                      5678   5683   5891
FAC3M3                         $0025   366D  4362   4383   4408   5532
                                      5535   5640   5673   5675   5684
                                      5893
FAC3M4                         $0026   367D  4391   4411   5530   5533
                                      5641   5670   5672   5685   5838
                                      5895
FAC3M5                         $0027   369
TXTTAB                         $0028   377D  1611   1612   1748   1749
                                      1791y  1793y  1794   1798   1860
                                      1863   2145   2147   2249   2250
                                      6368   6369   7042   7048   7075
                                      7078  10161y 10163y 10543  10546
                                     10604  10605  11181  11183  12225
                                     12226  12626  12628
VARTAB                         $002a   381D  1533   1541   1542   1544
                                      1546   1551   1574   1578   1590
                                      1591   1797   1800   1828   1829
                                      2560   2564   3897   3898   6379
                                      6381   8963   8964   9792  12148
                                     12151  12169  12171  12622  12624
                                     13898  13902  13909  13911  13946
                                     13949  13953  13957
ARYTAB                         $002c   385D  1830   1831   3901   3903
                                      3962   3963   3980   3981   4187
                                      4188
STREND                         $002e   389D  1371   1372   1588   1589
                                      1832   1833   3966   3967   3990
                                      3992   4191   4193   4293   4294
                                      4307   4311   4428   4431   4719
                                      4722  11290  11412  11491y 11522y
                                     13908  13910  13954  13958
FRETOP                         $0030   393D  1435   1438   1447   1450
                                      1821   1822   2553   2557   2644
                                      2647   4040   4043   4427   4430
                                      4706   4709   4734   4735   4759
                                      4761   4829   4831   4973   4975
                                      4980   4983   7068   7069  11299
FRESPC                         $0032   397D  4724   4725   4732   4733
                                      4753   4756   4793   4795   4796
                                      4799y  4801   4803   4805   4809
                                      4816y  4820y  4822   4825   4828
                                      4830   4928y  4933   4934   4936
MEMSIZ                         $0034   401D  1819   1820   4752   4755
                                      7066   7067   7073   7077
CURLIN                         $0036   407D  1486   1510   2027   2029
                                      2082   2085   2168   2173   2174
                                      2199   2200   2221   2223   2239
                                      2279   2281   2852   2853   3159
                                      3161   4461   6395   6396
OLDLIN                         $0038   412D  2175   2176   2197   2198
OLDTXT                         $003a   419D  1851   2071   2072   2171
                                      2172   2191   2194   2862   2863
DATLIN                         $003c   427D  2850   2851   3079   3083
DATPTR                         $003e   433D  2150   2151   2962   2963
INPPTR                         $0040   439D  2973   2974   2985   2986
                                      3056   3057   3092   3093   3098
VARNAM                         $0042   449D  3555   3556   3850   3883
                                      3884   3889   3905   3908   3943
                                      3944   4060   4063   4155   4157
                                      4161   4163   4198   4200   4246
                                      4251   4355   4358
VARPTR                         $0044   455D  4082   4083   4367   4370
                                      4372   4489   4491   4529   4534
                                      4536y  4540   4551   4553   6554
                                      6566
FORPNT                         $0046   460D  1342   1345   1347   1350
                                      2052   2054   2267   2437   2438
                                      2461y  2464y  2474   2593   2596
                                      2601   2603   2617y  2979   2980
                                      3129   3130   3148   3149   5283
                                      5288   5291   5292   5950   5951
YSAVE                          $0048   466D  2983   2984   3058   3059
                                      3264   3343
ACCSYM                         $004a   470D  3227   3236   3237   3239
                                      3243   3278   3293   3778
FUNCPT                         $004b   476D  4509   4510   4524   4526
                                      4528y  4532y  4546y  4549y  4557
                                      4559   4569y  4572y  4575y  4578y
                                      4581y  4754   4757   4760   4762
                                      4765   4767   4769   4772y  4776
                                      4777y  4778   4780   4784y  4787
                                      4789   4791   4807   4810   4815y
                                      4819y  6669   6670   6675   6676
                                      6685   6686   6918   6919   6928
                                      6929
DESCPT                         $004d   480D  2586   2587   2616y  4605
                                      4606   4887   4888   5037y  5040y
                                      5047   5048   5068y  5090y  5112
                                      5114
INDEXC                         $004f   484D  2594y  2597y  2608y  2611y
                                      2655   2658   4967y  4970y  4978
                                      4981
JUMPER                         $0051   489D  3711   7027
FUNJMP                         $0052   494D  3708   3710   5106   5115
                                      5337   5367   5381   5432   6730
                                      6747
FACTPA                         $0054   499D  5942   5943   6769   6772
                                      6773   6921   6922
TMPPTA                         $0055   500D  1391   1393   1395   1398y
                                      1402y  1404   1577   1582   3974
                                      3975   3977   3978   3982   3983
                                      3988   3989   4004   4005   4008
                                      4009   4024   4026   4099   4100
                                      4283   4285   4288   4300y  4302
                                      4305   4366   4369  13901  13906
                                     13922  13925  13931  13934  13938y
                                     13943  13945  13947  13950
TMPPTB                         $0057   501D  1374   1378   1384   1387
                                      1389   1397y  1401y  1403   1575
                                      1579   3968   3969   4034   4039
                                      4047y  4050y  8826y  8829y 10548
                                     10550  10606  10607  10621  10623
                                     13899  13903  13933  13936  13939y
                                     13940  13942
FACTPB                         $0059   506D  5935   6807   6808
TMPVAR                         $005a   507D  3566   3570   4393   4414
                                      6204   6236   6243   6245   6246
                                      6251   6256   6268   6293   6303
                                      6310   6430   6462   6471   6477
                                      6493   6504   6505   6560   6587
                                      6592
TMPPTC                         $005c   508D  1375   1379   1531y  1535
                                      1537   1539y  1547   1550   1595y
                                      1756   1757   1758y  1763y  1768y
                                      1772y  1898y  1906y  1909y  1927y
                                      1930y  1931   1932   1956y  1965y
                                      2253   2256   3899   3900   3906y
                                      3910y  3915   3964   3965   4061y
                                      4064y  4067y  4069y  4071y  4073y
                                      4075y  4076   4079   4095   4096
                                      4189   4190   4196y  4201y  4204y
                                      4206   4209y  4210   4235y  4247y
                                      4252y  4261y  4273y  4276y  4308
                                      4310y  4313   4314y  4318y  4329y
                                      4334y  4382y  4385y  6229   6232
                                      6239   6240   6266   6297   8846y
                                      8852y  8855y  8903y  8906y  8913y
                                      8916y  8952y  8959   8962   9776
                                      9778   9794y  9799   9800  10542
                                     10545  10549  10551  10571y 10574y
                                     10575  10576  10589y 10592y 10595y
                                     10608  10609  10611y 10614y 10617y
                                     10620  10622  10626y 10629y 11088
                                     11091  11182  11184  11201y 11204y
                                     11205  11206  11277y 11280y 13876y
                                     13888  13890  13894  13895  13897
                                     13913  13915  13921  13923
FAC1EX                         $005e   512D  2343   2481   2581   2582
                                      3325   3361   3780   3790   3794
                                      4130   4615   4645   4672   4838
                                      5240   5319   5358   5361   5368
                                      5375   5428   5456   5460   5467
                                      5600   5604   5725   5735   5742
                                      5775   5816   5817   5819   5907
                                      5916   5975   5993   6010   6021
                                      6038   6072   6103   6136   6173
                                      6178   6288   6447   6697   6732
                                      6742   6743   6856   6859   6962
FAC1M1/FAC1M2                  $005f   513D  2036   2037   3323   3626
                                      3781   3807y  4439   4613   4632
                                      4674   5027y  5394   5408   5411
                                      5443   5445   5453   5469   5488
                                      5490   5516   5650   5824   5862
                                      5890   5912   5915   5923   5972
                                      6057   6061   6107   6146   6402
                                      6536   6538   6829   6847   6849
                                     11154    514D  2503   3321   3782
                                      4440   4614   4633   4676   5391
                                      5410   5413   5440   5442   5452
                                      5470   5491   5493   5514   5648
                                      5827   5859   5892   5924   5967
                                      6059   6111   6147   6403   6533
                                      6535   6831   6850   6852  11152
FAC1M3/FAC1M4                  $0061   515D  2460   2544y  2547y  2563
                                      2566   2573y  2578   2683   2684
                                      3319   3423   3553   3592y  3595y
                                      3667   3694   3728   3740   3745
                                      4171   4326   4345   4603   4679
                                      4870   4881y  4949   5171   5244
                                      5388   5412   5415   5437   5439
                                      5451   5471   5494   5496   5512
                                      5646   5830   5856   5894   5925
                                      5964   6071   6115   6148   6530
                                      6532   6833   6851   6853    516D
                                      2367   2463   2559   2567   2579
                                      2680   2681   3317   3420   3554
                                      3559   3604   3668   3692   3730
                                      3737   3742   4173   4328   4349
                                      4604   4680   4868   4950   5077
                                      5093   5095   5173   5245   5385
                                      5414   5417   5434   5436   5450
                                      5472   5497   5499   5510   5644
                                      5833   5853   5896   5926   5961
                                      6070   6121   6149   6179   6184
                                      6527   6529   6835   6846   6848
FAC1SI                         $0063   517D  2034   2049   2482   2676
                                      3147   3314   3359   3796   3802
                                      4123   5238   5314   5316   5363
                                      5429   5480   5482   5717   5745
                                      5747   5913   5970   5990   6040
                                      6074   6081   6101   6123   6154
                                      6180   6286   6436   6440   6699
                                      6701   6855   6890   6894   6925
                                      6958   6961   6978
SGNFLG                         $0064   518D  6212   6259   6789   6809
BITS                           $0065   520D  4840   4846   4847   6143
FAC2EX                         $0066   524D  3348   3771   3772   5338
                                      5339   5376   5378   5724   5732
                                      5992   6011   6666   6741   6744
FAC2M1                         $0067   525D  3350   3769   3770   5444
                                      5680   5721   5823   5847   5861
                                      5863
FAC2M2                         $0068   526D  3352   5441   5677   5713
                                      5826   5846   5858   5860
FAC2M3/FAC2M4                  $0069   527D  3354   3783   3786   3806y
                                      5438   5674   5710   5829   5845
                                      5855   5857    528D  3356   3784
                                      3787   5435   5671   5707   5832
                                      5844   5852   5854
FAC2SI                         $006b   529D  3358   3767   5317   5362
                                      5716   5719   5984   6285   6672
                                      6880
STRPTR/FROUND                  $006c   533D  2545   2548   2552   2556
                                      2575   2576   3360   4630   4631
                                      4636y  4647   4649   4653   4659
                                      4660   4875   4877   4879y  4891
                                      4892   4902y  4905y  4908y  5318
                                      5373   5718   5744   5773   5798
                                      6287   6755   6885    538D  4681
                                      4845   5336   5371   5382   5416
                                      5418   5433   5449   5473   5500
                                      5502   5503   5531   5552   5642
                                      5686   5874   5911   5977   5996
                                      6014   6023   6073   6119   6150
                                      6151   6159   6726   6748   6857
TMPPTD                         $006e   542D  1681   1701   2483   2486
                                      2487   2495   3568   4244   4256
                                      4278   4279   4296   4297   4303
                                      4321   4322   4339   4340   4350
                                      4353   4403   4404   4648   4652
                                      5185   5186   5212   5213   6441
                                      6509   6518   6555   6565   6578
                                      6766   6767   6780   6781   6788y
                                      6790   6794   6795   6796   6798
                                      6799   6804   6805
CHRGET                         $0070   562D  1506   1882   2046   2125
                                      2371   2394   2790   2875   3009
                                      3174   3240   3372   3382   3468
                                      3496   3683   3863   3868   3888
                                      4115   5158   6213   6219   6230
                                      7035   8563   8613   8634   8642
                                      8709   8766   8811   8822   9783
                                     11145  11237  11252  12816  12915
                                     13816
CHRGOT                         $0076   563D  1878   2043   2135   2227
                                      2338   2352   2712   2989   3048
                                      3062   3171   3228   3499   3829
                                      3838   3851   4176   4560   5078
                                      5174   5202   5285   7687   7704
                                      7714   8522   8629   8676   8798
                                      8808   8819   9773   9780  10463
                                     11169  12323  12339  12939  13812
TXTPTR                         $0077   564D  1504   1505   1657   1684
                                      1725   1739   1741   1862   1865
                                      2022   2024   2067   2070   2074y
                                      2077y  2081y  2084y  2087   2088
                                      2090   2166   2167   2195   2196
                                      2217   2219   2244   2245   2255
                                      2258   2283   2285   2299   2300
                                      2302   2324y  2864   2865   2981
                                      2982   2987   2988   3004   3005
                                      3015   3030   3031   3054   3055
                                      3060   3061   3075y  3078y  3081y
                                      3084y  3163   3165   3215   3217
                                      3218   3273   3275   3276   3397
                                      3398   3466y  4493   4495   4542
                                      4544   4547   4550   4564   4566
                                      5183   5184   5188   5193   5214
                                      5215   6307y  7005   7007   8603
                                      8605   8606y 10457  10462  11067
                                     11069  11070x 11090  11093  11217
                                     11229  11269  12048  12834y 12855
                                     12856y 12866y 12942  12944y 12949
                                     12951  13818  13829
ISNUM                          $007d   565D  2515
RNDX                           $0088   569D  6837   6838   6861   6862
JIFFY_CLOCK                    $008d   578D  2504   3621   3622   9977
                                     12719  12721  12723  12724  12727
                                     12731  12732
CINV                           $0090   586D  7133   7135   7484   7486
                                      9740   9984   9986  13652  13654
CBINV                          $0092   594D  9739  13601  13603  13671
NMINV                          $0094   599D 13597  13599  13619
STATUS                         $0096   610D  2935   3508   3637   6373
                                      7891   7901   8405   9813  11295
                                     11305  11488  11493  11512  11524
                                     11565  11602  11620  11875  11900
                                     12068  12081  12101  12211  12253
                                     12274  12288  12360  12752  12763
                                     12791  12803  12931  13434  13435
Key_Index                      $0097   615D 10270  10303  10329
Key_Flags                      $0098   624D  6357   9980  10266  10268
                                     10308  10309  10383
Power_Flag                     $0099   629D  9666  10440  10442  10499
                                     10533
Default_Bank                   $009a   636D  9982  11031  11052
Stop_Flag                      $009b   641D 10374  12020
Source_Unit                    $009c   646D  8218   8519   8580   8583
                                     11401  11481  11548  11597
VERCK                          $009d   651D  7535   7555   7580   8321
                                     12084  12138  12145  12162  12199
                                     12272  12833
CharsInBuffer                  $009e   655D  9080   9082   9092   9109
                                     10359  10366  11878  12025  12905
                                     13338
ReverseFlag                    $009f   659D  9213   9428   9576   9677
C3PO                           $00a0   663D 11677  11683  11808  11810
LastInputCol                   $00a1   665D  9125   9133   9181  11898
InputRow                       $00a3   666D  9128   9650  11892
InputCol                       $00a4   667D  9131  11890
BSOUR                          $00a5   678D 11688  11704  11728  11799
                                     11815
SFDX                           $00a6   704D 10271  10375
BLNSW                          $00a7   711D  9093   9747  10008
BLNCT                          $00a8   718D  9101   9221   9749   9752
                                     10007
GDBLN                          $00a9   727D  9102   9758
BLNON                          $00aa   734D  9096   9099   9754   9757
Wedge_Unit                     $00ab   739D  7046  12818  12825  12928
                                     12953  13639  13641
CRSW                           $00ac   744D  9118   9155   9184   9367
                                     11896
Target_Unit                    $00ad   746D 11400  11449  11507  11541
                                     11615
LDTND                          $00ae   753D  8000   8129  11927  11956
                                     12002  12003  12005  12358  12363
DFLTN                          $00af   757D 11876  11887  11937  11949
                                     12766
DFLTO                          $00b0   761D  9187   9990  11913  11933
                                     11947  12806
DOS_FC                         $00b1   771D 11368  11429  11499  11527
DOS_EOF                        $00b2   772D 11494  11530
PC_Adjust                      $00b3   773D  7116   7128   7144   7354
                                     12413  12415
SCROLLING                      $00b4   774
MONCNT                         $00b5   775D  7186   7195   7198   7214
                                      7346   7349   7452   7466  13564
                                     13575
R_Bank                         $00b6   780D  7139   7327   7440   7927
                                      8840   8937  10985  11026
W_Bank                         $00b7   781D  7141   7329   7442   7935
                                      8841   8897  11046  13465
ZP_b8                          $00b8   782
DOS_RL                         $00b9   783D  9821   9825   9827  11422
                                     11437  11460  11472  11496  11501
                                     11513  11532  11606
Dis_Line                       $00ba   784D  7367   7369   7371   7409
                                      7422   9912  13297
DosPtr                         $00bb   785D 11322  11324  11326  11331y
                                     11338  11340  11411  11415
Mon_Format                     $00bd   786D 12496  13131
Dis_Length                     $00be   787D 12430  12440  12498  13134
                                     13142  13302
Mon_A                          $00bf   788D 12695  12701  13132  13147
                                     13152  13467  13471  13505  13511
                                     13515  13518
Mon_B                          $00c0   789D 12697  12700
Mon_Op                         $00c1   790D 12424  12453  13255  13276
                                     13289  13303  13306
Mon_Lo                         $00c2   791D 13150  13235  13239  13256
                                     13688  13692  13693  13702  13703
                                     13717  13731  13736  13793
Mon_Hi                         $00c3   792D 13145  13232  13257  13689
                                     13698  13713  13733  13738
ScrPtr                         $00c4   797D  9104y  9120y  9163y  9219y
                                      9266y  9333y  9335y  9342y  9461y
                                      9499y  9504y  9507y  9511y  9624y
                                      9687y  9755y  9760y 10098  10102
                                     10509y 10559
CursorCol                      $00c6   798D  2763   2782   4448   9025
                                      9103   9132   9162   9179   9232
                                      9258   9277   9313   9316   9330
                                      9332   9368   9420   9503   9594
                                      9595   9622   9668   9753   9846
                                      9849  10503  10523  10537  10557
                                     11889
SAL                            $00c7   800D  9042   9043   9044y  9686y
                                     10072  10076
EAL                            $00c9   801D  6370   6371   6378   6380
                                      7577  11292  11294  11297  11302
                                     11304y 12066  12067  12074  12076
                                     12086y 12091y 12092y 12093y 12095
                                     12097  12150  12153  12168  12170
                                     12181  12183  12227  12228  12623
                                     12625  12663  12665
Mon_Tmp                        $00cb   803D  7460   7463   7669   7674
                                     13695  13726
Mon_ZP                         $00cc   804D 13291  13293  13714
QTSW                           $00cd   824D  9127   9175   9204   9205
                                      9381   9532   9678  10597
BITTS                          $00ce   826
EOT                            $00cf   827
ZD0                            $00d0   828
FNLEN                          $00d1   830D  6364   7560   8243   8460
                                      8516   8618   9830  11360  11427
                                     11459  11462  11463  11474  11475
                                     11589  12060  12212  12242  12261
                                     12289  12312  12649  12948  13421
LA                             $00d2   831D  7693   7883   8120   8144
                                      8512   8556  11973  11985  12293
                                     12348  12364
SA                             $00d3   832D  6367   7537   7573   7881
                                      8006   8064   8158   9817   9934
                                      9954  11485  11510  11519  11544
                                     11551  11600  11618  11975  12062
                                     12115  12118  12155  12214  12224
                                     12245  12287  12299  12366  12368
                                     12648  12653  12682  12761  12801
                                     13385
FA                             $00d4   833D  7566   8058   8061   8128
                                      8220   8521   8722  11399  11402
                                     11450  11482  11508  11542  11549
                                     11598  11616  11687  11977  12056
                                     12216  12221  12296  12370  12643
                                     12765  12805  12929  12954  13626
RigMargin                      $00d5   835D  9117   9222   9255   9267
                                      9296   9314   9337   9419   9462
                                      9498   9514   9587   9688  10512
                                     10560  11897
TAPE1                          $00d6   836
CursorRow                      $00d8   837D  9018   9031   9129   9253
                                      9256   9448   9469   9585   9606
                                      9608   9636   9651   9656  10501
                                     10514  10525  10535  10554  10577
                                     11891
DATAX                          $00d9   838D  9168   9170   9171   9190
                                      9195   9354   9369
FNADR                          $00da   839D  6360   6362   7518   7520
                                      7549y  8245   8247   8462   8464
                                      9832y 11339  11341  11344y 11348y
                                     11351y 11354y 11363y 11378y 11433y
                                     11440y 11445y 11455  11575y 11580y
                                     11587y 11605y 11623y 12258y 12314
                                     12316  12950  12952
INSRT                          $00dc   840D  9216   9218   9377   9513
                                      9516   9536   9676
ROPRTY                         $00dd   841
FSBLK                          $00de   842
ScreenRows                     $00df   843D  9059   9288  10013
TopMargin                      $00e0   844D  9006   9017   9252   9286
                                      9303   9449   9467   9470   9605
                                      9634   9637   9640   9700   9713
                                     10476  10487  10555  10563  10566
                                     10569
BotMargin                      $00e1   845D  9009   9295   9586   9652
                                      9698   9715  10475  10488  10505
LefMargin                      $00e2   846D  9024   9231   9251   9276
                                      9287   9304   9329   9450   9593
                                      9621   9667  10087  10456
XMAX                           $00e3   847D  9988  10360
LSTX                           $00e4   848D 10331  10336  10353
KOUNT                          $00e5   849D 10010  10342  10348
DELAY                          $00e6   850D 10009  10338  10340  10355
CHIME                          $00e7   851D 10029  10042  10051
PrevChar                       $00e8   857D  9243   9474   9976
SCRIV                          $00e9   858D  9149  10022  10023
SCROV                          $00eb   859D  9359  10026  10027
JIFFY6                         $00f8   860D 12733  12736
BPTR                           $00f9   861D  7454   7456   8929   8939
                                      8942   9868   9879   9881  11050y
                                     11191  11193  13299  13301  13371
                                     13372  13374  13448  13463  13486
                                     13488  13514  13516  13517  13519
                                     13528  13530  13531
STAL                           $00fb   862D  7223   7225   7357   7359
                                      7379   7381   7453   7455   7604
                                      7606   7639   8946   8948   8955
                                      8960   9938y  9957y 10982  10984
                                     11029y 12627  12629  12655  12656
                                     12662  12667y 12673  13236  13298
                                     13300  13327  13331  13353  13354
                                     13356  13468  13487  13489  13501
                                     13503  13507  13509  13524  13526
                                     13527  13792  13797
MEMUSS                         $00fd   863D  7378   7380   7411   7412
                                      7419   8246   8248   8259y  8672
                                      8673   9871   9878   9880  13445
                                     13500  13502  13504  13506  13508
                                     13510
STACK                          $0100   872D  1339   1344   1346   1348
                                      1351   3143   3146   3152   3156
                                      3158   3160   3162   3164   4167
                                      4169   4172   4174   4595   4596
                                      6439   6512   6517   6559   6564
                                      6579   6595   6597   6605   6607
                                      6609   6612   6614   9736  11162
BUF                            $0200   877D  1571   1586   1587   1594
                                      1645   1660   1694   1704   1705
                                      1717   1722   1736   1738   2743
                                      2744   2745   2880   2881   2883
                                      2931   2940   2994   2995   2996
                                     11221  11273  13820  13826  13832
                                     13837  13874
LAT                            $0251   879D  8134  11959  11972  12006
                                     12007  12365
FAT                            $025b   880D  8132  11976  12008  12009
                                     12371
SAT                            $0265   881D  8003  11974  12010  12011
                                     12369
KEYD                           $026f   882D  9075   9077   9078   9111
                                     10365  12907  13324  13326  13329
                                     13330  13333  13334  13336
Bank_Fetch                     $027a   893D   892   7189   7202   7462
                                      8951  10987  10993  10997  11000
                                     11016  12452  13305  13464  13466
                                     13469  13470  13491  13520  13571
Bank_Store                     $028b   892D  7461   8853   8856   8859
                                      8862   8890   8904   8907   8920
                                      8923   9884  11098  11104  11113
                                     11129  11164  11170  13304  13492
                                     13521
Mon_Register                   $02a0   894D  7119   7121   7123   7125
                                      7129   7132   7134   7136   7138
                                      7140   7142   7222   7224   7328
                                      7330   7334   7336   7339   7341
                                      7345   7356   7358   7435   7439
                                      7441   7479   7481   7483   7485
                                      7492   7494   7496   7498   7500
                                      7501   7502   7509
Dis_Buf_Length                 $02b0   895D 13166  13206  13282
Dis_Buf                        $02b1   896D 12706  13137  13155  13159
                                     13188  13193  13203  13287
Ass_Buf_Length                 $02c0   897D 13275  13281  13749  13759
                                     13760
Ass_Buf                        $02c1   898D 13220  13224  13227  13264
                                     13272  13286  13707  13750  13753
                                     13757  13758  13775
Ass_Index                      $02d0   899D 13278  13318
Ass_Dollar                     $02d1   900D 13258
Ass_Length                     $02d2   901D 13259
DOS_Tmp                        $033a   907D  7686   7713   8164   8244
                                      8256   8263   8517   8671  11426
DOS_Drive_1                    $033b   908D  8446   8514   8591  11603
DOS_Drive_2                    $033c   909D  8450   8515   8592   8660
                                     11346  11621
DOS_Attr                       $033d   910D  8435   8471   8476   8513
                                      8571   8597   8612
DOS_Flags                      $033e   923D  7736   7740   7757   7766
                                      7776   7869   8020   8179   8195
                                      8295   8511   8550   8561   8585
                                      8615   8654   8668   8685   8692
                                      8693   8741
DOS_Id                         $033f   924D  8096   8276   8279   8518
                                      8607
DOS_Command_Length             $0341   925D  8420   8422   8619   8625
DOS_Filename                   $0342   926D  7517   7519   8623  13417
                                     13551  13560  13572
DOS_Command_Buffer             $0353   927D  8027   8157   8159   8161
                                      8163   8165   8260   8277   8280
                                      8299   8452   8461   8463   9899
                                      9904   9928  10221  10232  11404
DOS_Status                     $03ad   928D  3580   3581   3656   8068
                                      8075   8077   8358   9818
TABS_SET                       $03ee   929D  9600   9602   9855  10017
Reset_Vector                   $03fa   930D 13605  13607
Ignore_Timeout                 $03fc   931D 11744  11753  13609
SCREEN_RAM                     $8000   933
Basic_Statement_Table          $b000  1056D  2121   2123
Basic_Function_Table           $b066  1114D  3707   3709
Basic_Operator_Table           $b094  1144D  3258   3280   3288   3290
                                      3302
Basic_Keyword_Table            $b0b2  1161D  1685   1687   1976   1978
Msg_Start                      $b20d  1260D  1460   1475   1649   2272
                                      2274   2857   3205   3474   4217
                                      4224   4229   4464   4471   4670
                                      4737   4883   5523   5882   8702
                                      8754
Msg_SYNTA                      $b21d  1264D  3474
Msg_GOSUB                      $b223  1265D  2272
Msg_QUANT                      $b242  1267D  4224   8702
Msg_FLOW                       $b252  1268D  5523
Msg_OOM                        $b25a  1269D  1460   4737
Msg_UNDEF                      $b267  1270D  2274
Msg_SUBSC                      $b278  1271D  4217
Msg_REDIM                      $b285  1272D  4229
Msg_DIV                        $b292  1273D  5882
Msg_DIREC                      $b2a2  1274D  4464
Msg_TYPE                       $b2b0  1275D  3205
Msg_LONG                       $b2bd  1276D  1649   4883   8754
Msg_DATA                       $b2cc  1277D  2857
Msg_COMPL                      $b2d5  1278D  4670
Msg_FUNC                       $b2f6  1280D  4471
Msg_ERR                        $b306  1281D  1483   1484
Msg_IN                         $b30d  1282D  6392   6393
Msg_READY                      $b312  1287D  1495   1496
Msg_BREAK                      $b31b  1293D  2179   2180
Find_Active_FOR                $b322  1327D  2010   2268   3131
FAF_10                         $b327  1339D  1357
FAF_20                         $b33c  1348D  1343
FAF_30                         $b348  1353D  1349
FAF_Ret                        $b34f  1358D  1341   1352
Open_Up_Space                  $b350  1361D  1583   3976  13907
OUS_10                         $b374  1391D  1388
OUS_20                         $b380  1397D  1400
OUS_30                         $b384  1399D  1394   1396   1406
OUS_40                         $b38b  1403D  1383
Check_Stack_Avail              $b393  1410D  2018   2216   3224
BSOS_Bank_Init                 $b399  1419D  9981
Check_Mem_Avail                $b3a0  1427D  1370   4242   4292
CMA_10                         $b3aa  1440D  1437
CMA_Ret                        $b3bd  1452D  1436   1439   1448
Error_Out_Of_Memory            $b3cd  1457D  1415   1449   1451   4337
                                      8932  11301
Basic_Error                    $b3cf  1463D  1650   2193   2275   2858
                                      3206   3475   4225   4472   4671
                                      4884   5524   5883   8703   8755
Berr_10                        $b3da  1473D  1469
Berr_20                        $b3e0  1475D  1481
Berr_30                        $b3ed  1482D 12397
Berr_40                        $b3f4  1485D  2182
Basic_Ready                    $b3ff  1492D  1488   1937   2183   7086
                                      7097   7099   7511   8967  11263
                                     12822  12826  12879  12888  13596
                                     13598  13855
Get_Basic_Statement            $b406  1500D  1508   1572   1605
New_Basic_Line                 $b41f  1517D  1511
NBL_10                         $b45a  1556D  1553
NBL_20                         $b462  1561D  1558   1564   1568
NBL_30                         $b470  1569D  1529
NBL_40                         $b48b  1582D  1580
NBL_50                         $b4a5  1594D  1597
Reset_And_Rechain              $b4ad  1600D 12172
Rechain                        $b4b6  1608D  1570   1604   6383   8966
                                     10164  13881
Rech_10                        $b4be  1615D  1632
Rech_20                        $b4c0  1616D  1618
Rech_30                        $b4d4  1629D  1614
Read_String                    $b4e2  1638D  2956  10441
ReaS_10                        $b4e4  1642D  1648
ReaS_20                        $b4f8  1651D  1644
Tokenize_Line                  $b4fb  1654D  1526  11251  12848  13815
ToLi_01                        $b501  1660D  1665   1715
ToLi_02                        $b50d  1666D  1661
ToLi_03                        $b523  1677D  1674
ToLi_04                        $b52b  1681D  1678
ToLi_05                        $b53d  1690D  1697
ToLi_06                        $b544  1694D  1689   1692   1735
ToLi_07                        $b552  1701D  1737
ToLi_08                        $b554  1702D  1663   1667   1672   1676
                                      1680   1718   1720
ToLi_09                        $b567  1712D  1709
ToLi_10                        $b569  1713D  1711
ToLi_11                        $b570  1717D  1724
ToLi_12                        $b579  1721D  1670
ToLi_13                        $b580  1725D  1699
ToLi_14                        $b584  1727D  1733
ToLi_15                        $b58d  1732D  1730
ToLi_16                        $b599  1738D  1706
Find_BASIC_Line                $b5a3  1745D  1528   1877   9775   9789
Find_BASIC_Line_AX             $b5a7  1752D  1773   2251
FBL_10                         $b5c5  1771D  1765
FBL_30                         $b5cb  1774D  1759
FBL_Ret                        $b5cc  1775D  1764   1769   1770   1783
Basic_NEW                      $b5d2  1780D  1093
Perform_NEW                    $b5d4  1786D  7083
Reset_BASIC_Execution          $b5e9  1803D  1569   1603   2208   6382
                                      8965
Basic_CLR                      $b5ee  1810D  1087
Reset_Variable_Pointer         $b5f0  1816D  2209  13854
RVP_10                         $b60b  1834D 12174
Flush_BASIC_Stack              $b60e  1837D  1482   7025
FBS_Ret                        $b621  1853D  1813
Reset_BASIC_Exec_Pointer       $b622  1856D  1806  12173
RBEP_Ret                       $b62f  1866D  1875   1881   1884
Basic_LIST                     $b630  1869D  1086
LIST_10                        $b638  1876D  1872   1873
LIST_15                        $b64f  1885D  1879
LIST_20                        $b659  1894D  1889   1933
LIST_25                        $b674  1917D  1914
LIST_30                        $b676  1922D  1916
LIST_60                        $b679  1926
LIST_50                        $b686  1937D  1899   1917
List_Line                      $b689  1942D  1922  10596
LiLi_08                        $b690  1949D  1967   1969
LiLi_10                        $b697  1955D  1960
LiLi_20                        $b6a3  1964D  1951   1998
LiLi_30                        $b6bb  1981D  1988
LiLi_40                        $b6be  1983D  1987
LiLi_50                        $b6c4  1986D  1984
LiLi_60                        $b6ca  1989D  1982   1995
LiLi_Ret                       $b6da  1999D  1957   1966
Basic_FOR                      $b6de  2004D  1060
FOR_10                         $b6ef  2016D  2011
FOR_30                         $b72f  2048D  2045
Execute                        $b74a  2063D  2058   2102   2229   3166
                                      6384
Exec_10                        $b759  2073D  2069
Start_Program                  $b77c  2097D  1514   2089   2128  12849
Interpret                      $b785  2105D  2101   2355
Inpr_10                        $b787  2112D  2370
Inpr_20                        $b795  2119D  2115
Inpr_30                        $b7a2  2126D  2113
Inpr_40                        $b7a5  2127D  2075
Inpr_50                        $b7a9  2129D  2117
Basic_GO                       $b7ac  2132D  1094
Basic_RESTORE                  $b7b7  2141D  1071   1834
REST_10                        $b7c1  2150D  2148   3096
REST_Ret                       $b7c5  2152D  2111
Basic_STOP                     $b7c6  2155D  1075  12034
Basic_END                      $b7c8  2161D  1059
END_10                         $b7c9  2165D  2158
END_20                         $b7d8  2173D  2944
END_30                         $b7e0  2177D  2170
END_40                         $b7e2  2179D  2079
END_50                         $b7eb  2183D  2181
Basic_CONT                     $b7ee  2186D  1085
CONT_10                        $b7f9  2194D  2192
CONT_Ret                       $b807  2201D  2165   2189
Basic_RUN                      $b808  2204D  1069
RUN_10                         $b80a  2208
RUN_20                         $b80d  2209D  2207
Basic_GOSUB                    $b813  2213D  1072
GOSUB_10                       $b825  2227D  2210
Basic_GOTO                     $b830  2234D  1068   2138   2228   2354
GOTO_10                        $b847  2249D  2241
GOTO_20                        $b84b  2251D  2246   2248
GOTO_Ret                       $b85c  2259D  2265
Basic_RETURN                   $b85d  2262D  1073
RET_10                         $b86e  2274D  2252
RET_20                         $b873  2276D  2366
RET_30                         $b876  2277D  2271
Basic_DATA                     $b883  2288D  1062   2939   4497
Add_Y_To_Execution_Pointer     $b886  2294D  2351   3086
AYEP_Ret                       $b890  2303D  2301   2325   2327
Next_Statement                 $b891  2306D  2019   2291   3069
End_Of_Line                    $b894  2313D  2238   2350
NeSt_10                        $b89c  2320D  2331
NeSt_20                        $b8a4  2324D  2330
Basic_IF                       $b8b3  2334D  1070
IF_10                          $b8c2  2343D  2340
Basic_REM                      $b8c6  2347D  1074
REM_10                         $b8cb  2352D  2344
REM_20                         $b8d3  2355D  2353
Basic_ON                       $b8d6  2358D  1076
ON_10                          $b8de  2365D  2392
ON_20                          $b8e2  2367D  2364   2374
ON_30                          $b8ea  2371D  2368
Scan_Linenumber                $b8f6  2379D  1525   1876   1883   2237
                                      2372   8800   8812   8823   9774
                                      9784  10465  11147  12823
ScLi_10                        $b8fe  2390D  2395
ScLi_Ret                       $b90c  2396D  2389
Dec_Char                       $b90d  2399D  2393  13735
LIM_10                         $b92e  2428D  2426
Basic_LET                      $b930  2433D  1067   2009   2126
Assign_Numeric_variable        $b94d  2453D  3044
LET_10                         $b961  2466D  2456
LET_20                         $b964  2468D  2449
Assign_String_Variable         $b965  2471D  3037
CLOCK_10                       $b978  2483D  2498
CLOCK_20                       $b992  2495D  2491
CLOCK_30                       $b9a2  2503D  2506
Add_TI_String_Digit_To_FAC1    $b9ab  2511D  2484   2488
ATSD_10                        $b9b2  2517D  2479
ATSD_20                        $b9b5  2518D  2516
Assign_Normal_String           $b9ba  2522D  2476
ANS_10                         $b9c9  2552
ANS_20                         $b9cb  2553
ANS_30                         $b9d7  2559D  2555
ANS_40                         $b9e5  2566D  2554   2558   2561
ANS_50                         $b9ec  2572D  2550   2562   2565
ANS_60                         $ba05  2586D  2568
ANS_70                         $ba1e  2601D  2592
ANS_80                         $ba33  2615D  2606
ANS_90                         $ba35  2616D  2619
Back_Reference_Position        $ba3d  2623D  2591   2605   4964
BRP_10                         $ba57  2649D  2646
BRP_no                         $ba6c  2662D  2637   2643   2645   2648
FAC1_INT                       $ba6f  2672D  4137
FACI_Ret                       $ba81  2685D  2677
Basic_PRINTN                   $ba88  2690D  1083
Basic_CMD                      $ba8e  2697D  1088   2693
CMD_10                         $ba98  2704D  2701
PRINT_10                       $baa2  2711D  2731
PRINT_20                       $baa5  2712D  2736
Basic_PRINT                    $baa8  2715D  1084   2708
PRINT_30                       $baaa  2719D  2791
Terminate_BUF                  $bad2  2739D  1651
Print_CR                       $badf  2750D  1473   1901   2718  12821
PRINT_Ret                      $bae4  2755D  2719   2747
Comma_Tab                      $baf0  2760D  2726
CoTa_10                        $baf3  2765D  2766
Tab_Spc                        $bafd  2772D  2721   2724
TaSp_10                        $bb0d  2784D  2769
TaSp_20                        $bb0e  2785D  2780
TaSp_30                        $bb11  2787D  2789
TaSp_40                        $bb14  2788D  2786
TaSp_50                        $bb17  2790D  2728   2783
Print_String                   $bb1d  2794D  1485   1497   2861   3104
                                      6413   7072   7082
Print_String_From_Descriptor   $bb20  2800D  2711   2734   2923
PSFD_10                        $bb28  2807D  2811
PSFD_Ret                       $bb31  2812D  2805
Cursor_Right_Or_Space          $bb3a  2817D  2735   2787   2955
CROS_10                        $bb41  2824D  2821
Print_Question_Mark            $bb44  2828D  1474   2954   3002
Print_Char                     $bb46  2834D  1949   1958   1993
Bad_Input                      $bb4c  2842D  3052
BaIn_10                        $bb56  2850D  2847
BaIn_20                        $bb5a  2852D  2849
SynErr                         $bb5e  2854D  2778
BaIn_30                        $bb61  2855D  2846
BaIn_40                        $bb6a  2859D  2856
Basic_GET                      $bb7a  2869D  1092
GET_10                         $bb8f  2880D  2874
Basic_INPUTN                   $bba4  2893D  1063
Set_Default_Channels           $bbb2  2903D  2694   2938
SDC_10                         $bbb4  2907D  2887
Basic_INPUT                    $bbbe  2915D  1064
Input_String                   $bbcd  2926D  2900   2919
InSt_10                        $bbd5  2932D  3511
InSt_20                        $bbe8  2940D  2934   2937
InSt_30                        $bbf0  2943D  3507
Prompt_And_Input               $bbf5  2949D  2932   3003
PAI_10                         $bbff  2956D  2953
Basic_READ                     $bc02  2959D  1066
READ_10                        $bc09  2966D  2941   3512
Read_Get                       $bc0b  2969D  2885
READ_15                        $bc11  2978D  3065
READ_20                        $bc3d  2999D  2992
READ_25                        $bc46  3003D  3001
READ_30                        $bc49  3004D  2997
READ_35                        $bc4d  3009D  2990   3089
READ_40                        $bc61  3022D  3013
READ_45                        $bc6d  3028D  3018
READ_50                        $bc6e  3029D  3024
READ_55                        $bc79  3035D  3033
READ_60                        $bc85  3042D  3011
READ_65                        $bc8d  3048D  3038
READ_70                        $bc99  3054D  3049   3051
READ_75                        $bcb4  3069D  2999   3088
READ_80                        $bccd  3084D  3072
READ_85                        $bcda  3092D  3063
READ_90                        $bce5  3097D  3095
READ_Ret                       $bcf6  3105D  3099   3101
Msg_Extra_Ignored              $bcf7  3110D  3102   3103
Msg_Redo_From_Start            $bd07  3116D  2859   2860
Basic_NEXT                     $bd19  3122D  1061
NEXT_10                        $bd1f  3128D  3125   3175
NEXT_20                        $bd24  3130D  3127
NEXT_30                        $bd2d  3134D  3076
NEXT_40                        $bd2f  3135D  3132
NEXT_50                        $bd6f  3166D  3173
NEXT_60                        $bd72  3167D  3157
Eval_Numeric                   $bd84  3178D  2033   2047   4555   5164
                                      5224  12614
Is_Numeric                     $bd87  3184D  3260   3342   3712   4122
                                      4484   4511   4522   4590
Is_String                      $bd89  3191D  3689   4873   4943
Check_Var_Type                 $bd8a  3197D  2448   3765
CVT_10                         $bd90  3203D  3204
CVT_20                         $bd91  3204D  3201
CVT_30                         $bd93  3205D  3202
CVT_40                         $bd95  3206D  3134
Eval_Expression                $bd98  3212D  2337   2445   2729   3181
                                      3439   3687   4116   7698   7702
                                      8733  12310
EvEx_05                        $bd9e  3218D  3216
EvEx_10                        $bda3  3221D  3294
EvEx_15                        $bdb0  3228D  4895
EvEx_20                        $bdb3  3229D  3241
EvEx_25                        $bdce  3243D  3231   3233
EvEx_30                        $bddf  3252D  3249
EvEx_35                        $bde7  3257D  3279
EvEx_40                        $bdf0  3261D  3282
EvEx_45                        $bdf1  3262D  3484
EvEx_50                        $bdfe  3270D  3244
EvEx_55                        $be08  3276D  3274
EvEx_60                        $be10  3280D  3265
Use_Operator                   $be17  3285D  3262
SynErr1                        $be27  3296D  3238
Push_Operand                   $be2a  3299D  3292
Push_FAC1                      $be2e  3306D  2039   2051
PuFA_10                        $be39  3316D  3313
Pop_FAC2                       $be52  3334D  3245   3247
PoFA_10                        $be55  3339D  3267
PoFA_20                        $be57  3340D  3259
PoFA_30                        $be5e  3343D  3341
PoFA_40                        $be60  3344D  3268   3281
PoFA_50                        $be7a  3361D  3339
Evaluate                       $be81  3367D  3225   4872
Eva_10                         $be85  3372D  3389
Eva_20                         $be8a  3374D  3385
Eva_30                         $be8d  3375D  3373
Float_PI                       $bea0  3383D  3379   3380
Eva_40                         $bea5  3384D  3378
Make_String_Descriptor_From_Co $beb5  3394D  2920
MSDF_10                        $bebe  3402D  3400
Eva_50                         $bec4  3405D  3391
Op_NOT                         $becc  3411D  1155
Eva_60                         $bedb  3427D  3406
Eva_70                         $bee2  3430D  3428
Eval_In_Parenthesis            $bee9  3435D  3431   3704   4521
Need_Right_Parenthesis         $beef  3442D  4180   4485   5102   7700
                                      8777
Need_Left_Parenthesis          $bef2  3449D  3438   3686   4480   7697
                                      8775
Need_Comma                     $bef5  3456D  2877   2897   3064   3688
                                      3821   5081   5231   7694   7706
                                     12333
Need_A                         $bef7  3462D  2032   2137   2342   2440
                                      2703   2922   4487   4505   7689
Syntax_Error                   $bf00  3471D  2129   2276   2854   3296
                                      3467   3498   3854   3951   4562
                                      7730   8032   8118   8194   8293
                                      8316   8548   8600   8641   8653
                                      8684   8743   8773  12059  12341
                                     12646  13856
Negate                         $bf05  3478D  3387
Nega_10                        $bf07  3482D  3408
JMP_Get_Var                    $bf0c  3487D  3376
Any_Except_Pi                  $bf0f  3493D  2100
Input_String_Patch             $bf19  3502D  2942
InSt_40                        $bf20  3508D  3506
InSt_50                        $bf29  3512D  3510
Extended_Statement_Table       $bf2c  3515D 11233  11235  11242
Extended_Keyword_Table         $bf3a  3527D 11223  11240
Get_Var                        $bf8c  3542D  3490   3938
GeVa_10                        $bfbb  3575D  3562   3564
GeVa_Ret                       $bfcd  3583D  3560   3576   3578
Get_Numeric_Value              $bfce  3586D  3558
Load_Float                     $bfdf  3601D  3590
Load_Jiffyclock                $c003  3618D  3565   3610
Check_ST_Var                   $c00f  3630D  3607
Check_DS_Var                   $c01c  3641D  3634   3636
Load_Float_Var                 $c040  3664D  3605   3609   3645   3647
Function_Call                  $c047  3672D  3432
FuCa_10                        $c071  3704D  3685
FuCa_20                        $c076  3707D  3703
Op_OR                          $c086  3715D  1153
Op_AND                         $c088  3722D  1152
ANDOR_10                       $c0a8  3742D  3736
Op_COMPARE                     $c0b6  3757D  1156
OpCO_10                        $c0ce  3776D  3766
OpCO_20                        $c0f6  3796D  3791   3793
OpCO_30                        $c0fb  3799D  3808
OpCO_40                        $c101  3803D  3775
OpCO_50                        $c106  3806D  3801
OpCO_60                        $c112  3812D  3803   3805   3810
OpCO_70                        $c11b  3818D  3816
DIM_10                         $c11e  3821D  3830
Basic_DIM                      $c121  3824D  1065
Parse_Name                     $c12b  3834D  2436   2978   3128   3552
                                      4483
Get_Array_Address              $c130  3841D  3828
Get_FN_Address                 $c132  3847D  4508
GFA_Err                        $c13c  3854D  3880
Get_Address                    $c13f  3857D  3853
GeAd_05                        $c14f  3867D  3864
GeAd_10                        $c150  3868D  3869   3871
GeAd_15                        $c15a  3872D  3866
GeAd_20                        $c164  3877D  3873
GeAd_25                        $c174  3885D  3876
GeAd_30                        $c17b  3889D  3878
GeAd_35                        $c187  3895D  3893
GeAd_40                        $c18f  3899D  3919
GeAd_45                        $c191  3900D  3917
GeAd_50                        $c19b  3905D  3902
GeAd_55                        $c1ab  3913D  3911
GeAd_60                        $c1ac  3914D  3907
Is_Alpha                       $c1b6  3922D  3375   3852   3865   3870
IsAl_Ret                       $c1bf  3930D  3926
Create_Var                     $c1c0  3933D  3904
CrVa_05                        $c1c6  3940D  3948
CrVa_10                        $c1cb  3943D  3939
CrVa_15                        $c1db  3951D  3955   3959   3961
CrVa_20                        $c1de  3952D  3946   3950
CrVa_25                        $c1e6  3956D  3953
CrVa_30                        $c1f2  3962D  3957
CrVa_35                        $c208  3974D  3972
CrVa_40                        $c21c  3988D  4011   4013
CrVa_45                        $c220  3990D  4027
CrVa_50                        $c228  3994D  3991
CrVa_55                        $c259  4023D  4021   4055   4057
CrVa_60                        $c263  4028D  4025
CrVa_65                        $c281  4045D  4042
CrVa_70                        $c28b  4051D  4030   4041   4044
CrVa_75                        $c298  4059D  3993
CrVa_80                        $c2b4  4076D  3912
CrVa_85                        $c2be  4082D  4080
Array_Pointer_To_First         $c2c8  4089D  4232   4241
APTF_10                        $c2d4  4099D  4097
Float_M32768                   $c2d9  4104D  4133   4134
Eval_Positive_Integer          $c2dd  4112D  4159
Eval_Positive_Integer_Check    $c2e3  4119D  5170
Real_To_Integer                $c2ea  4127D  2458   3419   3727   3733
RIT_10                         $c2f7  4136D  4124
RIT_20                         $c2f9  4137D  4132
Find_Array                     $c2fc  4140D  3894
FiAr_05                        $c306  4153D  4178
FiAr_10                        $c347  4189D  4211
FiAr_15                        $c353  4195D  4192
FiAr_20                        $c362  4203D  4199
Bad_Subscript                  $c370  4214D  4236   4336
Jump_To_Illegal_Quantity       $c373  4221D  2517   4136   5150   5599
                                      7029   7030   8805   9805
FiAr_Err                       $c375  4225D  4231
FiAr_25                        $c378  4229D  4202
FiAr_30                        $c38c  4241D  4194
FiAr_35                        $c39f  4250D  4248
FiAr_40                        $c3a8  4256D  4253
FiAr_45                        $c3b1  4262D  4282
FiAr_50                        $c3c1  4272D  4265
FiAr_55                        $c3e4  4292D  4289
FiAr_60                        $c3f3  4299D  4301   4304
FiAr_65                        $c3f8  4302D  4298
FiAr_70                        $c415  4318D  4237
FiAr_72                        $c41d  4322D  4352
FiAr_74                        $c433  4336D  4331
FiAr_76                        $c436  4337D  4284   4291   4402   4413
FiAr_78                        $c439  4338D  4330
FiAr_80                        $c43a  4339D  4335
FiAr_82                        $c44b  4349D  4342
FiAr_84                        $c45c  4358D  4356
FiAr_86                        $c462  4362D  4359
FiAr_Ret                       $c476  4373D  4316   4463
Mult_16x16                     $c477  4378D  4277   4343
Mult_16x16_A                   $c480  4388D  4364
Mu16_10                        $c48a  4396D  4415
Mu16_20                        $c4a3  4414D  4405
Basic_FRE                      $c4a8  4419D  1121
FRE_10                         $c4af  4425D  4423
AY_To_Real                     $c4bc  4434D  3425   3598   3741   3746
                                      4455
Basic_POS                      $c4c9  4445D  1122
Y_To_Float                     $c4cb  4451D  5128   5149   5266
Assert_Non_Direct              $c4cf  4458D  2872   2929   4479
Undefined_Function             $c4d7  4468D  4533
Basic_DEF                      $c4dc  4475D  1081
Get_FN                         $c50a  4501D  4478   4517
Eval_FNX                       $c51d  4514D  3429
FNX_10                         $c53e  4536D  4539
FNX_20                         $c56f  4563D  4561
FNX_30                         $c575  4567D  4498
Basic_STR                      $c58e  4587D  1133
STR_10                         $c598  4595D  3573
Allocate_String_FAC1           $c59e  4600D  4658   4885
Allocate_String_A              $c5a6  4609D  2574   5024   5046
Create_String_Descriptor       $c5b0  4619D  2733   2797   3402   3582
                                      4597
Create_String_Descriptor_AY    $c5b6  4627D  3035
CSD_10                         $c5c0  4635D  4641
CSD_20                         $c5cd  4642D  4639
CSD_30                         $c5d1  4644D  4637
CSD_40                         $c5d2  4645D  4643
CSD_50                         $c5de  4652D  4650
CSD_60                         $c5e8  4657D  4654
Push_String_Descriptor         $c5f3  4664D  4656   4894   5030   5060
PuSD_Err                       $c5fb  4671D  4739
PuSD_10                        $c5fe  4672D  4669
Allocate_String_Space          $c61d  4692D  4612
ASS_10                         $c61f  4702D  4744
ASS_30                         $c63a  4719D  4717
ASS_40                         $c644  4724D  4721
ASS_50                         $c65a  4736D  4703
ASS_60                         $c65b  4737D  4720   4723
Garbage_Collection             $c66a  4749D  1443   4425   4740  11398
GaCo_05                        $c676  4759D  4779   4781   4811   4827
GaCo_10                        $c68a  4771D  4768
GaCo_15                        $c69f  4783D  4775
GaCo_20                        $c6b0  4793D  4790
GaCo_25                        $c6b6  4796D  4794
GaCo_30                        $c6c7  4807D  4804
GaCo_35                        $c6d1  4813D  4808
GaCo_40                        $c6d4  4815D  4818
GaCo_45                        $c6eb  4828D  4763
FAC1_LSB                       $c6f4  4835D  6141
FACX_LSB                       $c6f6  4839D  5551
FACB_10                        $c6fa  4841D  4858
FACB_Ret                       $c71c  4859D  4842
Concatenate                    $c74f  4865D  3250
Conc_10                        $c76f  4885D  4882
Store_String_STRPTR            $c78c  4898D  4886
Store_String_XY                $c79a  4913D  2577   4661
Store_String_INDEXA            $c79e  4920D  4890   5059
SSI_10                         $c7a2  4926D  4930
SSI_Ret                        $c7b4  4937D  4924   4935
Eval_And_Free_String           $c7b5  4940D  5134   8734  12311
Free_String_FAC1               $c7b8  4946D  2477   2803   3779   4424
Free_String_AY                 $c7bc  4953D  3785   4889   4893   5049
GSD_40                         $c7ed  4986D  4963   4965
GSD_Ret                        $c7ff  4998D  4974   4976
Pop_Descriptor_Stack           $c811  5003D  2580   2590   4962
PDS_Ret                        $c821  5014D  5007   5009
Basic_CHR                      $c822  5017D  1136
Basic_LEFT                     $c836  5033D  1137
LEFT_10                        $c83c  5039D  5070
LEFT_20                        $c842  5043D  5039
LEFT_30                        $c843  5044D  5091
LEFT_40                        $c844  5045D  5094   5096
LEFT_50                        $c85b  5058D  5056
Basic_RIGHT                    $c862  5063D  1138
Basic_MID                      $c86d  5073D  1139
MID_10                         $c87e  5083D  5080
Pop_DESCPT                     $c897  5099D  5036   5066   5083
Basic_LEN                      $c8b2  5124D  1132
Eval_String_Desc               $c8b8  5131D  5127   5144   5180
Basic_ASC                      $c8c1  5141D  1135
ASC_10                         $c8cb  5149D  5145
ASC_Err                        $c8ce  5150D  5084   5172   5239   5242
Get_Next_Byte_Value            $c8d1  5155D  2776
Get_Byte_Value                 $c8d4  5161D  2361   2700   2876   2896
                                      3698   5082   5232   8776   8778
                                     12236  12292
Eval_Byte                      $c8d7  5167D  5020
Basic_VAL                      $c8e3  5177D  1134
VAL_10                         $c8eb  5183D  5181
VAL_20                         $c903  5196D  5194
Restore_Execution_Pointer      $c918  5209D  3036   3403
Get_Word_And_Byte              $c921  5221D  5272   5282
Need_Comma_Get_Byte            $c927  5228D  5287
FAC1_To_LINNUM                 $c92d  5235D  5225   5258   7699   7703
                                     12615
Basic_PEEK                     $c943  5251D  1131
Basic_POKE                     $c95a  5269D  1082
Basic_WAIT                     $c963  5279D  1077
WAIT_10                        $c972  5288D  5286
WAIT_20                        $c976  5290D  5293
WAIT_Ret                       $c97e  5294D  5356
Add_0_5_To_FAC1                $c97f  5297D  6486   6893
AY_Minus_FAC1                  $c986  5305D  5613   6889   6976
Op_MINUS                       $c989  5311D  1148   6749   6886
Add_Var_AY_To_FAC1             $c99d  5325D  3150   5302   5607   5619
                                      6806   6845   6871   6902
Op_PLUS                        $c9a0  5331D  1147   5320   6289
PLUS_10                        $c9a5  5336D  5334
AddSub_FAC2_To_FAC1            $c9ad  5342D  5774
AFTF_10                        $c9c9  5370D  5360
AFTF_20                        $c9cd  5372D  5369
AFTF_30                        $c9d0  5373D  5359
AFTF_40                        $c9dc  5379D  5377
AFTF_50                        $c9ff  5395D  6075
Normalise_FAC1                 $ca0d  5402D  5395   5397   5897   6186
                                      6860
NF1_10                         $ca11  5408D  5421
Clear_FAC1                     $ca2d  5424D  5182   5457   5752
CF1_10                         $ca2f  5428D  6668
AFTF_60                        $ca34  5432D  5374
AFTF_65                        $ca53  5448D  5454
AFTF_70                        $ca5f  5454D  5409
Mantissa_Overflow              $ca6c  5463D  5446
AFTF_80                        $ca6e  5467D  6032
AFTF_Ret                       $ca7c  5474D  5466
Negate_FAC1                    $ca7d  5477D  5396
Negate_FAC1_Mantissa           $ca83  5485
Inc_FAC1_Mantissa              $caa5  5507D  6030   6158
IFM_Ret                        $cab3  5517D  5504   5511   5513   5515
Overflow_Error                 $cab4  5520D  5468   5753   6299
Shift_FAC3                     $cab9  5527D  5659
Shift_FACX_A                   $cacf  5548D  5372
SFA_10                         $cad8  5555D  5561
SFA_40                         $cae4  5562D  5554
REAL_1                         $caf2  5568D  2040   2041   5611   5612
                                      6966   6967
VLOG_A                         $caf7  5572D  5614   5615
HALF_SQRT_2                    $cb0c  5579D  5605   5606
SQRT_2                         $cb11  5583D  5608   5609
MINUS_0_5                      $cb16  5586D  5617   5618
LN_2                           $cb1b  5590D  5622   5623
Basic_LOG                      $cb20  5593D  1125   6684
LOG_10                         $cb27  5599D  5597
LOG_20                         $cb2a  5600D  5598
Multiply_FAC1_With_AY          $cb5e  5626D  6460   6687   6725   6770
                                      6774   6797   6842
Op_MULTIPLY                    $cb61  5632D  1149
Mult_SubA                      $cb8c  5655D  5643   5645   5647   5649
Mult_SubB                      $cb91  5662D  5651   5658
MULT_20                        $cb94  5667D  5689
MULT_30                        $cbb0  5682D  5668
MULT_Ret                       $cbbe  5690D  5635
Load_FAC2_From_AY              $cbc2  5695D  5308   5328   5629   5806
Check_FAC                      $cbed  5729D  5636   5818
ChFA_10                        $cbef  5733D  6757
ChFA_20                        $cbfa  5740D  5736
ChFA_30                        $cc04  5745D  5743
ChFA_40                        $cc07  5747D  6735
ChFA_50                        $cc0d  5750D  5733   5740
ChFA_Err                       $cc12  5753D  5737   5749   5766   5776
                                      5820
Multiply_FAC1_BY_10            $cc18  5758D  2485   2499   6255   6269
                                      6470
Add_And_Double                 $cc23  5769D  2494
Mul10_Ret                      $cc2e  5777D  5763
Float_10                       $cc2f  5780D  5790   5791
Divide_FAC1_By_10              $cc34  5786D  6250   6476
Divide_FAC2_By_AY              $cc3d  5795D  6881
AY_Divided_By_FAC1             $cc45  5803D  5610   6930   6968
Op_DIVIDE                      $cc48  5809D  1150   5800
DIV_10                         $cc5f  5823D  5849
DIV_20                         $cc75  5834D  5825   5828   5831   5848
                                      5850
DIV_30                         $cc82  5842D  5836   5867
DIV_40                         $cc85  5844D  5865
DIV_50                         $cc93  5851D  5843
DIV_60                         $ccb0  5866D  5839
DIV_70                         $ccb4  5868D  5840
Divide_By_Zero                 $ccc0  5879D  5812
FAC3_To_FAC1                   $ccc5  5886D  5652   5876
Load_FAC1_AY                   $ccd8  5900D  2042   3144   3381   3624
                                      3669   5799   6659   6839   6923
LFAY_10                        $ccde  5906D  5909
Set_FAC1                       $ccf4  5920D  6138
FAC1_To_FACTPB                 $ccfd  5932D  6787
FAC1_To_FACTPA                 $cd00  5939D  6768   6914
FAC1_To_FORPNT                 $cd06  5947D  2466   3151
FAC1_To_XY                     $cd0a  5954D  4541   5944   6671   6863
                                      6920
FAC2_To_FAC1                   $cd32  5981D  3732   5335
Copy_ABS_FAC2_To_FAC1          $cd34  5987D  6681
F1F2_10                        $cd38  5992D  5995
FAC1_Round_And_Copy_To_FAC2    $cd42  6000D  2489   5761   5789   6282
                                      6656   6877   6882
FAC1_To_FAC2                   $cd45  6006D  6731
FA12_10                        $cd47  6010D  6013
FA12_Ret                       $cd50  6015D  6022   6024   6031
Round_FAC1                     $cd51  6018D  2457   3316   5813   5957
                                      6003
Inc_FAC1                       $cd59  6027D  6729
Get_FAC1_Sign                  $cd61  6035D  2048   5596   6051   6099
                                      6825
GFS_10                         $cd65  6040D  6102
GFS_20                         $cd67  6041D  6126
GFS_Ret                        $cd6e  6045D  6039   6043
Basic_SGN                      $cd6f  6048D  1117
A_To_FAC1                      $cd72  6054D  3638   3659   3818   6284
ATOF_10                        $cd7a  6061D  4442
Convert_Integer_To_Real        $cd7f  6066D  6406  11157
CITR_10                        $cd85  6072D  3613
Basic_ABS                      $cd8e  6078D  1119
Compare_FAC1_AY                $cd91  6085D  3773   4135   6468   6480
                                      6677
Compare_FAC1_INDEXB_Y          $cd93  6091D  3153
CFAY_10                        $cdc8  6123D  6104   6108   6112   6116
CFAY_20                        $cdce  6126D  6124
FAC1_LSR                       $cdd1  6129D  2500   2675   5243   6176
                                      6487
FLSR_10                        $cdd5  6138
FLSR_20                        $cdd8  6139D  6137
FLSR_30                        $cde6  6146D  6144   6153
FLSR_40                        $cdff  6159D  6142   6155   6157
FLSR_Ret                       $ce01  6160D  6122   6175
Basic_INT                      $ce02  6165D  1118   6674   6736   6883
INT_10                         $ce1a  6185D  6181
Read_Real_To_FAC1              $ce29  6191D  3042   3374   5203
RRTF_02                        $ce2d  6204D  6206
RRTF_04                        $ce3e  6213D  6209   6241   6273
RRTF_06                        $ce43  6215D  6211
RRTF_08                        $ce60  6229D  6226
RRTF_10                        $ce62  6230D  6222   6224   6311
RRTF_12                        $ce67  6232D  6228
RRTF_20                        $ce73  6239D  6216
RRTF_22                        $ce79  6243D  6218   6233
RRTF_24                        $ce7b  6244D  6237
RRTF_26                        $ce84  6250D  6252
RRTF_28                        $ce8d  6255D  6248   6257
RRTF_30                        $ce94  6259D  6247   6253
RRTF_32                        $ce99  6263D  6260
RRTF_34                        $ce9c  6265D  6207   6214
RRTF_36                        $cea3  6269D  6267
Add_A_To_FAC1                  $ceb4  6278D  2519   5621   6272
RRTF_40                        $cec7  6293D  6220   6231
RRTF_42                        $ced6  6300D  6295
RRTF_44                        $cee4  6310D  6298
REAL_1e8                       $cee9  6314D  6466   6467
REAL_9x9                       $ceee  6320D  6478   6479
REAL_1e9                       $cef3  6326D  6458   6459
BSOS_TEXT                      $cef8  6331D  6339   6346   6359   6361
                                      6363
Option_ROM                     $cf01  6334D  7084
OpRO_10                        $cf03  6338D  6342
OpRO_20                        $cf11  6344D  6340
OpRO_30                        $cf13  6345D  6349
OpRO_40                        $cf21  6351D  6347   6358
BOOT_File                      $cf22  6354D  7085
BOFi_10                        $cf4e  6377D  6374
Print_IN                       $cf78  6389D  1489
Print_Integer_XA               $cf83  6399D  1945   7079   7896  12820
To_Print_String                $cf90  6410D  6394
Format_FAC1                    $cf93  6416D  2732   6407  11158
Format_FAC1_Y                  $cf95  6422D  4592
FoFA_02                        $cfa1  6439D  6437
FoFA_04                        $cfb2  6455D  6448
FoFA_06                        $cfc1  6462D  6457
FoFA_08                        $cfc3  6466D  6472
FoFA_10                        $cfd3  6476D  6481
FoFA_12                        $cfd8  6478D  6469
FoFA_14                        $cff9  6502D  6496
FoFA_16                        $cffa  6503D  6498
FoFA_18                        $d005  6509D  6507
FoFA_20                        $d016  6518D  6514
FoFA_22                        $d018  6519D  6508
Format_Jiffyclock              $d01a  6522D  3572
FoFA_78                        $d01c  6526D  6541   6544   6574
FoFA_80                        $d040  6544D  6540
FoFA_82                        $d042  6545D  6542
FoFA_84                        $d049  6549D  6546
FoFA_86                        $d064  6565D  6561
FoFA_88                        $d076  6578D  6572
FoFA_90                        $d078  6579D  6582
FoFA_91                        $d085  6586D  6584
FoFA_92                        $d095  6595D  6589
FoFA_93                        $d0a1  6601D  6603
FoFA_94                        $d0b6  6612D  6449
FoFA_95                        $d0b9  6613D  6588
FoFA_96                        $d0be  6615D  6610
Float_0_5                      $d0c7  6622D  2475   3940   3941   5300
                                      5301   6657   6658
Decimal_Conversion_Table       $d0cc  6628D  6528   6531   6534   6537
Jiffy_Conversion_Table         $d0f0  6642
Basic_SQR                      $d108  6653D  1123
Op_POWER                       $d112  6662D  1151
PWR_10                         $d11b  6669D  6667
PWR_20                         $d135  6681D  6673   6678
Op_NEGATE                      $d14b  6694D  1154   6263   6750   6899
                                      6905
NEGA_Ret                       $d155  6702D  6691   6698
REV_LOG_2                      $d156  6705D  6723   6724
VAR_EXP                        $d15b  6709D  6751   6752
Basic_EXP                      $d184  6720D  1126   6665   6688
EXP_10                         $d194  6730D  6728
EXP_20                         $d19f  6735
EXP_30                         $d1a2  6736D  6734
EXP_40                         $d1ac  6741D  6746
Square_And_Series_Eval         $d1d7  6763D  5616   6908   6971
Eval_Series_AY                 $d1ed  6777D  6753
Eval_Series                    $d1f1  6784D  6771
EvSe_10                        $d200  6795D  6793
EvSe_20                        $d204  6797D  6810
EvSe_30                        $d211  6804D  6802
RND_VA                         $d221  6813D  6840   6841
RND_VB                         $d225  6814D  6843   6844
Basic_RND                      $d229  6817D  1124
RND_10                         $d247  6837D  6827
RND_20                         $d25c  6846D  6826
RND_30                         $d26c  6854D  6836
Basic_COS                      $d282  6866D  1127
Basic_SIN                      $d289  6874D  1128   6917
SIN_10                         $d2bb  6899D  6892   6937
SIN_20                         $d2be  6900D  6895
SIN_30                         $d2cb  6906D  6904
Basic_TAN                      $d2d2  6911D  1129
TAN_10                         $d2fa  6933D  6927
PI_Half                        $d2fe  6938D  6869   6870   6974   6975
Two_PI                         $d303  6939D  6878   6879
Float_0_25                     $d308  6942D  6887   6888   6900   6901
VAR_SIN                        $d30d  6946D  6906   6907
Basic_ATN                      $d32c  6955D  1130
ATN_20                         $d341  6969D  6965
ATN_30                         $d352  6977D  6973
VAR_ATN                        $d35c  6984D  6969   6970
CHRGET_ROM                     $d399  7002D  7012   7034
CHRG_10                        $d39f  7008D  7006
CHRG_20                        $d3b0  7017D  7010
Init_BASIC_RAM_Vectors         $d3b6  7022D 13611
IBRV_10                        $d3c9  7034D  7037
IBRV_20                        $d3e8  7049D  7062   7064
IBRV_30                        $d404  7065D  7054   7058
Bytes_Free_Message             $d435  7089D  7080   7081
Monitor                        $d442  7095D  3519
MONITOR_BREAK                  $d44e  7108D 13600  13602
MOBR_05                        $d456  7116D  7114
MOBR_10                        $d499  7147D  7151
MOBR_20                        $d4a5  7152D  7145   7149
Mon_Error                      $d4a9  7156D  7173   7427   7553   9888
                                     13296  13455  13498  13582  13604
                                     13606
Mon_Main                       $d4ae  7163D  7168   7402   7443   7558
                                      7583   7928   7936   9887  12416
                                     13409  13426  13479  13497  13581
                                     13644
Mon_10                         $d4b1  7167D  7170  13340
Mon_20                         $d4ba  7171D  7153
Mon_30                         $d4bc  7172D  7175
Mon_Print_A_Hex_Values         $d4cd  7183D  7344   7397
MPAH_10                        $d4d1  7188D  7196
MPAH_12                        $d4e2  7195D  7193
MPAH_20                        $d4f1  7202D  7215
MPAH_30                        $d4fe  7208D  7205
MPAH_40                        $d500  7209D  7207
MPAH_42                        $d50b  7214D  7212
MPAH_Ret                       $d50f  7216D  7200
Mon_STAL_Register              $d510  7219D  7343
Mon_Print_Blank                $d51b  7230D  7188   7194   7197   7213
                                      7333   7338  12410  12427  12428
                                     12429  12450  13315  13317  13474
                                     13578  13640
Mon_Print_CR                   $d51e  7237D  7166   7313  11260  13406
                                     13423  13462  13565  13643  13883
Mon_Start                      $d523  7244D  7148
Mon_Commands                   $d52e  7247D  7174
Mon_Sub_Hi                     $d546  7253D  7176
Mon_Sub_Lo                     $d55d  7281D  7178
Mon_Prompt                     $d574  7309D  7332   7394  12409  13314
Display_Register               $d57c  7318D  7273   7301
DiRe_10                        $d57e  7322D  7326
DiRe_20                        $d5c3  7348D  7353
Mon_Cmp_Addr                   $d5e0  7364D  7391  12406  13568
Cmp_STAL_MEMUSS                $d5eb  7375D  7368  13477  13495  13522
Display_Memory                 $d5f4  7385D  7271   7299
DiMe_10                        $d5f7  7389D  7400   9943   9964
To_Mon_Main                    $d615  7401D  7355   7390   7392   7468
Mon_Get_Addr                   $d618  7405D  7388  12403  13538
MGA_Ret                        $d639  7423D  7414   7418
MGA_Err                        $d63a  7424D  7416   7421
To_Mon_Err                     $d63c  7426D  7450   7459   7464   7477
Modify_Register                $d63f  7430D  7261   7289
MoRe_10                        $d641  7434D  7438
Modify_Memory                  $d659  7446D  7260   7288
MoMe_10                        $d660  7452
MoMe_20                        $d66c  7458D  7467
MoMe_30                        $d67d  7465
Mon_Go                         $d684  7471D  7268   7296
MoGo_10                        $d699  7482D  7475
Mon_Step                       $d6a4  7489D 13661
Mon_Exit                       $d6be  7506D  7278   7306
Set_DOS_FNADR                  $d6c5  7514D  7539   8620  13422
Mon_Load                       $d6ce  7524D  7259   7270   7287   7298
Mon_Save                       $d6d1  7531D  7274   7302
MLS_10                         $d6e0  7541D  7544
MLS_20                         $d6e9  7545D  7552
MLS_Err                        $d6f9  7553D  7542   7546   7556   7570
                                      7576   7579   7581
MLS_30                         $d6fc  7555D  7562   7568
MLS_35                         $d6fe  7556
MLS_50                         $d706  7560D  7548   7564
Make_Hex_Byte                  $d73e  7586D  7612  13328  13332
Mon_Print_STAL                 $d74d  7601D  7395  12449  13316  13473
                                     13577
Print_Hex_Byte                 $d754  7609D  7190   7335   7337   7340
                                      7342   7605   9826  11588  12075
                                     12077  12182  12184  12425  13642
Mon_Print_XA                   $d757  7615
Nibble_To_Hex                  $d760  7625D  7594   7598  13187  13192
NTH_10                         $d767  7632D  7630
Hex_To_STAL                    $d76a  7636D  7415   7449   7571   9900
                                     13252  13443
Read_Hex_Word                  $d76c  7642D  7420   7578   9869   9872
                                     13446  13449
RHW_Ret                        $d778  7650D  7646
Read_Hex                       $d779  7653D  7434   7458   7478   7480
                                      7565   7645   7648   7660   7926
                                      7934   9874  13549  13633
Read_Hex_A                     $d780  7661D 13546
ReHe_Ret                       $d79c  7676D  7663   7672
Kernal_RECORD                  $d7af  7682D 13986
RECO_10                        $d7db  7702D  7696
RECO_20                        $d7e1  7704D  7701
RECO_30                        $d7fe  7716D  7705
RECO_40                        $d801  7717D  7692   7710   7712
Allow_Drive_Unit_Filename      $d804  7720D  8087   8341
DOS_JMP_Syntax_Error           $d808  7727D  7695   7707   7715   7739
                                      7748   7756   7765   7775
Check_Filename_Given           $d80b  7733D  7724   8290   8313
Allow_Drive_And_Unit           $d818  7744D  7866   8175
No_WL_Record                   $d81d  7752D  8234
Check_Filename_Syntax          $d824  7760D  8329
Check_Record_Syntax            $d82e  7770D  8014   8043
DOS_Build_Table                $d838  7780D  8425
Kernal_DIRECTORY               $d873  7862D 14034
DIRE_10                        $d885  7873D  7871
Wedge_Call_Dir                 $d889  7877D 12887  13425
WCD_10                         $d89e  7889D  7895   7916
WCD_20                         $d8b4  7899D  7908   7911
WCD_30                         $d8cc  7909D  7910
WCD_40                         $d8d3  7913D  7900
WCD_80                         $d8dc  7918D  7892   7902   7905
Mon_Set_Bank                   $d8e4  7923D  7264   7292
Mon_Write_Bank                 $d8ec  7931D  7277   7305
Mon_CHRIN                      $d8f4  7939D  7167   7413   7417   7474
                                      7541   7545   7561   7567   7574
                                      7658   7670   9903  13214  13260
                                     13268  13392  13398  13419  13540
                                     13556  13683  13739
Hex_To_Bin                     $d8fa  7947D  7664   7673  13686
HTB_Ret                        $d904  7956D  7954
Is_Int                         $d905  7959D 13679
Is_Hex                         $d911  7970D  7662   7671  13684
Is_Dec                         $d919  7979D 13740
IH_True                        $d921  7986D  7963   7965   7967   7976
IH_False                       $d923  7988D  7974   7983   7985
Select_Free_SA                 $d92f  7994D  8017   8046
SFSA_10                        $d931  7998D  8004
SFSA_20                        $d935  8001D  8005
SFSA_30                        $d93f  8006D  8002
Kernal_DOPEN                   $d942  8010D 13974
DOPEN_20                       $d95c  8025D  8021
DOPEN_30                       $d964  8029D  8025
DOPEN_Err                      $d96c  8032D  8016   8045   8090
Kernal_APPEND                  $d977  8039D 14016
Kernal_Read_DS                 $d991  8055D  3579   3648   6376   8100
                                      8349   9815  11503  11534  11563
                                     12895  14052
KRD_10                         $d999  8062D  8059
KDR_20                         $d9a5  8067D  8073
KDR_30                         $d9b4  8074D  8071
Kernal_HEADER                  $d9d2  8083D 13992
HEAD_10                        $d9f1  8099D  8097
HEAD_20                        $da05  8107D  8093   8102   8104
Kernal_DCLOSE                  $da07  8112D 13980
CLOSE_10                       $da11  8119D  8117
Close_All_Device_Files         $da1b  8125D  8091   8121   8137   8176
                                      8198
CLOSE_20                       $da1f  8130D  8133
CLOSE_Ret                      $da30  8138D  8131
Build_Record_Command           $da31  8141D  7716
BRC_10                         $da3d  8149D  8146
DOS_Record_No                  $da43  8153D 11562
Kernal_COLLECT                 $da65  8171D 13998
COLL_10                        $da7a  8183D  8181
Kernal_BACKUP                  $da7e  8187D 14004
BACK_Err                       $da87  8194D  8197
BACK_10                        $da8a  8195D  8193
Put_DOS_Command                $da98  8203D  8099   8184   8225   8237
                                      8334   8346
PDC_10                         $da9b  8207D  8168  11451
Kernal_COPY                    $daa7  8214D 14010
KECO_10                        $dab5  8223D  8219   8221
Kernal_CONCAT                  $dac7  8230D 13968
Copy_Filename_To_DOS_Buffer    $dad4  8240D  8429
Copy_MEMUSS_To_DOS_Buffer      $dae1  8251D  8432
CMDB_10                        $daea  8259D  8264
CMDB_20                        $daf8  8266D  8257
CMDB_30                        $daf9  8267D  8265
Insert_DOS_Id                  $dafd  8273D  8439
Kernal_DSAVE                   $db0d  8286D 14022
DSAVE_10                       $db1a  8294D  8292
DSAVE_20                       $db32  8304D  8297
Kernal_DLOAD                   $db3a  8309D 14028
DLOAD_10                       $db44  8316D  8331
DLOAD_20                       $db47  8317D  8315
Kernal_RENAME                  $db55  8325D 14040
Kernal_SCRATCH                 $db66  8337D 14046
Display_Status                 $db85  8354D 12896
DiSt_10                        $db87  8358D  8362
DiSt_Ret                       $db92  8363D  8343   8348
Are_You_Sure                   $db9e  8368D  8092   8342
AYS_10                         $dbcb  8390D  8378   8383   8386   8394
AYS_20                         $dbd5  8395D  8372   8381   8389
AYS_Ret                        $dbd6  8396D  8392
Clear_Status                   $dbe1  8401D  8119   8150   8421  12894
Build_DOS_Command              $dbfa  8411D  7874   8049   8206   8305
                                      8319
Build_DOS_Command_X            $dbfc  8417D  8030   8302  11408
BDC_10                         $dc02  8422D  8449   8454
BDC_20                         $dc14  8430D  8428
BDC_30                         $dc1b  8433D  8431
BDC_40                         $dc24  8437D  8434
BDC_50                         $dc2b  8440D  8438
BDC_60                         $dc34  8444D  8441
BDC_70                         $dc3d  8448D  8445
BDC_80                         $dc44  8451D  8447
BDC_90                         $dc46  8452D  8426   8436   8443
DOS_SETNAM                     $dc4c  8457D  8167   8423   9910
Write_Attribute                $dc57  8468D  8442
WrAt_10                        $dc60  8475D  8472
WrAt_Ret                       $dc67  8478D  8474
Parse_DOS_Parameter            $dc68  8507D  7865   8013   8042   8086
                                      8115   8174   8190   8217   8233
                                      8289   8312   8328   8340
PDP_02                         $dc8e  8526D  8523   8635
PDP_04                         $dca1  8536D  8533
PDP_08                         $dcb9  8548D  8552   8562   8587
PDP_10                         $dcbc  8550D  8527
PDP_12                         $dcd4  8561D  8529
PDP_14                         $dcdf  8566D  8531
PDP_16                         $dced  8573D  8564
PDP_20                         $dcf5  8577D  8543   8547
PDP_22                         $dcf8  8579D  8539   8638
PDP_24                         $dd00  8582D  8541
PDP_26                         $dd08  8585D  8537
PDP_28                         $dd24  8596D  8555   8568   8570   8590
PDP_30                         $dd27  8597D  8545
PDP_32                         $dd31  8601D  8599
PDP_34                         $dd35  8603D  8610
PDP_36                         $dd3b  8606D  8604
PDP_37                         $dd4a  8613D  8534
PDP_38                         $dd50  8615D  8577
PDP_40                         $dd62  8622D  8626
PDP_44                         $dd72  8629D  8559   8575   8581   8584
                                      8595   8614
PDP_46                         $dd7a  8632D  8630
PDP_48                         $dd84  8636D  8633
PDP_50                         $dd8b  8639D  8637
PDP_52                         $dd92  8642D  8640   8679
PDP_54                         $dda9  8653D  8656
PDP_56                         $ddac  8654D  8644
PDP_58                         $ddc5  8664D  8646   8681
PDP_60                         $ddcb  8666D  8648   8683
PDP_62                         $ddd1  8668D  8650   8652
PDP_64                         $dde5  8676D  8663   8665   8667
PDP_66                         $ddf6  8684D  8711   8732
PDP_68                         $ddf9  8685D  8524   8631   8677
Set_DOS_Flags                  $ddfd  8689D  8558   8574   8594   8628
                                      8662   8675   8724   8749
DOS_JMP_Illegal_Quantity       $de27  8699D  7717   8596   8659   8719
                                      8721   8736   8751
DOS_Parse_Unit                 $de2c  8706D  8579   8664
Get_Unit_Value                 $de33  8714D  8582   8666
DOS_Parse_Filename             $de49  8729D  8617   8670
DPF_10                         $de64  8744D  8742
DPF_20                         $de6a  8747D  8745
DPF_30                         $de70  8750D  8740
DPF_40                         $de7c  8756D  8753
DOS_Parse_Value                $de87  8763D  8553   8566   8588   8657
                                      8717
DOS_Get_Byte                   $de8a  8769D  7690   7708
DGB_10                         $de8f  8774D  8772
DGB_20                         $de9a  8778D  8774
Start_Message                  $de9d  8781D  7070   7071
Renumber                       $deb1  8787D  3518
Renu_Err                       $decd  8805D  8816   8831   8874
Renu_10                        $ded0  8806D  8804
Renu_15                        $df0f  8837D  8799   8810   8821
Renu_20                        $df12  8838D  8833
Renu_25                        $df1b  8845D  8884
Renu_30                        $df55  8888D  8847
Renu_35                        $df59  8890D  8892
Renu_40                        $df66  8902D  8931
Renu_45                        $dfa0  8936D  8908
Renu_50                        $dfbd  8951D  8958   8961
Renu_55                        $dfca  8957D  8954
Renu_60                        $dfd3  8962D  8956
Renu_90                        $dfd5  8963D  9804  10171
EDITOR_JUMP_TABLE              $e000  8972
EDIT_RESET                     $e037  8996D  8975  13595
EDIT_CLEAR                     $e03d  9003D  8982   9579
EDCL_10                        $e03f  9007D  9011
EDIT_HOME                      $e04a  9014D  9477  10552
Edit_Goto_Left_Margin          $e04e  9021D  9641  10587
Edit_Use_CursorRow             $e052  9028D  9257   9457   9613   9657
                                     10526
EDIT_SET_CRT                   $e057  9035D 10422  10433
ESC_10                         $e05b  9044D  9048
Edit_Program_Rows              $e067  9053D  9488
EDIT_GETIN                     $e0a7  9072D  8976   9105  11881
EDGE_10                        $e0ac  9077D  9081
Edit_Get_Line                  $e0bc  9088D  9116
EGL_10                         $e0bf  9092D  9094   9114   9156
EGL_20                         $e0d7  9105D  9097
EGL_30                         $e0e2  9110D  9113
EGL_40                         $e0ed  9115D  9107
EGL_50                         $e0f7  9120D  9123
EGL_60                         $e0fe  9124D  9121
EDIT_CHRIN                     $e116  9142D  8977  11893  11899
Edit_CHRIN_Standard            $e11d  9152D 10020  10021
Edit_CHRIN_Screen              $e121  9159D  9130   9134
ECS_05                         $e12d  9168D  9165
ECS_10                         $e139  9174D  9172
ECS_20                         $e13f  9177D  9174
ECS_30                         $e143  9179D  9167   9176   9177
ECS_40                         $e14c  9183D  9135
ECS_50                         $e15b  9190D  9182   9188
ECS_Ret                        $e163  9196
Edit_Quote_Toggle              $e164  9199D  9180   9416
EQT_Ret                        $e16e  9207D  9203
Edit_Display_Char              $e16f  9210D  9417   9446   9570   9573
EDC_10                         $e175  9216D  9214
EDC_20                         $e17b  9219D  9217
Edit_Chrout_Epilog_Return      $e186  9227D  9422
EDC_30                         $e18b  9232D  9224
Edit_Chrout_Epilog             $e18d  9235D  9259   9411   9478   9562
                                      9591   9603   9614   9642   9679
Edit_Wrap_Back                 $e196  9248D  9597
EWB_10                         $e1a5  9258D  9254
Edit_Erase_To_EOL              $e1aa  9262D  9008   9705   9720
EETE_10                        $e1ac  9266D  9269
Edit_To_Left_Margin            $e1b4  9273D  9126  13310
Edit_Full_Screen               $e1bb  9282D  9476   9489  10014
EDIT_BOTTOM_RIGHT              $e1c5  9292D  8992
EDIT_TOP_LEFT                  $e1ca  9300D  8991
CO_Shift                       $e1cf  9307D  9370
CO_Tab                         $e1d2  9310D  9318   9398
CO_Size                        $e1e2  9323D  9406
Edit_Delete_Char               $e1e5  9326D  9380
EdDC_05                        $e1e9  9331D  9315
EdDC_10                        $e1ed  9333D  9339
EDIT_CHROUT                    $e202  9350D  7150   7160   7209   7241
                                      7315   7323   7351   7620   7622
                                      7898   7903   7914   8351   8360
                                      8978   9091   9189  11789  11917
                                     12079  12187  13204  13312  13321
Edit_CHROUT_Standard           $e20c  9363D 10024  10025
CO_Exit                        $e266  9411D  9319   9331   9343   9421
                                      9425   9429   9432   9435   9443
                                      9451   9458   9465
CO_Normal                      $e269  9415D  9372
CO_Right                       $e271  9419D  9384
CO_Down                        $e27a  9424D  9386
CO_RVS                         $e27f  9427D  9388
CO_Bell                        $e285  9431D  9390
CO_ChText                      $e28a  9434D  9392
CO_Return                      $e28f  9437D  9374
CO_Escape                      $e292  9439D  9376
CO_ChNew                       $e295  9441D  9394
CO_Switch                      $e297  9442D  9583
CO_Rev                         $e29c  9445D  9378   9382
CO_Top                         $e2a1  9448D  9396
CO_ScDown                      $e2a9  9453D  9410
CO_ScUp                        $e2ac  9455D  9400
CO_DEOL                        $e2b7  9460D  9402
CODE_10                        $e2b9  9461D  9464
CO_DLine                       $e2c2  9467D  9404
CO_Home                        $e2cf  9474D  9408
CoHo_05                        $e2d3  9476
COHo_10                        $e2d6  9477D  9475
Edit_Screen_30                 $e2dc  9480D  9566
Edit_Screen_25                 $e2e2  9484D  9323
Edit_Screen_Program            $e2e6  9487D  9483
CS_Return                      $e2ef  9492D  9531
Edit_Insert_Char               $e2f2  9495D  9535
InCh_10                        $e2fa  9502D  9509
InCh_20                        $e307  9510D  9506
Edit_CHROUT_Shifted            $e316  9522D  9307
CS_Exit                        $e360  9562D  9501   9515   9517   9577
                                      9580   9588   9596   9623
CS_Size                        $e363  9566D  9561
CS_Pi                          $e366  9567D  9527
CS_Print                       $e369  9569D  9529
CS_Rev                         $e36e  9572D  9533   9537
CS_RVS                         $e373  9575D  9543
CS_Clear                       $e379  9579D  9490   9545
CS_ChOld                       $e37e  9582D  9551
CS_Bottom                      $e383  9585D  9555
CS_Graph                       $e38b  9590D  9557
CS_Left                        $e391  9593D  9539
CS_Tab                         $e39c  9599D  9547
CS_Up                          $e3ab  9605D  9541
CS_ScDown                      $e3b5  9611D  9453   9553   9607
COSW_10                        $e3bb  9613D  9609
CS_Delete_BOL                  $e3c1  9617D  9549
CSDB_10                        $e3c5  9622D  9626
CS_Insert_Line                 $e3ce  9631D  9559
TM_Epi                         $e3d8  9639D  9472
Edit_Cursor_Down               $e3e1  9647D  9230   9424   9669
CSCD_10                        $e3ef  9656D  9653
CO_Screen_Return               $e3f4  9662D  9437   9492
CO_JMP_Escape                  $e3ff  9672D  9439
Edit_Scroll                    $e40a  9682D  9703   9718
ES_10                          $e40d  9686D  9690
EDIT_SCROLL_DOWN               $e417  9695D  8986   9611   9638  10567
ESD_10                         $e419  9699D  9704
ESD_30                         $e426  9705D  9701
EDIT_SCROLL_UP                 $e429  9710D  8987   9455   9471   9654
ESU_10                         $e42b  9714D  9719
ESU_30                         $e438  9720D  9716
IRQ_MAIN                       $e442  9727D  8979  14151
IRQ_05                         $e452  9740D  9738
IRQ_NORMAL                     $e455  9743D  8980   9983   9985  13672
IRQ_10                         $e470  9759D  9756
IRQ_20                         $e474  9761D  9748   9750
IRQ_END                        $e477  9762D  8981
Delete                         $e47d  9770D  3520
Del_10                         $e4a3  9789D  9787
Del_20                         $e4ab  9792D  9790
Del_30                         $e4af  9794D  9797   9801
DelErr                         $e4c5  9805D  9782
Get_Record_Size                $e4c8  9809D  9833  11608
GRS_90                         $e4fa  9834D  9820   9829
Mon_Message                    $e4fb  9837D  7322
IS_TAB                         $e525  9843D  9317   9599
BITPOS                         $e537  9859D  9601   9854
Mon_Fill                       $e53f  9865D  7267   7295
MoFi_10                        $e555  9878D  9886
MoFi_End                       $e569  9887D  9882
MoFi_Err                       $e56c  9888D  9870   9873   9875
Open_Disk_Buffer               $e56f  9894D  9927
ODB_20                         $e580  9903D  9909
ODB_30                         $e58f  9910D  9907
Mon_Disk                       $e5a7  9922D  7276   7304
MIB_30                         $e5c0  9937D  9940
Mon_Output_Block               $e5d1  9946D  9930
MOB_10                         $e5e0  9957D  9960
Edit_Init                      $e606  9969D  8999
EdIn_10                        $e611  9977D  9979
EdIn_20                        $e66d 10017D 10019
Double_Beep                    $e68a 10033D 10030
EDIT_BEEP                      $e68d 10039D  8989   8990   9431  10036
BEEP_10                        $e69d 10049D 10058
BEEP_20                        $e6a5 10052D 10053  10056
BEEP_Ret                       $e6b6 10061D 10043
Set_Screen_SAL                 $e6b7 10064D  9685
Cursor_BOL                     $e6c9 10080D  9007   9699   9714  10507
Update_ScrPtr                  $e6cb 10090D  9032
RUN_String                     $e6dd 10106D  9110
CRT_TEXT                       $e6e5 10113D 10420  10421
CRT_GRAPHICS                   $e6f7 10139D 10431  10432
OLD                            $e701 10157D  3524
SOUND_TAB                      $e74e 10176D 10049
Line_Addr_Lo                   $e755 10182D 10071  10097  10455
Line_Addr_Hi                   $e76e 10191D 10075  10101  10460
B_P_0                          $e78e 10199D 10208  10211
U1                             $e796 10200D 10220
Reset_BP                       $e79b 10203D  9951
RBP_30                         $e7a0 10208D 10212
Preset_U1                      $e7ae 10216D  9897
PU1_10                         $e7b0 10220D 10223
Mon_Disk_Comm                  $e7ba 10227D  9931   9962
MDC_10                         $e7bf 10232D 10236
PIA1_Port_A                    $e810   950D  9992  10263  10265  10324
                                     11854
PIA1_Cont_A                    $e811   951D 10004  11680  11685
PIA1_Port_B                    $e812   952D 10000  10276  10277
PIA1_Cont_B                    $e813   953D  9999
PIA2_Port_A                    $e820   970D 11858
PIA2_Cont_A                    $e821   971D 10002  11676  11778  11841
                                     11862  11866
PIA2_Port_B                    $e822   972D  9996  10005  11706  11721
PIA2_Cont_B                    $e823   973D 10003  11699  11710  11719
VIA_Port_B                     $e840  1014D  9994  11672  11674  11689
                                     11692  11700  11707  11713  11735
                                     11737  11774  11776  11822  11824
                                     11842  11844  11849  11851  11853
                                     11863
VIA_Port_A                     $e841  1015
VIA_DDR_B                      $e842  1016D  9995
VIA_DDR_A                      $e843  1017
VIA_Timer_1_Lo                 $e844  1018D  6828
VIA_Timer_1_Hi                 $e845  1019D  6832   9997  11712  11846
VIA_Timer_1_Latch_Lo           $e846  1020
VIA_Timer_1_Latch_Hi           $e847  1021
VIA_Timer_2_Lo                 $e848  1022D  6830  10050  13658  13670
VIA_Timer_2_Hi                 $e849  1023D  6834  13660
VIA_Shift                      $e84a  1024D 10047  10059
VIA_ACR                        $e84b  1026D 10045  10060
VIA_PCR                        $e84c  1031D 10419  10430
VIA_IFR                        $e84d  1033D 11714  11847  13667
VIA_IER                        $e84e  1043D  9973  10011  13656
VIA_Port_A_no_HS               $e84f  1044
CRT_Address                    $e880  1049D  9045   9062   9065  10401
CRT_Value                      $e881  1050D  9046   9063   9066  10402
EDIT_KEY_SCAN                  $e924 10258D  8988   9761
ScKbd_02                       $e93a 10276D 10278  10325
ScKbd_04                       $e944 10283D 10320
ScKbd_06                       $e95c 10308D 10291  10293  10299
ScKbd_08                       $e960 10313D 10304
ScKbd_10                       $e961 10314D 10284
ScKbd_12                       $e96c 10329D 10315
ScKbd_22                       $e972 10332D 10341  10343
ScKbd_13                       $e973 10336D 10330
ScKbd_14                       $e97f 10342D 10339
ScKbd_15                       $e98b 10348D 10346
ScKbd_16                       $e98f 10353D 10337
ScKbd_18                       $e995 10356D 10349
ScKbd_24                       $e9a2 10365
ScKbd_26                       $e9a7 10370D 10361
ScKbd_28                       $e9af 10374D 10372
ScKbd_30                       $e9b1 10375D 10358
Lookup_Keycode                 $e9b4 10379D 10356
LoKe_10                        $e9bf 10387D 10385
LoKe_20                        $e9c0 10388D 10384
LoKe_30                        $e9c6 10391D 10388
Edit_Switch_Char_ROM           $e9ca 10395D  9442
EDIT_RESET_CRT                 $e9d3 10407D  8985   9000
EDIT_CHARSET_TEXT              $e9d6 10414D  8983   9434
EDIT_CHARSET_GRAPHICS          $e9e4 10425D  8984   9590
Read_Power_String              $e9f2 10436D  1503
Check_Linenumber               $e9fc 10446D 10479  10491
ChLi_Ret                       $ea1c 10467D 10464
Check_Line_Upwards             $ea1f 10472D 10515
CLU_10                         $ea21 10476D 10480
CLU_Ret                        $ea2b 10481D 10477
Check_Line_Downwards           $ea2c 10484D 10539
CLD_10                         $ea2e 10488D 10492
CLD_Ret                        $ea38 10493D 10489
Power_Scroll_Up                $ea39 10496D  9456   9655
PSU_10                         $ea4b 10509D 10513
PSU_20                         $ea61 10520D 10518
PSU_30                         $ea67 10522D 10510  10516  10540  10547
                                     10556  10579
PSU_Ret                        $ea70 10527D 10500  10534
Power_Scroll_Down              $ea71 10530D  9612
PSD_20                         $ea8f 10548D 10544
PSD_30                         $eaa7 10559D 10562
List_BASIC_Line                $eace 10584D 10521  10553  10578  11259
                                     13882
LBL_Ret                        $eae3 10598D 10590
Find_Power_Line                $eae4 10601D  8824  10520  10541
FPL_10                         $eaec 10608D 10630
FPL_40                         $eb14 10631D 10612  10619
KEYBOARD_NORMAL                $eb15 10634D 10391
KEYBOARD_SHIFTED               $eb65 10758D 10389
KEYBOARD_CONTROL               $ebb6 10874D 10382
Find_Entry                     $ec07 10969D  8917
Find_LINNUM                    $ec0b 10976D 11148
FiEn_10                        $ec17 10986D 11007
FiEn_20                        $ec38 11002D 10989
FiEn_30                        $ec3b 11005D 10991  10995
Install_Bank_Access            $ec43 11011D  7126   8838
FSC_10                         $ec45 11015D 11019
Bank_Fetch_Start               $ec51 11023D   892  11015  11018
Bank_Store_Start               $ec62 11042D   892
Bank_Fetch_End                 $ec62 11038
Bank_Store_End                 $ec75 11059D 11018
Get_Next                       $ec75 11064D 11097  11103  11112  11128
GeNe_10                        $ec7b 11070D 11068
Xfer_Line                      $ec7e 11074D  8924
XfLi_10                        $ec8f 11096D 11108  11117  11133
XfLi_20                        $ec9c 11102D 11107
XfLi_30                        $ecab 11109D 11101
XfLi_40                        $ecaf 11111D 11114
XfLi_50                        $ecb9 11116D 11110  11136
XfLi_55                        $eccf 11127D 11131
XfLi_60                        $ecda 11132D 11126
XfLi_70                        $ecde 11134D 11118  11120  11122  11124
XfLi_Ret                       $ece5 11137D 11099  11105
Exchange_Number                $ece6 11141D 11134  11172
ExNu_10                        $ed09 11162D 11167
ExNu_20                        $ed15 11168D 11146  11163
ExNu_Ret                       $ed21 11173
Reset_Renumber_Pointer         $ed22 11176D  8837   8898   8949  11254
                                     13842
Reset_BPTR                     $ed2a 11187D  8832
Update_Link                    $ed33 11197D  8883   8928   9791  11261
                                     13852
Extended_Command               $ed40 11211D 12847
ExCo_10                        $ed44 11216D 11243
ExCo_20                        $ed48 11219D 11224
ExCo_30                        $ed6a 11238D 11226
ExCo_40                        $ed6c 11239D 11241
Find_Text                      $ed78 11248D  3521
FiTe_10                        $ed83 11255D 11262
FiTe_20                        $ed92 11261D 11258
Contains_Pattern               $ed9a 11266D 11257  13847
CoPa_10                        $ed9a 11269D 11281
CoPa_20                        $ed9e 11271D 11278
CoPa_Ret                       $edb5 11283D 11274  11276
Load_Directory                 $edb6 11286D 11409
LoDi_10                        $edc6 11297D 11309
LoDi_20                        $edd0 11302D 11300
LoDi_30                        $edd2 11303D 11308
LoDi_40                        $ede0 11310D 11306
DOS_Get_Dir_Entry              $ede3 11313D 11367  11417
DGDE_05                        $edee 11328D 11325
DGDE_10                        $edf0 11330D 11333
DGDE_20                        $ee17 11353D 11358
DGDE_40                        $ee22 11360D 11356
DGDE_60                        $ee24 11362D 11365
DGDE_80                        $ee33 11371D 11334
DOS_Add_Comma                  $ee34 11374D 11428  11435  11442
DOS_Copy                       $ee3a 11395D  8222
DOSC_10                        $ee60 11417D 11553
DOSC_15                        $ee67 11422D 11419
DOSC_20                        $ee8a 11440D 11431
DOSC_25                        $ee92 11445D 11438
DOSC_35                        $eea7 11467D 11461
DOSC_47                        $eead 11472
DOSC_50                        $eeb5 11477D 11473
DOSC_55                        $eeb8 11481D 11531  11536  11538
DOSC_60                        $eeca 11490D 11497
DOSC_65                        $eeda 11499D 11495
DOSC_66                        $eeea 11507D 11502
DOSC_67                        $eefd 11517D 11514
DOSC_70                        $ef07 11522D 11528
DOSC_75                        $ef2b 11540D 11505  11525  11533
Send_Record_No                 $ef4c 11556D 11515
SRN_10                         $ef52 11562D 11560
Print_Filename                 $ef5d 11569D 11467
PrFi_10                        $ef64 11575D 11590
PrFi_20                        $ef82 11589D 11579  11582
PrFi_90                        $ef86 11591D 11573
Open_Read_File                 $ef87 11594D 11468
ORF_10                         $efa1 11609D 11607
Open_Write_File                $efa4 11612D 11477
KERNAL_MESSAGES                $f000 11630D 11786
MSG_TOO_MANY                   $f000 11633
MSG_FILE_OPEN                  $f00e 11634D 12355
MSG_FILE_NOT_O                 $f017 11635D  8147  12772
MSG_FILE_NOT_F                 $f024 11636D 12385
MSG_SEARCHING                  $f032 11637D 12203
MSG_FOR                        $f03d 11638
MSG_PRESS                      $f041 11639
MSG_RECORD                     $f04d 11640
MSG_ON_TAPE                    $f056 11641
MSG_LOAD                       $f05f 11642D 12198
MSG_WRITING                    $f064 11643
MSG_VERIFY                     $f06d 11644D 12201  12277
MSG_DEVICE_NOT                 $f074 11645D 12255  12774
MSG_NOT_INPUT                  $f086 11646
MSG_NOT_OUTPUT                 $f094 11647D 12776
MSG_FOUND                      $f0a3 11648
MSG_OK                         $f0aa 11649D 12279
MSG_READY                      $f0ae 11650D 12164
MSG_SURE                       $f0b6 11651D  8373
MSG_BAD_DISK                   $f0c5 11652D  8105
TALK                           $f0d2 11655D  8062   9932  11483  12117
                                     12760
LISTEN                         $f0d5 11662D  8207   9913   9952  11517
                                     12244  12652  12681  12800  13383
TALI_10                        $f0d7 11668D 11833
TALI_20                        $f0fa 11686D 11678
TALI_30                        $f0ff 11689D 11690
Send_IEEE_Byte                 $f109 11695D 11681  11729  11800  11813
SIB_10                         $f11e 11707D 11708
SIB_20                         $f128 11711D 11747
SIB_30                         $f12d 11713D 11717
tby6                           $f138 11718D 11759
SECOND                         $f143 11725D  9915   9955  11520  12252
                                     12654  12685  12802  13386
Set_ATN                        $f148 11732D 11802  11834
Time_Out_Writing               $f151 11741D 11715
Time_Out_Reading               $f15b 11750D 11848
Timo_W                         $f165 11757D 11745
Timo_S                         $f167 11758D 11766
Device_Not_Present             $f16c 11762D 11703
Timo_R                         $f170 11767D 11754
Set_NRFD_NDAC_low              $f175 11771D 11801
Display_Kernal_Message         $f185 11783D  8106   8374  11792  12042
                                     12280  12396
TKSA                           $f193 11796D  8065   9935  11486  12119
                                     12762
CIOUT                          $f19e 11805D  9917   9958  10209  10234
                                     11523  11918  12259  12658  12660
                                     12668  12868  13397
Ciout_10                       $f1a6 11812D 11809
Ciout_20                       $f1ab 11815D 11811
UNTLK                          $f1ae 11819D  6375   8076   9941  11500
                                     11940  12103
UNLSN                          $f1b9 11829D  7884   9918   9961  10213
                                     10237  11529  11540  11936  12263
                                     12675  12686  12871  13400
ACPTR                          $f1c0 11837D  7889   7893   7899   8067
                                      9937  11303  11490  11904  12083
                                     12120  12122
Acptr_10                       $f1cd 11845D 11756
Acptr_20                       $f1d2 11847D 11850
Acptr_30                       $f1ee 11858D 11855
Acptr_40                       $f1f9 11863D 11864
Kernal_GETIN                   $f205 11871D 14130
GETIN_10                       $f20d 11878D  7906   7909
Kernal_CHRIN                   $f215 11884D  7942   8376   8379   8384
                                      8387   8393   9898   9901  14088
KeIn_10                        $f224 11894D 11877  11888
KeIn_20                        $f231 11900D 11895
KeIn_30                        $f237 11903D 11879
KeIn_40                        $f238 11904D 11901
Kernal_CHROUT                  $f266 11909D 12393  12395  14094
KeCH_10                        $f271 11918D 11916
Kernal_CLALL                   $f2a2 11923D 12391  14136
Kernal_CLRCHN                  $f2a6 11930D  7117   7918   8375  12024
                                     14082
KeCL_10                        $f2af 11937D 11935
Set_Default_IO                 $f2b8 11943D 11939
LOOKUP_LA                      $f2c1 11953D  8145  11991  12356  12755
                                     12794
LOOK_10                        $f2c3 11957D 11960
LOOK_Ret                       $f2cb 11961D 11958
Set_LFS_From_X                 $f2cd 11966D  8149  11998  12757  12796
Kernal_CLOSE                   $f2dd 11981D 14064
Close_LA_in_A                  $f2e2 11988D  7920   8122
Close_File_A                   $f2e7 11995D  8135
ClFi_10                        $f2f1 12002D 12000
ClFi_20                        $f30b 12012D 11992  12004
Check_STOP_Key                 $f335 12017D  7389   7904  12033  12404
                                     13566  13845
ChST_Ret                       $f342 12027D 12022  12041
Kernal_STOP                    $f343 12030D  2066  11746  11755  12082
                                     12669  14124
Kernal_Message_If_Direct       $f349 12037D 12165  12202  12204
In_Direct_Mode                 $f351 12045D  8103   8347   8371  11572
                                     12040  12071  12098  12105  12166
Load_File                      $f356 12053D  7557  12161
LoFi_10                        $f35c 12059D 12061
LoFi_15                        $f35f 12060D 12058
LoFi_20                        $f370 12068D 12065
LoFi_25                        $f377 12071D 12069
LoFi_30                        $f38e 12080D  6377  12072
LoFi_35                        $f390 12081
LoFi_40                        $f392 12082D 12102
LoFi_45                        $f3a7 12091D 12085
LoFi_50                        $f3a9 12092D 12094
LoFi_55                        $f3af 12095D 12087
LoFi_60                        $f3bd 12101D 12096  12099
LoFi_70                        $f3c1 12103D 11310  12090
LoFi_80                        $f3cd 12108D 12106
Open_Load_File                 $f3d0 12111D  6372  11289  12063
Merge                          $f3e6 12125D  3523
Kernal_LOAD                    $f401 12134D 14100
KeLO_10                        $f403 12138D 12129
Load_Verify                    $f405 12141D 12273
Load_Verify_Params_Set         $f41d 12158D  8322  12146  12922
LVPS_20                        $f439 12173D 12167
LVPS_Ret                       $f43f 12175D 12163
Print_EAL                      $f440 12178D 12100  12108
PrEA_10                        $f44e 12187D 12189
PrEA_Ret                       $f454 12190
Display_Load_Or_Verify         $f46d 12195D 12073
DLOV_10                        $f475 12202D 12200
Get_File_Parameter             $f47d 12207D 12144  12636
GFP_Ret                        $f4a8 12229D 12243
Get_Comma_And_Byte             $f4a9 12232D 12220  12223  12295  12298
Send_Filename                  $f4af 12239D  9814  11609  11624  12116
                                     12376  12651
Send_DOS_Command               $f4ba 12249D  8209
SeDC_10                        $f4c6 12257D 12254
SeDC_20                        $f4c8 12258D 12262
Kernal_VERIFY                  $f4f6 12268D 14112
VERI_OK                        $f508 12279D 12276
Get_Open_Close_Parameter       $f50d 12283D 11984  12347
Set_Filename_From_String       $f53c 12307D 12218  12302
ChrGot_Or_RTS                  $f54d 12320D 12217  12219  12222  12294
                                     12297  12300
Get_Ret                        $f554 12327D 12324  12340  12372  12374
Get_Comma_And_Chr              $f555 12330D 12235  12301
Assert_Not_At_End              $f558 12336D 12291
Err_f55d                       $f55d 12341D 12354  12375
Kernal_OPEN                    $f560 12344D 14058
Mf563                          $f563 12348D  8031   8050
Open_File                      $f565 12351D  7885
Display_File_Not_Found         $f5ad 12382D 12070
Handle_IO_Error                $f5af 12388D  8148  12256  12278  12357
                                     12362  12777
Disassemble                    $f5c2 12400D  7266   7294
Disa_10                        $f5c5 12404D 12414
Disa_15                        $f5cf 12408D  7360
Disa_Main                      $f5e3 12416D 12405  12407
Print_Dis_Line                 $f5e6 12419D 12412  13319
Disa_20                        $f5e9 12424D 12432
Disa_40                        $f5f2 12427D 12434
Disa_50                        $f5f8 12429D 12426
Dis_Inst                       $f614 12446D 12411
DiIn_10                        $f61c 12452D 12455
Analyze_Opcode                 $f625 12458D 13277
AnOp_10                        $f634 12482D 12475
AnOp_20                        $f63f 12490D 12485
AnOp_30                        $f643 12492D 12477  12479
AnOp_40                        $f647 12494D 12491
AnOp_50                        $f65c 12506D 12515
AnOp_60                        $f660 12509D 12512
AnOp_70                        $f667 12514D 12505  12507
admode_index                   $f66b 12519D 12484
Kernal_SYS                     $f6c3 12611D 14118
Set_Save_Range                 $f6cc 12619D 12637
Kernal_SAVE                    $f6dd 12633D 14106
Mf6e0                          $f6e0 12637D  8303   8306
Save_File                      $f6e3 12640D  7582
SaFi_10                        $f6e9 12646D 12650
SaFi_20                        $f6ec 12647D 12645
SaFi_30                        $f70f 12663D 12671  12674
SaFi_40                        $f717 12667D 12664
SaFi_50                        $f727 12675D 12666
Close_Disk_File                $f72a 12678D  9942   9963  11545  11552
                                     12001  12104
Store_Mnemonic                 $f739 12689D 12436  13279
PrMn_10                        $f746 12698D 12709
PrMn_20                        $f74a 12700D 12704
Kernal_UDTIM                   $f768 12716D  9746  12737  14142
ud_10                          $f772 12724D 12722
ud_20                          $f784 12733D 12720  12726  12729
ud_30                          $f78e 12738D 12734
Kernal_CHKIN                   $f7af 12743D  7887  14070
CHKIN_10                       $f7d0 12766D 12759
CHERR_17                       $f7d6 12772D 12756  12795
CHERR_74                       $f7d9 12774D 12764  12804
CHERR_94                       $f7dc 12776D 12797
CHERR_IO                       $f7de 12777
Kernal_CHKOUT                  $f7fe 12782D 14076
KeCo_10                        $f821 12806D 12799
Set_Wedge_Unit                 $f827 12813D 12842
SWUN_10                        $f838 12823D 12817
Wedge_Parser                   $f842 12829D  1513
Command_Or_Status              $f869 12852D 12836  12838
Send_Command                   $f873 12862
SeCo_10                        $f876 12866D 12870
SeCo_20                        $f880 12871D 12867
Get_Status                     $f883 12874D 12857
Wedge_Directory                $f88c 12882D 12840  12859
Print_Status                   $f898 12891D 12878  13408
RUN_Now                        $f8a1 12898D 12906
Wedge_Run                      $f8a6 12901D 12846
WeRu_10                        $f8aa 12906D 12909
Wedge_Load                     $f8b3 12912D 12844  12919
WeLo_10                        $f8be 12920D 12917
Wedge_Prepare                  $f8c7 12925D  6365   7540   9911  12877
                                     12886  12921  13382  13407  13424
Wedge_Filename                 $f8d0 12935D 12885  12920
WeFi_10                        $f8db 12943D 12941  12947
WeFi_20                        $f8e4 12948D 12945
Mnemonic_Left                  $f8f3 12958D 12694
Mnemonic_Right                 $f933 13027D 12696
admode_format                  $f973 13096D 12495
adr_char1                      $f981 13124D 13154
adr_char2                      $f987 13125D 13157
Store_Address                  $f98d 13128D 12437  13280
StAd_10                        $f99f 13140D 13162
StAd_20                        $f9ae 13147D 13144
StAd_30                        $f9b9 13152D 13141
StAd_40                        $f9cd 13161D 13153  13158
StAd_50                        $f9d2 13164D 13149
StAd_Ret                       $f9d8 13166D 13135  13163
Store_Hex_XA                   $f9dc 13171D 13165  13778
Store_Hex                      $f9e2 13179D 13146  13151  13175  13716
                                     13718
Print_Dis_Buf                  $f9f9 13199D 12438
PDB_10                         $f9fb 13203D 13207
Ass_Operand                    $fa08 13211D 13217  13223  13274
AsOp_30                        $fa1e 13224D 13215  13219
AsOp_Ret                       $fa3e 13240D 13226  13229  13231
AsOp_40                        $fa3f 13241D 13233
Assemble                       $fa42 13245D  7258   7263   7286   7291
Ass_010                        $fa47 13254D 13263
Ass_020                        $fa55 13260D 13267
Ass_040                        $fa76 13275D 13269
Ass_050                        $fa79 13276D 13290  13295
Ass_060                        $fa8f 13284D 13288
Ass_070                        $fa9a 13289D 13283
Ass_Err                        $faaa 13296D 13253  13261  13271  13292
                                     13307
Ass_080                        $faad 13297D 13285
Ass_090                        $fab9 13303D 13309
Inc_STAL                       $fb19 13343D 13475  13493  13579
Add_STAL                       $fb1b 13349D  7399  11006
AdST_00                        $fb1c 13353D 12441
AdST_10                        $fb22 13356
AdST_Ret                       $fb24 13357D 13355
Inc_BPTR                       $fb25 13361D  9885  13476  13494
Add_BPTR                       $fb27 13367D  8879   8927
AdBP_00                        $fb28 13371
AdBP_10                        $fb2e 13374
AdBP_Ret                       $fb30 13375D 13373
DOS_Open_Comm_Write            $fb31 13379D 10206  10230  12865  13395
Mon_Wedge                      $fb3e 13389D  7262   7290
MoWe_10                        $fb48 13397D 13399
Mon_Wedge_Status               $fb53 13403D 13393
Mon_Dir                        $fb5f 13412D  7257   7285
MoDi_10                        $fb63 13417D 13420
Set_STATUS                     $fbc4 13431D 11758  11768  11857  12089
Mon_Get_3                      $fbc9 13440D 13461  13485
MG3_Err                        $fbdf 13453D 13444  13447  13450
Mon_Compare                    $fbe4 13458D  7265   7293
MoCo_10                        $fbea 13463D 13478
MoCo_20                        $fc08 13475D 13472
Mon_Transfer                   $fc16 13482D  7275   7303
MoTr_10                        $fc23 13491D 13496
MoTr_Ret                       $fc34 13497D 13523
MoTr_Err                       $fc37 13498D 13512
MoTr_20                        $fc3a 13499D 13490
MoTr_30                        $fc62 13520D 13532
MoTr_40                        $fc73 13527D 13525
MoTr_50                        $fc7b 13531D 13529
Mon_Hunt                       $fc80 13535D  7269   7297
MoHu_10                        $fc85 13540D 13543
MoHu_20                        $fc99 13549D 13554
MoHu_30                        $fc9e 13551D 13548
MoHu_40                        $fca8 13556D 13545  13563
MoHu_50                        $fcb9 13564D 13550  13555  13557  13559
MoHu_60                        $fcbe 13566D 13580
MoHu_70                        $fcca 13571D 13576
MoHu_80                        $fcdd 13579D 13573
MoHu_Ret                       $fce2 13581D 13567  13569
MoHu_Err                       $fce5 13582D 13541  13547
Entry_RESET                    $fd16 13588D 14150
Entry_NMI                      $fd49 13616D 14149
Set_FA_to_8                    $fd4c 13622D 12290
Mon_Unit                       $fd51 13630D  7256   7284
MoUn_10                        $fd60 13640D 13634  13636  13638
Mon_Next                       $fd6e 13647D  7272   7300
Mon_Step_IRQ                   $fd89 13664D 13651  13653
MSI_10                         $fd96 13672D 13669
Get_Constant                   $fd99 13676D 13218
GeCo_10                        $fda2 13683D 13694
GeCo_20                        $fdaf 13688D 13691
GeCo_25                        $fdbd 13695D 13742
GeCo_30                        $fdcf 13705D 13685  13697
GeCo_40                        $fde4 13717D 13715
GeCo_Ret                       $fdef 13724D 13680  13699
GeCo_45                        $fdf2 13726D 13682
GeCo_50                        $fdfc 13731D 13741
GeCo_70                        $fe0d 13739D 13728  13730
Expand_Address                 $fe17 13746D 13294
ExAd_10                        $fe1a 13750D 13755
ExAd_20                        $fe27 13756D 13752
Expand_Target                  $fe36 13764D 13241
Offset_To_Target               $fe46 13784D 13164  13777
OTT_10                         $fe4d 13796D 13794
OTT_20                         $fe53 13800D 13798
OTT_30                         $fe59 13804D 13802
Replace                        $fe5a 13809D  3522
Repl_00                        $fe67 13817D 13814
Repl_01                        $fe6b 13819D 13823
Repl_02                        $fe82 13831D 13835
Repl_08                        $fe9a 13843D 13853
Repl_10                        $fe9e 13845D 13851
Repl_20                        $feb0 13852D 13848
Repl_Ret                       $feb8 13855D 13846
Repl_Err                       $febb 13856D 13821  13833
Replace_String                 $febe 13860D 13849
ReSt_05                        $fec7 13868D 13918
ReSt_10                        $fece 13873D 13878
ReSt_20                        $fed9 13879D 13875
ReSt_25                        $fee0 13882D 13880
ReSt_30                        $fee7 13885D 13867
ReSt_35                        $fefb 13898D 13896
ReSt_40                        $ff0a 13906D 13904
ReSt_45                        $ff1d 13916D 13959
ReSt_50                        $ff21 13919D 13885
ReSt_60                        $ff43 13938D 13948  13951
ReSt_62                        $ff4d 13943D 13941
ReSt_64                        $ff53 13946D 13944
ReSt_Ret                       $ff6f 13960
Basic_CONCAT                   $ff93 13965D  1095
Basic_DOPEN                    $ff96 13971D  1096
Basic_DCLOSE                   $ff99 13977D  1097
Basic_RECORD                   $ff9c 13983D  1098
Basic_HEADER                   $ff9f 13989D  1099
Basic_COLLECT                  $ffa2 13995D  1100
Basic_BACKUP                   $ffa5 14001D  1101
Basic_COPY                     $ffa8 14007D  1102
Basic_APPEND                   $ffab 14013D  1103
Basic_DSAVE                    $ffae 14019D  1104
Basic_DLOAD                    $ffb1 14025D  1105
Basic_DIRECTORY                $ffb4 14031D  1106   1109
Basic_RENAME                   $ffb7 14037D  1107
Basic_SCRATCH                  $ffba 14043D  1108
Read_DS                        $ffbd 14049
OPEN                           $ffc0 14055D  1090
CLOSE                          $ffc3 14061D  1091
CHKIN                          $ffc6 14067D  2878   2898
CHKOUT                         $ffc9 14073D  2705
CLRCHN                         $ffcc 14079D  1470   2907
CHRIN                          $ffcf 14085D  1642
CHROUT                         $ffd2 14091D  1478   2754   2808   2837
                                      9823   9824  11547  11577  11583
                                     11585
Basic_LOAD                     $ffd5 14097D  1078
Basic_SAVE                     $ffd8 14103D  1079
Basic_VERIFY                   $ffdb 14109D  1080
Basic_SYS                      $ffde 14115D  1089
STOP                           $ffe1 14121D  1900
GETIN                          $ffe4 14127D  2993
CLALL                          $ffe7 14133D  1827
UDTIM                          $ffea 14139
HardwareVectors                $fffa 14146
INDEXA                         $001f   352D  1376   1386   1392   1532
                                      1534   1557   1559   1561y  1565
                                      1617y  1621   1624y  1626   1628y
                                      1629   1630   1631y  1686   1688
                                      1691   1693   1696y  1727y  1729
                                      1731   1734y  1977   1979   1983
                                      1985   1986y  1990y  2514y  2588
                                      2589   2602   2604   2635y  2639y
                                      2642y  2649   2650   2654   2656
                                      2807y  3253   3255   3310   3312
                                      3327   3329   3994   3995   3997y
                                      4000y  4003y  4007y  4015y  4019
                                      4020   4022   4023   4029y  4033y
                                      4037y  4046   4049   4053   4054
                                      4056   4280   4348   4381   4708
                                      4711   4716   4728y  4731y  4783
                                      4785   4788y  4798   4802y  4813y
                                      4823y  4826y  4916   4917   4927y
                                      4960   4961   4971   4972   4987y
                                      4990y  4993y  4995   4996   5054
                                      5055   5057   5147y  5187   5190
                                      5192   5703   5704   5706y  5709y
                                      5712y  5715y  5723y  5903   5904
                                      5906y  5958   5959   5962y  5965y
                                      5968y  5973y  5976y  8622y  8738y
                                      8744   8746   8756   8757  10166
                                     10169  12313  12315
TMPPTC                         $005c   508D  1375   1379   1531y  1535
                                      1537   1539y  1547   1550   1595y
                                      1756   1757   1758y  1763y  1768y
                                      1772y  1898y  1906y  1909y  1927y
                                      1930y  1931   1932   1956y  1965y
                                      2253   2256   3899   3900   3906y
                                      3910y  3915   3964   3965   4061y
                                      4064y  4067y  4069y  4071y  4073y
                                      4075y  4076   4079   4095   4096
                                      4189   4190   4196y  4201y  4204y
                                      4206   4209y  4210   4235y  4247y
                                      4252y  4261y  4273y  4276y  4308
                                      4310y  4313   4314y  4318y  4329y
                                      4334y  4382y  4385y  6229   6232
                                      6239   6240   6266   6297   8846y
                                      8852y  8855y  8903y  8906y  8913y
                                      8916y  8952y  8959   8962   9776
                                      9778   9794y  9799   9800  10542
                                     10545  10549  10551  10571y 10574y
                                     10575  10576  10589y 10592y 10595y
                                     10608  10609  10611y 10614y 10617y
                                     10620  10622  10626y 10629y 11088
                                     11091  11182  11184  11201y 11204y
                                     11205  11206  11277y 11280y 13876y
                                     13888  13890  13894  13895  13897
                                     13913  13915  13921  13923
FAC1M3/FAC1M4                  $0061   515D  2460   2544y  2547y  2563
                                      2566   2573y  2578   2683   2684
                                      3319   3423   3553   3592y  3595y
                                      3667   3694   3728   3740   3745
                                      4171   4326   4345   4603   4679
                                      4870   4881y  4949   5171   5244
                                      5388   5412   5415   5437   5439
                                      5451   5471   5494   5496   5512
                                      5646   5830   5856   5894   5925
                                      5964   6071   6115   6148   6530
                                      6532   6833   6851   6853    516D
                                      2367   2463   2559   2567   2579
                                      2680   2681   3317   3420   3554
                                      3559   3604   3668   3692   3730
                                      3737   3742   4173   4328   4349
                                      4604   4680   4868   4950   5077
                                      5093   5095   5173   5245   5385
                                      5414   5417   5434   5436   5450
                                      5472   5497   5499   5510   5644
                                      5833   5853   5896   5926   5961
                                      6070   6121   6149   6179   6184
                                      6527   6529   6835   6846   6848
TXTPTR                         $0077   564D  1504   1505   1657   1684
                                      1725   1739   1741   1862   1865
                                      2022   2024   2067   2070   2074y
                                      2077y  2081y  2084y  2087   2088
                                      2090   2166   2167   2195   2196
                                      2217   2219   2244   2245   2255
                                      2258   2283   2285   2299   2300
                                      2302   2324y  2864   2865   2981
                                      2982   2987   2988   3004   3005
                                      3015   3030   3031   3054   3055
                                      3060   3061   3075y  3078y  3081y
                                      3084y  3163   3165   3215   3217
                                      3218   3273   3275   3276   3397
                                      3398   3466y  4493   4495   4542
                                      4544   4547   4550   4564   4566
                                      5183   5184   5188   5193   5214
                                      5215   6307y  7005   7007   8603
                                      8605   8606y 10457  10462  11067
                                     11069  11070x 11090  11093  11217
                                     11229  11269  12048  12834y 12855
                                     12856y 12866y 12942  12944y 12949
                                     12951  13818  13829
LINNUM                         $0011   331D  1584   1585   1762   1767
                                      1887   1888   1890   1913   1915
                                      2240   2387   2388   2390   2411
                                      2413   2415   2416   2417   2419
                                      2420   2421   2422   2424   2425
                                      2427   5246   5247   5254   5256
                                      5260y  5263   5265   5275y  5290y
                                      7043   7044   7049y  7052y  7053y
                                      7056y  7057y  7060y  7063   7065
                                      8160   8162   8801   8803   8806
                                      8813   8815   8817   8919   8922
                                      9785   9786   9788  10517  10519
                                     10615  10618  10972  10973  10990
                                     10994  10998  11001  11151  11153
                                     11423  11424  11559  11561  12616
                                     12824  13732  13734  13737
FAC1M1/FAC1M2                  $005f   513D  2036   2037   3323   3626
                                      3781   3807y  4439   4613   4632
                                      4674   5027y  5394   5408   5411
                                      5443   5445   5453   5469   5488
                                      5490   5516   5650   5824   5862
                                      5890   5912   5915   5923   5972
                                      6057   6061   6107   6146   6402
                                      6536   6538   6829   6847   6849
                                     11154    514D  2503   3321   3782
                                      4440   4614   4633   4676   5391
                                      5410   5413   5440   5442   5452
                                      5470   5491   5493   5514   5648
                                      5827   5859   5892   5924   5967
                                      6059   6111   6147   6403   6533
                                      6535   6831   6850   6852  11152
STRPTR/FROUND                  $006c   533D  2545   2548   2552   2556
                                      2575   2576   3360   4630   4631
                                      4636y  4647   4649   4653   4659
                                      4660   4875   4877   4879y  4891
                                      4892   4902y  4905y  4908y  5318
                                      5373   5718   5744   5773   5798
                                      6287   6755   6885    538D  4681
                                      4845   5336   5371   5382   5416
                                      5418   5433   5449   5473   5500
                                      5502   5503   5531   5552   5642
                                      5686   5874   5911   5977   5996
                                      6014   6023   6073   6119   6150
                                      6151   6159   6726   6748   6857
FAC1EX                         $005e   512D  2343   2481   2581   2582
                                      3325   3361   3780   3790   3794
                                      4130   4615   4645   4672   4838
                                      5240   5319   5358   5361   5368
                                      5375   5428   5456   5460   5467
                                      5600   5604   5725   5735   5742
                                      5775   5816   5817   5819   5907
                                      5916   5975   5993   6010   6021
                                      6038   6072   6103   6136   6173
                                      6178   6288   6447   6697   6732
                                      6742   6743   6856   6859   6962
STAL                           $00fb   862D  7223   7225   7357   7359
                                      7379   7381   7453   7455   7604
                                      7606   7639   8946   8948   8955
                                      8960   9938y  9957y 10982  10984
                                     11029y 12627  12629  12655  12656
                                     12662  12667y 12673  13236  13298
                                     13300  13327  13331  13353  13354
                                     13356  13468  13487  13489  13501
                                     13503  13507  13509  13524  13526
                                     13527  13792  13797
TMPPTD                         $006e   542D  1681   1701   2483   2486
                                      2487   2495   3568   4244   4256
                                      4278   4279   4296   4297   4303
                                      4321   4322   4339   4340   4350
                                      4353   4403   4404   4648   4652
                                      5185   5186   5212   5213   6441
                                      6509   6518   6555   6565   6578
                                      6766   6767   6780   6781   6788y
                                      6790   6794   6795   6796   6798
                                      6799   6804   6805
FUNCPT                         $004b   476D  4509   4510   4524   4526
                                      4528y  4532y  4546y  4549y  4557
                                      4559   4569y  4572y  4575y  4578y
                                      4581y  4754   4757   4760   4762
                                      4765   4767   4769   4772y  4776
                                      4777y  4778   4780   4784y  4787
                                      4789   4791   4807   4810   4815y
                                      4819y  6669   6670   6675   6676
                                      6685   6686   6918   6919   6928
                                      6929
TMPPTA                         $0055   500D  1391   1393   1395   1398y
                                      1402y  1404   1577   1582   3974
                                      3975   3977   3978   3982   3983
                                      3988   3989   4004   4005   4008
                                      4009   4024   4026   4099   4100
                                      4283   4285   4288   4300y  4302
                                      4305   4366   4369  13901  13906
                                     13922  13925  13931  13934  13938y
                                     13943  13945  13947  13950
FAC1SI                         $0063   517D  2034   2049   2482   2676
                                      3147   3314   3359   3796   3802
                                      4123   5238   5314   5316   5363
                                      5429   5480   5482   5717   5745
                                      5747   5913   5970   5990   6040
                                      6074   6081   6101   6123   6154
                                      6180   6286   6436   6440   6699
                                      6701   6855   6890   6894   6925
                                      6958   6961   6978
CHRGET                         $0070   562D  1506   1882   2046   2125
                                      2371   2394   2790   2875   3009
                                      3174   3240   3372   3382   3468
                                      3496   3683   3863   3868   3888
                                      4115   5158   6213   6219   6230
                                      7035   8563   8613   8634   8642
                                      8709   8766   8811   8822   9783
                                     11145  11237  11252  12816  12915
                                     13816
RENNEW                         $0023   373D  8794   8797   8802   8807
                                      8827   8830   8858   8861   8867
                                      8869   8870   8872   8941   8953
                                     11253  11256  11270  11275  11279
                                     13817  13822  13824  13830  13834
                                     13840  13841  13844  13850  13864
                                     13865  13866  13870  13872  13879
                                     13900  13927  13928  13929  13932
                                     13952
CHRGOT                         $0076   563D  1878   2043   2135   2227
                                      2338   2352   2712   2989   3048
                                      3062   3171   3228   3499   3829
                                      3838   3851   4176   4560   5078
                                      5174   5202   5285   7687   7704
                                      7714   8522   8629   8676   8798
                                      8808   8819   9773   9780  10463
                                     11169  12323  12339  12939  13812
VARTAB                         $002a   381D  1533   1541   1542   1544
                                      1546   1551   1574   1578   1590
                                      1591   1797   1800   1828   1829
                                      2560   2564   3897   3898   6379
                                      6381   8963   8964   9792  12148
                                     12151  12169  12171  12622  12624
                                     13898  13902  13909  13911  13946
                                     13949  13953  13957
SA                             $00d3   832D  6367   7537   7573   7881
                                      8006   8064   8158   9817   9934
                                      9954  11485  11510  11519  11544
                                     11551  11600  11618  11975  12062
                                     12115  12118  12155  12214  12224
                                     12245  12287  12299  12366  12368
                                     12648  12653  12682  12761  12801
                                     13385
STATUS                         $0096   610D  2935   3508   3637   6373
                                      7891   7901   8405   9813  11295
                                     11305  11488  11493  11512  11524
                                     11565  11602  11620  11875  11900
                                     12068  12081  12101  12211  12253
                                     12274  12288  12360  12752  12763
                                     12791  12803  12931  13434  13435
FNADR                          $00da   839D  6360   6362   7518   7520
                                      7549y  8245   8247   8462   8464
                                      9832y 11339  11341  11344y 11348y
                                     11351y 11354y 11363y 11378y 11433y
                                     11440y 11445y 11455  11575y 11580y
                                     11587y 11605y 11623y 12258y 12314
                                     12316  12950  12952
EAL                            $00c9   801D  6370   6371   6378   6380
                                      7577  11292  11294  11297  11302
                                     11304y 12066  12067  12074  12076
                                     12086y 12091y 12092y 12093y 12095
                                     12097  12150  12153  12168  12170
                                     12181  12183  12227  12228  12623
                                     12625  12663  12665
TXTTAB                         $0028   377D  1611   1612   1748   1749
                                      1791y  1793y  1794   1798   1860
                                      1863   2145   2147   2249   2250
                                      6368   6369   7042   7048   7075
                                      7078  10161y 10163y 10543  10546
                                     10604  10605  11181  11183  12225
                                     12226  12626  12628
TMPPTB                         $0057   501D  1374   1378   1384   1387
                                      1389   1397y  1401y  1403   1575
                                      1579   3968   3969   4034   4039
                                      4047y  4050y  8826y  8829y 10548
                                     10550  10606  10607  10621  10623
                                     13899  13903  13933  13936  13939y
                                     13940  13942
CursorCol                      $00c6   798D  2763   2782   4448   9025
                                      9103   9132   9162   9179   9232
                                      9258   9277   9313   9316   9330
                                      9332   9368   9420   9503   9594
                                      9595   9622   9668   9753   9846
                                      9849  10503  10523  10537  10557
                                     11889
FA                             $00d4   833D  7566   8058   8061   8128
                                      8220   8521   8722  11399  11402
                                     11450  11482  11508  11542  11549
                                     11598  11616  11687  11977  12056
                                     12216  12221  12296  12370  12643
                                     12765  12805  12929  12954  13626
FORPNT                         $0046   460D  1342   1345   1347   1350
                                      2052   2054   2267   2437   2438
                                      2461y  2464y  2474   2593   2596
                                      2601   2603   2617y  2979   2980
                                      3129   3130   3148   3149   5283
                                      5288   5291   5292   5950   5951
FRETOP                         $0030   393D  1435   1438   1447   1450
                                      1821   1822   2553   2557   2644
                                      2647   4040   4043   4427   4430
                                      4706   4709   4734   4735   4759
                                      4761   4829   4831   4973   4975
                                      4980   4983   7068   7069  11299
STREND                         $002e   389D  1371   1372   1588   1589
                                      1832   1833   3966   3967   3990
                                      3992   4191   4193   4293   4294
                                      4307   4311   4428   4431   4719
                                      4722  11290  11412  11491y 11522y
                                     13908  13910  13954  13958
BPTR                           $00f9   861D  7454   7456   8929   8939
                                      8942   9868   9879   9881  11050y
                                     11191  11193  13299  13301  13371
                                     13372  13374  13448  13463  13486
                                     13488  13514  13516  13517  13519
                                     13528  13530  13531
TMPVAR                         $005a   507D  3566   3570   4393   4414
                                      6204   6236   6243   6245   6246
                                      6251   6256   6268   6293   6303
                                      6310   6430   6462   6471   6477
                                      6493   6504   6505   6560   6587
                                      6592
FNLEN                          $00d1   830D  6364   7560   8243   8460
                                      8516   8618   9830  11360  11427
                                     11459  11462  11463  11474  11475
                                     11589  12060  12212  12242  12261
                                     12289  12312  12649  12948  13421
FRESPC                         $0032   397D  4724   4725   4732   4733
                                      4753   4756   4793   4795   4796
                                      4799y  4801   4803   4805   4809
                                      4816y  4820y  4822   4825   4828
                                      4830   4928y  4933   4934   4936
CURLIN                         $0036   407D  1486   1510   2027   2029
                                      2082   2085   2168   2173   2174
                                      2199   2200   2221   2223   2239
                                      2279   2281   2852   2853   3159
                                      3161   4461   6395   6396
FAC2M3/FAC2M4                  $0069   527D  3354   3783   3786   3806y
                                      5438   5674   5710   5829   5845
                                      5855   5857    528D  3356   3784
                                      3787   5435   5671   5707   5832
                                      5844   5852   5854
VARNAM                         $0042   449D  3555   3556   3850   3883
                                      3884   3889   3905   3908   3943
                                      3944   4060   4063   4155   4157
                                      4161   4163   4198   4200   4246
                                      4251   4355   4358
ScrPtr                         $00c4   797D  9104y  9120y  9163y  9219y
                                      9266y  9333y  9335y  9342y  9461y
                                      9499y  9504y  9507y  9511y  9624y
                                      9687y  9755y  9760y 10098  10102
                                     10509y 10559
MEMUSS                         $00fd   863D  7378   7380   7411   7412
                                      7419   8246   8248   8259y  8672
                                      8673   9871   9878   9880  13445
                                     13500  13502  13504  13506  13508
                                     13510
TopMargin                      $00e0   844D  9006   9017   9252   9286
                                      9303   9449   9467   9470   9605
                                      9634   9637   9640   9700   9713
                                     10476  10487  10555  10563  10566
                                     10569
CursorRow                      $00d8   837D  9018   9031   9129   9253
                                      9256   9448   9469   9585   9606
                                      9608   9636   9651   9656  10501
                                     10514  10525  10535  10554  10577
                                     11891
QUOTE                          $0022   245D  1950   1959   2329   2918
                                      3023   3390   4622   4642   7543
                                      7547   8542   8649   9202   9206
                                     11100  11106  11332  11355  13813
INDEXB                         $0021   356D  1536   1543   1555   1562y
                                      1566   3141   5191   5196   5198y
                                      5201y  5206y  6088   6094   6096y
                                      6100y  6105y  6110y  6114y  6120
CR                             $000d   233D  1643   2753   7240   7913
                                      7943   8350   8380   8388   8390
                                      9115   9185   9373   9530  11546
                                     11779  11902  12392  13320  13724
IOPMPT                         $0010   323D  1468   1472   2706   2746
                                      2820   2855   2879   2886   2899
                                      2906   2909   2933   2952   3000
                                      3100   3505   7038
VALTYP                         $0007   270D  2443   2730   3010   3200
                                      3248   3270   3371   3557   3777
                                      3861   3875   4150   4182   4422
                                      4438   4683   5136
RigMargin                      $00d5   835D  9117   9222   9255   9267
                                      9296   9314   9337   9419   9462
                                      9498   9514   9587   9688  10512
                                     10560  11897
COUNT                          $0005   257D  1527   1576   1592   1683
                                      1700   1726   4092   4179   4233
                                      4257   4281   4319   4351  11215
                                     11230  11238
DESCPT                         $004d   480D  2586   2587   2616y  4605
                                      4606   4887   4888   5037y  5040y
                                      5047   5048   5068y  5090y  5112
                                      5114
VARPTR                         $0044   455D  4082   4083   4367   4370
                                      4372   4489   4491   4529   4534
                                      4536y  4540   4551   4553   6554
                                      6566
FAC2EX                         $0066   524D  3348   3771   3772   5338
                                      5339   5376   5378   5724   5732
                                      5992   6011   6666   6741   6744
LefMargin                      $00e2   846D  9024   9231   9251   9276
                                      9287   9304   9329   9450   9593
                                      9621   9667  10087  10456
Mon_Lo                         $00c2   791D 13150  13235  13239  13256
                                     13688  13692  13693  13702  13703
                                     13717  13731  13736  13793
CHARAC                         $0003   255D  2317   2321   2322   3017
                                      3022   3026   3726   3735   4623
                                      4638   6185   6680   6737
DOS_RL                         $00b9   783D  9821   9825   9827  11422
                                     11437  11460  11472  11496  11501
                                     11513  11532  11606
RENINC                         $0021   360D  8793   8796   8814   8818
                                      8868   8871   9777   9779   9795y
                                      9798   9802   9803
LA                             $00d2   831D  7693   7883   8120   8144
                                      8512   8556  11973  11985  12293
                                     12348  12364
Mon_A                          $00bf   788D 12695  12701  13132  13147
                                     13152  13467  13471  13505  13511
                                     13515  13518
VERCK                          $009d   651D  7535   7555   7580   8321
                                     12084  12138  12145  12162  12199
                                     12272  12833
JIFFY_CLOCK                    $008d   578D  2504   3621   3622   9977
                                     12719  12721  12723  12724  12727
                                     12731  12732
MONCNT                         $00b5   775D  7186   7195   7198   7214
                                      7346   7349   7452   7466  13564
                                     13575
CharsInBuffer                  $009e   655D  9080   9082   9092   9109
                                     10359  10366  11878  12025  12905
                                     13338
FAC2SI                         $006b   529D  3358   3767   5317   5362
                                      5716   5719   5984   6285   6672
                                      6880
FAC2M1                         $0067   525D  3350   3769   3770   5444
                                      5680   5721   5823   5847   5861
                                      5863
FUNJMP                         $0052   494D  3708   3710   5106   5115
                                      5337   5367   5381   5432   6730
                                      6747
INDEXC                         $004f   484D  2594y  2597y  2608y  2611y
                                      2655   2658   4967y  4970y  4978
                                      4981
ARYTAB                         $002c   385D  1830   1831   3901   3903
                                      3962   3963   3980   3981   4187
                                      4188
FAC3M4                         $0026   367D  4391   4411   5530   5533
                                      5641   5670   5672   5685   5838
                                      5895
FAC3M3                         $0025   366D  4362   4383   4408   5532
                                      5535   5640   5673   5675   5684
                                      5893
GARBFL                         $0009   291D  1659   1671   1712   3651
                                      3654   3655   3658   4701   4738
                                      4742
ENDCHR                         $0004   256D  1668   1716   1719   2319
                                      2320   2323   2326   3029   4624
                                      4640
BSOS_KBD                       $0001    15D 10650  10663  10674  10733
                                     10746  10764  10777  10788  10847
                                     10860
BotMargin                      $00e1   845D  9009   9295   9586   9652
                                      9698   9715  10475  10488  10505
LDTND                          $00ae   753D  8000   8129  11927  11956
                                     12002  12003  12005  12358  12363
CINV                           $0090   586D  7133   7135   7484   7486
                                      9740   9984   9986  13652  13654
INPPTR                         $0040   439D  2973   2974   2985   2986
                                      3056   3057   3092   3093   3098
OLDTXT                         $003a   419D  1851   2071   2072   2171
                                      2172   2191   2194   2862   2863
QTSW                           $00cd   824D  9127   9175   9204   9205
                                      9381   9532   9678  10597
Mon_Hi                         $00c3   792D 13145  13232  13257  13689
                                     13698  13713  13733  13738
DosPtr                         $00bb   785D 11322  11324  11326  11331y
                                     11338  11340  11411  11415
W_Bank                         $00b7   781D  7141   7329   7442   7935
                                      8841   8897  11046  13465
R_Bank                         $00b6   780D  7139   7327   7440   7927
                                      8840   8937  10985  11026
Source_Unit                    $009c   646D  8218   8519   8580   8583
                                     11401  11481  11548  11597
FAC2M2                         $0068   526D  3352   5441   5677   5713
                                      5826   5846   5858   5860
ACCSYM                         $004a   470D  3227   3236   3237   3239
                                      3243   3278   3293   3778
MEMSIZ                         $0034   401D  1819   1820   4752   4755
                                      7066   7067   7073   7077
INSRT                          $00dc   840D  9216   9218   9377   9513
                                      9516   9536   9676
DATAX                          $00d9   838D  9168   9170   9171   9190
                                      9195   9354   9369
Mon_Op                         $00c1   790D 12424  12453  13255  13276
                                     13289  13303  13306
Dis_Line                       $00ba   784D  7367   7369   7371   7409
                                      7422   9912  13297
Wedge_Unit                     $00ab   739D  7046  12818  12825  12928
                                     12953  13639  13641
Key_Flags                      $0098   624D  6357   9980  10266  10268
                                     10308  10309  10383
FACTPA                         $0054   499D  5942   5943   6769   6772
                                      6773   6921   6922
FAC3M2                         $0024   365D  5534   5537   5639   5676
                                      5678   5683   5891
FAC3M1                         $0023   364D  5536   5539   5638   5679
                                      5681   5682   5889
SUBFLG                         $000a   297D  1852   2008   3879   3891
                                      3896   4482   4507
INTFLG                         $0008   276D  2441   3043   3589   3862
                                      3882   4148   4184
Mon_Tmp                        $00cb   803D  7460   7463   7669   7674
                                     13695  13726
SAL                            $00c7   800D  9042   9043   9044y  9686y
                                     10072  10076
Dis_Length                     $00be   787D 12430  12440  12498  13134
                                     13142  13302
PC_Adjust                      $00b3   773D  7116   7128   7144   7354
                                     12413  12415
DFLTO                          $00b0   761D  9187   9990  11913  11933
                                     11947  12806
YSAVE                          $0048   466D  2983   2984   3058   3059
                                      3264   3343
TANSGN                         $000c   311D  3346   3815   6896   6898
                                      6916   6926
DIMFLG                         $0006   264D  3844   4147   4186   4230
                                      4264   4315
DFLTN                          $00af   757D 11876  11887  11937  11949
                                     12766
Target_Unit                    $00ad   746D 11400  11449  11507  11541
                                     11615
CRSW                           $00ac   744D  9118   9155   9184   9367
                                     11896
BLNCT                          $00a8   718D  9101   9221   9749   9752
                                     10007
BSOUR                          $00a5   678D 11688  11704  11728  11799
                                     11815
Power_Flag                     $0099   629D  9666  10440  10442  10499
                                     10533
LASTPT                         $0014   341D  4684   5006   5008   5012
                                      7039
INPFLG                         $000b   301D  2845   2972   2991   3012
                                      3094
DELAY                          $00e6   850D 10009  10338  10340  10355
DOS_FC                         $00b1   771D 11368  11429  11499  11527
BLNON                          $00aa   734D  9096   9099   9754   9757
LastInputCol                   $00a1   665D  9125   9133   9181  11898
C3PO                           $00a0   663D 11677  11683  11808  11810
ReverseFlag                    $009f   659D  9213   9428   9576   9677
CBINV                          $0092   594D  9739  13601  13603  13671
RNDX                           $0088   569D  6837   6838   6861   6862
BITS                           $0065   520D  4840   4846   4847   6143
SGNFLG                         $0064   518D  6212   6259   6789   6809
DATPTR                         $003e   433D  2150   2151   2962   2963
DATLIN                         $003c   427D  2850   2851   3079   3083
OLDLIN                         $0038   412D  2175   2176   2197   2198
TEMPPT                         $0013   336D  1841   4667   4688   5010
SCROV                          $00eb   859D  9359  10026  10027
SCRIV                          $00e9   858D  9149  10022  10023
PrevChar                       $00e8   857D  9243   9474   9976
CHIME                          $00e7   851D 10029  10042  10051
KOUNT                          $00e5   849D 10010  10342  10348
LSTX                           $00e4   848D 10331  10336  10353
ScreenRows                     $00df   843D  9059   9288  10013
Mon_ZP                         $00cc   804D 13291  13293  13714
BLNSW                          $00a7   711D  9093   9747  10008
InputRow                       $00a3   666D  9128   9650  11892
Default_Bank                   $009a   636D  9982  11031  11052
Key_Index                      $0097   615D 10270  10303  10329
NMINV                          $0094   599D 13597  13599  13619
FACTPB                         $0059   506D  5935   6807   6808
RIGHT                          $001d   244D  2824   9383   9538
JIFFY6                         $00f8   860D 12733  12736
XMAX                           $00e3   847D  9988  10360
Mon_B                          $00c0   789D 12697  12700
Mon_Format                     $00bd   786D 12496  13131
DOS_EOF                        $00b2   772D 11494  11530
GDBLN                          $00a9   727D  9102   9758
SFDX                           $00a6   704D 10271  10375
InputCol                       $00a4   667D  9131  11890
Stop_Flag                      $009b   641D 10374  12020
JUMPER                         $0051   489D  3711   7027
CTRLY                          $0019   242D  9399   9552
TEMPST                         $0016   348D  1840   4668
CTRLV                          $0016   241D  9401   9548
CTRLU                          $0015   240D  9403   9558
DEL                            $0014   239D  9379   9534
HOME                           $0013   238D  9407   9544
RVS                            $0012   237D  9387   9542
DOWN                           $0011   236D  9385   9540
CTRLO                          $000f   235D  9395   9554
CTRLN                          $000e   234D  9391   9556
TAB                            $0009   232D  9397   9546
CTRLD                          $0004   230D  9405   9560
CTRLB                          $0002   229D  9393   9550
USRVEC                         $0001   253D  7031   7032
Basic_USR                      $0000   252D  1120   7028
ISNUM                          $007d   565D  2515
ESC                            $001b   243D  9375
BELL                           $0007   231D  9389
CTRLA                          $0001   228D  9409
FSBLK                          $00de   842
ROPRTY                         $00dd   841
TAPE1                          $00d6   836
ZD0                            $00d0   828
EOT                            $00cf   827
BITTS                          $00ce   826
ZP_b8                          $00b8   782
SCROLLING                      $00b4   774
FAC3M5                         $0027   369
DS_Ptr                         $000e   316
DS_Len                         $000d   315
INDEXA                         $001f   352D  1376   1386   1392   1532
                                      1534   1557   1559   1561y  1565
                                      1617y  1621   1624y  1626   1628y
                                      1629   1630   1631y  1686   1688
                                      1691   1693   1696y  1727y  1729
                                      1731   1734y  1977   1979   1983
                                      1985   1986y  1990y  2514y  2588
                                      2589   2602   2604   2635y  2639y
                                      2642y  2649   2650   2654   2656
                                      2807y  3253   3255   3310   3312
                                      3327   3329   3994   3995   3997y
                                      4000y  4003y  4007y  4015y  4019
                                      4020   4022   4023   4029y  4033y
                                      4037y  4046   4049   4053   4054
                                      4056   4280   4348   4381   4708
                                      4711   4716   4728y  4731y  4783
                                      4785   4788y  4798   4802y  4813y
                                      4823y  4826y  4916   4917   4927y
                                      4960   4961   4971   4972   4987y
                                      4990y  4993y  4995   4996   5054
                                      5055   5057   5147y  5187   5190
                                      5192   5703   5704   5706y  5709y
                                      5712y  5715y  5723y  5903   5904
                                      5906y  5958   5959   5962y  5965y
                                      5968y  5973y  5976y  8622y  8738y
                                      8744   8746   8756   8757  10166
                                     10169  12313  12315
TMPPTC                         $005c   508D  1375   1379   1531y  1535
                                      1537   1539y  1547   1550   1595y
                                      1756   1757   1758y  1763y  1768y
                                      1772y  1898y  1906y  1909y  1927y
                                      1930y  1931   1932   1956y  1965y
                                      2253   2256   3899   3900   3906y
                                      3910y  3915   3964   3965   4061y
                                      4064y  4067y  4069y  4071y  4073y
                                      4075y  4076   4079   4095   4096
                                      4189   4190   4196y  4201y  4204y
                                      4206   4209y  4210   4235y  4247y
                                      4252y  4261y  4273y  4276y  4308
                                      4310y  4313   4314y  4318y  4329y
                                      4334y  4382y  4385y  6229   6232
                                      6239   6240   6266   6297   8846y
                                      8852y  8855y  8903y  8906y  8913y
                                      8916y  8952y  8959   8962   9776
                                      9778   9794y  9799   9800  10542
                                     10545  10549  10551  10571y 10574y
                                     10575  10576  10589y 10592y 10595y
                                     10608  10609  10611y 10614y 10617y
                                     10620  10622  10626y 10629y 11088
                                     11091  11182  11184  11201y 11204y
                                     11205  11206  11277y 11280y 13876y
                                     13888  13890  13894  13895  13897
                                     13913  13915  13921  13923
FAC1M3/FAC1M4                  $0061   515D  2460   2544y  2547y  2563
                                      2566   2573y  2578   2683   2684
                                      3319   3423   3553   3592y  3595y
                                      3667   3694   3728   3740   3745
                                      4171   4326   4345   4603   4679
                                      4870   4881y  4949   5171   5244
                                      5388   5412   5415   5437   5439
                                      5451   5471   5494   5496   5512
                                      5646   5830   5856   5894   5925
                                      5964   6071   6115   6148   6530
                                      6532   6833   6851   6853    516D
                                      2367   2463   2559   2567   2579
                                      2680   2681   3317   3420   3554
                                      3559   3604   3668   3692   3730
                                      3737   3742   4173   4328   4349
                                      4604   4680   4868   4950   5077
                                      5093   5095   5173   5245   5385
                                      5414   5417   5434   5436   5450
                                      5472   5497   5499   5510   5644
                                      5833   5853   5896   5926   5961
                                      6070   6121   6149   6179   6184
                                      6527   6529   6835   6846   6848
TXTPTR                         $0077   564D  1504   1505   1657   1684
                                      1725   1739   1741   1862   1865
                                      2022   2024   2067   2070   2074y
                                      2077y  2081y  2084y  2087   2088
                                      2090   2166   2167   2195   2196
                                      2217   2219   2244   2245   2255
                                      2258   2283   2285   2299   2300
                                      2302   2324y  2864   2865   2981
                                      2982   2987   2988   3004   3005
                                      3015   3030   3031   3054   3055
                                      3060   3061   3075y  3078y  3081y
                                      3084y  3163   3165   3215   3217
                                      3218   3273   3275   3276   3397
                                      3398   3466y  4493   4495   4542
                                      4544   4547   4550   4564   4566
                                      5183   5184   5188   5193   5214
                                      5215   6307y  7005   7007   8603
                                      8605   8606y 10457  10462  11067
                                     11069  11070x 11090  11093  11217
                                     11229  11269  12048  12834y 12855
                                     12856y 12866y 12942  12944y 12949
                                     12951  13818  13829
LINNUM                         $0011   331D  1584   1585   1762   1767
                                      1887   1888   1890   1913   1915
                                      2240   2387   2388   2390   2411
                                      2413   2415   2416   2417   2419
                                      2420   2421   2422   2424   2425
                                      2427   5246   5247   5254   5256
                                      5260y  5263   5265   5275y  5290y
                                      7043   7044   7049y  7052y  7053y
                                      7056y  7057y  7060y  7063   7065
                                      8160   8162   8801   8803   8806
                                      8813   8815   8817   8919   8922
                                      9785   9786   9788  10517  10519
                                     10615  10618  10972  10973  10990
                                     10994  10998  11001  11151  11153
                                     11423  11424  11559  11561  12616
                                     12824  13732  13734  13737
FAC1M1/FAC1M2                  $005f   513D  2036   2037   3323   3626
                                      3781   3807y  4439   4613   4632
                                      4674   5027y  5394   5408   5411
                                      5443   5445   5453   5469   5488
                                      5490   5516   5650   5824   5862
                                      5890   5912   5915   5923   5972
                                      6057   6061   6107   6146   6402
                                      6536   6538   6829   6847   6849
                                     11154    514D  2503   3321   3782
                                      4440   4614   4633   4676   5391
                                      5410   5413   5440   5442   5452
                                      5470   5491   5493   5514   5648
                                      5827   5859   5892   5924   5967
                                      6059   6111   6147   6403   6533
                                      6535   6831   6850   6852  11152
STRPTR/FROUND                  $006c   533D  2545   2548   2552   2556
                                      2575   2576   3360   4630   4631
                                      4636y  4647   4649   4653   4659
                                      4660   4875   4877   4879y  4891
                                      4892   4902y  4905y  4908y  5318
                                      5373   5718   5744   5773   5798
                                      6287   6755   6885    538D  4681
                                      4845   5336   5371   5382   5416
                                      5418   5433   5449   5473   5500
                                      5502   5503   5531   5552   5642
                                      5686   5874   5911   5977   5996
                                      6014   6023   6073   6119   6150
                                      6151   6159   6726   6748   6857
FAC1EX                         $005e   512D  2343   2481   2581   2582
                                      3325   3361   3780   3790   3794
                                      4130   4615   4645   4672   4838
                                      5240   5319   5358   5361   5368
                                      5375   5428   5456   5460   5467
                                      5600   5604   5725   5735   5742
                                      5775   5816   5817   5819   5907
                                      5916   5975   5993   6010   6021
                                      6038   6072   6103   6136   6173
                                      6178   6288   6447   6697   6732
                                      6742   6743   6856   6859   6962
STAL                           $00fb   862D  7223   7225   7357   7359
                                      7379   7381   7453   7455   7604
                                      7606   7639   8946   8948   8955
                                      8960   9938y  9957y 10982  10984
                                     11029y 12627  12629  12655  12656
                                     12662  12667y 12673  13236  13298
                                     13300  13327  13331  13353  13354
                                     13356  13468  13487  13489  13501
                                     13503  13507  13509  13524  13526
                                     13527  13792  13797
TMPPTD                         $006e   542D  1681   1701   2483   2486
                                      2487   2495   3568   4244   4256
                                      4278   4279   4296   4297   4303
                                      4321   4322   4339   4340   4350
                                      4353   4403   4404   4648   4652
                                      5185   5186   5212   5213   6441
                                      6509   6518   6555   6565   6578
                                      6766   6767   6780   6781   6788y
                                      6790   6794   6795   6796   6798
                                      6799   6804   6805
FUNCPT                         $004b   476D  4509   4510   4524   4526
                                      4528y  4532y  4546y  4549y  4557
                                      4559   4569y  4572y  4575y  4578y
                                      4581y  4754   4757   4760   4762
                                      4765   4767   4769   4772y  4776
                                      4777y  4778   4780   4784y  4787
                                      4789   4791   4807   4810   4815y
                                      4819y  6669   6670   6675   6676
                                      6685   6686   6918   6919   6928
                                      6929
TMPPTA                         $0055   500D  1391   1393   1395   1398y
                                      1402y  1404   1577   1582   3974
                                      3975   3977   3978   3982   3983
                                      3988   3989   4004   4005   4008
                                      4009   4024   4026   4099   4100
                                      4283   4285   4288   4300y  4302
                                      4305   4366   4369  13901  13906
                                     13922  13925  13931  13934  13938y
                                     13943  13945  13947  13950
FAC1SI                         $0063   517D  2034   2049   2482   2676
                                      3147   3314   3359   3796   3802
                                      4123   5238   5314   5316   5363
                                      5429   5480   5482   5717   5745
                                      5747   5913   5970   5990   6040
                                      6074   6081   6101   6123   6154
                                      6180   6286   6436   6440   6699
                                      6701   6855   6890   6894   6925
                                      6958   6961   6978
CHRGET                         $0070   562D  1506   1882   2046   2125
                                      2371   2394   2790   2875   3009
                                      3174   3240   3372   3382   3468
                                      3496   3683   3863   3868   3888
                                      4115   5158   6213   6219   6230
                                      7035   8563   8613   8634   8642
                                      8709   8766   8811   8822   9783
                                     11145  11237  11252  12816  12915
                                     13816
RENNEW                         $0023   373D  8794   8797   8802   8807
                                      8827   8830   8858   8861   8867
                                      8869   8870   8872   8941   8953
                                     11253  11256  11270  11275  11279
                                     13817  13822  13824  13830  13834
                                     13840  13841  13844  13850  13864
                                     13865  13866  13870  13872  13879
                                     13900  13927  13928  13929  13932
                                     13952
CHRGOT                         $0076   563D  1878   2043   2135   2227
                                      2338   2352   2712   2989   3048
                                      3062   3171   3228   3499   3829
                                      3838   3851   4176   4560   5078
                                      5174   5202   5285   7687   7704
                                      7714   8522   8629   8676   8798
                                      8808   8819   9773   9780  10463
                                     11169  12323  12339  12939  13812
Mon_Register                   $02a0   894D  7119   7121   7123   7125
                                      7129   7132   7134   7136   7138
                                      7140   7142   7222   7224   7328
                                      7330   7334   7336   7339   7341
                                      7345   7356   7358   7435   7439
                                      7441   7479   7481   7483   7485
                                      7492   7494   7496   7498   7500
                                      7501   7502   7509
VARTAB                         $002a   381D  1533   1541   1542   1544
                                      1546   1551   1574   1578   1590
                                      1591   1797   1800   1828   1829
                                      2560   2564   3897   3898   6379
                                      6381   8963   8964   9792  12148
                                     12151  12169  12171  12622  12624
                                     13898  13902  13909  13911  13946
                                     13949  13953  13957
SA                             $00d3   832D  6367   7537   7573   7881
                                      8006   8064   8158   9817   9934
                                      9954  11485  11510  11519  11544
                                     11551  11600  11618  11975  12062
                                     12115  12118  12155  12214  12224
                                     12245  12287  12299  12366  12368
                                     12648  12653  12682  12761  12801
                                     13385
STACK                          $0100   872D  1339   1344   1346   1348
                                      1351   3143   3146   3152   3156
                                      3158   3160   3162   3164   4167
                                      4169   4172   4174   4595   4596
                                      6439   6512   6517   6559   6564
                                      6579   6595   6597   6605   6607
                                      6609   6612   6614   9736  11162
STATUS                         $0096   610D  2935   3508   3637   6373
                                      7891   7901   8405   9813  11295
                                     11305  11488  11493  11512  11524
                                     11565  11602  11620  11875  11900
                                     12068  12081  12101  12211  12253
                                     12274  12288  12360  12752  12763
                                     12791  12803  12931  13434  13435
FNADR                          $00da   839D  6360   6362   7518   7520
                                      7549y  8245   8247   8462   8464
                                      9832y 11339  11341  11344y 11348y
                                     11351y 11354y 11363y 11378y 11433y
                                     11440y 11445y 11455  11575y 11580y
                                     11587y 11605y 11623y 12258y 12314
                                     12316  12950  12952
EAL                            $00c9   801D  6370   6371   6378   6380
                                      7577  11292  11294  11297  11302
                                     11304y 12066  12067  12074  12076
                                     12086y 12091y 12092y 12093y 12095
                                     12097  12150  12153  12168  12170
                                     12181  12183  12227  12228  12623
                                     12625  12663  12665
TXTTAB                         $0028   377D  1611   1612   1748   1749
                                      1791y  1793y  1794   1798   1860
                                      1863   2145   2147   2249   2250
                                      6368   6369   7042   7048   7075
                                      7078  10161y 10163y 10543  10546
                                     10604  10605  11181  11183  12225
                                     12226  12626  12628
BUF                            $0200   877D  1571   1586   1587   1594
                                      1645   1660   1694   1704   1705
                                      1717   1722   1736   1738   2743
                                      2744   2745   2880   2881   2883
                                      2931   2940   2994   2995   2996
                                     11221  11273  13820  13826  13832
                                     13837  13874
TMPPTB                         $0057   501D  1374   1378   1384   1387
                                      1389   1397y  1401y  1403   1575
                                      1579   3968   3969   4034   4039
                                      4047y  4050y  8826y  8829y 10548
                                     10550  10606  10607  10621  10623
                                     13899  13903  13933  13936  13939y
                                     13940  13942
CursorCol                      $00c6   798D  2763   2782   4448   9025
                                      9103   9132   9162   9179   9232
                                      9258   9277   9313   9316   9330
                                      9332   9368   9420   9503   9594
                                      9595   9622   9668   9753   9846
                                      9849  10503  10523  10537  10557
                                     11889
FA                             $00d4   833D  7566   8058   8061   8128
                                      8220   8521   8722  11399  11402
                                     11450  11482  11508  11542  11549
                                     11598  11616  11687  11977  12056
                                     12216  12221  12296  12370  12643
                                     12765  12805  12929  12954  13626
FORPNT                         $0046   460D  1342   1345   1347   1350
                                      2052   2054   2267   2437   2438
                                      2461y  2464y  2474   2593   2596
                                      2601   2603   2617y  2979   2980
                                      3129   3130   3148   3149   5283
                                      5288   5291   5292   5950   5951
FRETOP                         $0030   393D  1435   1438   1447   1450
                                      1821   1822   2553   2557   2644
                                      2647   4040   4043   4427   4430
                                      4706   4709   4734   4735   4759
                                      4761   4829   4831   4973   4975
                                      4980   4983   7068   7069  11299
STREND                         $002e   389D  1371   1372   1588   1589
                                      1832   1833   3966   3967   3990
                                      3992   4191   4193   4293   4294
                                      4307   4311   4428   4431   4719
                                      4722  11290  11412  11491y 11522y
                                     13908  13910  13954  13958
BPTR                           $00f9   861D  7454   7456   8929   8939
                                      8942   9868   9879   9881  11050y
                                     11191  11193  13299  13301  13371
                                     13372  13374  13448  13463  13486
                                     13488  13514  13516  13517  13519
                                     13528  13530  13531
TMPVAR                         $005a   507D  3566   3570   4393   4414
                                      6204   6236   6243   6245   6246
                                      6251   6256   6268   6293   6303
                                      6310   6430   6462   6471   6477
                                      6493   6504   6505   6560   6587
                                      6592
FNLEN                          $00d1   830D  6364   7560   8243   8460
                                      8516   8618   9830  11360  11427
                                     11459  11462  11463  11474  11475
                                     11589  12060  12212  12242  12261
                                     12289  12312  12649  12948  13421
FRESPC                         $0032   397D  4724   4725   4732   4733
                                      4753   4756   4793   4795   4796
                                      4799y  4801   4803   4805   4809
                                      4816y  4820y  4822   4825   4828
                                      4830   4928y  4933   4934   4936
CURLIN                         $0036   407D  1486   1510   2027   2029
                                      2082   2085   2168   2173   2174
                                      2199   2200   2221   2223   2239
                                      2279   2281   2852   2853   3159
                                      3161   4461   6395   6396
FAC2M3/FAC2M4                  $0069   527D  3354   3783   3786   3806y
                                      5438   5674   5710   5829   5845
                                      5855   5857    528D  3356   3784
                                      3787   5435   5671   5707   5832
                                      5844   5852   5854
VARNAM                         $0042   449D  3555   3556   3850   3883
                                      3884   3889   3905   3908   3943
                                      3944   4060   4063   4155   4157
                                      4161   4163   4198   4200   4246
                                      4251   4355   4358
DOS_Flags                      $033e   923D  7736   7740   7757   7766
                                      7776   7869   8020   8179   8195
                                      8295   8511   8550   8561   8585
                                      8615   8654   8668   8685   8692
                                      8693   8741
ScrPtr                         $00c4   797D  9104y  9120y  9163y  9219y
                                      9266y  9333y  9335y  9342y  9461y
                                      9499y  9504y  9507y  9511y  9624y
                                      9687y  9755y  9760y 10098  10102
                                     10509y 10559
Bank_Store                     $028b   892D  7461   8853   8856   8859
                                      8862   8890   8904   8907   8920
                                      8923   9884  11098  11104  11113
                                     11129  11164  11170  13304  13492
                                     13521
MEMUSS                         $00fd   863D  7378   7380   7411   7412
                                      7419   8246   8248   8259y  8672
                                      8673   9871   9878   9880  13445
                                     13500  13502  13504  13506  13508
                                     13510
TopMargin                      $00e0   844D  9006   9017   9252   9286
                                      9303   9449   9467   9470   9605
                                      9634   9637   9640   9700   9713
                                     10476  10487  10555  10563  10566
                                     10569
CursorRow                      $00d8   837D  9018   9031   9129   9253
                                      9256   9448   9469   9585   9606
                                      9608   9636   9651   9656  10501
                                     10514  10525  10535  10554  10577
                                     11891
DOS_Command_Buffer             $0353   927D  8027   8157   8159   8161
                                      8163   8165   8260   8277   8280
                                      8299   8452   8461   8463   9899
                                      9904   9928  10221  10232  11404
Bank_Fetch                     $027a   893D   892   7189   7202   7462
                                      8951  10987  10993  10997  11000
                                     11016  12452  13305  13464  13466
                                     13469  13470  13491  13520  13571
QUOTE                          $0022   245D  1950   1959   2329   2918
                                      3023   3390   4622   4642   7543
                                      7547   8542   8649   9202   9206
                                     11100  11106  11332  11355  13813
INDEXB                         $0021   356D  1536   1543   1555   1562y
                                      1566   3141   5191   5196   5198y
                                      5201y  5206y  6088   6094   6096y
                                      6100y  6105y  6110y  6114y  6120
CR                             $000d   233D  1643   2753   7240   7913
                                      7943   8350   8380   8388   8390
                                      9115   9185   9373   9530  11546
                                     11779  11902  12392  13320  13724
IOPMPT                         $0010   323D  1468   1472   2706   2746
                                      2820   2855   2879   2886   2899
                                      2906   2909   2933   2952   3000
                                      3100   3505   7038
VALTYP                         $0007   270D  2443   2730   3010   3200
                                      3248   3270   3371   3557   3777
                                      3861   3875   4150   4182   4422
                                      4438   4683   5136
RigMargin                      $00d5   835D  9117   9222   9255   9267
                                      9296   9314   9337   9419   9462
                                      9498   9514   9587   9688  10512
                                     10560  11897
COUNT                          $0005   257D  1527   1576   1592   1683
                                      1700   1726   4092   4179   4233
                                      4257   4281   4319   4351  11215
                                     11230  11238
DESCPT                         $004d   480D  2586   2587   2616y  4605
                                      4606   4887   4888   5037y  5040y
                                      5047   5048   5068y  5090y  5112
                                      5114
VARPTR                         $0044   455D  4082   4083   4367   4370
                                      4372   4489   4491   4529   4534
                                      4536y  4540   4551   4553   6554
                                      6566
FAC2EX                         $0066   524D  3348   3771   3772   5338
                                      5339   5376   5378   5724   5732
                                      5992   6011   6666   6741   6744
KEYD                           $026f   882D  9075   9077   9078   9111
                                     10365  12907  13324  13326  13329
                                     13330  13333  13334  13336
LefMargin                      $00e2   846D  9024   9231   9251   9276
                                      9287   9304   9329   9450   9593
                                      9621   9667  10087  10456
Mon_Lo                         $00c2   791D 13150  13235  13239  13256
                                     13688  13692  13693  13702  13703
                                     13717  13731  13736  13793
CHARAC                         $0003   255D  2317   2321   2322   3017
                                      3022   3026   3726   3735   4623
                                      4638   6185   6680   6737
Ass_Buf                        $02c1   898D 13220  13224  13227  13264
                                     13272  13286  13707  13750  13753
                                     13757  13758  13775
DOS_RL                         $00b9   783D  9821   9825   9827  11422
                                     11437  11460  11472  11496  11501
                                     11513  11532  11606
RENINC                         $0021   360D  8793   8796   8814   8818
                                      8868   8871   9777   9779   9795y
                                      9798   9802   9803
LA                             $00d2   831D  7693   7883   8120   8144
                                      8512   8556  11973  11985  12293
                                     12348  12364
Mon_A                          $00bf   788D 12695  12701  13132  13147
                                     13152  13467  13471  13505  13511
                                     13515  13518
VERCK                          $009d   651D  7535   7555   7580   8321
                                     12084  12138  12145  12162  12199
                                     12272  12833
JIFFY_CLOCK                    $008d   578D  2504   3621   3622   9977
                                     12719  12721  12723  12724  12727
                                     12731  12732
MONCNT                         $00b5   775D  7186   7195   7198   7214
                                      7346   7349   7452   7466  13564
                                     13575
CharsInBuffer                  $009e   655D  9080   9082   9092   9109
                                     10359  10366  11878  12025  12905
                                     13338
FAC2SI                         $006b   529D  3358   3767   5317   5362
                                      5716   5719   5984   6285   6672
                                      6880
FAC2M1                         $0067   525D  3350   3769   3770   5444
                                      5680   5721   5823   5847   5861
                                      5863
FUNJMP                         $0052   494D  3708   3710   5106   5115
                                      5337   5367   5381   5432   6730
                                      6747
INDEXC                         $004f   484D  2594y  2597y  2608y  2611y
                                      2655   2658   4967y  4970y  4978
                                      4981
ARYTAB                         $002c   385D  1830   1831   3901   3903
                                      3962   3963   3980   3981   4187
                                      4188
FAC3M4                         $0026   367D  4391   4411   5530   5533
                                      5641   5670   5672   5685   5838
                                      5895
FAC3M3                         $0025   366D  4362   4383   4408   5532
                                      5535   5640   5673   5675   5684
                                      5893
GARBFL                         $0009   291D  1659   1671   1712   3651
                                      3654   3655   3658   4701   4738
                                      4742
ENDCHR                         $0004   256D  1668   1716   1719   2319
                                      2320   2323   2326   3029   4624
                                      4640
BSOS_KBD                       $0001    15D 10650  10663  10674  10733
                                     10746  10764  10777  10788  10847
                                     10860
DOS_Tmp                        $033a   907D  7686   7713   8164   8244
                                      8256   8263   8517   8671  11426
BotMargin                      $00e1   845D  9009   9295   9586   9652
                                      9698   9715  10475  10488  10505
LDTND                          $00ae   753D  8000   8129  11927  11956
                                     12002  12003  12005  12358  12363
CINV                           $0090   586D  7133   7135   7484   7486
                                      9740   9984   9986  13652  13654
INPPTR                         $0040   439D  2973   2974   2985   2986
                                      3056   3057   3092   3093   3098
OLDTXT                         $003a   419D  1851   2071   2072   2171
                                      2172   2191   2194   2862   2863
DOS_Status                     $03ad   928D  3580   3581   3656   8068
                                      8075   8077   8358   9818
Dis_Buf                        $02b1   896D 12706  13137  13155  13159
                                     13188  13193  13203  13287
QTSW                           $00cd   824D  9127   9175   9204   9205
                                      9381   9532   9678  10597
Mon_Hi                         $00c3   792D 13145  13232  13257  13689
                                     13698  13713  13733  13738
DosPtr                         $00bb   785D 11322  11324  11326  11331y
                                     11338  11340  11411  11415
W_Bank                         $00b7   781D  7141   7329   7442   7935
                                      8841   8897  11046  13465
R_Bank                         $00b6   780D  7139   7327   7440   7927
                                      8840   8937  10985  11026
Source_Unit                    $009c   646D  8218   8519   8580   8583
                                     11401  11481  11548  11597
FAC2M2                         $0068   526D  3352   5441   5677   5713
                                      5826   5846   5858   5860
ACCSYM                         $004a   470D  3227   3236   3237   3239
                                      3243   3278   3293   3778
MEMSIZ                         $0034   401D  1819   1820   4752   4755
                                      7066   7067   7073   7077
DOS_Filename                   $0342   926D  7517   7519   8623  13417
                                     13551  13560  13572
DOS_Attr                       $033d   910D  8435   8471   8476   8513
                                      8571   8597   8612
INSRT                          $00dc   840D  9216   9218   9377   9513
                                      9516   9536   9676
DATAX                          $00d9   838D  9168   9170   9171   9190
                                      9195   9354   9369
Mon_Op                         $00c1   790D 12424  12453  13255  13276
                                     13289  13303  13306
Dis_Line                       $00ba   784D  7367   7369   7371   7409
                                      7422   9912  13297
Wedge_Unit                     $00ab   739D  7046  12818  12825  12928
                                     12953  13639  13641
Key_Flags                      $0098   624D  6357   9980  10266  10268
                                     10308  10309  10383
FACTPA                         $0054   499D  5942   5943   6769   6772
                                      6773   6921   6922
FAC3M2                         $0024   365D  5534   5537   5639   5676
                                      5678   5683   5891
FAC3M1                         $0023   364D  5536   5539   5638   5679
                                      5681   5682   5889
SUBFLG                         $000a   297D  1852   2008   3879   3891
                                      3896   4482   4507
INTFLG                         $0008   276D  2441   3043   3589   3862
                                      3882   4148   4184
DOS_Drive_2                    $033c   909D  8450   8515   8592   8660
                                     11346  11621
LAT                            $0251   879D  8134  11959  11972  12006
                                     12007  12365
Mon_Tmp                        $00cb   803D  7460   7463   7669   7674
                                     13695  13726
SAL                            $00c7   800D  9042   9043   9044y  9686y
                                     10072  10076
Dis_Length                     $00be   787D 12430  12440  12498  13134
                                     13142  13302
PC_Adjust                      $00b3   773D  7116   7128   7144   7354
                                     12413  12415
DFLTO                          $00b0   761D  9187   9990  11913  11933
                                     11947  12806
YSAVE                          $0048   466D  2983   2984   3058   3059
                                      3264   3343
TANSGN                         $000c   311D  3346   3815   6896   6898
                                      6916   6926
DIMFLG                         $0006   264D  3844   4147   4186   4230
                                      4264   4315
DOS_Id                         $033f   924D  8096   8276   8279   8518
                                      8607
Ass_Buf_Length                 $02c0   897D 13275  13281  13749  13759
                                     13760
SAT                            $0265   881D  8003  11974  12010  12011
                                     12369
FAT                            $025b   880D  8132  11976  12008  12009
                                     12371
DFLTN                          $00af   757D 11876  11887  11937  11949
                                     12766
Target_Unit                    $00ad   746D 11400  11449  11507  11541
                                     11615
CRSW                           $00ac   744D  9118   9155   9184   9367
                                     11896
BLNCT                          $00a8   718D  9101   9221   9749   9752
                                     10007
BSOUR                          $00a5   678D 11688  11704  11728  11799
                                     11815
Power_Flag                     $0099   629D  9666  10440  10442  10499
                                     10533
LASTPT                         $0014   341D  4684   5006   5008   5012
                                      7039
INPFLG                         $000b   301D  2845   2972   2991   3012
                                      3094
TABS_SET                       $03ee   929D  9600   9602   9855  10017
DOS_Command_Length             $0341   925D  8420   8422   8619   8625
DOS_Drive_1                    $033b   908D  8446   8514   8591  11603
DELAY                          $00e6   850D 10009  10338  10340  10355
DOS_FC                         $00b1   771D 11368  11429  11499  11527
BLNON                          $00aa   734D  9096   9099   9754   9757
LastInputCol                   $00a1   665D  9125   9133   9181  11898
C3PO                           $00a0   663D 11677  11683  11808  11810
ReverseFlag                    $009f   659D  9213   9428   9576   9677
CBINV                          $0092   594D  9739  13601  13603  13671
RNDX                           $0088   569D  6837   6838   6861   6862
BITS                           $0065   520D  4840   4846   4847   6143
SGNFLG                         $0064   518D  6212   6259   6789   6809
DATPTR                         $003e   433D  2150   2151   2962   2963
DATLIN                         $003c   427D  2850   2851   3079   3083
OLDLIN                         $0038   412D  2175   2176   2197   2198
TEMPPT                         $0013   336D  1841   4667   4688   5010
Ignore_Timeout                 $03fc   931D 11744  11753  13609
Dis_Buf_Length                 $02b0   895D 13166  13206  13282
SCROV                          $00eb   859D  9359  10026  10027
SCRIV                          $00e9   858D  9149  10022  10023
PrevChar                       $00e8   857D  9243   9474   9976
CHIME                          $00e7   851D 10029  10042  10051
KOUNT                          $00e5   849D 10010  10342  10348
LSTX                           $00e4   848D 10331  10336  10353
ScreenRows                     $00df   843D  9059   9288  10013
Mon_ZP                         $00cc   804D 13291  13293  13714
BLNSW                          $00a7   711D  9093   9747  10008
InputRow                       $00a3   666D  9128   9650  11892
Default_Bank                   $009a   636D  9982  11031  11052
Key_Index                      $0097   615D 10270  10303  10329
NMINV                          $0094   599D 13597  13599  13619
FACTPB                         $0059   506D  5935   6807   6808
RIGHT                          $001d   244D  2824   9383   9538
Reset_Vector                   $03fa   930D 13605  13607
Ass_Index                      $02d0   899D 13278  13318
JIFFY6                         $00f8   860D 12733  12736
XMAX                           $00e3   847D  9988  10360
Mon_B                          $00c0   789D 12697  12700
Mon_Format                     $00bd   786D 12496  13131
DOS_EOF                        $00b2   772D 11494  11530
GDBLN                          $00a9   727D  9102   9758
SFDX                           $00a6   704D 10271  10375
InputCol                       $00a4   667D  9131  11890
Stop_Flag                      $009b   641D 10374  12020
JUMPER                         $0051   489D  3711   7027
CTRLY                          $0019   242D  9399   9552
TEMPST                         $0016   348D  1840   4668
CTRLV                          $0016   241D  9401   9548
CTRLU                          $0015   240D  9403   9558
DEL                            $0014   239D  9379   9534
HOME                           $0013   238D  9407   9544
RVS                            $0012   237D  9387   9542
DOWN                           $0011   236D  9385   9540
CTRLO                          $000f   235D  9395   9554
CTRLN                          $000e   234D  9391   9556
TAB                            $0009   232D  9397   9546
CTRLD                          $0004   230D  9405   9560
CTRLB                          $0002   229D  9393   9550
USRVEC                         $0001   253D  7031   7032
Basic_USR                      $0000   252D  1120   7028
Ass_Length                     $02d2   901D 13259
Ass_Dollar                     $02d1   900D 13258
ISNUM                          $007d   565D  2515
ESC                            $001b   243D  9375
BELL                           $0007   231D  9389
CTRLA                          $0001   228D  9409
FSBLK                          $00de   842
ROPRTY                         $00dd   841
TAPE1                          $00d6   836
ZD0                            $00d0   828
EOT                            $00cf   827
BITTS                          $00ce   826
ZP_b8                          $00b8   782
SCROLLING                      $00b4   774
FAC3M5                         $0027   369
DS_Ptr                         $000e   316
DS_Len                         $000d   315
